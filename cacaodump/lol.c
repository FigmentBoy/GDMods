# 1 "Cacao/include/Cacao.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 390 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "Cacao/include/Cacao.cpp" 2

# 1 "Cacao/include/Cacao.hpp" 1




# 1 "Cacao/include/cc_defs.hpp" 1





# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 1 3
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 1 3
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 1 3
# 27 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 1 3
# 32 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 1 3
# 417 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_symbol_aliasing.h" 1 3
# 418 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 2 3
# 494 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_posix_availability.h" 1 3
# 495 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 2 3
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_types.h" 1 3
# 32 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_types.h" 1 3
# 37 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_types.h" 3
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_types.h" 3
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;





typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_types.h" 2 3
# 34 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 2 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 3
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[1168]; };
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 3
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
# 28 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 2 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 3
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/unistd.h" 1 3
# 138 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/unistd.h" 3
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/Availability.h" 1 3
# 141 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/Availability.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/AvailabilityInternal.h" 1 3
# 142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/Availability.h" 2 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3



typedef __darwin_gid_t gid_t;




typedef __darwin_intptr_t intptr_t;




typedef __darwin_off_t off_t;




typedef __darwin_pid_t pid_t;






typedef __darwin_size_t size_t;




typedef __darwin_ssize_t ssize_t;




typedef __darwin_uid_t uid_t;




typedef __darwin_useconds_t useconds_t;
# 468 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
extern "C" {
void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int, const void *, size_t) __asm("_" "write" );
}
# 545 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
extern "C" {
size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;
}
# 570 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
 extern "C" {




void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);



char *ctermid(char *);


void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((__const__)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" );

ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" );





void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void);


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}
# 657 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
extern "C" {
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}








# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/appleapiopts.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 88 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};







struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 183 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[_n/(sizeof(__int32_t) * 8)] & (1<<(_n % (sizeof(__int32_t) * 8))));
}
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3








typedef __darwin_time_t time_t;




typedef __darwin_suseconds_t suseconds_t;




typedef __darwin_sigset_t sigset_t;
# 134 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 3
extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )




  __asm("_" "pselect" "$1050")




  ;



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_select.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_select.h" 3
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )




  __asm("_" "select" "$1050")




  ;
# 153 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3

}
# 673 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3



typedef __darwin_dev_t dev_t;




typedef __darwin_mode_t mode_t;




typedef __darwin_uuid_t uuid_t;


extern "C" {
void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
int gethostuuid(uuid_t, const struct timespec *) __attribute__((visibility("default")));
mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" );



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
# 772 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((visibility("default")));

extern int optreset;

}
# 62 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 2 3


extern "C" {
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 3
extern void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1(void);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1(void);
extern void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1(void);


}
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpu_defines.h" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 2 3
# 153 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 3
namespace std {
# 165 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 3
}
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 1 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/clocale" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/clocale" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_locale.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_locale.h" 3
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};





extern "C" {
struct lconv *localeconv(void);
}
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 2 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 3
extern "C" {
char *setlocale(int, const char *);
}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/clocale" 2 3





namespace std {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstddef" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstddef" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 1 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 3
typedef __darwin_ptrdiff_t ptrdiff_t;
# 100 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 3
typedef __darwin_wint_t wint_t;
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstddef" 2 3

namespace std {

  using ::ptrdiff_t;
  using ::size_t;

}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 1 3
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" );
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
}
# 113 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
char *strtok_r(char *, const char *, char **);
}
# 125 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);
}
# 139 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((visibility("default")));
char *strndup(const char *, size_t) __attribute__((visibility("default")));
size_t strnlen(const char *, size_t) __attribute__((visibility("default")));
char *strsignal(int sig);
}
# 158 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
void *memmem(const void *, size_t, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern4(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern8(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern16(void *, const void *, size_t) __attribute__((visibility("default")));

char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);


void swab(const void * , void * , ssize_t);
}







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/strings.h" 1 3
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/strings.h" 3
extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((visibility("default")));
int fls(int) __attribute__((visibility("default")));
int flsl(long) __attribute__((visibility("default")));
}


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 1 3
# 95 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/strings.h" 2 3
# 181 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 2 3
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 2 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 3
namespace std {

  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }

}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 1 3
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
typedef __darwin_va_list va_list;
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
typedef __darwin_off_t fpos_t;
# 96 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 130 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 238 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen" );

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
# 296 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
# 306 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
}
# 318 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen" );

}
# 340 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







static inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 377 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


char *tempnam(const char *, const char *) __asm("_" "tempnam" );
}
# 417 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}



extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 445 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((visibility("default")));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((visibility("default")));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((visibility("default")));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((visibility("default")));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char **, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 2 3
# 98 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3
namespace std {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 155 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3
namespace __gnu_cxx {
# 170 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdarg" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdarg" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.0/include/stdarg.h" 1 3 4
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdarg" 2 3






namespace std {

  using ::va_list;

}
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3



namespace std {

  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, __null);
    char* __sav = __null;
    if (std::strcmp(__old, "C"))
      {
 __sav = new char[std::strlen(__old) + 1];
 std::strcpy(__sav, __old);
 std::setlocale(4, "C");
      }

    va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = std::vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }

}
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++io.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++io.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 1 3
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 114 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 1 3
# 57 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread_impl.h" 1 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sched.h" 1 3
# 30 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sched.h" 3
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_structs.h" 1 3
# 24 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 25 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_structs.h" 2 3
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 2 3







typedef __darwin_clock_t clock_t;
# 90 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 3
struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 113 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 3
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" );

}
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 2 3



typedef __darwin_pthread_attr_t pthread_attr_t;




typedef __darwin_pthread_cond_t pthread_cond_t;




typedef __darwin_pthread_condattr_t pthread_condattr_t;




typedef __darwin_pthread_key_t pthread_key_t;




typedef __darwin_pthread_mutex_t pthread_mutex_t;




typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;




typedef __darwin_pthread_once_t pthread_once_t;




typedef __darwin_pthread_rwlock_t pthread_rwlock_t;




typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;




typedef __darwin_pthread_t pthread_t;






typedef __darwin_mach_port_t mach_port_t;
# 149 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 3
extern "C" {
# 250 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 3
int pthread_atfork(void (*)(void), void (*)(void),
                      void (*)(void));
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(const pthread_attr_t *,
          int *);
int pthread_attr_getguardsize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_getinheritsched(const pthread_attr_t * ,
           int * );
int pthread_attr_getschedparam(const pthread_attr_t * ,
                                     struct sched_param * );
int pthread_attr_getschedpolicy(const pthread_attr_t * ,
          int * );
int pthread_attr_getscope(const pthread_attr_t * , int * );
int pthread_attr_getstack(const pthread_attr_t * ,
                                      void ** , size_t * );
int pthread_attr_getstackaddr(const pthread_attr_t * ,
                                      void ** );
int pthread_attr_getstacksize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *,
          int );
int pthread_attr_setguardsize(pthread_attr_t *, size_t );
int pthread_attr_setinheritsched(pthread_attr_t *,
           int );
int pthread_attr_setschedparam(pthread_attr_t * ,
                                     const struct sched_param * );
int pthread_attr_setschedpolicy(pthread_attr_t *,
          int );
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_setstack(pthread_attr_t *,
                                      void *, size_t );
int pthread_attr_setstackaddr(pthread_attr_t *,
                                      void *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t );
int pthread_cancel(pthread_t ) __asm("_" "pthread_cancel" );

int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t * ,
                            const pthread_condattr_t * ) __asm("_" "pthread_cond_init" );
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t * ,
     pthread_mutex_t * ,
     const struct timespec * ) __asm("_" "pthread_cond_timedwait" );
int pthread_cond_wait(pthread_cond_t * ,
       pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_getpshared(const pthread_condattr_t * ,
   int * );
int pthread_condattr_setpshared(pthread_condattr_t *,
   int );
int pthread_create(pthread_t * ,
                         const pthread_attr_t * ,
                         void *(*)(void *),
                         void * );
int pthread_detach(pthread_t );
int pthread_equal(pthread_t ,
   pthread_t );
void pthread_exit(void *) __attribute__((__noreturn__));
int pthread_getconcurrency(void);
int pthread_getschedparam(pthread_t , int * , struct sched_param * );
void *pthread_getspecific(pthread_key_t );
int pthread_join(pthread_t , void **) __asm("_" "pthread_join" );
int pthread_key_create(pthread_key_t *, void (*)(void *));
int pthread_key_delete(pthread_key_t );
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t * , int * );
int pthread_mutex_init(pthread_mutex_t * , const pthread_mutexattr_t * );
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_setprioceiling(pthread_mutex_t * , int, int * );
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_gettype(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int );
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );
int pthread_rwlock_init(pthread_rwlock_t * , const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init" );
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
   int * );
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,
   int );
pthread_t pthread_self(void);

int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate" );
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype" );
int pthread_setconcurrency(int);
int pthread_setschedparam(pthread_t ,
    int ,
                                const struct sched_param *);
int pthread_setspecific(pthread_key_t ,
         const void *);
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );



int pthread_is_threaded_np(void);

int pthread_threadid_np(pthread_t,__uint64_t*) __attribute__((visibility("default")));

int pthread_rwlock_longrdlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_yieldwrlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_downgrade_np(pthread_rwlock_t *);
int pthread_rwlock_upgrade_np(pthread_rwlock_t *);
int pthread_rwlock_tryupgrade_np(pthread_rwlock_t *);
int pthread_rwlock_held_np(pthread_rwlock_t *);
int pthread_rwlock_rdheld_np(pthread_rwlock_t *);
int pthread_rwlock_wrheld_np(pthread_rwlock_t *);


int pthread_getname_np(pthread_t,char*,size_t) __attribute__((visibility("default")));
int pthread_setname_np(const char*) __attribute__((visibility("default")));

int pthread_main_np(void);


mach_port_t pthread_mach_thread_np(pthread_t);
size_t pthread_get_stacksize_np(pthread_t);
void * pthread_get_stackaddr_np(pthread_t);


int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);


int pthread_cond_timedwait_relative_np(pthread_cond_t *,
     pthread_mutex_t *,
     const struct timespec *);


int pthread_create_suspended_np(pthread_t *,
                         const pthread_attr_t *,
                         void *(*)(void *),
                         void *);
int pthread_kill(pthread_t, int);

pthread_t pthread_from_mach_thread_np(mach_port_t) __attribute__((visibility("default")));

int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
void pthread_yield_np(void);

}
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 2 3


typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
# 214 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 571 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}


static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t attr;
      int r;

      r = pthread_mutexattr_init (&attr);
      if (!r)
 r = pthread_mutexattr_settype (&attr, 2);
      if (!r)
 r = pthread_mutex_init (mutex, &attr);
      if (!r)
 r = pthread_mutexattr_destroy (&attr);
      return r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
# 115 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++io.h" 2 3

namespace std {

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/runetype.h" 1 3
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/runetype.h" 3
typedef __darwin_ct_rune_t ct_rune_t;




typedef __darwin_rune_t rune_t;
# 81 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/runetype.h" 3
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 2 3
# 145 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

static inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 164 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


static inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

static inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 204 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


static inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






static inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

static inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

static inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

static inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


static inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

static inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

static inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

static inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

static inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

static inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

static inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


static inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

static inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

static inline int
tolower(int _c)
{
        return (__tolower(_c));
}

static inline int
toupper(int _c)
{
        return (__toupper(_c));
}


static inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

static inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

static inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

static inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

static inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

static inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

static inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 2 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 3
namespace std {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stringfwd.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stringfwd.h" 3



namespace std {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;


}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ctime" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ctime" 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ctime" 3
namespace std {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 1 3
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
typedef __darwin_mbstate_t mbstate_t;
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 1 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 3
typedef __darwin_wctype_t wctype_t;
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 3
static inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

static inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

static inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

static inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

static inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

static inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

static inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

static inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

static inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

static inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

static inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

static inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

static inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

static inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 176 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 3
extern "C" {
wctype_t
 wctype(const char *);
}
# 117 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 2 3



extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...) ;
int fwscanf(FILE * , const wchar_t * , ...) ;
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * ,
     ...) ;
int swscanf(const wchar_t * , const wchar_t * , ...) ;
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list) ;
int vwprintf(const wchar_t * , __darwin_va_list) ;
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...) ;
int wscanf(const wchar_t * , ...) ;
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list) ;
int vwscanf(const wchar_t * , __darwin_va_list) ;
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** ) ;

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 219 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((visibility("default")));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((visibility("default")));
wchar_t *wcsdup(const wchar_t *) __attribute__((visibility("default")));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((visibility("default")));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((visibility("default")));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((visibility("default")));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((visibility("default")));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 2 3
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::mbstate_t;

}
# 144 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }

}







namespace __gnu_cxx {






  using ::wcstold;
# 262 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 1 3
# 20 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 3
typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int64_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long uint64_t;



typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 3
typedef unsigned long uintptr_t;







typedef long int intmax_t;
# 106 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 3
typedef long unsigned int uintmax_t;
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 2 3


namespace std {
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;

  template<typename _StateT>
    class fpos;
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

}
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/functexcept.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/functexcept.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception_defines.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/functexcept.h" 2 3

namespace std {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

}
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3

namespace std {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 135 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 112 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx {
# 127 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
  void __verbose_terminate_handler ();

}

}

#pragma GCC visibility pop
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/climits" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/climits" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/limits.h" 1 3





# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/limits.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/limits.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_limits.h" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/limits.h" 2 3
# 7 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/limits.h" 2 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/syslimits.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 2 3
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/climits" 2 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 1 3
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;
# 95 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
typedef __darwin_id_t id_t;
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 1 3
# 81 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/signal.h" 1 3
# 32 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 3
typedef int sig_atomic_t;
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 1 3
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 2 3
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/signal.h" 2 3
# 82 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 2 3
# 148 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 57 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_structs.h" 1 3
# 29 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 1 3
# 38 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
# 402 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 454 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
# 751 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 2 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 86 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 127 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_structs.h" 2 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 2 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
# 128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};
# 218 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
typedef struct __darwin_sigaltstack stack_t;
# 227 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
typedef struct __darwin_ucontext ucontext_t;
# 149 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 2 3
# 175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 348 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
typedef void (*sig_t)(int);
# 365 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 384 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 406 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 117 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 1 3
# 77 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 2 3
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
typedef __uint64_t rlim_t;
# 151 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 162 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 222 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 244 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((visibility("default")));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((visibility("default")));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
# 118 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3
# 193 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/endian.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/endian.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/endian.h" 1 3
# 99 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/endian.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_endian.h" 1 3
# 124 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_endian.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((_data << 8) | (_data >> 8));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 2 3
# 125 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_endian.h" 2 3
# 100 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/endian.h" 2 3
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/endian.h" 2 3
# 194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 254 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/alloca.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/alloca.h" 3
extern "C" {
void *alloca(size_t);
}
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3
# 97 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 134 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
extern int __mb_cur_max;
# 144 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
extern "C" {
void abort(void) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((visibility("default")));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **) ;

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system" );
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" );
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/types.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/types.h" 1 3
# 80 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/types.h" 3
typedef unsigned char u_int8_t;




typedef unsigned short u_int16_t;




typedef unsigned int u_int32_t;




typedef unsigned long long u_int64_t;


typedef int64_t register_t;
# 114 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/types.h" 3
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/types.h" 2 3
# 256 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3
# 267 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
u_int32_t
  arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((visibility("default")));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((visibility("default")));

int atexit_b(void (^)(void)) __attribute__((visibility("default")));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((visibility("default")));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((deprecated,visibility("default")));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((visibility("default")));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((visibility("default")));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 2 3
# 104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
namespace std {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 161 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
namespace __gnu_cxx {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_pair.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_pair.h" 3
namespace std {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }

}
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
namespace __gnu_cxx {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std {

namespace __detail
{


  typedef char __one;
  typedef char __two[2];

  template<typename _Tp>
  __one __test_type(int _Tp::*);
  template<typename _Tp>
  __two& __test_type(...);
}


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };


  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   __value = (sizeof(__detail::__test_type<_Tp>(0))
       != sizeof(__detail::__one))
 };
    };




  template<typename _Tp>
    struct __is_empty
    {
    private:
      template<typename>
        struct __first { };
      template<typename _Up>
        struct __second
        : public _Up { };

    public:
      enum
 {
   __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)
 };
    };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


}
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/type_traits.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/type_traits.h" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/utility" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/utility" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 1 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
namespace std {

  namespace rel_ops
  {
# 90 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 103 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 129 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/utility" 2 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/type_traits.h" 2 3


namespace __gnu_cxx {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;

}
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3

namespace std {
# 80 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/concept_check.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/concept_check.h" 3
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 2 3

namespace std {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 113 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 171 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 76 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 1 3
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
namespace std {
# 93 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
# 384 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 410 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 444 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 459 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 484 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 518 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 537 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 579 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 614 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx {
# 633 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 730 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 77 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/debug/debug.h" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}

namespace __gnu_cxx
{
  namespace __debug { };
}

namespace __gnu_debug
{
  using namespace std::__debug;
  using namespace __gnu_cxx::__debug;
}
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

namespace std {
# 91 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = *__a;
          *__a = *__b;
          *__b = __tmp;
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 141 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
# 160 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
 __are_same<_ValueType1 &, _ReferenceType1>::__value &&
 __are_same<_ValueType2 &, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 180 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 202 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 224 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 244 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }







  template<bool, typename>
    struct __copy
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy<_BoolType, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };

  template<>
    struct __copy<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<typename _II, typename _OI>
    inline _OI
    __copy_aux(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
    }


  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT*, _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT*, const _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
        _CharT*);

  template<bool, bool>
    struct __copy_normal
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_normal<true, false>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first.base(), __last.base(), __result); }
    };

  template<>
    struct __copy_normal<false, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
    };

  template<>
    struct __copy_normal<true, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first.base(), __last.base(),
         __result.base())); }
    };
# 387 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {




                                                     ;

       const bool __in = __is_normal_iterator<_InputIterator>::__value;
       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
       return std::__copy_normal<__in, __out>::__copy_n(__first, __last,
       __result);
    }


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                 ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  ostreambuf_iterator<_CharT>);

  template<bool, typename>
    struct __copy_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy_backward<_BoolType, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };

  template<>
    struct __copy_backward<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueType1>::__value
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_backward<__simple, _Category>::__copy_b(__first,
         __last,
         __result);
    }

  template<bool, bool>
    struct __copy_backward_normal
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_backward_normal<true, false>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first.base(), __last.base(),
       __result); }
    };

  template<>
    struct __copy_backward_normal<false, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first, __last,
            __result.base())); }
    };

  template<>
    struct __copy_backward_normal<true, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
            __result.base())); }
    };
# 524 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
      return std::__copy_backward_normal<__bi1, __bi2>::__copy_b_n(__first,
           __last,
           __result);
    }

  template<bool>
    struct __fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   for (; __first != __last; ++__first)
     *__first = __value;
 }
    };

  template<>
    struct __fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __first != __last; ++__first)
     *__first = __tmp;
 }
    };
# 581 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      const bool __scalar = __is_scalar<_Tp>::__value;
      std::__fill<__scalar>::fill(__first, __last, __value);
    }


  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
                                                   ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
                                                   ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
                                                   ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<bool>
    struct __fill_n
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   for (; __n > 0; --__n, ++__first)
     *__first = __value;
   return __first;
 }
    };

  template<>
    struct __fill_n<true>
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __n > 0; --__n, ++__first)
     *__first = __tmp;
   return __first;
 }
    };
# 657 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {



      const bool __scalar = __is_scalar<_Tp>::__value;
      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
    }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(signed char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 704 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 739 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 769 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
# 801 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
# 833 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {
# 847 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 873 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {



                                                       ;
                                                       ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
                                                     ;
                                                     ;

    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
                                                     ;
                                                     ;


    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);






  }

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 2 3


namespace __gnu_cxx {
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3
  template <class _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(std::memmove(__s1, __s2,
            __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std {
# 225 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>(((__darwin_wint_t)-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/localefwd.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/localefwd.h" 3






namespace std {


  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/atomic_word.h" 1 3
# 37 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 2 3

namespace __gnu_cxx {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 1 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/allocator.h" 1 3
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/allocator.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++allocator.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++allocator.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 1 3
# 37 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/new" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/new" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 95 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 38 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 2 3


namespace __gnu_cxx {

  using std::size_t;
  using std::ptrdiff_t;
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++allocator.h" 2 3
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/allocator.h" 2 3



namespace std {

  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = std::__is_empty<_Alloc>::__value>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };

}
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
namespace std {







  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }







  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {


      ::new(static_cast<void*>(__p)) _T1();
    }






  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    {
      for (; __first != __last; ++__first)
 std::_Destroy(&*__first);
    }
# 134 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
# 146 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename std::__is_scalar<_Value_type>::__type
                _Has_trivial_destructor;

      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
# 166 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>)
    {
      _Destroy(__first, __last);
    }

}
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
namespace std {


  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
# 106 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 168 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { std::fill_n(__first, __n, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 213 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      _Allocator __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      allocator<_Tp>)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        allocator<_Tp2>)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 318 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last,
         _Allocator __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }

}
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_raw_storage_iter.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_raw_storage_iter.h" 3
namespace std {





  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };

}
# 59 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
# 150 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
namespace std {






  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 192 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;





    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };





  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -9223372036854775807L - 1; }
      static long max() throw()
      { return 9223372036854775807L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 9223372036854775807L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3

namespace std {
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 108 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    inline pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
# 120 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
# 132 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 173 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 199 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 211 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 222 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 239 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 269 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      element_type&
      operator*() const throw()
      {
                                   ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
                                   ;
 return _M_ptr;
      }
# 299 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 313 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 328 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 349 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
  };

}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream_insert.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream_insert.h" 3



namespace std {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
namespace std {
# 101 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template <class _Arg1, class _Arg2, class _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 133 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template <class _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template <class _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template <class _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template <class _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template <class _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 195 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template <class _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template <class _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template <class _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template <class _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template <class _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 256 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template <class _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template <class _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 311 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) {}

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template <class _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template <class _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
        bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x)
      : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template <class _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 391 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    };


  template <class _Operation, class _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template <class _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    };


  template <class _Operation, class _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
# 480 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() {}

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template <class _Arg, class _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template <class _Arg1, class _Arg2, class _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() {}

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template <class _Arg1, class _Arg2, class _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template <class _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template <class _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template <class _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 582 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Ret, class _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };


  template <class _Ret, class _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };


  template <class _Ret, class _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template <class _Ret, class _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3




namespace std {
# 110 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 147 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 172 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {
   this->_M_set_sharable();
   this->_M_length = __n;
   traits_type::assign(this->_M_refdata()[__n], _S_terminal);


 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __x, size_type __y)
      {
         if (__x > __y)
            return 1;
         if (__x < __y)
            return -1;
         return 0;
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 463 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 518 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 629 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 642 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 671 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 699 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }
# 716 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

                                       ;

                                         ;
 _M_leak();
 return _M_data()[__pos];
      }
# 737 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 756 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }






      basic_string&
      append(const basic_string& __str);
# 816 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }
# 848 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 859 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 898 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 914 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 926 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }
# 942 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 954 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 971 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 986 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1002 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1024 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1047 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1065 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1088 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1105 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1129 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1145 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1165 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {

                            ;
        const size_type __pos = __first - _M_ibegin();
 _M_mutate(__pos, __last - __first, size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1192 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1214 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1238 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1257 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1298 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1316 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1337 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1358 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1380 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }

      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __true_type)
 { return _S_construct(static_cast<size_type>(__beg),
         static_cast<value_type>(__end), __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1511 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1521 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1531 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1563 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1576 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1590 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1607 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1620 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1635 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1648 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1665 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1678 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1693 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1706 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1725 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1739 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1754 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1767 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1786 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1800 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1815 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1829 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1846 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1859 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1875 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1888 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1905 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1920 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 1938 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 1968 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 1992 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2010 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2033 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2058 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2079 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2150 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }
# 2224 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2261 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2298 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2335 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2372 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2389 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2407 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2430 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2447 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/algorithm" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/algorithm" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
namespace std {




  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 139 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;


      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
# 251 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;
                                              ;

      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
# 317 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                           ;

      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
# 342 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 382 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 420 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;


      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--));
    }
# 446 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--), __comp);
    }

}
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tempbuf.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tempbuf.h" 3
namespace std {
# 76 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tempbuf.h" 3
  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

      void
      _M_initialize_buffer(const _Tp&, __true_type) { }

      void
      _M_initialize_buffer(const _Tp& __val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, __val); }

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {

      typedef typename std::__is_scalar<_Tp>::__type _Trivial;

      try
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 2 3




namespace std {
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {


      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 119 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {


      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
# 151 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }






  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }






  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  const _CharT&);
# 316 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 338 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 360 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 391 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 422 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 446 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 485 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 556 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 628 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }
# 662 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 720 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 747 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !__binary_pred(*__first, __val))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
 }
      return __last;
    }
# 787 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!__binary_pred(*__lookAhead, __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 848 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 884 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
# 900 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                       ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 922 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 957 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 989 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 1020 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 1053 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 1089 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 1123 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
# 1149 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 1176 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1212 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1251 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
# 1286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
# 1312 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
# 1337 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1362 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1384 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(*__first, *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
# 1415 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1446 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1487 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 1527 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 1560 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1599 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1633 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }
# 1655 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1682 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1708 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
# 1736 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }






  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }






  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   swap(*__first, *--__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }






  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }

    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }

   *__p = __tmp;
   ++__first;
 }
    }
# 1915 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1948 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }
# 1974 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 2001 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }

      return __first;
    }






  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 2095 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }







  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 2206 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }







  enum { _S_threshold = 16 };






  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }






  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
# 2535 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 2573 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 2612 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2632 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2677 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2701 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }






  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }






  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
# 2814 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 2849 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 2882 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2932 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2979 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 3029 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }






  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3227 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3247 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 3288 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3309 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }






  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
# 3711 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





                                                  ;
                                                 ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3765 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






                                                               ;
                                                              ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
# 3874 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 3915 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 4030 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 4068 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 4107 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 4168 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;







                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 4226 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                            ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 4258 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





                                                                         ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 4297 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4345 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4363 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4394 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4415 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4460 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4483 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4526 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4545 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4582 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4603 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4639 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4658 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4699 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4720 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4756 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4777 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4821 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4845 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4879 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 4906 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 4958 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 4993 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5049 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5160 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5219 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 5255 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 5285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 5435 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 5480 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }

}
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/algorithm" 2 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.tcc" 1 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.tcc" 3

namespace std {

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__is_null_pointer(__beg) && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 559 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 59 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 2 3


namespace std {
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 123 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale() throw();
# 132 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 157 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 170 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 182 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 196 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 211 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 230 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 258 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 274 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 309 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 342 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 373 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    inline void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

 inline void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch (...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 433 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }




   inline void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);




   inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 2 3

namespace std {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 201 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 328 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 359 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;





    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 392 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 418 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 435 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 447 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:






    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    inline fmtflags
    flags() const { return _M_flags; }
# 557 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 573 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 590 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 617 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline streamsize
    precision() const { return _M_precision; }






    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    inline streamsize
    width() const { return _M_width; }






    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 666 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 678 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 689 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline locale
    getloc() const { return _M_ios_locale; }
# 699 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }
# 717 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 733 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 754 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 771 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3








namespace std {






  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 123 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
# 146 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_aux(istreambuf_iterator<_CharT2>,
     istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 195 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;






      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 223 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 240 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 294 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 312 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 334 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 353 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 367 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 392 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 419 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 445 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 459 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 477 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 493 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 504 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 524 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 550 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 571 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 586 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 597 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 609 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 622 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int
      sync() { return 0; }
# 644 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 660 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 682 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 695 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 719 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 737 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 762 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 791 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf.tcc" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf.tcc" 3

namespace std {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 821 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 2 3
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf_iterator.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf_iterator.h" 3




namespace std {



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_aux(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
     _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      {
 const bool __thiseof = _M_at_eof();
 const bool __beof = __b._M_at_eof();
 return (__thiseof && __beof || (!__thiseof && !__beof));
      }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT* __first, _CharT* __last,
        ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT* __first, const _CharT* __last,
        ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT> __first,
        istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

}
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 3
typedef __darwin_wctrans_t wctrans_t;
# 62 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 3
static inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


static inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

static inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

static inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

static inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

static inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

static inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

static inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 130 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 3
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 2 3
# 80 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 3
namespace std {

  using ::wint_t;

  using ::wctype_t;
  using ::wctrans_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_base.h" 1 3
# 38 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_base.h" 3
namespace std {


  struct ctype_base
  {

    typedef const int* __to_type;

    typedef unsigned long mask;


    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask xdigit = 0x00010000L;
    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask graph = 0x00000100L | 0x00000400L | 0x00002000L;
    static const mask cntrl = 0x00000200L;
    static const mask punct = 0x00002000L;
    static const mask alnum = 0x00000100L | 0x00000400L;
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_base.h" 3
  };

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3





namespace std {
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen, const bool __num);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline



 ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 148 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 166 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 183 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 199 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 215 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 229 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 244 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 258 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 273 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 290 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 309 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 328 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 350 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 375 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 394 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 413 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 432 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 450 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 467 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 483 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 500 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 519 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 562 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 586 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 609 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 678 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 715 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 728 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 741 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 756 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 770 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 784 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 799 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 816 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 832 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 849 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 869 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 896 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 927 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 960 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }

    protected:


      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();







      virtual
      ~ctype();
# 1007 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1024 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1040 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1057 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1077 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1100 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1126 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1152 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:

      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);

 _M_widen_ok = 1;

 if (memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }




      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);

 _M_narrow_ok = 1;
 if (memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {


     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 1216 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1249 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1260 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;


      virtual
      ~ctype();
# 1284 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1303 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1321 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1339 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1356 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1373 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1389 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1406 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1426 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1448 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1471 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1497 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype();
    };

  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_inline.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_inline.h" 3
namespace std {




bool
  ctype<char>::
  is(mask __m, char __c) const
  {
    if (_M_table)
      return _M_table[static_cast<unsigned char>(__c)] & __m;
    else
      return __istype(__c, __m);
  }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    if (_M_table)
      while (__low < __high)
 *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    else
      for (;__low < __high; ++__vec, ++__low)
 {

   *__vec = __maskrune (*__low, upper | lower | alpha | digit | xdigit
          | space | print | graph | cntrl | punct | alnum);
# 86 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_inline.h" 3
 }
    return __high;
  }




const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
 ++__low;
    else
      while (__low < __high && !this->is(__m, *__low))
 ++__low;
    return __low;
  }




const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
 ++__low;
    else
      while (__low < __high && this->is(__m, *__low) != 0)
 ++__low;
    return __low;
  }


  inline bool
  ctype<wchar_t>::
  do_is(mask __m, wchar_t __c) const
  {
    return __istype (__c, __m);
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const
  {
    for (; __lo < __hi; ++__vec, ++__lo)
      *__vec = __maskrune (*__lo, upper | lower | alpha | digit | xdigit
      | space | print | graph | cntrl | punct | alnum);
    return __hi;
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_is(mask __m, const wchar_t* __lo, const wchar_t* __hi) const
  {
    while (__lo < __hi && ! __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
  {
    while (__lo < __hi && __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }


}
# 1537 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 1 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3

namespace std {


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 119 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 158 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 199 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 240 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };

}
# 1540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3

namespace std {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1664 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1701 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1715 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1729 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1742 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1773 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1786 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1799 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1816 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1828 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1841 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1854 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1867 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1934 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1955 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1981 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2017 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2076 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2118 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2189 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2248 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2265 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2304 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2346 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2409 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2434 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2482 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2539 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 2566 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 2580 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 2597 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 2616 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 2630 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 2659 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 2675 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 2688 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };
# 2748 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 2906 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const;


}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/time_members.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/time_members.h" 3
namespace std {

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      const size_t __len = std::strlen(__s) + 1;
      char* __tmp = new char[__len];
      std::memcpy(__tmp, __s, __len);
      _M_name_timepunct = __tmp;

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }

}
# 3044 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3

namespace std {
# 3059 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 3081 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 3098 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 3122 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 3147 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 3175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 3204 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 3230 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 3250 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual dateorder
      do_date_order() const;
# 3268 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3287 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3306 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 3325 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 3344 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;



      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 3400 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 3421 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 3440 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 3460 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 3487 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 3525 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }







  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 3646 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 3658 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 3673 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 3687 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 3700 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 3729 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 3742 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 3759 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 3776 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 3792 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 3827 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 3849 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 3861 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 3874 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 3887 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 3900 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 3913 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 3927 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 3941 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 3955 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
# 4047 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 4069 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 4099 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 4129 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 4152 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 4164 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 4175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 4196 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 4217 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 4237 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 4259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 4293 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 4316 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 4327 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;






  struct messages_base
  {
    typedef int catalog;
  };
# 4366 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 4394 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      messages(size_t __refs = 0);
# 4408 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 4421 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 4439 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 4457 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 4468 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 4488 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 4507 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 4564 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/messages_members.h" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/messages_members.h" 3
namespace std {


  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }

}
# 4603 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3

namespace std {







  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 2 3

namespace std {
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 122 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 133 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 186 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 207 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 242 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
      _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 292 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 332 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 346 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 375 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 395 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 415 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const;
# 433 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      char_type
      widen(char __c) const;

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.tcc" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.tcc" 3

namespace std {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    { return __check_facet(_M_ctype).narrow(__c, __dfault); }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    { return __check_facet(_M_ctype).widen(__c); }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 160 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 466 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 2 3
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 2 3


namespace std {
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 111 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 168 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 314 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 327 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      flush();
# 338 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      pos_type
      tellp();
# 349 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 361 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      explicit
      basic_ostream() { }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 383 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 402 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 412 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      ~sentry()
      {

 if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 430 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 451 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 493 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 543 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream.tcc" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream.tcc" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/locale" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/locale" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 60 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name; }
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }

    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
# 127 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 2 3



namespace std {

  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 87 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }
# 109 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__np.grouping()[0]) > 0);

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__mp.grouping()[0]) > 0);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;

      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;

      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;

      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }
# 272 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  static bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }


      if (__testeof)
        __err |= ios_base::eofbit;
      return __beg;
    }





  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     if (numeric_limits<_ValueT>::is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 const __unsigned_type __max = __negative ?
   -numeric_limits<_ValueT>::min() : numeric_limits<_ValueT>::max();
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testfail = true;
       else
  {
    __result *= __base;
    __testfail |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testfail = true;
    else
      {
        __result *= __base;
        __testfail |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }

 if (!__testfail && (__sep_pos || __found_zero
       || __found_grouping.size()))
   __v = __negative ? -__result : __result;
 else
   __err |= ios_base::failbit;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = __l;
   else
            __err |= ios_base::failbit;
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   size_t __n;
   bool __testeof = __beg == __end;
          for (__n = 0; !__testeof; ++__n)
            {
       const char_type __c = *__beg;

       if (__testf)
  if (__n < __lc->_M_falsename_size)
    __testf = __c == __lc->_M_falsename[__n];
  else
    break;

       if (__testt)
  if (__n < __lc->_M_truename_size)
    __testt = __c == __lc->_M_truename[__n];
  else
    break;

       if (!__testf && !__testt)
  break;

       if (++__beg == __end)
  __testeof = true;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = 0;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = 1;
   else
     __err |= ios_base::failbit;

          if (__testeof)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
# 864 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags(__fmt & ~ios_base::basefield | ios_base::hex);

      unsigned long __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
        __w, __len, true);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = (__v > 0 || !__dec) ? __v : -__v;
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v > 0)
       {
  if (__flags & ios_base::showpos
      && numeric_limits<_ValueT>::is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else if (__v)
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (__flags & ios_base::showbase && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 1093 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits = numeric_limits<_ValueT>::digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1152 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1291 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<unsigned long>(__v));
      __io.flags(__flags);
      return __s;
    }

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || __mandatory_sign
         && (static_cast<part>(__p.field[3])
      == money_base::sign))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 1547 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 1752 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }







      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }






  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __tmperr);
    break;
  case 'Y':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }


  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val = *__lo + ((__val << 7) |
         (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
# 2503 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen, const bool __num)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, const_cast<_CharT*>(__olds), __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal && __num)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   const bool __testsign = (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0]);
   const bool __testhex = (__ctype.widen('0') == __olds[0]
      && __oldlen > 1
      && (__ctype.widen('x') == __olds[1]
          || __ctype.widen('X') == __olds[1]));
   if (__testhex)
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   else if (__testsign)
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, const_cast<_CharT*>(__olds + __mod),
      __oldlen - __mod);
    }

  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp)
  {
    const size_t __n = __grouping_tmp.size() - 1;
    const size_t __min = std::min(__n, size_t(__grouping_size - 1));
    size_t __i = __n;
    bool __test = true;




    for (size_t __j = 0; __j < __min && __test; --__i, ++__j)
      __test = __grouping_tmp[__i] == __grouping[__j];
    for (; __i && __test; --__i)
      __test = __grouping_tmp[__i] == __grouping[__min];



    if (static_cast<signed char>(__grouping[__min]) > 0)
      __test &= __grouping_tmp[0] <= __grouping[__min];
    return __test;
  }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);



}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/locale" 2 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream.tcc" 2 3

namespace std {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   _CharT* __ws = 0;
   try
     {
       __ws = new _CharT[__clen];
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
     }
   catch(...)
     {
       delete [] __ws;
       __out._M_setstate(ios_base::badbit);
       return __out;
     }

   try
     {
       __ostream_insert(__out, __ws, __clen);
       delete [] __ws;
     }
   catch(...)
     {
       delete [] __ws;
       throw;
     }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 573 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 2 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3




namespace std {
# 57 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

    protected:







      streamsize _M_gcount;

    public:
# 103 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 130 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 177 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 249 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 291 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      int_type
      get();
# 305 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(char_type& __c);
# 332 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 343 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 366 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 376 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 405 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 416 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 440 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 457 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      int_type
      peek();
# 475 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 494 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 510 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      putback(char_type __c);
# 525 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      unget();
# 543 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      int
      sync();
# 557 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      pos_type
      tellg();
# 572 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      seekg(pos_type);
# 588 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      explicit
      basic_istream(): _M_gcount(streamsize(0)) { }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 645 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 677 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 687 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      operator bool() const
      { return _M_ok; }

    private:
      bool _M_ok;
    };
# 707 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 748 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 775 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(), __ostream_type()
      { this->init(__sb); }




      virtual
      ~basic_iostream() { }

    protected:
      explicit
      basic_iostream() : __istream_type(), __ostream_type()
      { }
    };
# 838 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/istream.tcc" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/istream.tcc" 3




namespace std {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && (__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (numeric_limits<short>::min() <= __l
       && __l <= numeric_limits<short>::max())
     __n = __l;
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (numeric_limits<int>::min() <= __l
       && __l <= numeric_limits<int>::max())
     __n = __l;
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 429 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount < numeric_limits<streamsize>::max())
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = numeric_limits<streamsize>::max();

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       __in.width(0);
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 846 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 2 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 2 3

namespace std {
# 63 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 7 "Cacao/include/cc_defs.hpp" 2

# 1 "Cacao/include/GDML/GDML.hpp" 1







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 3






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
namespace std {






  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;
 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
   if (__n)
   {
     this->_M_impl._M_start = this->_M_allocate(__n);
     this->_M_impl._M_finish = this->_M_impl._M_start;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   }
      }

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 161 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a)
      { }
# 212 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_start + __n;
      }
# 231 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 254 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 282 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 295 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 311 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }



      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 418 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }





      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 461 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 476 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 491 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 516 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 534 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 580 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 599 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 620 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 638 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 654 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 672 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 697 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 718 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 730 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:






      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }





      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }






      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      void
      _M_insert_aux(iterator __position, const value_type& __x);





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 940 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 957 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_bvector.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_bvector.h" 3
namespace std {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<class _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }

      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std {
# 455 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    explicit
    vector(const allocator_type& __a = allocator_type())
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    template<class _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }





    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<class _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }

    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }

    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= size_type(-1) / int(_S_word_bit) ?
       __asize * int(_S_word_bit) : size_type(-1));
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector<bool, _Alloc>& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<class _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }

    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }


    template<class _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(__n);
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<class _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<class _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<class _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }

    template<class _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign((size_t) __n, (bool) __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<class _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<class _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }


    template<class _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<class _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len = size() + std::max(size(), __n);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    template<class _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<class _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len = size() + std::max(size(), __n);
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

    void
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len = size() ? 2 * size()
                                  : static_cast<size_type>(_S_word_bit);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/vector.tcc" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/vector.tcc" 3
namespace std {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n, this->_M_impl._M_start,
            this->_M_impl._M_finish);
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
        _M_insert_aux(__position, __x);
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      *(this->_M_impl._M_finish - 1));
   ++this->_M_impl._M_finish;
   _Tp __x_copy = __x;
   std::copy_backward(__position.base(),
        this->_M_impl._M_finish - 2,
        this->_M_impl._M_finish - 1);
   *__position = __x_copy;
 }
      else
 {
   const size_type __old_size = size();
   if (__old_size == this->max_size())
     __throw_length_error(("vector::_M_insert_aux"));




   size_type __len = __old_size != 0 ? 2 * __old_size : 1;
   if (__len < __old_size)
     __len = this->max_size();

   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {
       __new_finish =
  std::__uninitialized_copy_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       this->_M_impl.construct(__new_finish, __x);
       ++__new_finish;
       __new_finish =
  std::__uninitialized_copy_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
   catch(...)
     {
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n,
         __old_finish);
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_copy_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __old_size = size();
       if (this->max_size() - __old_size < __n)
  __throw_length_error(("vector::_M_fill_insert"));


       size_type __len = __old_size + std::max(__old_size, __n);
       if (__len < __old_size)
  __len = this->max_size();

       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish =
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    std::__uninitialized_fill_n_a(__new_finish, __n, __x,
      _M_get_Tp_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_copy_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp, _Alloc>::
    _M_range_insert(iterator __pos, _InputIterator __first,
      _InputIterator __last, std::input_iterator_tag)
    {
      for (; __first != __last; ++__first)
 {
   __pos = insert(__pos, *__first);
   ++__pos;
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n,
           __old_finish);
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_copy_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __old_size = size();
  if (this->max_size() - __old_size < __n)
    __throw_length_error(("vector::_M_range_insert"));


  size_type __len = __old_size + std::max(__old_size, __n);
  if (__len < __old_size)
    __len = this->max_size();

  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_copy_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last, __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }

}
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 2 3
# 9 "Cacao/include/GDML/GDML.hpp" 2

using namespace std;





typedef void(*func_t)();

#pragma GCC visibility push(default)

class BaseContainer {
protected:
    long address;
    size_t byteCount;
    char* originalBytes;
    char* moddedBytes;

public:
    virtual ~BaseContainer();
    void enable();
    void disable();
    friend class ModContainer;
};

class MemoryContainer : public BaseContainer{
public:
    MemoryContainer(long address, size_t byteCount, char* bytes);
    ~MemoryContainer();
};

class HookContainer : public BaseContainer {
public:
    HookContainer(long address, func_t function);
    func_t getOriginal();
    ~HookContainer();
private:
    func_t original;


};

class ModContainer
{
public:
    static vector<ModContainer*> containers;
    template <typename S>
    static ModContainer* containerByName(S name);
    ModContainer(char const* name);
    ~ModContainer();
    void enable();
    void disable();
    void registerWrite(long address, size_t byteCount, char* bytes);

    template <typename F>
    F registerHook(long address, F function) {
        HookContainer* hook = new HookContainer(address, (func_t)function);
        mods.push_back(hook);
        return (F)hook->getOriginal();
    }

    func_t getOriginal(long address);
    char const* getName();
private:
    vector<BaseContainer*> mods;
    char const* containerName;
};

struct OriginalNotFoundException : public exception
{
  const char * what () const throw ()
  {
    return "Cannot find the original address of this function";
  }
};

struct ModNotFoundException : public exception
{
  const char * what () const throw ()
  {
    return "Cannot find the mod container given the name";
  }
};

long getBase();

void inject(void) __attribute__((constructor));
#pragma GCC visibility pop
# 9 "Cacao/include/cc_defs.hpp" 2
# 1 "Cacao/include/cocos2dx/custom/Sprites/CCMenuItemSpriteExtra/CCMenuItemSpriteExtra.h" 1

# 1 "Cacao/include/cocos2dx/cocos2d.h" 1
# 38 "Cacao/include/cocos2dx/cocos2d.h"
# 1 "Cacao/include/cocos2dx/include/ccConfig.h" 1
# 30 "Cacao/include/cocos2dx/include/ccConfig.h"
# 1 "Cacao/include/cocos2dx/platform/CCPlatformConfig.h" 1
# 31 "Cacao/include/cocos2dx/include/ccConfig.h" 2
# 39 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/actions/CCAction.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCAction.h"
# 1 "Cacao/include/cocos2dx/cocoa/CCObject.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCObject.h"
# 1 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h"
# 1 "Cacao/include/cocos2dx/platform/CCPlatformMacros.h" 1
# 32 "Cacao/include/cocos2dx/platform/CCPlatformMacros.h"
# 1 "Cacao/include/cocos2dx/platform/mac/CCPlatformDefine.h" 1



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 1 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 3
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));



}
# 5 "Cacao/include/cocos2dx/platform/mac/CCPlatformDefine.h" 2
# 33 "Cacao/include/cocos2dx/platform/CCPlatformMacros.h" 2
# 29 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h" 2


namespace cocos2d {

class CCObject;
class CCBool;
class CCInteger;
class CCFloat;
class CCDouble;
class CCString;
class CCArray;
class CCDictionary;
class CCSet;
# 64 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h"
class CCDataVisitor
{
public:
    virtual ~CCDataVisitor() {}


    virtual void visitObject(const CCObject *p) = 0;

    virtual void visit(const CCBool *p);
    virtual void visit(const CCInteger *p);
    virtual void visit(const CCFloat *p);
    virtual void visit(const CCDouble *p);
    virtual void visit(const CCString *p);
    virtual void visit(const CCArray *p);
    virtual void visit(const CCDictionary *p);
    virtual void visit(const CCSet *p);
};





class CCPrettyPrinter : public CCDataVisitor
{
public:
    CCPrettyPrinter(int indentLevel = 0);

    virtual void clear();
    virtual std::string getResult();

    virtual void visitObject(const CCObject *p);
    virtual void visit(const CCBool * p);
    virtual void visit(const CCInteger *p);
    virtual void visit(const CCFloat *p);
    virtual void visit(const CCDouble *p);
    virtual void visit(const CCString *p);
    virtual void visit(const CCArray *p);
    virtual void visit(const CCDictionary *p);
    virtual void visit(const CCSet *p);
private:
    void setIndentLevel(int indentLevel);
    int _indentLevel;
    std::string _indentStr;
    std::string _result;
};




}
# 29 "Cacao/include/cocos2dx/cocoa/CCObject.h" 2




class DS_Dictionary;
namespace cocos2d {






class CCZone;
class CCObject;
class CCNode;
class CCEvent;
enum CCObjectType {
};




class CCCopying
{
public:
    virtual CCObject* copyWithZone(CCZone* pZone);
};




class CCObject : public CCCopying
{
public:

    unsigned int m_uID;

    int m_nLuaID;
protected:
    unsigned int m_uTag;

    unsigned int m_uReference;

    CCObjectType m_CCObjectType;


    unsigned int m_uAutoReleaseCount;

    unsigned int m_uPadding;
public:
    CCObject(void);



    virtual ~CCObject(void);

    void release(void);
    void retain(void);
    CCObject* autorelease(void);
    CCObject* copy(void);
    bool isSingleReference(void) const;
    unsigned int retainCount(void) const;
    virtual bool isEqual(const CCObject* pObject);

    virtual void acceptVisitor(CCDataVisitor &visitor);
    virtual void update(float dt) {(void)dt;};
    virtual void encodeWithCoder(DS_Dictionary*);
    virtual bool canEncode();
    virtual int getTag() const;
    virtual void setTag(int);

    friend class CCAutoreleasePool;
};


typedef void (CCObject::*SEL_SCHEDULE)(float);
typedef void (CCObject::*SEL_CallFunc)();
typedef void (CCObject::*SEL_CallFuncN)(CCNode*);
typedef void (CCObject::*SEL_CallFuncND)(CCNode*, void*);
typedef void (CCObject::*SEL_CallFuncO)(CCObject*);
typedef void (CCObject::*SEL_MenuHandler)(CCObject*);
typedef void (CCObject::*SEL_EventHandler)(CCEvent*);
typedef int (CCObject::*SEL_Compare)(CCObject*);
# 125 "Cacao/include/cocos2dx/cocoa/CCObject.h"
}
# 31 "Cacao/include/cocos2dx/actions/CCAction.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCGeometry.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCGeometry.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/math.h" 1 3
# 28 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/math.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 1 3
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern "C" {
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
 typedef float float_t;
 typedef double double_t;
# 108 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern int __math_errhandling ( void );
# 128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern int __fpclassifyf(float );
extern int __fpclassifyd(double );
extern int __fpclassify (long double);
# 163 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
 static __inline__ int __inline_isfinitef (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinited (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinite (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isinff (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinfd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinf (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnanf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnand (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnan (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormalf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormald (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormal (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbit (long double) __attribute__ ((always_inline));

 static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
 static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
 static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
 static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
 static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
 static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
 static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
 static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
 static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
 static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
 static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
 static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); }
 static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= 1.17549435e-38F; }
 static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= 2.2250738585072014e-308; }
 static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= 3.36210314311209350626e-4932L; }
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern double acos( double );
extern float acosf( float );

extern double asin( double );
extern float asinf( float );

extern double atan( double );
extern float atanf( float );

extern double atan2( double, double );
extern float atan2f( float, float );

extern double cos( double );
extern float cosf( float );

extern double sin( double );
extern float sinf( float );

extern double tan( double );
extern float tanf( float );

extern double acosh( double );
extern float acoshf( float );

extern double asinh( double );
extern float asinhf( float );

extern double atanh( double );
extern float atanhf( float );

extern double cosh( double );
extern float coshf( float );

extern double sinh( double );
extern float sinhf( float );

extern double tanh( double );
extern float tanhf( float );

extern double exp ( double );
extern float expf ( float );

extern double exp2 ( double );
extern float exp2f ( float );

extern double expm1 ( double );
extern float expm1f ( float );

extern double log ( double );
extern float logf ( float );

extern double log10 ( double );
extern float log10f ( float );

extern double log2 ( double );
extern float log2f ( float );

extern double log1p ( double );
extern float log1pf ( float );

extern double logb ( double );
extern float logbf ( float );

extern double modf ( double, double * );
extern float modff ( float, float * );

extern double ldexp ( double, int );
extern float ldexpf ( float, int );

extern double frexp ( double, int * );
extern float frexpf ( float, int * );

extern int ilogb ( double );
extern int ilogbf ( float );

extern double scalbn ( double, int );
extern float scalbnf ( float, int );

extern double scalbln ( double, long int );
extern float scalblnf ( float, long int );

extern double fabs( double );
extern float fabsf( float );

extern double cbrt( double );
extern float cbrtf( float );

extern double hypot ( double, double );
extern float hypotf ( float, float );

extern double pow ( double, double );
extern float powf ( float, float );

extern double sqrt( double );
extern float sqrtf( float );

extern double erf( double );
extern float erff( float );

extern double erfc( double );
extern float erfcf( float );






extern double lgamma( double );
extern float lgammaf( float );

extern double tgamma( double );
extern float tgammaf( float );

extern double ceil ( double );
extern float ceilf ( float );

extern double floor ( double );
extern float floorf ( float );

extern double nearbyint ( double );
extern float nearbyintf ( float );

extern double rint ( double );
extern float rintf ( float );

extern long int lrint ( double );
extern long int lrintf ( float );

extern double round ( double );
extern float roundf ( float );

extern long int lround ( double );
extern long int lroundf ( float );



    extern long long int llrint ( double );
    extern long long int llrintf ( float );
    extern long long int llround ( double );
    extern long long int llroundf ( float );


extern double trunc ( double );
extern float truncf ( float );

extern double fmod ( double, double );
extern float fmodf ( float, float );

extern double remainder ( double, double );
extern float remainderf ( float, float );

extern double remquo ( double, double, int * );
extern float remquof ( float, float, int * );

extern double copysign ( double, double );
extern float copysignf ( float, float );

extern double nan( const char * );
extern float nanf( const char * );

extern double nextafter ( double, double );
extern float nextafterf ( float, float );

extern double fdim ( double, double );
extern float fdimf ( float, float );

extern double fmax ( double, double );
extern float fmaxf ( float, float );

extern double fmin ( double, double );
extern float fminf ( float, float );

extern double fma ( double, double, double );
extern float fmaf ( float, float, float );

extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double exp2l(long double);
extern long double expm1l(long double);
extern long double logl(long double);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);
extern long double logbl(long double);
extern long double modfl(long double, long double *);
extern long double ldexpl(long double, int);
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double scalbnl(long double, int);
extern long double scalblnl(long double, long int);
extern long double fabsl(long double);
extern long double cbrtl(long double);
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double erfl(long double);
extern long double erfcl(long double);






extern long double lgammal(long double);

extern long double tgammal(long double);
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
extern long double rintl(long double);
extern long int lrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);



    extern long long int llrintl(long double);
    extern long long int llroundl(long double);


extern long double truncl(long double);
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);
# 507 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern double __inf( void );
extern float __inff( void );
extern long double __infl( void );
extern float __nan( void );


extern double j0 ( double );

extern double j1 ( double );

extern double jn ( int, double );

extern double y0 ( double );

extern double y1 ( double );

extern double yn ( int, double );

extern double scalb ( double, double );
# 543 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern int signgam;
# 558 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern long int rinttol ( double );


extern long int roundtol ( double );
# 643 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
}
# 29 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/math.h" 2 3
# 31 "Cacao/include/cocos2dx/cocoa/CCGeometry.h" 2

namespace cocos2d {







class CCSize;




class CCPoint
{
public:
    float x;
    float y;

public:
    CCPoint();
    CCPoint(float x, float y);



    CCPoint(const CCPoint& other);



    CCPoint(const CCSize& size);



    CCPoint& operator= (const CCPoint& other);



    CCPoint& operator= (const CCSize& size);



    CCPoint operator+(const CCPoint& right) const;



    CCPoint operator-(const CCPoint& right) const;



    CCPoint operator-() const;



    CCPoint operator*(float a) const;



    CCPoint operator/(float a) const;



    void setPoint(float x, float y);
    bool equals(const CCPoint& target) const;





    bool fuzzyEquals(const CCPoint& target, float variance) const;






    inline float getLength() const {
        return sqrtf(x*x + y*y);
    };






    inline float getLengthSq() const {
        return dot(*this);
    };





    inline float getDistanceSq(const CCPoint& other) const {
        return (*this - other).getLengthSq();
    };





    inline float getDistance(const CCPoint& other) const {
        return (*this - other).getLength();
    };




    inline float getAngle() const {
        return atan2f(y, x);
    };




    float getAngle(const CCPoint& other) const;





    inline float dot(const CCPoint& other) const {
        return x*other.x + y*other.y;
    };





    inline float cross(const CCPoint& other) const {
        return x*other.y - y*other.x;
    };





    inline CCPoint getPerp() const {
        return CCPoint(-y, x);
    };





    inline CCPoint getRPerp() const {
        return CCPoint(y, -x);
    };





    inline CCPoint project(const CCPoint& other) const {
        return other * (dot(other)/other.dot(other));
    };






    inline CCPoint rotate(const CCPoint& other) const {
        return CCPoint(x*other.x - y*other.y, x*other.y + y*other.x);
    };






    inline CCPoint unrotate(const CCPoint& other) const {
        return CCPoint(x*other.x + y*other.y, y*other.x - x*other.y);
    };






    inline CCPoint normalize() const {
        float length = getLength();
        if(length == 0.) return CCPoint(1.f, 0);
        return *this / getLength();
    };
# 224 "Cacao/include/cocos2dx/cocoa/CCGeometry.h"
    inline CCPoint lerp(const CCPoint& other, float alpha) const {
        return *this * (1.f - alpha) + other * alpha;
    };







    CCPoint rotateByAngle(const CCPoint& pivot, float angle) const;

    static inline CCPoint forAngle(const float a)
    {
     return CCPoint(cosf(a), sinf(a));
    }
};




class CCSize
{
public:
    float width;
    float height;

public:
    CCSize();
    CCSize(float width, float height);



    CCSize(const CCSize& other);



    CCSize(const CCPoint& point);



    CCSize& operator= (const CCSize& other);



    CCSize& operator= (const CCPoint& point);



    CCSize operator+(const CCSize& right) const;



    CCSize operator-(const CCSize& right) const;



    CCSize operator*(float a) const;



    CCSize operator/(float a) const;



    void setSize(float width, float height);



    bool equals(const CCSize& target) const;
};




class CCRect
{
public:
    CCPoint origin;
    CCSize size;

public:
    CCRect();
    CCRect(float x, float y, float width, float height);



    CCRect(const CCRect& other);



    CCRect& operator= (const CCRect& other);
    void setRect(float x, float y, float width, float height);
    float getMinX() const;
    float getMidX() const;
    float getMaxX() const;
    float getMinY() const;
    float getMidY() const;
    float getMaxY() const;
    bool equals(const CCRect& rect) const;
    bool containsPoint(const CCPoint& point) const;
    bool intersectsRect(const CCRect& rect) const;
};







const CCPoint CCPointZero = CCPoint((float)(0), (float)(0));


const CCSize CCSizeZero = CCSize((float)(0), (float)(0));


const CCRect CCRectZero = CCRect((float)(0), (float)(0), (float)(0), (float)(0));




}
# 32 "Cacao/include/cocos2dx/actions/CCAction.h" 2


namespace cocos2d {

enum {

    kCCActionTagInvalid = -1,
};
# 49 "Cacao/include/cocos2dx/actions/CCAction.h"
class CCAction : public CCObject
{
public:



    CCAction(void);




    virtual ~CCAction(void);




    const char* description();




    virtual CCObject* copyWithZone(CCZone *pZone);


    virtual bool isDone(void);


    virtual void startWithTarget(CCNode *pTarget);





    virtual void stop(void);


    virtual void step(float dt);
# 95 "Cacao/include/cocos2dx/actions/CCAction.h"
    virtual void update(float time);

    inline CCNode* getTarget(void) { return m_pTarget; }

    inline void setTarget(CCNode *pTarget) { m_pTarget = pTarget; }

    inline CCNode* getOriginalTarget(void) { return m_pOriginalTarget; }





    inline void setOriginalTarget(CCNode *pOriginalTarget) { m_pOriginalTarget = pOriginalTarget; }

    inline int getTag(void) { return m_nTag; }
    inline void setTag(int nTag) { m_nTag = nTag; }

public:

    static CCAction* create();
protected:
    CCNode *m_pOriginalTarget;





    CCNode *m_pTarget;

    int m_nTag;
};
# 136 "Cacao/include/cocos2dx/actions/CCAction.h"
class CCFiniteTimeAction : public CCAction
{
public:



    CCFiniteTimeAction()
        : m_fDuration(0)
    {}




    virtual ~CCFiniteTimeAction(){}

    inline float getDuration(void) { return m_fDuration; }

    inline void setDuration(float duration) { m_fDuration = duration; }


    virtual CCFiniteTimeAction* reverse(void);
protected:

    float m_fDuration;
};

class CCActionInterval;
class CCRepeatForever;







class CCSpeed : public CCAction
{
public:



    CCSpeed()
        : m_fSpeed(0.0)
        , m_pInnerAction(__null)
    {}




    virtual ~CCSpeed(void);

    inline float getSpeed(void) { return m_fSpeed; }

    inline void setSpeed(float fSpeed) { m_fSpeed = fSpeed; }


    bool initWithAction(CCActionInterval *pAction, float fSpeed);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode* pTarget);
    virtual void stop();
    virtual void step(float dt);
    virtual bool isDone(void);
    virtual CCActionInterval* reverse(void);

    void setInnerAction(CCActionInterval *pAction);

    inline CCActionInterval* getInnerAction()
    {
        return m_pInnerAction;
    }

public:

    static CCSpeed* create(CCActionInterval* pAction, float fSpeed);
protected:
    float m_fSpeed;
    CCActionInterval *m_pInnerAction;
};
# 228 "Cacao/include/cocos2dx/actions/CCAction.h"
class CCFollow : public CCAction
{
public:



    CCFollow()
        : m_pobFollowedNode(__null)
        , m_bBoundarySet(false)
        , m_bBoundaryFullyCovered(false)
        , m_fLeftBoundary(0.0)
        , m_fRightBoundary(0.0)
        , m_fTopBoundary(0.0)
        , m_fBottomBoundary(0.0)
    {}




    virtual ~CCFollow(void);

    inline bool isBoundarySet(void) { return m_bBoundarySet; }

    inline void setBoudarySet(bool bValue) { m_bBoundarySet = bValue; }


    bool initWithTarget(CCNode *pFollowedNode, const CCRect& rect = CCRectZero);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void step(float dt);
    virtual bool isDone(void);
    virtual void stop(void);

public:



    static CCFollow* create(CCNode *pFollowedNode, const CCRect& rect = CCRectZero);
protected:

    CCNode *m_pobFollowedNode;


    bool m_bBoundarySet;


    bool m_bBoundaryFullyCovered;


    CCPoint m_obHalfScreenSize;
    CCPoint m_obFullScreenSize;


    float m_fLeftBoundary;
    float m_fRightBoundary;
    float m_fTopBoundary;
    float m_fBottomBoundary;
};




}
# 42 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionInterval.h"
# 1 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 1
# 31 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
# 1 "Cacao/include/cocos2dx/include/ccMacros.h" 1
# 34 "Cacao/include/cocos2dx/include/ccMacros.h"
# 1 "Cacao/include/cocos2dx/platform/CCCommon.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCCommon.h"
namespace cocos2d {







static const int kMaxLogLen = 16*1024;




void CCLog(const char * pszFormat, ...) __attribute__((__format__(printf, 1, 2)));




void CCLuaLog(const char * pszFormat);




void CCMessageBox(const char * pszMsg, const char * pszTitle);




typedef enum LanguageType
{
    kLanguageEnglish = 0,
    kLanguageChinese,
    kLanguageFrench,
    kLanguageItalian,
    kLanguageGerman,
    kLanguageSpanish,
    kLanguageRussian,
    kLanguageKorean,
    kLanguageJapanese,
    kLanguageHungarian,
    kLanguagePortuguese,
    kLanguageArabic
} ccLanguageType;




}
# 35 "Cacao/include/cocos2dx/include/ccMacros.h" 2
# 1 "Cacao/include/cocos2dx/platform/mac/CCStdC.h" 1
# 29 "Cacao/include/cocos2dx/platform/mac/CCStdC.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.0/include/float.h" 1 3 4
# 30 "Cacao/include/cocos2dx/platform/mac/CCStdC.h" 2






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 1 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 2 3
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 144 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
struct clockinfo {
 int hz;
 int tick;
 int tickadj;
 int stathz;
 int profhz;
};







extern "C" {


int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *) __attribute__((visibility("default")));
int settimeofday(const struct timeval *, const struct timezone *);


int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * , void * );



int setitimer(int, const struct itimerval * ,
  struct itimerval * );
int utimes(const char *, const struct timeval *);

}
# 37 "Cacao/include/cocos2dx/platform/mac/CCStdC.h" 2
# 36 "Cacao/include/cocos2dx/include/ccMacros.h" 2
# 248 "Cacao/include/cocos2dx/include/ccMacros.h"
extern unsigned int g_uNumberOfDraws;
# 32 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCAffineTransform.h" 1
# 31 "Cacao/include/cocos2dx/cocoa/CCAffineTransform.h"
namespace cocos2d {

struct CCAffineTransform {
  float a, b, c, d;
  float tx, ty;
};

       CCAffineTransform __CCAffineTransformMake(float a, float b, float c, float d, float tx, float ty);


       CCPoint __CCPointApplyAffineTransform(const CCPoint& point, const CCAffineTransform& t);


       CCSize __CCSizeApplyAffineTransform(const CCSize& size, const CCAffineTransform& t);


       CCAffineTransform CCAffineTransformMakeIdentity();
       CCRect CCRectApplyAffineTransform(const CCRect& rect, const CCAffineTransform& anAffineTransform);

       CCAffineTransform CCAffineTransformTranslate(const CCAffineTransform& t, float tx, float ty);
       CCAffineTransform CCAffineTransformRotate(const CCAffineTransform& aTransform, float anAngle);
       CCAffineTransform CCAffineTransformScale(const CCAffineTransform& t, float sx, float sy);
       CCAffineTransform CCAffineTransformConcat(const CCAffineTransform& t1, const CCAffineTransform& t2);
       bool CCAffineTransformEqualToTransform(const CCAffineTransform& t1, const CCAffineTransform& t2);
       CCAffineTransform CCAffineTransformInvert(const CCAffineTransform& t);

extern const CCAffineTransform CCAffineTransformIdentity;

}
# 33 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCArray.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCArray.h"
# 1 "Cacao/include/cocos2dx/support/data_support/ccCArray.h" 1
# 52 "Cacao/include/cocos2dx/support/data_support/ccCArray.h"
namespace cocos2d {
# 61 "Cacao/include/cocos2dx/support/data_support/ccCArray.h"
typedef struct _ccArray {
 unsigned int num, max;
 CCObject** arr;
} ccArray;


ccArray* ccArrayNew(unsigned int capacity);


void ccArrayFree(ccArray*& arr);


void ccArrayDoubleCapacity(ccArray *arr);


void ccArrayEnsureExtraCapacity(ccArray *arr, unsigned int extra);


void ccArrayShrink(ccArray *arr);


unsigned int ccArrayGetIndexOfObject(ccArray *arr, CCObject* object);


bool ccArrayContainsObject(ccArray *arr, CCObject* object);


void ccArrayAppendObject(ccArray *arr, CCObject* object);


void ccArrayAppendObjectWithResize(ccArray *arr, CCObject* object);



void ccArrayAppendArray(ccArray *arr, ccArray *plusArr);


void ccArrayAppendArrayWithResize(ccArray *arr, ccArray *plusArr);


void ccArrayInsertObjectAtIndex(ccArray *arr, CCObject* object, unsigned int index);


void ccArraySwapObjectsAtIndexes(ccArray *arr, unsigned int index1, unsigned int index2);


void ccArrayRemoveAllObjects(ccArray *arr);



void ccArrayRemoveObjectAtIndex(ccArray *arr, unsigned int index, bool bReleaseObj = true);




void ccArrayFastRemoveObjectAtIndex(ccArray *arr, unsigned int index);

void ccArrayFastRemoveObject(ccArray *arr, CCObject* object);



void ccArrayRemoveObject(ccArray *arr, CCObject* object, bool bReleaseObj = true);



void ccArrayRemoveArray(ccArray *arr, ccArray *minusArr);



void ccArrayFullRemoveArray(ccArray *arr, ccArray *minusArr);




typedef struct _ccCArray {
    unsigned int num, max;
    void** arr;
} ccCArray;


ccCArray* ccCArrayNew(unsigned int capacity);


void ccCArrayFree(ccCArray *arr);


void ccCArrayDoubleCapacity(ccCArray *arr);


void ccCArrayEnsureExtraCapacity(ccCArray *arr, unsigned int extra);


unsigned int ccCArrayGetIndexOfValue(ccCArray *arr, void* value);


bool ccCArrayContainsValue(ccCArray *arr, void* value);


void ccCArrayInsertValueAtIndex( ccCArray *arr, void* value, unsigned int index);


void ccCArrayAppendValue(ccCArray *arr, void* value);


void ccCArrayAppendValueWithResize(ccCArray *arr, void* value);



void ccCArrayAppendArray(ccCArray *arr, ccCArray *plusArr);


void ccCArrayAppendArrayWithResize(ccCArray *arr, ccCArray *plusArr);


void ccCArrayRemoveAllValues(ccCArray *arr);





void ccCArrayRemoveValueAtIndex(ccCArray *arr, unsigned int index);






void ccCArrayFastRemoveValueAtIndex(ccCArray *arr, unsigned int index);




void ccCArrayRemoveValue(ccCArray *arr, void* value);




void ccCArrayRemoveArray(ccCArray *arr, ccCArray *minusArr);




void ccCArrayFullRemoveArray(ccCArray *arr, ccCArray *minusArr);

}
# 29 "Cacao/include/cocos2dx/cocoa/CCArray.h" 2
# 110 "Cacao/include/cocos2dx/cocoa/CCArray.h"
namespace cocos2d {



class CCArray : public CCObject
{
public:



    ~CCArray();


    static CCArray* create();



    static CCArray* create(CCObject* pObject, ...);

    static CCArray* createWithObject(CCObject* pObject);

    static CCArray* createWithCapacity(unsigned int capacity);

    static CCArray* createWithArray(CCArray* otherArray);





    static CCArray* createWithContentsOfFile(const char* pFileName);






    static CCArray* createWithContentsOfFileThreadSafe(const char* pFileName);




    bool init();



    bool initWithObject(CCObject* pObject);



    bool initWithObjects(CCObject* pObject, ...);



    bool initWithCapacity(unsigned int capacity);



    bool initWithArray(CCArray* otherArray);




    unsigned int count() const;

    unsigned int capacity() const;

    unsigned int indexOfObject(CCObject* object) const;

    CCObject* objectAtIndex(unsigned int index);

    CCObject* lastObject();

    CCObject* randomObject();

    bool containsObject(CCObject* object) const;

    bool isEqualToArray(CCArray* pOtherArray);



    void addObject(CCObject* object);

    void addObjectsFromArray(CCArray* otherArray);

    void insertObject(CCObject* object, unsigned int index);




    void removeLastObject(bool bReleaseObj = true);

    void removeObject(CCObject* object, bool bReleaseObj = true);

    void removeObjectAtIndex(unsigned int index, bool bReleaseObj = true);

    void removeObjectsInArray(CCArray* otherArray);

    void removeAllObjects();

    void fastRemoveObject(CCObject* object);

    void fastRemoveObjectAtIndex(unsigned int index);




    void exchangeObject(CCObject* object1, CCObject* object2);

    void exchangeObjectAtIndex(unsigned int index1, unsigned int index2);


    void replaceObjectAtIndex(unsigned int uIndex, CCObject* pObject, bool bReleaseObject = true);


    void reverseObjects();

    void reduceMemoryFootprint();





    virtual CCObject* copyWithZone(CCZone* pZone);


    virtual void acceptVisitor(CCDataVisitor &visitor);

public:
    ccArray* data;



    CCArray();



    CCArray(unsigned int capacity);
};




}
# 34 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/platform/mac/CCGL.h" 1
# 28 "Cacao/include/cocos2dx/platform/mac/CCGL.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3








extern "C" {
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

typedef long GLintptr;
typedef long GLsizeiptr;




typedef char GLchar;






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 1 3







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/inttypes.h" 1 3
# 257 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/inttypes.h" 3
extern "C" {


  extern intmax_t imaxabs(intmax_t j);


  typedef struct {
        intmax_t quot;
        intmax_t rem;
  } imaxdiv_t;

  extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);


  extern intmax_t strtoimax(const char * nptr, char ** endptr, int base);
  extern uintmax_t strtoumax(const char * nptr, char ** endptr, int base);
# 282 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/inttypes.h" 3
  extern intmax_t wcstoimax(const wchar_t * nptr, wchar_t ** endptr, int base);
  extern uintmax_t wcstoumax(const wchar_t * nptr, wchar_t ** endptr, int base);






}
# 9 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 2 3


extern "C" {
# 313 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
typedef unsigned short GLhalfARB;



typedef unsigned short GLhalf;



typedef char GLcharARB;
typedef void *GLhandleARB;



typedef long GLintptrARB;
typedef long GLsizeiptrARB;




typedef int64_t GLint64;
typedef uint64_t GLuint64;
typedef struct __GLsync *GLsync;



typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;
# 3135 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glActiveTextureARB(GLenum texture);
extern void glClientActiveTextureARB(GLenum texture);
extern void glMultiTexCoord1dARB(GLenum target, GLdouble s);
extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord1fARB(GLenum target, GLfloat s);
extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord1iARB(GLenum target, GLint s);
extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord1sARB(GLenum target, GLshort s);
extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v);
# 3179 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glLoadTransposeMatrixfARB(const GLfloat *m);
extern void glLoadTransposeMatrixdARB(const GLdouble *m);
extern void glMultTransposeMatrixfARB(const GLfloat *m);
extern void glMultTransposeMatrixdARB(const GLdouble *m);







extern void glSampleCoverageARB(GLclampf value, GLboolean invert);
# 3204 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data);
# 3227 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWeightbvARB(GLint size, const GLbyte *weights);
extern void glWeightsvARB(GLint size, const GLshort *weights);
extern void glWeightivARB(GLint size, const GLint *weights);
extern void glWeightfvARB(GLint size, const GLfloat *weights);
extern void glWeightdvARB(GLint size, const GLdouble *weights);
extern void glWeightubvARB(GLint size, const GLubyte *weights);
extern void glWeightusvARB(GLint size, const GLushort *weights);
extern void glWeightuivARB(GLint size, const GLuint *weights);
extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexBlendARB(GLint count);
# 3259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWindowPos2dARB(GLdouble x, GLdouble y);
extern void glWindowPos2dvARB(const GLdouble *p);
extern void glWindowPos2fARB(GLfloat x, GLfloat y);
extern void glWindowPos2fvARB(const GLfloat *p);
extern void glWindowPos2iARB(GLint x, GLint y);
extern void glWindowPos2ivARB(const GLint *p);
extern void glWindowPos2sARB(GLshort x, GLshort y);
extern void glWindowPos2svARB(const GLshort *p);
extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dvARB(const GLdouble *p);
extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fvARB(const GLfloat *p);
extern void glWindowPos3iARB(GLint x, GLint y, GLint z);
extern void glWindowPos3ivARB(const GLint *p);
extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z);
extern void glWindowPos3svARB(const GLshort *p);
# 3289 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenQueriesARB(GLsizei n, GLuint *ids);
extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids);
extern GLboolean glIsQueryARB(GLuint id);
extern void glBeginQueryARB(GLenum target, GLuint id);
extern void glEndQueryARB(GLenum target);
extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params);
# 3305 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameterfARB(GLenum pname, GLfloat param);
extern void glPointParameterfvARB(GLenum pname, const GLfloat *params);
# 3341 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindProgramARB(GLenum target, GLuint program);
extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs);
extern void glGenProgramsARB(GLsizei n, GLuint *programs);
extern GLboolean glIsProgramARB(GLuint program);

extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);

extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params);

extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);


extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params);

extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string);
extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string);

extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params);
# 3424 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttrib1dARB(GLuint index, GLdouble x);
extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib1fARB(GLuint index, GLfloat x);
extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib1sARB(GLuint index, GLshort x);
extern void glVertexAttrib1svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4NivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v);
extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib4ivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v);
extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);

extern void glDisableVertexAttribArrayARB(GLuint index);
extern void glEnableVertexAttribArrayARB(GLuint index);

extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer);
extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params);
# 3515 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDeleteObjectARB(GLhandleARB obj);
extern GLhandleARB glGetHandleARB(GLenum pname);
extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);
extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType);
extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length);
extern void glCompileShaderARB(GLhandleARB shaderObj);
extern GLhandleARB glCreateProgramObjectARB(void);
extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);
extern void glLinkProgramARB(GLhandleARB programObj);
extern void glUseProgramObjectARB(GLhandleARB programObj);
extern void glValidateProgramARB(GLhandleARB programObj);
extern void glUniform1fARB(GLint location, GLfloat v0);
extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1iARB(GLint location, GLint v0);
extern void glUniform2iARB(GLint location, GLint v0, GLint v1);
extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params);
extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params);
extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name);
extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params);
extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params);
extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
# 3563 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name);
extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name);
# 3583 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferARB(GLenum target, GLuint buffer);
extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers);
extern void glGenBuffersARB(GLsizei n, GLuint *buffers);
extern GLboolean glIsBufferARB(GLuint buffer);
extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
extern GLvoid *glMapBufferARB(GLenum target, GLenum access);
extern GLboolean glUnmapBufferARB(GLenum target);
extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params);







extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs);







extern void glClampColorARB(GLenum target, GLenum clamp);
# 3618 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);







extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor);
# 3638 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex);
extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount, const GLint *base_vertex);
# 3655 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLsync glFenceSync(GLenum condition, GLbitfield flags);
extern GLboolean glIsSync(GLsync sync);
extern void glDeleteSync(GLsync sync);
extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glGetInteger64v(GLenum pname, GLint64 *params);
extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);







extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
# 3821 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBlendEquationEXT(GLenum mode);
# 3891 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 3941 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bvEXT(const GLbyte *v);
extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dvEXT(const GLdouble *v);
extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fvEXT(const GLfloat *v);
extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue);
extern void glSecondaryColor3ivEXT(const GLint *v);
extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3svEXT(const GLshort *v);
extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubvEXT(const GLubyte *v);
extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uivEXT(const GLuint *v);
extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usvEXT(const GLushort *v);
extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 3974 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount);
# 3987 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFogCoordfEXT(GLfloat coord);
extern void glFogCoordfvEXT(const GLfloat *coord);
extern void glFogCoorddEXT(GLdouble coord);
extern void glFogCoorddvEXT(const GLdouble *coord);
extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer);
# 4049 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 4203 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glActiveStencilFaceEXT(GLenum face);







extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);







extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);
# 4243 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer);
extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebufferEXT(GLuint framebuffer);
extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatusEXT(GLenum target);
extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmapEXT(GLenum target);







extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);







extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 4285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);







extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 4322 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLboolean glIsRenderbuffer(GLuint renderbuffer);
extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebuffer(GLuint framebuffer);
extern void glBindFramebuffer(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatus(GLenum target);
extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmap(GLenum target);
extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 4355 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);
extern void glBeginTransformFeedbackEXT(GLenum primitiveMode);
extern void glEndTransformFeedbackEXT(void);
extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode);
extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
# 4370 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values);
extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values);
# 4381 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);
extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location);
extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location);
# 4396 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glClearColorIiEXT( GLint r, GLint g, GLint b, GLint a );
extern void glClearColorIuiEXT( GLuint r, GLuint g, GLuint b, GLuint a );
extern void glTexParameterIivEXT( GLenum target, GLenum pname, GLint *params );
extern void glTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params );
extern void glGetTexParameterIivEXT( GLenum target, GLenum pname, GLint *params);
extern void glGetTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params);
# 4442 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttribI1iEXT(GLuint index, GLint x);
extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern void glVertexAttribI1uiEXT(GLuint index, GLuint x);
extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v);
extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v);
extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v);
extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v);
extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params);
extern void glUniform1uiEXT(GLint location, GLuint v0);
extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);
extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params);
extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name);
extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name);
# 4486 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern void glEnableIndexedEXT(GLenum target, GLuint index);
extern void glDisableIndexedEXT(GLenum target, GLuint index);
extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index);







extern void glProvokingVertexEXT(GLenum mode);







extern void glProvokingVertex(GLenum mode);
# 4514 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params);
extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params);
# 4524 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer);
extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params);
# 4535 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param);
# 4548 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindVertexArrayAPPLE(GLuint id);
extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids);
extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids);
extern GLboolean glIsVertexArrayAPPLE(GLuint id);
# 4566 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenFencesAPPLE(GLsizei n, GLuint *fences);
extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences);
extern void glSetFenceAPPLE(GLuint fence);
extern GLboolean glIsFenceAPPLE(GLuint fence);
extern GLboolean glTestFenceAPPLE(GLuint fence);
extern void glFinishFenceAPPLE(GLuint fence);
extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name);
extern void glFinishObjectAPPLE(GLenum object, GLuint name);
# 4585 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer);
extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);
extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
# 4599 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFlushRenderAPPLE(void);
extern void glFinishRenderAPPLE(void);
extern void glSwapAPPLE(void);
# 4615 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname);
extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname);
extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);
extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
# 4630 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);
extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);
# 4641 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params);
# 4652 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexPointSizefAPPLE(GLfloat size);
# 4662 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPNTrianglesiATI(GLenum pname, GLint param);
extern void glPNTrianglesfATI(GLenum pname, GLfloat param);







extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha);
# 4680 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
# 4690 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPNTrianglesiATIX(GLenum pname, GLint param);
extern void glPNTrianglesfATIX(GLenum pname, GLfloat param);
# 4963 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameteriNV(GLenum pname, GLint param);
extern void glPointParameterivNV(GLenum pname, const GLint *params);
# 5407 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBeginConditionalRenderNV(GLuint id, GLenum mode);
extern void glEndConditionalRenderNV(void);



}
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 2 3
# 2405 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glBlendEquation (GLenum mode);
extern void glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
extern void glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params);
extern void glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glConvolutionParameteri (GLenum target, GLenum pname, GLint params);
extern void glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
extern void glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, GLvoid **params);
extern void glGetPolygonStipple (GLubyte *mask);
extern void glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern const GLubyte *glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMinmax (GLenum target, GLenum internalformat, GLboolean sink);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLint mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLint mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLint mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glResetHistogram (GLenum target);
extern void glResetMinmax (GLenum target);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

extern void glSampleCoverage (GLclampf value, GLboolean invert);

extern void glLoadTransposeMatrixf (const GLfloat *m);
extern void glLoadTransposeMatrixd (const GLdouble *m);
extern void glMultTransposeMatrixf (const GLfloat *m);
extern void glMultTransposeMatrixd (const GLdouble *m);

extern void glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImage (GLenum target, GLint lod, GLvoid *img);

extern void glActiveTexture (GLenum texture);
extern void glClientActiveTexture (GLenum texture);
extern void glMultiTexCoord1d (GLenum target, GLdouble s);
extern void glMultiTexCoord1dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord1f (GLenum target, GLfloat s);
extern void glMultiTexCoord1fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord1i (GLenum target, GLint s);
extern void glMultiTexCoord1iv (GLenum target, const GLint *v);
extern void glMultiTexCoord1s (GLenum target, GLshort s);
extern void glMultiTexCoord1sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord2i (GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2iv (GLenum target, const GLint *v);
extern void glMultiTexCoord2s (GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3iv (GLenum target, const GLint *v);
extern void glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord4i (GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4iv (GLenum target, const GLint *v);
extern void glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4sv (GLenum target, const GLshort *v);

extern void glFogCoordf (GLfloat coord);
extern void glFogCoordfv (const GLfloat *coord);
extern void glFogCoordd (GLdouble coord);
extern void glFogCoorddv (const GLdouble *coord);
extern void glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bv (const GLbyte *v);
extern void glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dv (const GLdouble *v);
extern void glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fv (const GLfloat *v);
extern void glSecondaryColor3i (GLint red, GLint green, GLint blue);
extern void glSecondaryColor3iv (const GLint *v);
extern void glSecondaryColor3s (GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3sv (const GLshort *v);
extern void glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubv (const GLubyte *v);
extern void glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uiv (const GLuint *v);
extern void glSecondaryColor3us (GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usv (const GLushort *v);
extern void glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glPointParameterf (GLenum pname, GLfloat param);
extern void glPointParameterfv (GLenum pname, const GLfloat *params);
extern void glPointParameteri (GLenum pname, GLint param);
extern void glPointParameteriv (GLenum pname, const GLint *params);

extern void glBlendFuncSeparate (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

extern void glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount);

extern void glWindowPos2d (GLdouble x, GLdouble y);
extern void glWindowPos2dv (const GLdouble *v);
extern void glWindowPos2f (GLfloat x, GLfloat y);
extern void glWindowPos2fv (const GLfloat *v);
extern void glWindowPos2i (GLint x, GLint y);
extern void glWindowPos2iv (const GLint *v);
extern void glWindowPos2s (GLshort x, GLshort y);
extern void glWindowPos2sv (const GLshort *v);
extern void glWindowPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dv (const GLdouble *v);
extern void glWindowPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fv (const GLfloat *v);
extern void glWindowPos3i (GLint x, GLint y, GLint z);
extern void glWindowPos3iv (const GLint *v);
extern void glWindowPos3s (GLshort x, GLshort y, GLshort z);
extern void glWindowPos3sv (const GLshort *v);

extern void glGenQueries (GLsizei n, GLuint *ids);
extern void glDeleteQueries (GLsizei n, const GLuint *ids);
extern GLboolean glIsQuery (GLuint id);
extern void glBeginQuery (GLenum target, GLuint id);
extern void glEndQuery (GLenum target);
extern void glGetQueryiv (GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectiv (GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);

extern void glBindBuffer (GLenum target, GLuint buffer);
extern void glDeleteBuffers (GLsizei n, const GLuint *buffers);
extern void glGenBuffers (GLsizei n, GLuint *buffers);
extern GLboolean glIsBuffer (GLuint buffer);
extern void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
extern void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
extern void glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
extern GLvoid *glMapBuffer (GLenum target, GLenum access);
extern GLboolean glUnmapBuffer (GLenum target);
extern void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointerv (GLenum target, GLenum pname, GLvoid **params);

extern void glDrawBuffers (GLsizei n, const GLenum *bufs);
extern void glVertexAttrib1d (GLuint index, GLdouble x);
extern void glVertexAttrib1dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib1f (GLuint index, GLfloat x);
extern void glVertexAttrib1fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib1s (GLuint index, GLshort x);
extern void glVertexAttrib1sv (GLuint index, const GLshort *v);
extern void glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib2s (GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2sv (GLuint index, const GLshort *v);
extern void glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nbv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4Niv (GLuint index, const GLint *v);
extern void glVertexAttrib4Nsv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4Nubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4Nuiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4Nusv (GLuint index, const GLushort *v);
extern void glVertexAttrib4bv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib4iv (GLuint index, const GLint *v);
extern void glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4ubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4uiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4usv (GLuint index, const GLushort *v);
extern void glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
extern void glEnableVertexAttribArray (GLuint index);
extern void glDisableVertexAttribArray (GLuint index);
extern void glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid **pointer);
extern void glDeleteShader (GLuint shader);
extern void glDetachShader (GLuint program, GLuint shader);
extern GLuint glCreateShader (GLenum type);
extern void glShaderSource (GLuint shader, GLsizei count, const GLchar **string, const GLint *length);
extern void glCompileShader (GLuint shader);
extern GLuint glCreateProgram (void);
extern void glAttachShader (GLuint program, GLuint shader);
extern void glLinkProgram (GLuint program);
extern void glUseProgram (GLuint program);
extern void glDeleteProgram (GLuint program);
extern void glValidateProgram (GLuint program);
extern void glUniform1f (GLint location, GLfloat v0);
extern void glUniform2f (GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1i (GLint location, GLint v0);
extern void glUniform2i (GLint location, GLint v0, GLint v1);
extern void glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform2iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform3iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform4iv (GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern GLboolean glIsShader (GLuint shader);
extern GLboolean glIsProgram (GLuint program);
extern void glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
extern void glGetProgramiv (GLuint program, GLenum pname, GLint *params);
extern void glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern void glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern void glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern GLint glGetUniformLocation (GLuint program, const GLchar *name);
extern void glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern void glGetUniformfv (GLuint program, GLint location, GLfloat *params);
extern void glGetUniformiv (GLuint program, GLint location, GLint *params);
extern void glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern void glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
extern void glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern GLint glGetAttribLocation (GLuint program, const GLchar *name);
extern void glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
extern void glStencilOpSeparate (GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
extern void glStencilMaskSeparate (GLenum face, GLuint mask);

extern void glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);





}
# 29 "Cacao/include/cocos2dx/platform/mac/CCGL.h" 2
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 1 3
# 11 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern "C" {
# 218 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
class GLUnurbs;
class GLUquadric;
class GLUtesselator;

typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;
# 239 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern void gluBeginCurve (GLUnurbs* nurb);
extern void gluBeginPolygon (GLUtesselator* tess);
extern void gluBeginSurface (GLUnurbs* nurb);
extern void gluBeginTrim (GLUnurbs* nurb);
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString);
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks);
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb);
extern void gluDeleteQuadric (GLUquadric* quad);
extern void gluDeleteTess (GLUtesselator* tess);
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops);
extern void gluEndCurve (GLUnurbs* nurb);
extern void gluEndPolygon (GLUtesselator* tess);
extern void gluEndSurface (GLUnurbs* nurb);
extern void gluEndTrim (GLUnurbs* nurb);
extern const GLubyte * gluErrorString (GLenum error);
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data);
extern const GLubyte * gluGetString (GLenum name);
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data);
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view);
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ);
extern GLUnurbs* gluNewNurbsRenderer (void);
extern GLUquadric* gluNewQuadric (void);
extern GLUtesselator* gluNewTess (void);
extern void gluNextContour (GLUtesselator* tess, GLenum type);
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)());
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type);
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value);
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type);
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top);
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep);
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport);
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ);
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type);
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, GLvoid (*CallBackFunc)());
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw);
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal);
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation);
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture);
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut);
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks);
extern void gluTessBeginContour (GLUtesselator* tess);
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data);
extern void gluTessCallback (GLUtesselator* tess, GLenum which, GLvoid (*CallBackFunc)());
extern void gluTessEndContour (GLUtesselator* tess);
extern void gluTessEndPolygon (GLUtesselator* tess);
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ);
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data);
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data);
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ);
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW);


}
# 30 "Cacao/include/cocos2dx/platform/mac/CCGL.h" 2
# 35 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h" 1
# 33 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
namespace cocos2d {






class CCGLProgram;


enum {
    kCCVertexAttribFlag_None = 0,

    kCCVertexAttribFlag_Position = 1 << 0,
    kCCVertexAttribFlag_Color = 1 << 1,
    kCCVertexAttribFlag_TexCoords = 1 << 2,

    kCCVertexAttribFlag_PosColorTex = ( kCCVertexAttribFlag_Position | kCCVertexAttribFlag_Color | kCCVertexAttribFlag_TexCoords ),
};


typedef enum {
# 63 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
      CC_GL_ALL = 0,

} ccGLServerState;
# 74 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
void ccGLInvalidateStateCache(void);





void ccGLUseProgram(GLuint program);





void ccGLDeleteProgram(GLuint program);





void ccGLBlendFunc(GLenum sfactor, GLenum dfactor);





void ccGLBlendResetToCache(void);




void ccSetProjectionMatrixDirty(void);
# 116 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
void ccGLEnableVertexAttribs(unsigned int flags);





void ccGLBindTexture2D(GLuint textureId);






void ccGLBindTexture2DN(GLuint textureUnit, GLuint textureId);





void ccGLDeleteTexture(GLuint textureId);





void ccGLDeleteTextureN(GLuint textureUnit, GLuint textureId);





void ccGLBindVAO(GLuint vaoId);





void ccGLEnable( ccGLServerState flags );




}
# 36 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/shaders/CCGLProgram.h" 1
# 36 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
namespace cocos2d {






enum {
    kCCVertexAttrib_Position,
    kCCVertexAttrib_Color,
    kCCVertexAttrib_TexCoords,

    kCCVertexAttrib_MAX,
};

enum {
 kCCUniformPMatrix,
 kCCUniformMVMatrix,
 kCCUniformMVPMatrix,
 kCCUniformTime,
 kCCUniformSinTime,
 kCCUniformCosTime,
 kCCUniformRandom01,
 kCCUniformSampler,

 kCCUniform_MAX,
};
# 90 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
struct _hashUniformEntry;

typedef void (*GLInfoFunction)(GLuint program, GLenum pname, GLint* params);
typedef void (*GLLogFunction) (GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog);







class CCGLProgram : public CCObject
{
public:




    CCGLProgram();




    virtual ~CCGLProgram();




    bool initWithVertexShaderByteArray(const GLchar* vShaderByteArray, const GLchar* fShaderByteArray);
# 128 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
    bool initWithVertexShaderFilename(const char* vShaderFilename, const char* fShaderFilename);



    void addAttribute(const char* attributeName, GLuint index);



    bool link();



    void use();
# 150 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
    void updateUniforms();




    GLint getUniformLocationForName(const char* name);





    void setUniformLocationWith1i(GLint location, GLint i1);




    void setUniformLocationWith2i(GLint location, GLint i1, GLint i2);




    void setUniformLocationWith3i(GLint location, GLint i1, GLint i2, GLint i3);




    void setUniformLocationWith4i(GLint location, GLint i1, GLint i2, GLint i3, GLint i4);




    void setUniformLocationWith2iv(GLint location, GLint* ints, unsigned int numberOfArrays);




    void setUniformLocationWith3iv(GLint location, GLint* ints, unsigned int numberOfArrays);





    void setUniformLocationWith4iv(GLint location, GLint* ints, unsigned int numberOfArrays);





    void setUniformLocationWith1f(GLint location, GLfloat f1);





    void setUniformLocationWith2f(GLint location, GLfloat f1, GLfloat f2);





    void setUniformLocationWith3f(GLint location, GLfloat f1, GLfloat f2, GLfloat f3);





    void setUniformLocationWith4f(GLint location, GLfloat f1, GLfloat f2, GLfloat f3, GLfloat f4);





    void setUniformLocationWith2fv(GLint location, GLfloat* floats, unsigned int numberOfArrays);





    void setUniformLocationWith3fv(GLint location, GLfloat* floats, unsigned int numberOfArrays);





    void setUniformLocationWith4fv(GLint location, GLfloat* floats, unsigned int numberOfArrays);





    void setUniformLocationWithMatrix4fv(GLint location, GLfloat* matrixArray, unsigned int numberOfMatrices);




    void setUniformsForBuiltins();





    const char* vertexShaderLog();




    const char* fragmentShaderLog();




    const char* programLog();





    void reset();



    inline const GLuint getProgram() { return m_uProgram; }

private:
    bool updateUniformLocation(GLint location, GLvoid* data, unsigned int bytes);
    const char* description();
    bool compileShader(GLuint * shader, GLenum type, const GLchar* source);
    const char* logForOpenGLObject(GLuint object, GLInfoFunction infoFunc, GLLogFunction logFunc);

private:
    GLuint m_uProgram;
    GLuint m_uVertShader;
    GLuint m_uFragShader;
    GLint m_uUniforms[kCCUniform_MAX];
    struct _hashUniformEntry* m_pHashForUniforms;
    bool m_bUsesTime;
    bool m_hasShaderCompiler;




};




}
# 37 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 1
# 29 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h"
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec2.h" 1
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec2.h"
struct kmMat3;





#pragma pack(push)
#pragma pack(1)
typedef struct kmVec2 {
    float x;
    float y;
} kmVec2;

#pragma pack(pop)


extern "C" {

       kmVec2* kmVec2Fill(kmVec2* pOut, float x, float y);
       float kmVec2Length(const kmVec2* pIn);
       float kmVec2LengthSq(const kmVec2* pIn);
       kmVec2* kmVec2Normalize(kmVec2* pOut, const kmVec2* pIn);
       kmVec2* kmVec2Add(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2);
       float kmVec2Dot(const kmVec2* pV1, const kmVec2* pV2);
       kmVec2* kmVec2Subtract(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2);
       kmVec2* kmVec2Transform(kmVec2* pOut, const kmVec2* pV1, const struct kmMat3* pM);
       kmVec2* kmVec2TransformCoord(kmVec2* pOut, const kmVec2* pV, const struct kmMat3* pM);
       kmVec2* kmVec2Scale(kmVec2* pOut, const kmVec2* pIn, const float s);
       int kmVec2AreEqual(const kmVec2* p1, const kmVec2* p2);


}
# 30 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec3.h" 1
# 30 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec3.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 1 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 3
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));



}
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec3.h" 2





struct kmMat4;

typedef struct kmVec3 {
    float x;
    float y;
    float z;
} kmVec3;


extern "C" {


       kmVec3* kmVec3Fill(kmVec3* pOut, float x, float y, float z);
       float kmVec3Length(const kmVec3* pIn);
       float kmVec3LengthSq(const kmVec3* pIn);
       kmVec3* kmVec3Normalize(kmVec3* pOut, const kmVec3* pIn);
       kmVec3* kmVec3Cross(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
       float kmVec3Dot(const kmVec3* pV1, const kmVec3* pV2);
       kmVec3* kmVec3Add(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
       kmVec3* kmVec3Subtract(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
       kmVec3* kmVec3Transform(kmVec3* pOut, const kmVec3* pV1, const struct kmMat4* pM);
       kmVec3* kmVec3TransformNormal(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
       kmVec3* kmVec3TransformCoord(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
       kmVec3* kmVec3Scale(kmVec3* pOut, const kmVec3* pIn, const float s);
       int kmVec3AreEqual(const kmVec3* p1, const kmVec3* p2);
       kmVec3* kmVec3InverseTransform(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
       kmVec3* kmVec3InverseTransformNormal(kmVec3* pOut, const kmVec3* pVect, const struct kmMat4* pM);
       kmVec3* kmVec3Assign(kmVec3* pOut, const kmVec3* pIn);
       kmVec3* kmVec3Zero(kmVec3* pOut);


}
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat3.h" 1
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat3.h"
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/utility.h" 1
# 60 "Cacao/include/cocos2dx/kazmath/include/kazmath/utility.h"
extern "C" {


       float kmSQR(float s);
       float kmDegreesToRadians(float degrees);
       float kmRadiansToDegrees(float radians);

       float kmMin(float lhs, float rhs);
       float kmMax(float lhs, float rhs);
       unsigned char kmAlmostEqual(float lhs, float rhs);


}
# 32 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat3.h" 2

struct kmVec3;
struct kmQuaternion;

typedef struct kmMat3{
    float mat[9];
} kmMat3;


extern "C" {


       kmMat3* const kmMat3Fill(kmMat3* pOut, const float* pMat);
       kmMat3* const kmMat3Adjugate(kmMat3* pOut, const kmMat3* pIn);
       kmMat3* const kmMat3Identity(kmMat3* pOut);
       kmMat3* const kmMat3Inverse(kmMat3* pOut, const float pDeterminate, const kmMat3* pM);
       const int kmMat3IsIdentity(const kmMat3* pIn);
       kmMat3* const kmMat3Transpose(kmMat3* pOut, const kmMat3* pIn);
       const float kmMat3Determinant(const kmMat3* pIn);
       kmMat3* const kmMat3Multiply(kmMat3* pOut, const kmMat3* pM1, const kmMat3* pM2);
       kmMat3* const kmMat3ScalarMultiply(kmMat3* pOut, const kmMat3* pM, const float pFactor);

       kmMat3* const kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians);
       struct kmVec3* const kmMat3RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat3* pIn);

       kmMat3* const kmMat3Assign(kmMat3* pOut, const kmMat3* pIn);
       const int kmMat3AreEqual(const kmMat3* pM1, const kmMat3* pM2);

       kmMat3* const kmMat3RotationX(kmMat3* pOut, const float radians);
       kmMat3* const kmMat3RotationY(kmMat3* pOut, const float radians);
       kmMat3* const kmMat3RotationZ(kmMat3* pOut, const float radians);

       kmMat3* const kmMat3Rotation(kmMat3* pOut, const float radians);
       kmMat3* const kmMat3Scaling(kmMat3* pOut, const float x, const float y);
       kmMat3* const kmMat3Translation(kmMat3* pOut, const float x, const float y);

       kmMat3* const kmMat3RotationQuaternion(kmMat3* pOut, const struct kmQuaternion* pIn);
       kmMat3* const kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians);
       struct kmVec3* const kmMat3RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat3* pIn);


}
# 32 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat4.h" 1
# 32 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat4.h"
struct kmVec3;
struct kmMat3;
struct kmQuaternion;
struct kmPlane;
# 47 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat4.h"
extern "C" {


typedef struct kmMat4 {
    float mat[16];
} kmMat4;

       kmMat4* const kmMat4Fill(kmMat4* pOut, const float* pMat);


       kmMat4* const kmMat4Identity(kmMat4* pOut);

       kmMat4* const kmMat4Inverse(kmMat4* pOut, const kmMat4* pM);


       const int kmMat4IsIdentity(const kmMat4* pIn);

       kmMat4* const kmMat4Transpose(kmMat4* pOut, const kmMat4* pIn);
       kmMat4* const kmMat4Multiply(kmMat4* pOut, const kmMat4* pM1, const kmMat4* pM2);

       kmMat4* const kmMat4Assign(kmMat4* pOut, const kmMat4* pIn);
       const int kmMat4AreEqual(const kmMat4* pM1, const kmMat4* pM2);

       kmMat4* const kmMat4RotationX(kmMat4* pOut, const float radians);
       kmMat4* const kmMat4RotationY(kmMat4* pOut, const float radians);
       kmMat4* const kmMat4RotationZ(kmMat4* pOut, const float radians);
       kmMat4* const kmMat4RotationPitchYawRoll(kmMat4* pOut, const float pitch, const float yaw, const float roll);
       kmMat4* const kmMat4RotationQuaternion(kmMat4* pOut, const struct kmQuaternion* pQ);
       kmMat4* const kmMat4RotationTranslation(kmMat4* pOut, const struct kmMat3* rotation, const struct kmVec3* translation);
       kmMat4* const kmMat4Scaling(kmMat4* pOut, const float x, const float y, const float z);
       kmMat4* const kmMat4Translation(kmMat4* pOut, const float x, const float y, const float z);

       struct kmVec3* const kmMat4GetUpVec3(struct kmVec3* pOut, const kmMat4* pIn);
       struct kmVec3* const kmMat4GetRightVec3(struct kmVec3* pOut, const kmMat4* pIn);
       struct kmVec3* const kmMat4GetForwardVec3(struct kmVec3* pOut, const kmMat4* pIn);

       kmMat4* const kmMat4PerspectiveProjection(kmMat4* pOut, float fovY, float aspect, float zNear, float zFar);
       kmMat4* const kmMat4OrthographicProjection(kmMat4* pOut, float left, float right, float bottom, float top, float nearVal, float farVal);
       kmMat4* const kmMat4LookAt(kmMat4* pOut, const struct kmVec3* pEye, const struct kmVec3* pCenter, const struct kmVec3* pUp);

       kmMat4* const kmMat4RotationAxisAngle(kmMat4* pOut, const struct kmVec3* axis, float radians);
       struct kmMat3* const kmMat4ExtractRotation(struct kmMat3* pOut, const kmMat4* pIn);
       struct kmPlane* const kmMat4ExtractPlane(struct kmPlane* pOut, const kmMat4* pIn, const unsigned int plane);
       struct kmVec3* const kmMat4RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat4* pIn);

}
# 33 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2

# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/quaternion.h" 1
# 30 "Cacao/include/cocos2dx/kazmath/include/kazmath/quaternion.h"
extern "C" {





struct kmMat4;
struct kmMat3;
struct kmVec3;

typedef struct kmQuaternion {
    float x;
    float y;
    float z;
    float w;
} kmQuaternion;

       kmQuaternion* const kmQuaternionConjugate(kmQuaternion* pOut, const kmQuaternion* pIn);

       const float kmQuaternionDot(const kmQuaternion* q1, const kmQuaternion* q2);

       kmQuaternion* kmQuaternionExp(kmQuaternion* pOut, const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionIdentity(kmQuaternion* pOut);



       kmQuaternion* kmQuaternionInverse(kmQuaternion* pOut,
                                            const kmQuaternion* pIn);



       int kmQuaternionIsIdentity(const kmQuaternion* pIn);



       float kmQuaternionLength(const kmQuaternion* pIn);



       float kmQuaternionLengthSq(const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionLn(kmQuaternion* pOut, const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionMultiply(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2);



       kmQuaternion* kmQuaternionNormalize(kmQuaternion* pOut, const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionRotationAxis(kmQuaternion* pOut, const struct kmVec3* pV, float angle);



       kmQuaternion* kmQuaternionRotationMatrix(kmQuaternion* pOut, const struct kmMat3* pIn);



       kmQuaternion* kmQuaternionRotationYawPitchRoll(kmQuaternion* pOut, float yaw, float pitch, float roll);

       kmQuaternion* kmQuaternionSlerp(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2, float t);


       void kmQuaternionToAxisAngle(const kmQuaternion* pIn, struct kmVec3* pVector, float* pAngle);


       kmQuaternion* kmQuaternionScale(kmQuaternion* pOut, const kmQuaternion* pIn, float s);
       kmQuaternion* kmQuaternionAssign(kmQuaternion* pOut, const kmQuaternion* pIn);
       kmQuaternion* kmQuaternionAdd(kmQuaternion* pOut, const kmQuaternion* pQ1, const kmQuaternion* pQ2);
       kmQuaternion* kmQuaternionRotationBetweenVec3(kmQuaternion* pOut, const struct kmVec3* vec1, const struct kmVec3* vec2, const struct kmVec3* fallback);
       struct kmVec3* kmQuaternionMultiplyVec3(struct kmVec3* pOut, const kmQuaternion* q, const struct kmVec3* v);


}
# 35 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/plane.h" 1
# 39 "Cacao/include/cocos2dx/kazmath/include/kazmath/plane.h"
struct kmVec3;
struct kmVec4;
struct kmMat4;

typedef struct kmPlane {
    float a, b, c, d;
} kmPlane;


extern "C" {


typedef enum POINT_CLASSIFICATION {
    POINT_INFRONT_OF_PLANE = 0,
    POINT_BEHIND_PLANE,
    POINT_ON_PLANE,
} POINT_CLASSIFICATION;

       const float kmPlaneDot(const kmPlane* pP, const struct kmVec4* pV);
       const float kmPlaneDotCoord(const kmPlane* pP, const struct kmVec3* pV);
       const float kmPlaneDotNormal(const kmPlane* pP, const struct kmVec3* pV);
       kmPlane* const kmPlaneFromPointNormal(kmPlane* pOut, const struct kmVec3* pPoint, const struct kmVec3* pNormal);
       kmPlane* const kmPlaneFromPoints(kmPlane* pOut, const struct kmVec3* p1, const struct kmVec3* p2, const struct kmVec3* p3);
       kmVec3* const kmPlaneIntersectLine(struct kmVec3* pOut, const kmPlane* pP, const struct kmVec3* pV1, const struct kmVec3* pV2);
       kmPlane* const kmPlaneNormalize(kmPlane* pOut, const kmPlane* pP);
       kmPlane* const kmPlaneScale(kmPlane* pOut, const kmPlane* pP, float s);
       const POINT_CLASSIFICATION kmPlaneClassifyPoint(const kmPlane* pIn, const kmVec3* pP);


}
# 36 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/aabb.h" 1
# 34 "Cacao/include/cocos2dx/kazmath/include/kazmath/aabb.h"
extern "C" {






typedef struct kmAABB {
    kmVec3 min;
    kmVec3 max;
} kmAABB;

       const int kmAABBContainsPoint(const kmVec3* pPoint, const kmAABB* pBox);
       kmAABB* const kmAABBAssign(kmAABB* pOut, const kmAABB* pIn);
       kmAABB* const kmAABBScale(kmAABB* pOut, const kmAABB* pIn, float s);


}
# 37 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/ray2.h" 1
# 34 "Cacao/include/cocos2dx/kazmath/include/kazmath/ray2.h"
extern "C" {


typedef struct kmRay2 {
    kmVec2 start;
    kmVec2 dir;
} kmRay2;

       void kmRay2Fill(kmRay2* ray, float px, float py, float vx, float vy);
       unsigned char kmRay2IntersectLineSegment(const kmRay2* ray, const kmVec2* p1, const kmVec2* p2, kmVec2* intersection);
       unsigned char kmRay2IntersectTriangle(const kmRay2* ray, const kmVec2* p1, const kmVec2* p2, const kmVec2* p3, kmVec2* intersection, kmVec2* normal_out);
       unsigned char kmRay2IntersectCircle(const kmRay2* ray, const kmVec2 centre, const float radius, kmVec2* intersection);


}
# 38 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 38 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 1
# 29 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
# 1 "Cacao/include/cocos2dx/platform/mac/CCAccelerometer.h" 1
# 28 "Cacao/include/cocos2dx/platform/mac/CCAccelerometer.h"
# 1 "Cacao/include/cocos2dx/platform/CCAccelerometerDelegate.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCAccelerometerDelegate.h"
namespace cocos2d {



class CCAcceleration
{
public:
    double x;
    double y;
    double z;

    double timestamp;
};
# 51 "Cacao/include/cocos2dx/platform/CCAccelerometerDelegate.h"
class CCAccelerometerDelegate
{
public:
    virtual void didAccelerate(CCAcceleration* pAccelerationValue) {(void)pAccelerationValue;}
};

}
# 29 "Cacao/include/cocos2dx/platform/mac/CCAccelerometer.h" 2

namespace cocos2d {

class CCAccelerometer
{
public:
    CCAccelerometer() {}
    ~CCAccelerometer() {}

    void setDelegate(CCAccelerometerDelegate* pDelegate) { (void)pDelegate; }
    void setAccelerometerInterval(float interval) {(void)interval;};
};

}
# 30 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2
# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouch.h" 1
# 31 "Cacao/include/cocos2dx/touch_dispatcher/CCTouch.h"
namespace cocos2d {






class CCTouch : public CCObject
{
public:



    CCTouch()
        : m_nId(0),
        m_startPointCaptured(false)
    {}


    CCPoint getLocation() const;

    CCPoint getPreviousLocation() const;

    CCPoint getStartLocation() const;

    CCPoint getDelta() const;

    CCPoint getLocationInView() const;

    CCPoint getPreviousLocationInView() const;

    CCPoint getStartLocationInView() const;

    void setTouchInfo(int id, float x, float y)
    {
        m_nId = id;
        m_prevPoint = m_point;
        m_point.x = x;
        m_point.y = y;
        if (!m_startPointCaptured)
        {
            m_startPoint = m_point;
            m_startPointCaptured = true;
        }
    }



    int getID() const
    {
        return m_nId;
    }

private:
    int m_nId;
    bool m_startPointCaptured;
    CCPoint m_startPoint;
    CCPoint m_point;
    CCPoint m_prevPoint;
};

class CCEvent : public CCObject
{
};




}
# 31 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCSet.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCSet.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tree.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tree.h" 3







namespace std {
# 93 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,
                       _Rb_tree_node_base*& __root);

  void
  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,
                        _Rb_tree_node_base*& __root);

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val> _Rb_tree_node;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node* _Link_type;
      typedef const _Rb_tree_node* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Rb_tree_node*
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Rb_tree_node* __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }

      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };



      template<typename _Key_compare>
        struct _Rb_tree_impl<_Key_compare, true> : public _Node_allocator
 {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      const_iterator
      _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __y,
  const value_type& __v);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

    public:

      _Rb_tree()
      { }

      _Rb_tree(const _Compare& __comp)
      : _M_impl(allocator_type(), __comp)
      { }

      _Rb_tree(const _Compare& __comp, const allocator_type& __a)
      : _M_impl(__a, __comp)
      { }

      _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
      : _M_impl(__x._M_get_Node_allocator(), __x._M_impl._M_key_compare)
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }

      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
      operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return get_allocator().max_size(); }

      void
      swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t);


      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);



      iterator
      _M_insert_equal_lower(const value_type& __x);

      iterator
      _M_insert_unique(iterator __position, const value_type& __x);

      const_iterator
      _M_insert_unique(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal(iterator __position, const value_type& __x);

      const_iterator
      _M_insert_equal(const_iterator __position, const value_type& __x);

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      void
      erase(const_iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const_iterator __first, const_iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __x);

      const_iterator
      find(const key_type& __x) const;

      size_type
      count(const key_type& __x) const;

      iterator
      lower_bound(const key_type& __x);

      const_iterator
      lower_bound(const key_type& __x) const;

      iterator
      upper_bound(const key_type& __x);

      const_iterator
      upper_bound(const key_type& __x) const;

      pair<iterator,iterator>
      equal_range(const key_type& __x);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return const_iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 if (__j == begin())
   return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
 else
   --__j;
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else
 return __position;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return const_iterator(_M_insert_unique(__v).first);
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return const_iterator(_M_insert_unique(__v).first);
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return const_iterator(_M_insert_unique(__v).first);
 }
      else
 return __position;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {

   iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return const_iterator(_M_insert_equal(__v));
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return const_iterator(_M_insert_equal(__v));
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return const_iterator(_M_insert_equal_lower(__v));
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      iterator __j = iterator(__y);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

     while (__x != 0)
       {
  if (!_M_impl._M_key_compare(_S_key(__x), __k))
    __y = __x, __x = _S_left(__x);
  else
    __x = _S_right(__x);
       }
     const_iterator __j = const_iterator(__y);
     return (__j == end()
      || _M_impl._M_key_compare(__k,
           _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KoV,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    { return pair<const_iterator, const_iterator>(lower_bound(__k),
        upper_bound(__k)); }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }

}
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
namespace std {
# 91 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
  template<class _Key, class _Compare = std::less<_Key>,
    class _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;




      set()
      : _M_t(_Compare(), allocator_type()) {}







      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) {}
# 163 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      template<class _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
        : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_unique(__first, __last); }
# 179 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      template<class _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 193 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      set(const set<_Key,_Compare,_Alloc>& __x)
      : _M_t(__x._M_t) { }
# 203 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      set<_Key,_Compare,_Alloc>&
      operator=(const set<_Key, _Compare, _Alloc>& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }




      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }





      iterator
      begin() const
      { return _M_t.begin(); }





      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }


      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      void
      swap(set<_Key,_Compare,_Alloc>& __x)
      { _M_t.swap(__x._M_t); }
# 303 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      std::pair<iterator,bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 330 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique(__position, __x); }
# 342 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      template<class _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 356 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 371 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 386 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 410 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 428 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 449 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 465 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 490 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<class _K1, class _C1, class _A1>
        friend bool
        operator== (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<class _K1, class _C1, class _A1>
        friend bool
        operator< (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 519 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 536 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<class _Key, class _Compare, class _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
namespace std {
# 88 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
  template <class _Key, class _Compare = std::less<_Key>,
     class _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      multiset()
      : _M_t(_Compare(), allocator_type()) { }

      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 153 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      template <class _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_equal(__first, __last); }
# 169 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      template <class _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 183 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      multiset(const multiset<_Key,_Compare,_Alloc>& __x)
      : _M_t(__x._M_t) { }
# 193 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      multiset<_Key,_Compare,_Alloc>&
      operator=(const multiset<_Key,_Compare,_Alloc>& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }




      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }


      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 277 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      void
      swap(multiset<_Key, _Compare, _Alloc>& __x)
      { _M_t.swap(__x._M_t); }
# 293 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 317 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal(__position, __x); }
# 329 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      template <class _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 344 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 359 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 374 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 395 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 413 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 434 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 450 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 475 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <class _K1, class _C1, class _A1>
        friend bool
        operator== (const multiset<_K1, _C1, _A1>&,
      const multiset<_K1, _C1, _A1>&);

      template <class _K1, class _C1, class _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 505 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 522 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template <class _Key, class _Compare, class _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 2 3
# 29 "Cacao/include/cocos2dx/cocoa/CCSet.h" 2


namespace cocos2d {






typedef std::set<CCObject *>::iterator CCSetIterator;

class CCSet : public CCObject
{
public:




    CCSet(void);



    CCSet(const CCSet &rSetObject);




    virtual ~CCSet(void);





    static CCSet * create();




    CCSet* copy();




    CCSet* mutableCopy();



    int count();



    void addObject(CCObject *pObject);



    void removeObject(CCObject *pObject);



    void removeAllObjects();



    bool containsObject(CCObject *pObject);





    CCSetIterator begin();





    CCSetIterator end();



    CCObject* anyObject();




    virtual void acceptVisitor(CCDataVisitor &visitor);

private:
    std::set<CCObject *> *m_pSet;
};




}
# 32 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
namespace std {
# 91 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t(_Compare(), allocator_type()) { }





      explicit
      map(const _Compare& __comp, const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_unique(__first, __last); }
# 203 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp, const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 225 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }


      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }





      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 341 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 363 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 398 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 425 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique(__position, __x); }
# 437 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 452 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 467 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 482 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 497 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 555 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 567 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 582 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 597 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 636 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 655 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const map<_K1, _T1, _C1, _A1>&,
      const map<_K1, _T1, _C1, _A1>&);

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);
    };
# 680 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 697 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
namespace std {
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t(_Compare(), allocator_type()) { }





      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 173 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 185 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_equal(__first, __last); }
# 201 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 224 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }


      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }



      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 338 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 362 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal(__position, __x); }
# 374 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 389 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 404 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 419 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 434 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 477 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 492 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 516 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 531 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 568 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 585 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const multimap<_K1, _T1, _C1, _A1>&,
      const multimap<_K1, _T1, _C1, _A1>&);

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);
  };
# 610 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 627 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 2 3
# 34 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 3






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
namespace std {







  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
    };
# 111 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };
# 188 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }







  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 298 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }


      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 406 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
# 449 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }

    public:





      explicit
      list(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 482 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
# 495 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 508 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 533 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 546 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 562 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }






      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 677 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 732 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 748 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 762 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 777 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 792 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 807 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
# 827 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
# 851 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 872 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 889 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 925 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x)
      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 945 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 971 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x, iterator __first, iterator __last)
      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 994 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1008 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1022 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      unique();
# 1037 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1050 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1065 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);






      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:



      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_fill_initialize(static_cast<size_type>(__n),
        static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   push_back(__x);
      }





      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node, __last._M_node); }


      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }


      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        _M_get_Tp_allocator().destroy(&__n->_M_data);
        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (_M_get_Node_allocator() != __x._M_get_Node_allocator())
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1223 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/list.tcc" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/list.tcc" 3
namespace std {

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);
   _M_get_Tp_allocator().destroy(&__tmp->_M_data);
   _M_put_node(__tmp);
 }
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     _M_erase(__first);
   __first = __next;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    merge(list& __x)
    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }

}
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 2 3
# 36 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2

typedef struct lua_State lua_State;

namespace cocos2d {

class CCTimer;
class CCLayer;
class CCMenuItem;
class CCNotificationCenter;
class CCCallFunc;
class CCAcceleration;

enum ccScriptType {
    kScriptTypeNone = 0,
    kScriptTypeLua,
    kScriptTypeJavascript
};




class CCScriptHandlerEntry : public CCObject
{
public:
    static CCScriptHandlerEntry* create(int nHandler);
    ~CCScriptHandlerEntry(void);

    int getHandler(void) {
        return m_nHandler;
    }

    int getEntryId(void) {
        return m_nEntryId;
    }

protected:
    CCScriptHandlerEntry(int nHandler)
    : m_nHandler(nHandler)
    {
        static int newEntryId = 0;
        newEntryId++;
        m_nEntryId = newEntryId;
    }

    int m_nHandler;
    int m_nEntryId;
};
# 91 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
class CCSchedulerScriptHandlerEntry : public CCScriptHandlerEntry
{
public:

    static CCSchedulerScriptHandlerEntry* create(int nHandler, float fInterval, bool bPaused);
    ~CCSchedulerScriptHandlerEntry(void);

    cocos2d::CCTimer* getTimer(void) {
        return m_pTimer;
    }

    bool isPaused(void) {
        return m_bPaused;
    }

    void markedForDeletion(void) {
        m_bMarkedForDeletion = true;
    }

    bool isMarkedForDeletion(void) {
        return m_bMarkedForDeletion;
    }

private:
    CCSchedulerScriptHandlerEntry(int nHandler)
    : CCScriptHandlerEntry(nHandler)
    , m_pTimer(__null)
    , m_bPaused(false)
    , m_bMarkedForDeletion(false)
    {
    }
    bool init(float fInterval, bool bPaused);

    cocos2d::CCTimer* m_pTimer;
    bool m_bPaused;
    bool m_bMarkedForDeletion;
};






class CCTouchScriptHandlerEntry : public CCScriptHandlerEntry
{
public:
    static CCTouchScriptHandlerEntry* create(int nHandler, bool bIsMultiTouches, int nPriority, bool bSwallowsTouches);
    ~CCTouchScriptHandlerEntry(void);

    bool isMultiTouches(void) {
        return m_bIsMultiTouches;
    }

    int getPriority(void) {
        return m_nPriority;
    }

    bool getSwallowsTouches(void) {
        return m_bSwallowsTouches;
    }

private:
    CCTouchScriptHandlerEntry(int nHandler)
    : CCScriptHandlerEntry(nHandler)
    , m_bIsMultiTouches(false)
    , m_nPriority(0)
    , m_bSwallowsTouches(false)
    {
    }
    bool init(bool bIsMultiTouches, int nPriority, bool bSwallowsTouches);

    bool m_bIsMultiTouches;
    int m_nPriority;
    bool m_bSwallowsTouches;
};
# 175 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
class CCScriptEngineProtocol
{
public:
    virtual ~CCScriptEngineProtocol() {};


    virtual ccScriptType getScriptType() { return kScriptTypeNone; };


    virtual void removeScriptObjectByCCObject(CCObject* pObj) = 0;


    virtual void removeScriptHandler(int nHandler) {};


    virtual int reallocateScriptHandler(int nHandler) { return -1;}







    virtual int executeString(const char* codes) = 0;





    virtual int executeScriptFile(const char* filename) = 0;







    virtual int executeGlobalFunction(const char* functionName) = 0;







    virtual int executeNodeEvent(CCNode* pNode, int nAction) = 0;

    virtual int executeMenuItemEvent(CCMenuItem* pMenuItem) = 0;

    virtual int executeNotificationEvent(CCNotificationCenter* pNotificationCenter, const char* pszName) = 0;


    virtual int executeCallFuncActionEvent(CCCallFunc* pAction, CCObject* pTarget = __null) = 0;

    virtual int executeSchedule(int nHandler, float dt, CCNode* pNode = __null) = 0;


    virtual int executeLayerTouchesEvent(CCLayer* pLayer, int eventType, CCSet *pTouches) = 0;
    virtual int executeLayerTouchEvent(CCLayer* pLayer, int eventType, CCTouch *pTouch) = 0;


    virtual int executeLayerKeypadEvent(CCLayer* pLayer, int eventType) = 0;


    virtual int executeAccelerometerEvent(CCLayer* pLayer, CCAcceleration* pAccelerationValue) = 0;


    virtual int executeEvent(int nHandler, const char* pEventName, CCObject* pEventSource = __null, const char* pEventSourceClassName = __null) = 0;


    virtual int executeEventWithArgs(int nHandler, CCArray* pArgs) { return 0; }




    virtual bool handleAssert(const char *msg) = 0;




    enum ConfigType
    {
        NONE,
        COCOSTUDIO,
    };
    virtual bool parseConfig(ConfigType type, const std::string& str) = 0;
};
# 270 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
class CCScriptEngineManager
{
public:
    ~CCScriptEngineManager(void);

    CCScriptEngineProtocol* getScriptEngine(void) {
        return m_pScriptEngine;
    }
    void setScriptEngine(CCScriptEngineProtocol *pScriptEngine);
    void removeScriptEngine(void);

    static CCScriptEngineManager* sharedManager(void);
    static void purgeSharedManager(void);

private:
    CCScriptEngineManager(void)
    : m_pScriptEngine(__null)
    {
    }

    CCScriptEngineProtocol *m_pScriptEngine;
};




}
# 39 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/include/CCProtocols.h" 1
# 29 "Cacao/include/cocos2dx/include/CCProtocols.h"
# 1 "Cacao/include/cocos2dx/include/ccTypes.h" 1
# 35 "Cacao/include/cocos2dx/include/ccTypes.h"
namespace cocos2d {




typedef struct _ccColor3B
{
    GLubyte r;
    GLubyte g;
    GLubyte b;
} ccColor3B;


static inline ccColor3B
ccc3(const GLubyte r, const GLubyte g, const GLubyte b)
{
    ccColor3B c = {r, g, b};
    return c;
}



static inline bool ccc3BEqual(const ccColor3B &col1, const ccColor3B &col2)
{
    return col1.r == col2.r && col1.g == col2.g && col1.b == col2.b;
}



static const ccColor3B ccWHITE={255,255,255};

static const ccColor3B ccYELLOW={255,255,0};

static const ccColor3B ccBLUE={0,0,255};

static const ccColor3B ccGREEN={0,255,0};

static const ccColor3B ccRED={255,0,0};

static const ccColor3B ccMAGENTA={255,0,255};

static const ccColor3B ccBLACK={0,0,0};

static const ccColor3B ccORANGE={255,127,0};

static const ccColor3B ccGRAY={166,166,166};




typedef struct _ccColor4B
{
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
} ccColor4B;

static inline ccColor4B
ccc4(const GLubyte r, const GLubyte g, const GLubyte b, const GLubyte o)
{
    ccColor4B c = {r, g, b, o};
    return c;
}





typedef struct _ccColor4F {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
} ccColor4F;





static inline ccColor4F ccc4FFromccc3B(ccColor3B c)
{
    ccColor4F c4 = {c.r/255.f, c.g/255.f, c.b/255.f, 1.f};
    return c4;
}


static inline ccColor4F
ccc4f(const GLfloat r, const GLfloat g, const GLfloat b, const GLfloat a)
{
    ccColor4F c4 = {r, g, b, a};
    return c4;
}




static inline ccColor4F ccc4FFromccc4B(ccColor4B c)
{
    ccColor4F c4 = {c.r/255.f, c.g/255.f, c.b/255.f, c.a/255.f};
    return c4;
}

static inline ccColor4B ccc4BFromccc4F(ccColor4F c)
{
    ccColor4B ret = {(GLubyte)(c.r*255), (GLubyte)(c.g*255), (GLubyte)(c.b*255), (GLubyte)(c.a*255)};
 return ret;
}




static inline bool ccc4FEqual(ccColor4F a, ccColor4F b)
{
    return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
}




typedef struct _ccVertex2F
{
    GLfloat x;
    GLfloat y;
} ccVertex2F;

static inline ccVertex2F vertex2(const float x, const float y)
{
    ccVertex2F c = {x, y};
    return c;
}





typedef struct _ccVertex3F
{
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ccVertex3F;

static inline ccVertex3F vertex3(const float x, const float y, const float z)
{
    ccVertex3F c = {x, y, z};
    return c;
}




typedef struct _ccTex2F {
     GLfloat u;
     GLfloat v;
} ccTex2F;

static inline ccTex2F tex2(const float u, const float v)
{
    ccTex2F t = {u , v};
    return t;
}



typedef struct _ccPointSprite
{
    ccVertex2F pos;
    ccColor4B color;
    GLfloat size;
} ccPointSprite;


typedef struct _ccQuad2 {
    ccVertex2F tl;
    ccVertex2F tr;
    ccVertex2F bl;
    ccVertex2F br;
} ccQuad2;



typedef struct _ccQuad3 {
    ccVertex3F bl;
    ccVertex3F br;
    ccVertex3F tl;
    ccVertex3F tr;
} ccQuad3;


typedef struct _ccV2F_C4B_T2F
{

    ccVertex2F vertices;

    ccColor4B colors;

    ccTex2F texCoords;
} ccV2F_C4B_T2F;


typedef struct _ccV2F_C4F_T2F
{

    ccVertex2F vertices;

    ccColor4F colors;

    ccTex2F texCoords;
} ccV2F_C4F_T2F;


typedef struct _ccV3F_C4B_T2F
{

    ccVertex3F vertices;



    ccColor4B colors;



    ccTex2F texCoords;
} ccV3F_C4B_T2F;


typedef struct _ccV2F_C4B_T2F_Triangle
{

 ccV2F_C4B_T2F a;

 ccV2F_C4B_T2F b;

 ccV2F_C4B_T2F c;
} ccV2F_C4B_T2F_Triangle;


typedef struct _ccV2F_C4B_T2F_Quad
{

    ccV2F_C4B_T2F bl;

    ccV2F_C4B_T2F br;

    ccV2F_C4B_T2F tl;

    ccV2F_C4B_T2F tr;
} ccV2F_C4B_T2F_Quad;


typedef struct _ccV3F_C4B_T2F_Quad
{

    ccV3F_C4B_T2F tl;

    ccV3F_C4B_T2F bl;

    ccV3F_C4B_T2F tr;

    ccV3F_C4B_T2F br;
} ccV3F_C4B_T2F_Quad;


typedef struct _ccV2F_C4F_T2F_Quad
{

    ccV2F_C4F_T2F bl;

    ccV2F_C4F_T2F br;

    ccV2F_C4F_T2F tl;

    ccV2F_C4F_T2F tr;
} ccV2F_C4F_T2F_Quad;


typedef struct _ccBlendFunc
{

    GLenum src;

    GLenum dst;
} ccBlendFunc;

static const ccBlendFunc kCCBlendFuncDisable = {1, 0};



typedef enum
{
    kCCVerticalTextAlignmentTop,
    kCCVerticalTextAlignmentCenter,
    kCCVerticalTextAlignmentBottom,
} CCVerticalTextAlignment;



typedef enum
{
    kCCTextAlignmentLeft,
    kCCTextAlignmentCenter,
    kCCTextAlignmentRight,
} CCTextAlignment;




typedef struct _ccT2F_Quad
{

    ccTex2F bl;

    ccTex2F br;

    ccTex2F tl;

    ccTex2F tr;
} ccT2F_Quad;


typedef struct
{
    ccT2F_Quad texCoords;
    float delay;
    CCSize size;
} ccAnimationFrameData;
# 370 "Cacao/include/cocos2dx/include/ccTypes.h"
typedef struct _ccFontShadow
{
public:


    _ccFontShadow(): m_shadowEnabled(false) {}


    bool m_shadowEnabled;

 CCSize m_shadowOffset;

 float m_shadowBlur;

 float m_shadowOpacity;

} ccFontShadow;


typedef struct _ccFontStroke
{
public:


    _ccFontStroke(): m_strokeEnabled(false) {}


    bool m_strokeEnabled;

 ccColor3B m_strokeColor;

    float m_strokeSize;

} ccFontStroke;






typedef struct _ccFontDefinition
{
public:

    _ccFontDefinition(): m_alignment(kCCTextAlignmentCenter),
    m_vertAlignment(kCCVerticalTextAlignmentTop),
    m_fontFillColor(ccWHITE)
    { m_dimensions = CCSize((float)(0), (float)(0)); }


    std::string m_fontName;

    int m_fontSize;

    CCTextAlignment m_alignment;

    CCVerticalTextAlignment m_vertAlignment;

    CCSize m_dimensions;

    ccColor3B m_fontFillColor;

    ccFontShadow m_shadow;

    ccFontStroke m_stroke;

} ccFontDefinition;


}
# 30 "Cacao/include/cocos2dx/include/CCProtocols.h" 2
# 1 "Cacao/include/cocos2dx/textures/CCTexture2D.h" 1
# 37 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
namespace cocos2d {

class CCImage;
# 51 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
typedef enum {


    kCCTexture2DPixelFormat_RGBA8888,

    kCCTexture2DPixelFormat_RGB888,

    kCCTexture2DPixelFormat_RGB565,

    kCCTexture2DPixelFormat_A8,

    kCCTexture2DPixelFormat_I8,

    kCCTexture2DPixelFormat_AI88,

    kCCTexture2DPixelFormat_RGBA4444,

    kCCTexture2DPixelFormat_RGB5A1,

    kCCTexture2DPixelFormat_PVRTC4,

    kCCTexture2DPixelFormat_PVRTC2,



    kCCTexture2DPixelFormat_Default = kCCTexture2DPixelFormat_RGBA8888,


    kTexture2DPixelFormat_RGBA8888 = kCCTexture2DPixelFormat_RGBA8888,
    kTexture2DPixelFormat_RGB888 = kCCTexture2DPixelFormat_RGB888,
    kTexture2DPixelFormat_RGB565 = kCCTexture2DPixelFormat_RGB565,
    kTexture2DPixelFormat_A8 = kCCTexture2DPixelFormat_A8,
    kTexture2DPixelFormat_RGBA4444 = kCCTexture2DPixelFormat_RGBA4444,
    kTexture2DPixelFormat_RGB5A1 = kCCTexture2DPixelFormat_RGB5A1,
    kTexture2DPixelFormat_Default = kCCTexture2DPixelFormat_Default

} CCTexture2DPixelFormat;

class CCGLProgram;




typedef struct _ccTexParams {
    GLuint minFilter;
    GLuint magFilter;
    GLuint wrapS;
    GLuint wrapT;
} ccTexParams;
# 109 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
class CCTexture2D : public CCObject



{
public:



    CCTexture2D();




    virtual ~CCTexture2D();




    const char* description(void);




    void releaseData(void *data);



    void* keepData(void *data, unsigned int length);





    bool initWithData(const void* data, CCTexture2DPixelFormat pixelFormat, unsigned int pixelsWide, unsigned int pixelsHigh, const CCSize& contentSize);






    void drawAtPoint(const CCPoint& point);

    void drawInRect(const CCRect& rect);







    bool initWithImage(CCImage * uiImage);


    bool initWithString(const char *text, const char *fontName, float fontSize, const CCSize& dimensions, CCTextAlignment hAlignment, CCVerticalTextAlignment vAlignment);

    bool initWithString(const char *text, const char *fontName, float fontSize);

    bool initWithString(const char *text, ccFontDefinition *textDefinition);


    bool initWithPVRFile(const char* file);


    bool initWithETCFile(const char* file);
# 186 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    void setTexParameters(ccTexParams* texParams);
# 196 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    void setAntiAliasTexParameters();
# 206 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    void setAliasTexParameters();






    void generateMipmap();




    const char* stringForFormat();




    unsigned int bitsPerPixelForFormat();




    unsigned int bitsPerPixelForFormat(CCTexture2DPixelFormat format);
# 247 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    static void setDefaultAlphaPixelFormat(CCTexture2DPixelFormat format);





    static CCTexture2DPixelFormat defaultAlphaPixelFormat();
# 263 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    static void PVRImagesHavePremultipliedAlpha(bool haveAlphaPremultiplied);


    const CCSize& getContentSizeInPixels();

    bool hasPremultipliedAlpha();
    bool hasMipmaps();


    void releaseGLTexture(void);
private:
    bool initPremultipliedATextureWithImage(CCImage * image, unsigned int pixelsWide, unsigned int pixelsHigh);


    bool m_bPVRHaveAlphaPremultiplied;


    protected: CCTexture2DPixelFormat m_ePixelFormat;public: virtual CCTexture2DPixelFormat getPixelFormat(void);

    protected: unsigned int m_uPixelsWide;public: virtual unsigned int getPixelsWide(void);

    protected: unsigned int m_uPixelsHigh;public: virtual unsigned int getPixelsHigh(void);


    protected: GLuint m_uName;public: virtual GLuint getName(void);


    protected: GLfloat m_fMaxS;public: virtual GLfloat getMaxS(void);public: virtual void setMaxS(GLfloat var);

    protected: GLfloat m_fMaxT;public: virtual GLfloat getMaxT(void);public: virtual void setMaxT(GLfloat var);

    protected: CCSize m_tContentSize;public: virtual CCSize getContentSize(void);


    bool m_bHasPremultipliedAlpha;

    bool m_bHasMipmaps;


    protected: CCGLProgram* m_pShaderProgram;public: virtual CCGLProgram* getShaderProgram(void);public: virtual void setShaderProgram(CCGLProgram* var);;
};




}
# 31 "Cacao/include/cocos2dx/include/CCProtocols.h" 2


namespace cocos2d {





class CCRGBAProtocol
{
public:





    virtual void setColor(const ccColor3B& color) = 0;






    virtual const ccColor3B& getColor(void) = 0;






    virtual const ccColor3B& getDisplayedColor(void) = 0;






    virtual GLubyte getDisplayedOpacity(void) = 0;
# 77 "Cacao/include/cocos2dx/include/CCProtocols.h"
    virtual GLubyte getOpacity(void) = 0;






    virtual void setOpacity(GLubyte opacity) = 0;
# 96 "Cacao/include/cocos2dx/include/CCProtocols.h"
    virtual void setOpacityModifyRGB(bool bValue) = 0;







    virtual bool isOpacityModifyRGB(void) = 0;




    virtual bool isCascadeColorEnabled(void) = 0;
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled) = 0;




    virtual void updateDisplayedColor(const ccColor3B& color) = 0;




    virtual bool isCascadeOpacityEnabled(void) = 0;
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled) = 0;




    virtual void updateDisplayedOpacity(GLubyte opacity) = 0;
};
# 136 "Cacao/include/cocos2dx/include/CCProtocols.h"
class CCBlendProtocol
{
public:







    virtual void setBlendFunc(ccBlendFunc blendFunc) = 0;






    virtual ccBlendFunc getBlendFunc(void) = 0;
};
# 166 "Cacao/include/cocos2dx/include/CCProtocols.h"
class CCTextureProtocol : public CCBlendProtocol
{
public:






    virtual CCTexture2D* getTexture(void) = 0;







    virtual void setTexture(CCTexture2D *texture) = 0;
};






class CCLabelProtocol
{
public:





    virtual void setString(const char *label) = 0;






    virtual const char* getString(void) = 0;
};






class CCDirectorDelegate
{
public:



    virtual void updateProjection(void) = 0;
};

}
# 40 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2

namespace cocos2d {

class CCCamera;
class CCGridBase;
class CCPoint;
class CCTouch;
class CCAction;
class CCRGBAProtocol;
class CCLabelProtocol;
class CCScheduler;
class CCActionManager;
class CCComponent;
class CCDictionary;
class CCComponentContainer;






enum {
    kCCNodeTagInvalid = -1,
};

enum {
    kCCNodeOnEnter,
    kCCNodeOnExit,
    kCCNodeOnEnterTransitionDidFinish,
    kCCNodeOnExitTransitionDidStart,
    kCCNodeOnCleanup
};
# 128 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
class CCNode : public CCObject
{
public:







    CCNode(void);






    virtual ~CCNode(void);





    virtual bool init();




    static CCNode * create(void);






    const char* description(void);
# 182 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setZOrder(int zOrder);
# 191 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void _setZOrder(int z);







    virtual int getZOrder();
# 214 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setVertexZ(float vertexZ);







    virtual float getVertexZ();
# 232 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScaleX(float fScaleX);







    virtual float getScaleX();
# 250 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScaleY(float fScaleY);







    virtual float getScaleY();
# 268 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScale(float scale);
# 277 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual float getScale();
# 288 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScale(float fScaleX,float fScaleY);
# 305 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setPosition(const CCPoint &position);







    virtual const CCPoint& getPosition();
# 331 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setPosition(float x, float y);





    virtual void getPosition(float* x, float* y);




    virtual void setPositionX(float x);
    virtual float getPositionX(void);
    virtual void setPositionY(float y);
    virtual float getPositionY(void);
# 357 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setSkewX(float fSkewX);







    virtual float getSkewX();
# 377 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setSkewY(float fSkewY);







    virtual float getSkewY();
# 399 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setAnchorPoint(const CCPoint& anchorPoint);







    virtual const CCPoint& getAnchorPoint();
# 416 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual const CCPoint& getAnchorPointInPoints();
# 427 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setContentSize(const CCSize& contentSize);







    virtual const CCSize& getContentSize() const;


    virtual CCSize getScaledContentSize();
# 447 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setVisible(bool visible);







    virtual bool isVisible();
# 466 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setRotation(float fRotation);







    virtual float getRotation();
# 485 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setRotationX(float fRotaionX);







    virtual float getRotationX();
# 504 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setRotationY(float fRotationY);







    virtual float getRotationY();
# 525 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setOrderOfArrival(unsigned int uOrderOfArrival);







    virtual unsigned int getOrderOfArrival();
# 542 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setGLServerState(ccGLServerState glServerState);






    virtual ccGLServerState getGLServerState();
# 561 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void ignoreAnchorPointForPosition(bool ignore);







    virtual bool isIgnoreAnchorPointForPosition();
# 584 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void addChild(CCNode * child);
# 593 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void addChild(CCNode * child, int zOrder);
# 603 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);







    virtual CCNode * getChildByTag(int tag);
# 628 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCArray* getChildren();






    virtual unsigned int getChildrenCount(void) const;






    virtual void setParent(CCNode* parent);







    virtual CCNode* getParent();
# 660 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void removeFromParent();






    virtual void removeFromParentAndCleanup(bool cleanup);


    virtual void removeMeAndCleanup();







    virtual void removeChild(CCNode* child);






    virtual void removeChild(CCNode* child, bool cleanup);







    virtual void removeChildByTag(int tag);






    virtual void removeChildByTag(int tag, bool cleanup);





    virtual void removeAllChildren();






    virtual void removeAllChildrenWithCleanup(bool cleanup);







    virtual void reorderChild(CCNode * child, int zOrder);






    virtual void sortAllChildren();
# 743 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCGridBase* getGrid();





    virtual void setGrid(CCGridBase *pGrid);
# 811 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void* getUserData();
# 822 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setUserData(void *pUserData);
# 832 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCObject* getUserObject();
# 843 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setUserObject(CCObject *pUserObject);
# 855 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCGLProgram* getShaderProgram();
# 867 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setShaderProgram(CCGLProgram *pShaderProgram);
# 882 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCCamera* getCamera();
# 891 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual bool isRunning();
# 918 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void registerScriptHandler(int handler);





    virtual void unregisterScriptHandler(void);







    inline int getScriptHandler() { return m_nScriptHandler; };





    void scheduleUpdateWithPriorityLua(int nHandler, int priority);
# 954 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void onEnter();







    virtual void onEnterTransitionDidFinish();
# 972 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void onExit();







    virtual void onExitTransitionDidStart();







    virtual void cleanup(void);
# 1000 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void draw(void);




    virtual void visit(void);
# 1018 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCRect boundingBox(void);
# 1030 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setActionManager(CCActionManager* actionManager);





    virtual CCActionManager* getActionManager();
# 1046 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCAction* runAction(CCAction* action);




    void stopAllActions(void);






    void stopAction(CCAction* action);






    void stopActionByTag(int tag);
# 1074 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCAction* getActionByTag(int tag);
# 1086 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    unsigned int numberOfRunningActions(void);
# 1101 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScheduler(CCScheduler* scheduler);







    virtual CCScheduler* getScheduler();
# 1119 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    bool isScheduled(SEL_SCHEDULE selector);
# 1129 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void scheduleUpdate(void);
# 1139 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void scheduleUpdateWithPriority(int priority);





    void unscheduleUpdate(void);
# 1163 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void schedule(SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay);
# 1173 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void schedule(SEL_SCHEDULE selector, float interval);
# 1183 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void scheduleOnce(SEL_SCHEDULE selector, float delay);
# 1192 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void schedule(SEL_SCHEDULE selector);
# 1201 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void unschedule(SEL_SCHEDULE selector);





    void unscheduleAllSelectors(void);







    void resumeSchedulerAndActions(void);






    void pauseSchedulerAndActions(void);




    virtual void update(float delta);
# 1237 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void transform(void);





    void transformAncestors(void);







    virtual void updateTransform(void);







    virtual const CCAffineTransform nodeToParentTransform(void);





    virtual const CCAffineTransform parentToNodeTransform(void);




    virtual CCAffineTransform nodeToWorldTransform(void);




    virtual CCAffineTransform worldToNodeTransform(void);
# 1286 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCPoint convertToNodeSpace(const CCPoint& worldPoint);




    CCPoint convertToWorldSpace(const CCPoint& nodePoint);





    CCPoint convertToNodeSpaceAR(const CCPoint& worldPoint);





    CCPoint convertToWorldSpaceAR(const CCPoint& nodePoint);




    CCPoint convertTouchToNodeSpace(CCTouch * touch);




    CCPoint convertTouchToNodeSpaceAR(CCTouch * touch);
# 1363 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void setAdditionalTransform(const CCAffineTransform& additionalTransform);
# 1372 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCComponent* getComponent(const char *pName) const;




    virtual bool addComponent(CCComponent *pComponent);




    virtual bool removeComponent(const char *pName);




    virtual bool removeComponent(CCComponent *pComponent);




    virtual void removeAllComponents();



    virtual void updateTweenAction(float, char const*);
private:

    void childrenAlloc(void);


    void insertChild(CCNode* child, int z);


    void detachChild(CCNode *child, bool doCleanup);





    CCPoint convertToWindowSpace(const CCPoint& nodePoint);

protected:
    float m_fRotationX;
    float m_fRotationY;

    float m_fScaleX;
    float m_fScaleY;

    float m_fVertexZ;

    CCPoint m_obPosition;

    float m_fSkewX;
    float m_fSkewY;

    CCPoint m_obAnchorPointInPoints;
    CCPoint m_obAnchorPoint;

    CCSize m_obContentSize;


    CCAffineTransform m_sAdditionalTransform;
    CCAffineTransform m_sTransform;
    CCAffineTransform m_sInverse;

    CCCamera *m_pCamera;

    CCGridBase *m_pGrid;

    int m_nZOrder;

    CCArray *m_pChildren;
    CCNode *m_pParent;



    void *m_pUserData;
    CCObject *m_pUserObject;

    CCGLProgram *m_pShaderProgram;

    ccGLServerState m_eGLServerState;

    unsigned int m_uOrderOfArrival;

    CCScheduler *m_pScheduler;

    CCActionManager *m_pActionManager;

    bool m_bRunning;

    bool m_bTransformDirty;
    bool m_bInverseDirty;
    bool m_bAdditionalTransformDirty;
    bool m_bVisible;

    bool m_bIgnoreAnchorPointForPosition;


    bool m_bReorderChildDirty;

    int m_nScriptHandler;
    int m_nUpdateScriptHandler;
    ccScriptType m_eScriptType;

    CCComponentContainer *m_pComponentContainer;

};
# 1494 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
class CCNodeRGBA : public CCNode, public CCRGBAProtocol
{
public:



    CCNodeRGBA();




    virtual ~CCNodeRGBA();

    virtual bool init();





    static CCNodeRGBA * create(void);

    virtual GLubyte getOpacity();
    virtual GLubyte getDisplayedOpacity();
    virtual void setOpacity(GLubyte opacity);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual bool isCascadeOpacityEnabled();
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);

    virtual const ccColor3B& getColor(void);
    virtual const ccColor3B& getDisplayedColor();
    virtual void setColor(const ccColor3B& color);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual bool isCascadeColorEnabled();
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled);

    virtual void setOpacityModifyRGB(bool bValue) {(void)bValue;};
    virtual bool isOpacityModifyRGB() { return false; };

protected:
 GLubyte _displayedOpacity;
    GLubyte _realOpacity;
 ccColor3B _displayedColor;
    ccColor3B _realColor;
 bool _cascadeColorEnabled;
    bool _cascadeOpacityEnabled;
};




}
# 31 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 2


# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrame.h" 1
# 35 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrame.h"
namespace cocos2d {

class CCTexture2D;
class CCZone;
# 55 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrame.h"
class CCSpriteFrame : public CCObject
{
public:


    inline const CCRect& getRectInPixels(void) { return m_obRectInPixels; }
    void setRectInPixels(const CCRect& rectInPixels);

    inline bool isRotated(void) { return m_bRotated; }
    inline void setRotated(bool bRotated) { m_bRotated = bRotated; }


    inline const CCRect& getRect(void) { return m_obRect; }

    void setRect(const CCRect& rect);


    const CCPoint& getOffsetInPixels(void);

    void setOffsetInPixels(const CCPoint& offsetInPixels);


    inline const CCSize& getOriginalSizeInPixels(void) { return m_obOriginalSizeInPixels; }

    inline void setOriginalSizeInPixels(const CCSize& sizeInPixels) { m_obOriginalSizeInPixels = sizeInPixels; }


    inline const CCSize& getOriginalSize(void) { return m_obOriginalSize; }

    inline void setOriginalSize(const CCSize& sizeInPixels) { m_obOriginalSize = sizeInPixels; }


    CCTexture2D* getTexture(void);

    void setTexture(CCTexture2D* pobTexture);

    const CCPoint& getOffset(void);
    void setOffset(const CCPoint& offsets);

public:




    ~CCSpriteFrame(void);




    virtual CCObject* copyWithZone(CCZone *pZone);




    static CCSpriteFrame* create(const char* filename, const CCRect& rect);




    static CCSpriteFrame* create(const char* filename, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);




    static CCSpriteFrame* createWithTexture(CCTexture2D* pobTexture, const CCRect& rect);




    static CCSpriteFrame* createWithTexture(CCTexture2D* pobTexture, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);

public:



    bool initWithTexture(CCTexture2D* pobTexture, const CCRect& rect);




    bool initWithTextureFilename(const char* filename, const CCRect& rect);




    bool initWithTexture(CCTexture2D* pobTexture, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);






    bool initWithTextureFilename(const char* filename, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);


protected:
    CCPoint m_obOffset;
    CCSize m_obOriginalSize;
    CCRect m_obRectInPixels;
    bool m_bRotated;
    CCRect m_obRect;
    CCPoint m_obOffsetInPixels;
    CCSize m_obOriginalSizeInPixels;
    CCTexture2D *m_pobTexture;
    std::string m_strTextureFilename;
};




}
# 34 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 2
# 1 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h" 1
# 32 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
# 1 "Cacao/include/cocos2dx/cocoa/CCDictionary.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
# 1 "Cacao/include/cocos2dx/support/data_support/uthash.h" 1
# 28 "Cacao/include/cocos2dx/support/data_support/uthash.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 1 3
# 29 "Cacao/include/cocos2dx/support/data_support/uthash.h" 2
# 872 "Cacao/include/cocos2dx/support/data_support/uthash.h"
typedef struct UT_hash_bucket {
   struct UT_hash_handle *hh_head;
   unsigned count;
# 888 "Cacao/include/cocos2dx/support/data_support/uthash.h"
   unsigned expand_mult;

} UT_hash_bucket;





typedef struct UT_hash_table {
   UT_hash_bucket *buckets;
   unsigned num_buckets, log2_num_buckets;
   unsigned num_items;
   struct UT_hash_handle *tail;
   ptrdiff_t hho;



   unsigned ideal_chain_maxlen;




   unsigned nonideal_items;







   unsigned ineff_expands, noexpand;

   uint32_t signature;






} UT_hash_table;

typedef struct UT_hash_handle {
   struct UT_hash_table *tbl;
   void *prev;
   void *next;
   struct UT_hash_handle *hh_prev;
   struct UT_hash_handle *hh_next;
   void *key;
   unsigned keylen;
   unsigned hashv;
} UT_hash_handle;
# 29 "Cacao/include/cocos2dx/cocoa/CCDictionary.h" 2


# 1 "Cacao/include/cocos2dx/cocoa/CCString.h" 1
# 33 "Cacao/include/cocos2dx/cocoa/CCString.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/functional" 1 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/functional" 3
# 34 "Cacao/include/cocos2dx/cocoa/CCString.h" 2


namespace cocos2d {







class CCString : public CCObject
{
public:



    CCString();



    CCString(const char* str);



    CCString(const std::string& str);



    CCString(const CCString& str);



    virtual ~CCString();




    CCString& operator= (const CCString& other);




    bool initWithFormat(const char* format, ...) __attribute__((__format__(printf, 2, 3)));


    int intValue() const;


    unsigned int uintValue() const;


    float floatValue() const;


    double doubleValue() const;


    bool boolValue() const;


    const char* getCString() const;


    unsigned int length() const;


    int compare(const char *) const;





    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual bool isEqual(const CCObject* pObject);





    static CCString* create(const std::string& str);







    static CCString* createWithFormat(const char* format, ...) __attribute__((__format__(printf, 1, 2)));





    static CCString* createWithData(const unsigned char* pData, unsigned long nLen);





    static CCString* createWithContentsOfFile(const char* pszFileName);



    virtual void acceptVisitor(CCDataVisitor &visitor);

private:


    bool initWithFormatAndValist(const char* format, va_list ap);

public:
    std::string m_sString;
};

struct CCStringCompare : public std::binary_function<CCString *, CCString *, bool> {
    public:
        bool operator() (CCString * a, CCString * b) const {
            return strcmp(a->getCString(), b->getCString()) < 0;
        }
};







}
# 32 "Cacao/include/cocos2dx/cocoa/CCDictionary.h" 2

namespace cocos2d {

class CCDictionary;
# 63 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
class CCDictElement
{
private:






    CCDictElement(const char* pszKey, CCObject* pObject);







    CCDictElement(intptr_t iKey, CCObject* pObject);

public:



    ~CCDictElement();
# 97 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    inline const char* getStrKey() const
    {
        ((void)(m_szKey[0] != '\0'));
        return m_szKey;
    }
# 110 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    inline intptr_t getIntKey() const
    {
        ((void)(m_szKey[0] == '\0'));
        return m_iKey;
    }






    inline CCObject* getObject() const { return m_pObject; }

private:




    char m_szKey[256];
    intptr_t m_iKey;
    CCObject* m_pObject;
public:
    UT_hash_handle hh;
    friend class CCDictionary;
};
# 174 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
class CCDictionary : public CCObject
{
public:




    CCDictionary();





    ~CCDictionary();






    unsigned int count();






    CCArray* allKeys();






    CCArray* allKeysForObject(CCObject* object);
# 228 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    CCObject* objectForKey(const std::string& key);
# 238 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    CCObject* objectForKey(intptr_t key);
# 248 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    const CCString* valueForKey(const std::string& key);
# 258 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    const CCString* valueForKey(intptr_t key);
# 271 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void setObject(CCObject* pObject, const std::string& key);
# 283 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void setObject(CCObject* pObject, intptr_t key);
# 292 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectForKey(const std::string& key);
# 301 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectForKey(intptr_t key);
# 310 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectsForKeys(CCArray* pKeyArray);
# 320 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectForElememt(CCDictElement* pElement);







    void removeAllObjects();
# 338 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    virtual CCObject* copyWithZone(CCZone* pZone);
# 348 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    CCObject* randomObject();






    static CCDictionary* create();
# 364 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    static CCDictionary* createWithDictionary(CCDictionary* srcDict);







    static CCDictionary* createWithContentsOfFile(const char *pFileName);







    bool writeToFile(const char *fullPath);
# 394 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    static CCDictionary* createWithContentsOfFileThreadSafe(const char *pFileName);




    virtual void acceptVisitor(CCDataVisitor &visitor);

private:



    void setObjectUnSafe(CCObject* pObject, const std::string& key);
    void setObjectUnSafe(CCObject* pObject, const intptr_t key);

public:





    CCDictElement* m_pElements;
private:


    enum CCDictType
    {
        kCCDictUnknown = 0,
        kCCDictStr,
        kCCDictInt
    };




    CCDictType m_eDictType;
};




}
# 33 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h" 2




namespace cocos2d {

class CCTexture2D;
class CCSpriteFrame;
# 55 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
class CCAnimationFrame : public CCObject
{
public:



    CCAnimationFrame();




    virtual ~CCAnimationFrame();




    virtual CCObject* copyWithZone(CCZone* pZone);

    bool initWithSpriteFrame(CCSpriteFrame* spriteFrame, float delayUnits, CCDictionary* userInfo);
# 86 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
    CCSpriteFrame* getSpriteFrame(void)const;
    void setSpriteFrame(CCSpriteFrame*);

    float getDelayUnits(void)const;
    void setDelayUnits(float);

    CCDictionary* getUserInfo(void)const;
    void setUserInfo(CCDictionary*);
};
# 107 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
class CCAnimation : public CCObject
{
public:



    CCAnimation();




    ~CCAnimation(void);
public:



    static CCAnimation* create(void);






    static CCAnimation* createWithSpriteFrames(CCArray* arrayOfSpriteFrameNames, float delay = 0.0f);




    static CCAnimation* create(CCArray *arrayOfAnimationFrameNames, float delayPerUnit, unsigned int loops);
    static CCAnimation* create(CCArray *arrayOfAnimationFrameNames, float delayPerUnit) {
        return CCAnimation::create(arrayOfAnimationFrameNames, delayPerUnit, 1);
    }




    void addSpriteFrame(CCSpriteFrame *pFrame);






    void addSpriteFrameWithFileName(const char *pszFileName);





    void addSpriteFrameWithTexture(CCTexture2D* pobTexture, const CCRect& rect);



    bool init();





    bool initWithSpriteFrames(CCArray *pFrames, float delay = 0.0f);





    bool initWithAnimationFrames(CCArray* arrayOfAnimationFrames, float delayPerUnit, unsigned int loops);




    virtual CCObject* copyWithZone(CCZone* pZone);


    protected: float m_fTotalDelayUnits;public: float getTotalDelayUnits(void) const { return m_fTotalDelayUnits; }


    protected: float m_fDelayPerUnit;public: float getDelayPerUnit(void) const { return m_fDelayPerUnit; }public: void setDelayPerUnit(float var){ m_fDelayPerUnit = var; }


    protected: float m_fDuration;public: virtual float getDuration(void);


    private: CCArray* m_pFrames; public: CCArray* getFrames(void) const { return m_pFrames; } public: void setFrames(CCArray* var);


    protected: bool m_bRestoreOriginalFrame;public: bool getRestoreOriginalFrame(void) const { return m_bRestoreOriginalFrame; }public: void setRestoreOriginalFrame(bool var){ m_bRestoreOriginalFrame = var; }


    protected: unsigned int m_uLoops;public: unsigned int getLoops(void) const { return m_uLoops; }public: void setLoops(unsigned int var){ m_uLoops = var; }
};




}
# 35 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 2


namespace cocos2d {
# 61 "Cacao/include/cocos2dx/actions/CCActionInterval.h"
class CCActionInterval : public CCFiniteTimeAction
{
public:

    inline float getElapsed(void) { return m_elapsed; }


    bool initWithDuration(float d);


    virtual bool isDone(void);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void step(float dt);
    virtual void startWithTarget(CCNode *pTarget);

    virtual CCActionInterval* reverse(void);

public:


    static CCActionInterval* create(float d);

public:

    void setAmplitudeRate(float amp);
    float getAmplitudeRate(void);

protected:
    float m_elapsed;
    bool m_bFirstTick;
};



class CCSequence : public CCActionInterval
{
public:




    ~CCSequence(void);




    bool initWithTwoActions(CCFiniteTimeAction *pActionOne, CCFiniteTimeAction *pActionTwo);




    virtual CCObject* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void stop(void);



    virtual void update(float t);
    virtual CCActionInterval* reverse(void);

public:




    static CCSequence* create(CCFiniteTimeAction *pAction1, ...);



    static CCSequence* create(CCArray *arrayOfActions);




    static CCSequence* createWithVariableList(CCFiniteTimeAction *pAction1, va_list args);



    static CCSequence* createWithTwoActions(CCFiniteTimeAction *pActionOne, CCFiniteTimeAction *pActionTwo);

protected:
    CCFiniteTimeAction *m_pActions[2];
    float m_split;
    int m_last;
};




class CCRepeat : public CCActionInterval
{
public:




    ~CCRepeat(void);


    bool initWithAction(CCFiniteTimeAction *pAction, unsigned int times);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float dt);
    virtual bool isDone(void);
    virtual CCActionInterval* reverse(void);

    inline void setInnerAction(CCFiniteTimeAction *pAction)
    {
        if (m_pInnerAction != pAction)
        {
            do { if(pAction) { (pAction)->retain(); } } while(0);
            do { if(m_pInnerAction) { (m_pInnerAction)->release(); } } while(0);
            m_pInnerAction = pAction;
        }
    }

    inline CCFiniteTimeAction* getInnerAction()
    {
        return m_pInnerAction;
    }

public:


    static CCRepeat* create(CCFiniteTimeAction *pAction, unsigned int times);
protected:
    unsigned int m_uTimes;
    unsigned int m_uTotal;
    float m_fNextDt;
    bool m_bActionInstant;

    CCFiniteTimeAction *m_pInnerAction;
};





class CCRepeatForever : public CCActionInterval
{
public:



    CCRepeatForever()
        : m_pInnerAction(__null)
    {}




    virtual ~CCRepeatForever();


    bool initWithAction(CCActionInterval *pAction);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode* pTarget);
    virtual void step(float dt);
    virtual bool isDone(void);
    virtual CCActionInterval* reverse(void);

    inline void setInnerAction(CCActionInterval *pAction)
    {
        if (m_pInnerAction != pAction)
        {
            do { if(m_pInnerAction) { (m_pInnerAction)->release(); } } while(0);
            m_pInnerAction = pAction;
            do { if(m_pInnerAction) { (m_pInnerAction)->retain(); } } while(0);
        }
    }

    inline CCActionInterval* getInnerAction()
    {
        return m_pInnerAction;
    }

public:


    static CCRepeatForever* create(CCActionInterval *pAction);
protected:

    CCActionInterval *m_pInnerAction;
};



class CCSpawn : public CCActionInterval
{
public:




    ~CCSpawn(void);




    bool initWithTwoActions(CCFiniteTimeAction *pAction1, CCFiniteTimeAction *pAction2);




    virtual CCObject* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void stop(void);



    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:




    static CCSpawn* create(CCFiniteTimeAction *pAction1, ...);





    static CCSpawn* createWithVariableList(CCFiniteTimeAction *pAction1, va_list args);




    static CCSpawn* create(CCArray *arrayOfActions);




    static CCSpawn* createWithTwoActions(CCFiniteTimeAction *pAction1, CCFiniteTimeAction *pAction2);

protected:
    CCFiniteTimeAction *m_pOne;
    CCFiniteTimeAction *m_pTwo;
};





class CCRotateTo : public CCActionInterval
{
public:

    static CCRotateTo* create(float fDuration, float fDeltaAngle);

    bool initWithDuration(float fDuration, float fDeltaAngle);


    static CCRotateTo* create(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
    virtual bool initWithDuration(float fDuration, float fDeltaAngleX, float fDeltaAngleY);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

protected:
    float m_fDstAngleX;
    float m_fStartAngleX;
    float m_fDiffAngleX;

    float m_fDstAngleY;
    float m_fStartAngleY;
    float m_fDiffAngleY;
};



class CCRotateBy : public CCActionInterval
{
public:

    static CCRotateBy* create(float fDuration, float fDeltaAngle);

    bool initWithDuration(float fDuration, float fDeltaAngle);

    static CCRotateBy* create(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
    bool initWithDuration(float fDuration, float fDeltaAngleX, float fDeltaAngleY);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

protected:
    float m_fAngleX;
    float m_fStartAngleX;
    float m_fAngleY;
    float m_fStartAngleY;
};







class CCMoveBy : public CCActionInterval
{
public:

    bool initWithDuration(float duration, const CCPoint& deltaPosition);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);
    virtual void update(float time);

public:

    static CCMoveBy* create(float duration, const CCPoint& deltaPosition);
protected:
    CCPoint m_positionDelta;
    CCPoint m_startPosition;
    CCPoint m_previousPosition;
};






class CCMoveTo : public CCMoveBy
{
public:

    bool initWithDuration(float duration, const CCPoint& position);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCMoveTo* create(float duration, const CCPoint& position);
protected:
    CCPoint m_endPosition;
};




class CCSkewTo : public CCActionInterval
{
public:



    CCSkewTo();
    virtual bool initWithDuration(float t, float sx, float sy);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCSkewTo* create(float t, float sx, float sy);
protected:
    float m_fSkewX;
    float m_fSkewY;
    float m_fStartSkewX;
    float m_fStartSkewY;
    float m_fEndSkewX;
    float m_fEndSkewY;
    float m_fDeltaX;
    float m_fDeltaY;
};




class CCSkewBy : public CCSkewTo
{
public:
    virtual bool initWithDuration(float t, float sx, float sy);
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);

public:


    static CCSkewBy* create(float t, float deltaSkewX, float deltaSkewY);
};



class CCJumpBy : public CCActionInterval
{
public:

    bool initWithDuration(float duration, const CCPoint& position, float height, unsigned int jumps);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCJumpBy* create(float duration, const CCPoint& position, float height, unsigned int jumps);
protected:
    CCPoint m_startPosition;
    CCPoint m_delta;
    float m_height;
    unsigned int m_nJumps;
    CCPoint m_previousPos;
};



class CCJumpTo : public CCJumpBy
{
public:
    virtual void startWithTarget(CCNode *pTarget);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCJumpTo* create(float duration, const CCPoint& position, float height, int jumps);
};



typedef struct _ccBezierConfig {

    CCPoint endPosition;

    CCPoint controlPoint_1;

    CCPoint controlPoint_2;
} ccBezierConfig;



class CCBezierBy : public CCActionInterval
{
public:



    bool initWithDuration(float t, const ccBezierConfig& c);




    virtual CCObject* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:






    static CCBezierBy* create(float t, const ccBezierConfig& c);
protected:
    ccBezierConfig m_sConfig;
    CCPoint m_startPosition;
    CCPoint m_previousPosition;
};




class CCBezierTo : public CCBezierBy
{
public:



    virtual void startWithTarget(CCNode *pTarget);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:







    static CCBezierTo* create(float t, const ccBezierConfig& c);



    bool initWithDuration(float t, const ccBezierConfig &c);

protected:
    ccBezierConfig m_sToConfig;
};




class CCScaleTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, float s);


    bool initWithDuration(float duration, float sx, float sy);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCScaleTo* create(float duration, float s);


    static CCScaleTo* create(float duration, float sx, float sy);
protected:
    float m_fScaleX;
    float m_fScaleY;
    float m_fStartScaleX;
    float m_fStartScaleY;
    float m_fEndScaleX;
    float m_fEndScaleY;
    float m_fDeltaX;
    float m_fDeltaY;
};



class CCScaleBy : public CCScaleTo
{
public:
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCScaleBy* create(float duration, float s);


    static CCScaleBy* create(float duration, float sx, float sy);
};



class CCBlink : public CCActionInterval
{
public:

    bool initWithDuration(float duration, unsigned int uBlinks);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:


    static CCBlink* create(float duration, unsigned int uBlinks);

    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop();

protected:
    unsigned int m_nTimes;
    bool m_bOriginalState;
};




class CCFadeIn : public CCActionInterval
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCFadeIn* create(float d);
};




class CCFadeOut : public CCActionInterval
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCFadeOut* create(float d);
};




class CCFadeTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, GLubyte opacity);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:

    static CCFadeTo* create(float duration, GLubyte opacity);
protected:
    GLubyte m_toOpacity;
    GLubyte m_fromOpacity;
};





class CCTintTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, GLubyte red, GLubyte green, GLubyte blue);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:

    static CCTintTo* create(float duration, GLubyte red, GLubyte green, GLubyte blue);
protected:
    ccColor3B m_to;
    ccColor3B m_from;
};




class CCTintBy : public CCActionInterval
{
public:

    bool initWithDuration(float duration, GLshort deltaRed, GLshort deltaGreen, GLshort deltaBlue);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCTintBy* create(float duration, GLshort deltaRed, GLshort deltaGreen, GLshort deltaBlue);
protected:
    GLshort m_deltaR;
    GLshort m_deltaG;
    GLshort m_deltaB;

    GLshort m_fromR;
    GLshort m_fromG;
    GLshort m_fromB;
};



class CCDelayTime : public CCActionInterval
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCDelayTime* create(float d);
};
# 849 "Cacao/include/cocos2dx/actions/CCActionInterval.h"
class CCReverseTime : public CCActionInterval
{
public:



    ~CCReverseTime(void);




    CCReverseTime();


    bool initWithAction(CCFiniteTimeAction *pAction);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCReverseTime* create(CCFiniteTimeAction *pAction);
protected:
    CCFiniteTimeAction *m_pOther;
};

class CCTexture2D;

class CCAnimate : public CCActionInterval
{
public:



    CCAnimate();




    ~CCAnimate();


    bool initWithAnimation(CCAnimation *pAnimation);





    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float t);
    virtual CCActionInterval* reverse(void);

public:

    static CCAnimate* create(CCAnimation *pAnimation);
    private: CCAnimation* m_pAnimation; public: virtual CCAnimation* getAnimation(void) const { return m_pAnimation; } public: virtual void setAnimation(CCAnimation* var) { if (m_pAnimation != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pAnimation) { (m_pAnimation)->release(); } } while(0); m_pAnimation = var; } }
protected:
    std::vector<float>* m_pSplitTimes;
    int m_nNextFrame;
    CCSpriteFrame* m_pOrigFrame;
       unsigned int m_uExecutedLoops;
};




class CCTargetedAction : public CCActionInterval
{
public:



    CCTargetedAction();




    virtual ~CCTargetedAction();


    static CCTargetedAction* create(CCNode* pTarget, CCFiniteTimeAction* pAction);


    bool initWithTarget(CCNode* pTarget, CCFiniteTimeAction* pAction);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float time);


    private: CCNode* m_pForcedTarget; public: virtual CCNode* getForcedTarget(void) const { return m_pForcedTarget; } public: virtual void setForcedTarget(CCNode* var) { if (m_pForcedTarget != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pForcedTarget) { (m_pForcedTarget)->release(); } } while(0); m_pForcedTarget = var; } };
private:
    CCFiniteTimeAction* m_pAction;
};




}
# 43 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionCamera.h" 1
# 31 "Cacao/include/cocos2dx/actions/CCActionCamera.h"
namespace cocos2d {

class CCCamera;
# 44 "Cacao/include/cocos2dx/actions/CCActionCamera.h"
class CCActionCamera : public CCActionInterval
{
public:



    CCActionCamera()
        :m_fCenterXOrig(0)
        ,m_fCenterYOrig(0)
        ,m_fCenterZOrig(0)
        ,m_fEyeXOrig(0)
        ,m_fEyeYOrig(0)
        ,m_fEyeZOrig(0)
        ,m_fUpXOrig(0)
        ,m_fUpYOrig(0)
        ,m_fUpZOrig(0)
    {}




    virtual ~CCActionCamera(){}

    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval * reverse();
protected:
    float m_fCenterXOrig;
    float m_fCenterYOrig;
    float m_fCenterZOrig;

    float m_fEyeXOrig;
    float m_fEyeYOrig;
    float m_fEyeZOrig;

    float m_fUpXOrig;
    float m_fUpYOrig;
    float m_fUpZOrig;
};






class CCOrbitCamera : public CCActionCamera
{
public:



    CCOrbitCamera()
        : m_fRadius(0.0)
        , m_fDeltaRadius(0.0)
        , m_fAngleZ(0.0)
        , m_fDeltaAngleZ(0.0)
        , m_fAngleX(0.0)
        , m_fDeltaAngleX(0.0)
        , m_fRadZ(0.0)
        , m_fRadDeltaZ(0.0)
        , m_fRadX(0.0)
        , m_fRadDeltaX(0.0)
    {}




    ~CCOrbitCamera(){}


    static CCOrbitCamera* create(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX);


    bool initWithDuration(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX);

    void sphericalRadius(float *r, float *zenith, float *azimuth);





    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

protected:
    float m_fRadius;
    float m_fDeltaRadius;
    float m_fAngleZ;
    float m_fDeltaAngleZ;
    float m_fAngleX;
    float m_fDeltaAngleX;

    float m_fRadZ;
    float m_fRadDeltaZ;
    float m_fRadX;
    float m_fRadDeltaX;
};




}
# 44 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionManager.h" 1
# 35 "Cacao/include/cocos2dx/actions/CCActionManager.h"
namespace cocos2d {

class CCSet;

struct _hashElement;
# 57 "Cacao/include/cocos2dx/actions/CCActionManager.h"
class CCActionManager : public CCObject
{
public:



    CCActionManager(void);




    ~CCActionManager(void);
# 77 "Cacao/include/cocos2dx/actions/CCActionManager.h"
    void addAction(CCAction *pAction, CCNode *pTarget, bool paused);



    void removeAllActions(void);




    void removeAllActionsFromTarget(CCObject *pTarget);



    void removeAction(CCAction *pAction);


    void removeActionByTag(unsigned int tag, CCObject *pTarget);




    CCAction* getActionByTag(unsigned int tag, CCObject *pTarget);






    unsigned int numberOfRunningActionsInTarget(CCObject *pTarget);



    void pauseTarget(CCObject *pTarget);



    void resumeTarget(CCObject *pTarget);



    CCSet* pauseAllRunningActions();



    void resumeTargets(CCSet *targetsToResume);

protected:


    void removeActionAtIndex(unsigned int uIndex, struct _hashElement *pElement);
    void deleteHashElement(struct _hashElement *pElement);
    void actionAllocWithHashElement(struct _hashElement *pElement);
    void update(float dt);

protected:
    struct _hashElement *m_pTargets;
    struct _hashElement *m_pCurrentTarget;
    bool m_bCurrentTargetSalvaged;
};




}
# 45 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionEase.h" 1
# 31 "Cacao/include/cocos2dx/actions/CCActionEase.h"
namespace cocos2d {

class CCObject;
class CCZone;
# 45 "Cacao/include/cocos2dx/actions/CCActionEase.h"
class CCActionEase : public CCActionInterval
{
public:




    virtual ~CCActionEase(void);


    bool initWithAction(CCActionInterval *pAction);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);
    virtual CCActionInterval* getInnerAction();

public:


    static CCActionEase* create(CCActionInterval *pAction);

protected:

    CCActionInterval *m_pInner;
};





class CCEaseRateAction : public CCActionEase
{
public:




    virtual ~CCEaseRateAction(void);


    inline void setRate(float rate) { m_fRate = rate; }

    inline float getRate(void) { return m_fRate; }


    bool initWithAction(CCActionInterval *pAction, float fRate);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse(void);

public:


    static CCEaseRateAction* create(CCActionInterval* pAction, float fRate);

protected:
    float m_fRate;
};





class CCEaseIn : public CCEaseRateAction
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);
public:


    static CCEaseIn* create(CCActionInterval* pAction, float fRate);
};





class CCEaseOut : public CCEaseRateAction
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse();




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseOut* create(CCActionInterval* pAction, float fRate);
};





class CCEaseInOut : public CCEaseRateAction
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse(void);

public:


    static CCEaseInOut* create(CCActionInterval* pAction, float fRate);
};





class CCEaseExponentialIn : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCEaseExponentialIn* create(CCActionInterval* pAction);
};





class CCEaseExponentialOut : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCEaseExponentialOut* create(CCActionInterval* pAction);
};





class CCEaseExponentialInOut : public CCActionEase
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseExponentialInOut* create(CCActionInterval* pAction);
};





class CCEaseSineIn : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCEaseSineIn* create(CCActionInterval* pAction);
};





class CCEaseSineOut : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseSineOut* create(CCActionInterval* pAction);
};





class CCEaseSineInOut : public CCActionEase
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseSineInOut* create(CCActionInterval* pAction);
};






class CCEaseElastic : public CCActionEase
{
public:

    inline float getPeriod(void) { return m_fPeriod; }

    inline void setPeriod(float fPeriod) { m_fPeriod = fPeriod; }


    bool initWithAction(CCActionInterval *pAction, float fPeriod = 0.3f);

    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElastic* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElastic* create(CCActionInterval *pAction);
protected:
    float m_fPeriod;
};







class CCEaseElasticIn : public CCEaseElastic
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElasticIn* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElasticIn* create(CCActionInterval *pAction);
};







class CCEaseElasticOut : public CCEaseElastic
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElasticOut* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElasticOut* create(CCActionInterval *pAction);
};







class CCEaseElasticInOut : public CCEaseElastic
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElasticInOut* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElasticInOut* create(CCActionInterval *pAction);
};






class CCEaseBounce : public CCActionEase
{
public:
    float bounceTime(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseBounce* create(CCActionInterval* pAction);
};







class CCEaseBounceIn : public CCEaseBounce
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBounceIn* create(CCActionInterval* pAction);
};







class CCEaseBounceOut : public CCEaseBounce
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBounceOut* create(CCActionInterval* pAction);
};







class CCEaseBounceInOut : public CCEaseBounce
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseBounceInOut* create(CCActionInterval* pAction);
};







class CCEaseBackIn : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBackIn* create(CCActionInterval* pAction);
};







class CCEaseBackOut : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBackOut* create(CCActionInterval* pAction);
};







class CCEaseBackInOut : public CCActionEase
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseBackInOut* create(CCActionInterval* pAction);
};




}
# 46 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h" 1
# 28 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h"
# 1 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h" 1
# 28 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h"
# 1 "Cacao/include/cocos2dx/actions/CCActionGrid.h" 1
# 29 "Cacao/include/cocos2dx/actions/CCActionGrid.h"
# 1 "Cacao/include/cocos2dx/actions/CCActionInstant.h" 1
# 31 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
# 1 "Cacao/include/cocos2dx/include/ccTypeInfo.h" 1
# 34 "Cacao/include/cocos2dx/include/ccTypeInfo.h"
namespace cocos2d {

class TypeInfo
{
public:
 virtual long getClassTypeInfo() = 0;
};

static inline unsigned int getHashCodeByString(const char *key)
{
 unsigned int len = strlen(key);
 const char *end=key+len;
 unsigned int hash;

 for (hash = 0; key < end; key++)
 {
  hash *= 16777619;
  hash ^= (unsigned int) (unsigned char) toupper(*key);
 }
 return (hash);
}
}
# 32 "Cacao/include/cocos2dx/actions/CCActionInstant.h" 2


namespace cocos2d {
# 45 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
class CCActionInstant : public CCFiniteTimeAction
{
public:



    CCActionInstant();




    virtual ~CCActionInstant(){}





    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual bool isDone(void);
    virtual void step(float dt);
    virtual void update(float time);

    virtual CCFiniteTimeAction * reverse(void);
};



class CCShow : public CCActionInstant
{
public:




    CCShow(){}




    virtual ~CCShow(){}

    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);




    virtual CCObject* copyWithZone(CCZone *pZone);
public:


    static CCShow * create();
};






class CCHide : public CCActionInstant
{
public:




    CCHide(){}




    virtual ~CCHide(){}




    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);




    virtual CCObject* copyWithZone(CCZone *pZone);
public:


    static CCHide * create();
};



class CCToggleVisibility : public CCActionInstant
{
public:



    CCToggleVisibility(){}




    virtual ~CCToggleVisibility(){}

    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone *pZone);
public:


    static CCToggleVisibility * create();
};






class CCRemoveSelf : public CCActionInstant
{
public:
 CCRemoveSelf(){}
 virtual ~CCRemoveSelf(){}

 virtual void update(float time);
 virtual CCFiniteTimeAction * reverse(void);
 virtual CCObject* copyWithZone(CCZone *pZone);
public:

 static CCRemoveSelf * create(bool isNeedCleanUp = true);

 bool init(bool isNeedCleanUp);
protected:
 bool m_bIsNeedCleanUp;
};






class CCFlipX : public CCActionInstant
{
public:



    CCFlipX()
        :m_bFlipX(false)
    {}




    virtual ~CCFlipX(){}


    static CCFlipX * create(bool x);


    bool initWithFlipX(bool x);

    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);



    virtual CCObject* copyWithZone(CCZone *pZone);

protected:
    bool m_bFlipX;
};






class CCFlipY : public CCActionInstant
{
public:



    CCFlipY()
        :m_bFlipY(false)
    {}




    virtual ~CCFlipY(){}


    static CCFlipY * create(bool y);


    bool initWithFlipY(bool y);

    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);



    virtual CCObject* copyWithZone(CCZone *pZone);

protected:
    bool m_bFlipY;
};



class CCPlace : public CCActionInstant
{
public:



    CCPlace(){}




    virtual ~CCPlace(){}


    static CCPlace * create(const CCPoint& pos);

    bool initWithPosition(const CCPoint& pos);

    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone *pZone);
protected:
    CCPoint m_tPosition;
};



class CCCallFunc : public CCActionInstant
{
public:



    CCCallFunc()
        : m_pSelectorTarget(__null)
  , m_nScriptHandler(0)
        , m_pCallFunc(__null)
    {
    }




    virtual ~CCCallFunc();






    static CCCallFunc * create(CCObject* pSelectorTarget, SEL_CallFunc selector);




 static CCCallFunc * create(int nHandler);






    virtual bool initWithTarget(CCObject* pSelectorTarget);



    virtual void execute();



    virtual void update(float time);




    CCObject * copyWithZone(CCZone *pZone);



    inline CCObject* getTargetCallback()
    {
        return m_pSelectorTarget;
    }



    inline void setTargetCallback(CCObject* pSel)
    {
        if (pSel != m_pSelectorTarget)
        {
            do { if(pSel) { (pSel)->retain(); } } while(0);
            do { if(m_pSelectorTarget) { (m_pSelectorTarget)->release(); } } while(0);
            m_pSelectorTarget = pSel;
        }
    }



    inline int getScriptHandler() { return m_nScriptHandler; };
protected:

    CCObject* m_pSelectorTarget;

 int m_nScriptHandler;

    union
    {
        SEL_CallFunc m_pCallFunc;
        SEL_CallFuncN m_pCallFuncN;
        SEL_CallFuncND m_pCallFuncND;
        SEL_CallFuncO m_pCallFuncO;
    };
};






class CCCallFuncN : public CCCallFunc, public TypeInfo
{
public:




    CCCallFuncN(){}




    virtual ~CCCallFuncN(){}



    virtual long getClassTypeInfo() {
  static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCCallFunc).name());
  return id;
    }






    static CCCallFuncN * create(CCObject* pSelectorTarget, SEL_CallFuncN selector);


 static CCCallFuncN * create(int nHandler);






    virtual bool initWithTarget(CCObject* pSelectorTarget, SEL_CallFuncN selector);




    virtual CCObject* copyWithZone(CCZone *pZone);



    virtual void execute();
};
# 437 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
class CCCallFuncND : public CCCallFuncN
{
public:
    virtual long getClassTypeInfo() {
        static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCCallFunc).name());
  return id;
    }


    static CCCallFuncND * create(CCObject* pSelectorTarget, SEL_CallFuncND selector, void* d);


    virtual bool initWithTarget(CCObject* pSelectorTarget, SEL_CallFuncND selector, void* d);





    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void execute();

protected:
    void *m_pData;
};
# 471 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
class CCCallFuncO : public CCCallFunc, public TypeInfo
{
public:
    CCCallFuncO();
    virtual ~CCCallFuncO();

    virtual long getClassTypeInfo() {
     static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCCallFunc).name());
  return id;
    }





    static CCCallFuncO * create(CCObject* pSelectorTarget, SEL_CallFuncO selector, CCObject* pObject);





    virtual bool initWithTarget(CCObject* pSelectorTarget, SEL_CallFuncO selector, CCObject* pObject);





    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void execute();

    inline CCObject* getObject()
    {
        return m_pObject;
    }

    inline void setObject(CCObject* pObj)
    {
        if (pObj != m_pObject)
        {
            do { if(m_pObject) { (m_pObject)->release(); } } while(0);
            m_pObject = pObj;
            do { if(m_pObject) { (m_pObject)->retain(); } } while(0);
        }
    }

protected:

    CCObject* m_pObject;
};




}
# 30 "Cacao/include/cocos2dx/actions/CCActionGrid.h" 2

namespace cocos2d {

class CCGridBase;







class CCGridAction : public CCActionInterval
{
public:




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);


    virtual bool initWithDuration(float duration, const CCSize& gridSize);


    virtual CCGridBase* getGrid(void);

public:






    static CCGridAction* create(float duration, const CCSize& gridSize);
protected:
    CCSize m_sGridSize;
};





class CCGrid3DAction : public CCGridAction
{
public:

    virtual CCGridBase* getGrid(void);

    ccVertex3F vertex(const CCPoint& position);

    ccVertex3F originalVertex(const CCPoint& position);

    void setVertex(const CCPoint& position, const ccVertex3F& vertex);

public:




    static CCGrid3DAction* create(float duration, const CCSize& gridSize);
};


class CCTiledGrid3DAction : public CCGridAction
{
public:

    ccQuad3 tile(const CCPoint& position);

    ccQuad3 originalTile(const CCPoint& position);

    void setTile(const CCPoint& position, const ccQuad3& coords);


    virtual CCGridBase* getGrid(void);

public:




    static CCTiledGrid3DAction* create(float duration, const CCSize& gridSize);
};


class CCAccelDeccelAmplitude : public CCActionInterval
{
public:




    virtual ~CCAccelDeccelAmplitude(void);

    bool initWithAction(CCAction *pAction, float duration);

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);


    inline float getRate(void) { return m_fRate; }

    inline void setRate(float fRate) { m_fRate = fRate; }

public:

    static CCAccelDeccelAmplitude* create(CCAction *pAction, float duration);

protected:
    float m_fRate;
    CCActionInterval *m_pOther;
};


class CCAccelAmplitude : public CCActionInterval
{
public:




    ~CCAccelAmplitude(void);

    bool initWithAction(CCAction *pAction, float duration);


    inline float getRate(void) { return m_fRate; }

    inline void setRate(float fRate) { m_fRate = fRate; }

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCAccelAmplitude* create(CCAction *pAction, float duration);
protected:
    float m_fRate;
    CCActionInterval *m_pOther;
};


class CCDeccelAmplitude : public CCActionInterval
{
public:




    ~CCDeccelAmplitude(void);

    bool initWithAction(CCAction *pAction, float duration);


    inline float getRate(void) { return m_fRate; }

    inline void setRate(float fRate) { m_fRate = fRate; }

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCDeccelAmplitude* create(CCAction *pAction, float duration);

protected:
    float m_fRate;
    CCActionInterval *m_pOther;
};






class CCStopGrid : public CCActionInstant
{
public:
    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCStopGrid* create(void);
};


class CCReuseGrid : public CCActionInstant
{
public:

    bool initWithTimes(int times);

    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCReuseGrid* create(int times);
protected:
    int m_nTimes;
};




}
# 29 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h" 2

namespace cocos2d {
# 40 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h"
class CCWaves3D : public CCGrid3DAction
{
public:
    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCWaves3D* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCFlipX3D : public CCGrid3DAction
{
public:

    virtual bool initWithDuration(float duration);
    virtual bool initWithSize(const CCSize& gridSize, float duration);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCFlipX3D* create(float duration);
};


class CCFlipY3D : public CCFlipX3D
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCFlipY3D* create(float duration);
};


class CCLens3D : public CCGrid3DAction
{
public:

    inline float getLensEffect(void) { return m_fLensEffect; }

    inline void setLensEffect(float fLensEffect) { m_fLensEffect = fLensEffect; }

    inline void setConcave(bool bConcave) { m_bConcave = bConcave; }

    inline const CCPoint& getPosition(void) { return m_position; }
    void setPosition(const CCPoint& position);


    bool initWithDuration(float duration, const CCSize& gridSize, const CCPoint& position, float radius);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCLens3D* create(float duration, const CCSize& gridSize, const CCPoint& position, float radius);
protected:

    CCPoint m_position;
    float m_fRadius;

    float m_fLensEffect;

    bool m_bConcave;

    bool m_bDirty;
};


class CCRipple3D : public CCGrid3DAction
{
public:

    inline const CCPoint& getPosition(void) { return m_position; }

    void setPosition(const CCPoint& position);

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, const CCPoint& position, float radius, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCRipple3D* create(float duration, const CCSize& gridSize, const CCPoint& position, float radius, unsigned int waves, float amplitude);
protected:

    CCPoint m_position;
    float m_fRadius;
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCShaky3D : public CCGrid3DAction
{
public:

    bool initWithDuration(float duration, const CCSize& gridSize, int range, bool shakeZ);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCShaky3D* create(float duration, const CCSize& gridSize, int range, bool shakeZ);
protected:
    int m_nRandrange;
    bool m_bShakeZ;
};


class CCLiquid : public CCGrid3DAction
{
public:
    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCLiquid* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCWaves : public CCGrid3DAction
{
public:
    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCWaves* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
    bool m_bVertical;
    bool m_bHorizontal;
};


class CCTwirl : public CCGrid3DAction
{
public:

    inline const CCPoint& getPosition(void) { return m_position; }

    void setPosition(const CCPoint& position);

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, CCPoint position, unsigned int twirls, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCTwirl* create(float duration, const CCSize& gridSize, CCPoint position, unsigned int twirls, float amplitude);
protected:

    CCPoint m_position;
    unsigned int m_nTwirls;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};




}
# 29 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h" 2

namespace cocos2d {
# 46 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h"
class CCPageTurn3D : public CCGrid3DAction
{
public:
    virtual void update(float time);

public:


    static CCPageTurn3D* create(float duration, const CCSize& gridSize);
};




}
# 47 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/actions/CCActionProgressTimer.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionProgressTimer.h"
namespace cocos2d {
# 41 "Cacao/include/cocos2dx/actions/CCActionProgressTimer.h"
class CCProgressTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, float fPercent);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:

    static CCProgressTo* create(float duration, float fPercent);
protected:
    float m_fTo;
    float m_fFrom;
};





class CCProgressFromTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, float fFromPercentage, float fToPercentage);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual CCActionInterval* reverse(void);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCProgressFromTo* create(float duration, float fFromPercentage, float fToPercentage);
protected:
    float m_fTo;
    float m_fFrom;
};




}
# 49 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/actions/CCActionTiledGrid.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionTiledGrid.h"
namespace cocos2d {







class CCShakyTiles3D : public CCTiledGrid3DAction
{
public:

    virtual bool initWithDuration(float duration, const CCSize& gridSize, int nRange, bool bShakeZ);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCShakyTiles3D* create(float duration, const CCSize& gridSize, int nRange, bool bShakeZ);

protected:
    int m_nRandrange;
    bool m_bShakeZ;
};


class CCShatteredTiles3D : public CCTiledGrid3DAction
{
public:

    virtual bool initWithDuration(float duration, const CCSize& gridSize, int nRange, bool bShatterZ);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCShatteredTiles3D* create(float duration, const CCSize& gridSize, int nRange, bool bShatterZ);
protected:
    int m_nRandrange;
    bool m_bOnce;
    bool m_bShatterZ;
};

struct Tile;



class CCShuffleTiles : public CCTiledGrid3DAction
{
public:




    ~CCShuffleTiles(void);

    virtual bool initWithDuration(float duration, const CCSize& gridSize, unsigned int seed);
    void shuffle(unsigned int *pArray, unsigned int nLen);
    CCSize getDelta(const CCSize& pos);
    void placeTile(const CCPoint& pos, Tile *t);

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCShuffleTiles* create(float duration, const CCSize& gridSize, unsigned int seed);
protected:
    unsigned int m_nSeed;
    unsigned int m_nTilesCount;
    unsigned int* m_pTilesOrder;
    Tile* m_pTiles;
};




class CCFadeOutTRTiles : public CCTiledGrid3DAction
{
public:
    virtual float testFunc(const CCSize& pos, float time);
    void turnOnTile(const CCPoint& pos);
    void turnOffTile(const CCPoint& pos);
    virtual void transformTile(const CCPoint& pos, float distance);
    virtual void update(float time);

public:


    static CCFadeOutTRTiles* create(float duration, const CCSize& gridSize);
};




class CCFadeOutBLTiles : public CCFadeOutTRTiles
{
public:
    virtual float testFunc(const CCSize& pos, float time);

public:


    static CCFadeOutBLTiles* create(float duration, const CCSize& gridSize);
};




class CCFadeOutUpTiles : public CCFadeOutTRTiles
{
public:
    virtual float testFunc(const CCSize& pos, float time);
    virtual void transformTile(const CCPoint& pos, float distance);

public:

    static CCFadeOutUpTiles* create(float duration, const CCSize& gridSize);

};




class CCFadeOutDownTiles : public CCFadeOutUpTiles
{
public:
    virtual float testFunc(const CCSize& pos, float time);

public:


    static CCFadeOutDownTiles* create(float duration, const CCSize& gridSize);
};




class CCTurnOffTiles : public CCTiledGrid3DAction
{
public:




    ~CCTurnOffTiles(void);

    virtual bool initWithDuration(float duration, const CCSize& gridSize, unsigned int seed);
    void shuffle(unsigned int *pArray, unsigned int nLen);
    void turnOnTile(const CCPoint& pos);
    void turnOffTile(const CCPoint& pos);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCTurnOffTiles* create(float duration, const CCSize& gridSize);

    static CCTurnOffTiles* create(float duration, const CCSize& gridSize, unsigned int seed);

protected:
    unsigned int m_nSeed;
    unsigned int m_nTilesCount;
    unsigned int* m_pTilesOrder;
};


class CCWavesTiles3D : public CCTiledGrid3DAction
{
public:

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }


    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    virtual bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCWavesTiles3D* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};




class CCJumpTiles3D : public CCTiledGrid3DAction
{
public:

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }


    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int numberOfJumps, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCJumpTiles3D* create(float duration, const CCSize& gridSize, unsigned int numberOfJumps, float amplitude);
protected:
    unsigned int m_nJumps;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCSplitRows : public CCTiledGrid3DAction
{
public :

    virtual bool initWithDuration(float duration, unsigned int nRows);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);
    virtual void startWithTarget(CCNode *pTarget);

public:


    static CCSplitRows* create(float duration, unsigned int nRows);
protected:
    unsigned int m_nRows;
    CCSize m_winSize;
};


class CCSplitCols : public CCTiledGrid3DAction
{
public:

    virtual bool initWithDuration(float duration, unsigned int nCols);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);
    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCSplitCols* create(float duration, unsigned int nCols);
protected:
    unsigned int m_nCols;
    CCSize m_winSize;
};




}
# 51 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/actions/CCActionTween.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionTween.h"
namespace cocos2d {






class CCActionTweenDelegate
{
public:




    virtual ~CCActionTweenDelegate() {}
    virtual void updateTweenAction(float value, const char* key) = 0;
};
# 66 "Cacao/include/cocos2dx/actions/CCActionTween.h"
class CCActionTween : public CCActionInterval
{
public:

    static CCActionTween* create(float aDuration, const char* key, float from, float to);

    bool initWithDuration(float aDuration, const char* key, float from, float to);

    void startWithTarget(CCNode *pTarget);
    void update(float dt);
    CCActionInterval* reverse();

    std::string m_strKey;
    float m_fFrom, m_fTo;
    float m_fDelta;
};




}
# 53 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionCatmullRom.h" 1
# 46 "Cacao/include/cocos2dx/actions/CCActionCatmullRom.h"
namespace cocos2d {;
# 58 "Cacao/include/cocos2dx/actions/CCActionCatmullRom.h"
class CCPointArray : public CCObject
{
public:




    static CCPointArray* create(unsigned int capacity);



    virtual ~CCPointArray();



    CCPointArray();


    bool initWithCapacity(unsigned int capacity);


    void addControlPoint(CCPoint controlPoint);


    void insertControlPoint(CCPoint &controlPoint, unsigned int index);


    void replaceControlPoint(CCPoint &controlPoint, unsigned int index);


    CCPoint getControlPointAtIndex(unsigned int index);


    void removeControlPointAtIndex(unsigned int index);


    unsigned int count();


    CCPointArray* reverse();


    void reverseInline();




    virtual CCObject* copyWithZone(CCZone *zone);

    const std::vector<CCPoint*>* getControlPoints();

    void setControlPoints(std::vector<CCPoint*> *controlPoints);
private:

    std::vector<CCPoint*> *m_pControlPoints;
};





class CCCardinalSplineTo : public CCActionInterval
{
public:







    static CCCardinalSplineTo* create(float duration, CCPointArray* points, float tension);




    virtual ~CCCardinalSplineTo();




    CCCardinalSplineTo();




    bool initWithDuration(float duration, CCPointArray* points, float tension);






    virtual CCCardinalSplineTo* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void update(float time);
    virtual CCActionInterval* reverse();



    virtual void updatePosition(CCPoint &newPos);

    inline CCPointArray* getPoints() { return m_pPoints; }



    inline void setPoints(CCPointArray* points)
    {
        do { if(points) { (points)->retain(); } } while(0);
        do { if(m_pPoints) { (m_pPoints)->release(); } } while(0);
        m_pPoints = points;
    }

protected:

    CCPointArray *m_pPoints;
    float m_fDeltaT;
    float m_fTension;
    CCPoint m_previousPosition;
    CCPoint m_accumulatedDiff;
};





class CCCardinalSplineBy : public CCCardinalSplineTo
{
public:







    static CCCardinalSplineBy* create(float duration, CCPointArray* points, float tension);




    CCCardinalSplineBy();



    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse();



    virtual void updatePosition(CCPoint &newPos);
protected:
    CCPoint m_startPosition;
};






class CCCatmullRomTo : public CCCardinalSplineTo
{
public:







    static CCCatmullRomTo* create(float dt, CCPointArray* points);





    bool initWithDuration(float dt, CCPointArray* points);
};






class CCCatmullRomBy : public CCCardinalSplineBy
{
public:







    static CCCatmullRomBy* create(float dt, CCPointArray* points);





    bool initWithDuration(float dt, CCPointArray* points);
};


extern CCPoint ccCardinalSplineAt(CCPoint &p0, CCPoint &p1, CCPoint &p2, CCPoint &p3, float tension, float t);




};
# 54 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/base_nodes/CCAtlasNode.h" 1
# 34 "Cacao/include/cocos2dx/base_nodes/CCAtlasNode.h"
namespace cocos2d {






class CCTextureAtlas;
# 51 "Cacao/include/cocos2dx/base_nodes/CCAtlasNode.h"
class CCAtlasNode : public CCNodeRGBA, public CCTextureProtocol
{
protected:


    unsigned int m_uItemsPerRow;

    unsigned int m_uItemsPerColumn;


    unsigned int m_uItemWidth;

    unsigned int m_uItemHeight;

    ccColor3B m_tColorUnmodified;

    protected: CCTextureAtlas* m_pTextureAtlas;public: virtual CCTextureAtlas* getTextureAtlas(void);public: virtual void setTextureAtlas(CCTextureAtlas* var);;


    bool m_bIsOpacityModifyRGB;

    protected: ccBlendFunc m_tBlendFunc;public: virtual ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(ccBlendFunc var);;


    protected: unsigned int m_uQuadsToDraw;public: virtual unsigned int getQuadsToDraw(void);public: virtual void setQuadsToDraw(unsigned int var);;

    GLint m_nUniformColor;

    bool m_bIgnoreContentScaleFactor;

public:



    CCAtlasNode();




    virtual ~CCAtlasNode();


 static CCAtlasNode * create(const char* tile,unsigned int tileWidth, unsigned int tileHeight,
  unsigned int itemsToRender);


    bool initWithTileFile(const char* tile, unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);


    bool initWithTexture(CCTexture2D* texture, unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);




    virtual void updateAtlasValues();

    virtual void draw(void);




    virtual CCTexture2D* getTexture(void);


    virtual void setTexture(CCTexture2D *texture);

    virtual bool isOpacityModifyRGB();
    virtual void setOpacityModifyRGB(bool isOpacityModifyRGB);
    virtual const ccColor3B& getColor(void);
    virtual void setColor(const ccColor3B& color);
    virtual void setOpacity(GLubyte opacity);

private :
    void calculateMaxItems();
    void updateBlendFunc();
    void updateOpacityModifyRGB();

    friend class CCDirector;
    void setIgnoreContentScaleFactor(bool bIgnoreContentScaleFactor);
};




}
# 58 "Cacao/include/cocos2dx/cocos2d.h" 2








# 1 "Cacao/include/cocos2dx/cocoa/CCAutoreleasePool.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCAutoreleasePool.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCAutoreleasePool.h"
class CCAutoreleasePool : public CCObject
{
    CCArray* m_pManagedObjectArray;
public:
    CCAutoreleasePool(void);
    ~CCAutoreleasePool(void);

    void addObject(CCObject *pObject);
    void removeObject(CCObject *pObject);

    void clear();
};





class CCPoolManager
{
    CCArray* m_pReleasePoolStack;
    CCAutoreleasePool* m_pCurReleasePool;

    CCAutoreleasePool* getCurReleasePool();
public:
    CCPoolManager();
    ~CCPoolManager();
    void finalize();
    void push();
    void pop();

    void removeObject(CCObject* pObject);
    void addObject(CCObject* pObject);

    static CCPoolManager* sharedPoolManager();
    static void purgePoolManager();

    friend class CCAutoreleasePool;
};




}
# 67 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCInteger.h" 1





namespace cocos2d {







class CCInteger : public CCObject
{
public:
    CCInteger(int v)
        : m_nValue(v) {}
    int getValue() const {return m_nValue;}

    static CCInteger* create(int v)
    {
        CCInteger* pRet = new CCInteger(v);
        pRet->autorelease();
        return pRet;
    }




    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    int m_nValue;
};




}
# 68 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCFloat.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCFloat.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCFloat.h"
class CCFloat : public CCObject
{
public:
    CCFloat(float v)
        : m_fValue(v) {}
    float getValue() const {return m_fValue;}

    static CCFloat* create(float v)
    {
        CCFloat* pRet = new CCFloat(v);
        if (pRet)
        {
            pRet->autorelease();
        }
        return pRet;
    }


    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    float m_fValue;
};




}
# 69 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCDouble.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCDouble.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCDouble.h"
class CCDouble : public CCObject
{
public:
    CCDouble(double v)
        : m_dValue(v) {}
    double getValue() const {return m_dValue;}

    static CCDouble* create(double v)
    {
        CCDouble* pRet = new CCDouble(v);
        if (pRet)
        {
            pRet->autorelease();
        }
        return pRet;
    }


    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    double m_dValue;
};




}
# 70 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCBool.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCBool.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCBool.h"
class CCBool : public CCObject
{
public:
    CCBool(bool v)
        : m_bValue(v) {}
    bool getValue() const {return m_bValue;}

    static CCBool* create(bool v)
    {
        CCBool* pRet = new CCBool(v);
        if (pRet)
        {
            pRet->autorelease();
        }
        return pRet;
    }


    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    bool m_bValue;
};




}
# 71 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/cocoa/CCNS.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCNS.h"
namespace cocos2d {
# 47 "Cacao/include/cocos2dx/cocoa/CCNS.h"
CCRect CCRectFromString(const char* pszContent);
# 59 "Cacao/include/cocos2dx/cocoa/CCNS.h"
CCPoint CCPointFromString(const char* pszContent);
# 71 "Cacao/include/cocos2dx/cocoa/CCNS.h"
CCSize CCSizeFromString(const char* pszContent);




}
# 73 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCZone.h" 1
# 31 "Cacao/include/cocos2dx/cocoa/CCZone.h"
namespace cocos2d {






class CCObject;




class CCZone
{
public:
    CCZone(CCObject *pObject = __null);

public:
    CCObject *m_pCopyObject;
};




}
# 74 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/draw_nodes/CCDrawingPrimitives.h" 1
# 69 "Cacao/include/cocos2dx/draw_nodes/CCDrawingPrimitives.h"
namespace cocos2d {






class CCPointArray;


void ccDrawInit();


void ccDrawFree();


void ccDrawPoint( const CCPoint& point );




void ccDrawPoints( const CCPoint *points, unsigned int numberOfPoints );


void ccDrawLine( const CCPoint& origin, const CCPoint& destination );


void ccDrawRect( CCPoint origin, CCPoint destination );




void ccDrawSolidRect( CCPoint origin, CCPoint destination, ccColor4F color );




void ccDrawPoly( const CCPoint *vertices, unsigned int numOfVertices, bool closePolygon );



void ccDrawSolidPoly( const CCPoint *poli, unsigned int numberOfPoints, ccColor4F color );


void ccDrawCircle( const CCPoint& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float scaleX, float scaleY);
void ccDrawCircle( const CCPoint& center, float radius, float angle, unsigned int segments, bool drawLineToCenter);





void ccDrawQuadBezier(const CCPoint& origin, const CCPoint& control, const CCPoint& destination, unsigned int segments);





void ccDrawCubicBezier(const CCPoint& origin, const CCPoint& control1, const CCPoint& control2, const CCPoint& destination, unsigned int segments);





void ccDrawCatmullRom( CCPointArray *arrayOfControlPoints, unsigned int segments );





void ccDrawCardinalSpline( CCPointArray *config, float tension, unsigned int segments );




void ccDrawColor4B( GLubyte r, GLubyte g, GLubyte b, GLubyte a );




void ccDrawColor4F( GLfloat r, GLfloat g, GLfloat b, GLfloat a );




void ccPointSize( GLfloat pointSize );




}
# 77 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/draw_nodes/CCDrawNode.h" 1
# 36 "Cacao/include/cocos2dx/draw_nodes/CCDrawNode.h"
namespace cocos2d {
# 45 "Cacao/include/cocos2dx/draw_nodes/CCDrawNode.h"
class CCDrawNode : public CCNode
{
protected:
    GLuint m_uVao;
    GLuint m_uVbo;

    unsigned int m_uBufferCapacity;
    GLsizei m_nBufferCount;
    ccV2F_C4B_T2F *m_pBuffer;

    ccBlendFunc m_sBlendFunc;

    bool m_bDirty;

public:
    static CCDrawNode* create();
    virtual ~CCDrawNode();

    virtual bool init();
    virtual void draw();


    void drawDot(const CCPoint &pos, float radius, const ccColor4F &color);


    void drawSegment(const CCPoint &from, const CCPoint &to, float radius, const ccColor4F &color);







    void drawPolygon(CCPoint *verts, unsigned int count, const ccColor4F &fillColor, float borderWidth, const ccColor4F &borderColor);


    void clear();



    ccBlendFunc getBlendFunc() const;






    void setBlendFunc(const ccBlendFunc &blendFunc);

    CCDrawNode();




    void listenBackToForeground(CCObject *obj);
private:
    void ensureCapacity(unsigned int count);
    void render();
};

}
# 78 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/effects/CCGrabber.h" 1
# 28 "Cacao/include/cocos2dx/effects/CCGrabber.h"
# 1 "Cacao/include/cocos2dx/CCConfiguration.h" 1
# 36 "Cacao/include/cocos2dx/CCConfiguration.h"
namespace cocos2d {

typedef enum _ccConfigurationType {
    ConfigurationError,
    ConfigurationString,
    ConfigurationInt,
    ConfigurationDouble,
    ConfigurationBoolean
} ccConfigurationType;
# 55 "Cacao/include/cocos2dx/CCConfiguration.h"
class CCConfiguration : public CCObject
{
public:

    static CCConfiguration *sharedConfiguration(void);


    static void purgeConfiguration(void);

public:




 virtual ~CCConfiguration(void);


 int getMaxTextureSize(void) const;


 int getMaxModelviewStackDepth(void) const;




 int getMaxTextureUnits(void) const;






 bool supportsNPOT(void) const;


 bool supportsPVRTC(void) const;




 bool supportsBGRA8888(void) const;




 bool supportsDiscardFramebuffer(void) const;




 bool supportsShareableVAO(void) const;


    bool checkForGLExtension(const std::string &searchName) const;

    bool init(void);



 const char* getCString( const char *key, const char *default_value=__null ) const;



 bool getBool( const char *key, bool default_value=false ) const;



 double getNumber( const char *key, double default_value=0.0 ) const;


 CCObject * getObject( const char *key ) const;


 void setObject( const char *key, CCObject *value );


 void dumpInfo(void) const;


 void gatherGPUInfo( void );


 void loadConfigFile( const char *filename );

private:
    CCConfiguration(void);
    static CCConfiguration *s_gSharedConfiguration;
 static std::string s_sConfigfile;

protected:
    GLint m_nMaxTextureSize;
    GLint m_nMaxModelviewStackDepth;
    bool m_bSupportsPVRTC;
    bool m_bSupportsNPOT;
    bool m_bSupportsBGRA8888;
    bool m_bSupportsDiscardFramebuffer;
    bool m_bSupportsShareableVAO;
    GLint m_nMaxSamplesAllowed;
    GLint m_nMaxTextureUnits;
    char * m_pGlExtensions;

 CCDictionary *m_pValueDict;
};




}
# 29 "Cacao/include/cocos2dx/effects/CCGrabber.h" 2



namespace cocos2d {

class CCTexture2D;
# 45 "Cacao/include/cocos2dx/effects/CCGrabber.h"
class CCGrabber : public CCObject
{
public:
    CCGrabber(void);
    ~CCGrabber(void);

    void grab(CCTexture2D *pTexture);
    void beforeRender(CCTexture2D *pTexture);
    void afterRender(CCTexture2D *pTexture);

protected:
    GLuint m_FBO;
    GLint m_oldFBO;
    GLfloat m_oldClearColor[4];
};




}
# 81 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/effects/CCGrid.h" 1
# 30 "Cacao/include/cocos2dx/effects/CCGrid.h"
# 1 "Cacao/include/cocos2dx/CCCamera.h" 1
# 35 "Cacao/include/cocos2dx/CCCamera.h"
namespace cocos2d {
# 64 "Cacao/include/cocos2dx/CCCamera.h"
class CCCamera : public CCObject
{
protected:
    float m_fEyeX;
    float m_fEyeY;
    float m_fEyeZ;

    float m_fCenterX;
    float m_fCenterY;
    float m_fCenterZ;

    float m_fUpX;
    float m_fUpY;
    float m_fUpZ;

    bool m_bDirty;
    kmMat4 m_lookupMatrix;
public:



    CCCamera(void);




    ~CCCamera(void);

    void init(void);



    const char* description(void);


    inline void setDirty(bool bValue) { m_bDirty = bValue; }

    inline bool isDirty(void) { return m_bDirty; }


    void restore(void);

    void locate(void);



    void setEyeXYZ(float fEyeX, float fEyeY, float fEyeZ);



    void setCenterXYZ(float fCenterX, float fCenterY, float fCenterZ);



    void setUpXYZ(float fUpX, float fUpY, float fUpZ);




    void getEyeXYZ(float *pEyeX, float *pEyeY, float *pEyeZ);



    void getCenterXYZ(float *pCenterX, float *pCenterY, float *pCenterZ);



    void getUpXYZ(float *pUpX, float *pUpY, float *pUpZ);
public:

    static float getZEye();

private:
    CCCamera(const CCCamera&); void operator=(const CCCamera&);
};




}
# 31 "Cacao/include/cocos2dx/effects/CCGrid.h" 2


# 1 "Cacao/include/cocos2dx/CCDirector.h" 1
# 37 "Cacao/include/cocos2dx/CCDirector.h"
# 1 "Cacao/include/cocos2dx/label_nodes/CCLabelAtlas.h" 1
# 31 "Cacao/include/cocos2dx/label_nodes/CCLabelAtlas.h"
namespace cocos2d {
# 51 "Cacao/include/cocos2dx/label_nodes/CCLabelAtlas.h"
class CCLabelAtlas : public CCAtlasNode, public CCLabelProtocol
{
public:




    CCLabelAtlas()
        :m_sString("")
    {}




    virtual ~CCLabelAtlas()
    {
        m_sString.clear();
    }


    static CCLabelAtlas * create(const char *string, const char *charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);





    static CCLabelAtlas* create(const char *string, const char *fntFile);


    bool initWithString(const char *string, const char *charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);




    bool initWithString(const char *string, const char *fntFile);


    bool initWithString(const char* string, CCTexture2D* texture, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);


    virtual void updateAtlasValues();
    virtual void setString(const char *label);
    virtual const char* getString(void);





protected:

    std::string m_sString;

    unsigned int m_uMapStartChar;
};






}
# 38 "Cacao/include/cocos2dx/CCDirector.h" 2



namespace cocos2d {
# 51 "Cacao/include/cocos2dx/CCDirector.h"
    typedef enum {

    kCCDirectorProjection2D,


    kCCDirectorProjection3D,


    kCCDirectorProjectionCustom,


    kCCDirectorProjectionDefault = kCCDirectorProjection3D,
} ccDirectorProjection;

    typedef enum {
        LOW=1,
        MEDIUM,
        HIGH
    }TextureQuality;

    typedef enum{
        FadeTransition,
        MoveInTransition
    }PopTransition;





class CCLabelAtlas;
class CCScene;
class CCEGLView;
class CCDirectorDelegate;
class CCNode;
class CCScheduler;
class CCActionManager;
class CCTouchDispatcher;
class CCKeypadDispatcher;
class CCKeyboardDispatcher;
class CCMouseDispatcher;
class CCSceneDelegate;
class CCAccelerometer;
# 115 "Cacao/include/cocos2dx/CCDirector.h"
class CCDirector : public CCObject, public TypeInfo
{
public:



    CCDirector(void);




    virtual ~CCDirector(void);
    virtual bool init(void);




    virtual long getClassTypeInfo() {
        static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCDirector).name());
        return id;
    }




    inline CCScene* getRunningScene(void) { return m_pRunningScene; }


    inline double getAnimationInterval(void) { return m_dAnimationInterval; }

    virtual void setAnimationInterval(double dValue) = 0;


    inline bool isDisplayStats(void) { return m_bDisplayStats; }

    inline void setDisplayStats(bool bDisplayStats) { m_bDisplayStats = bDisplayStats; }


    inline float getSecondsPerFrame() { return m_fSecondsPerFrame; }




    inline CCEGLView* getOpenGLView(void) { return m_pobOpenGLView; }
    void setOpenGLView(CCEGLView* pobOpenGLView);

    inline bool isNextDeltaTimeZero(void) { return m_bNextDeltaTimeZero; }
    void setNextDeltaTimeZero(bool bNextDeltaTimeZero);


    inline bool isPaused(void) { return m_bPaused; }


    inline unsigned int getTotalFrames(void) { return m_uTotalFrames; }





    inline ccDirectorProjection getProjection(void) { return m_eProjection; }
    void setProjection(ccDirectorProjection kProjection);

    void reshapeProjection(const CCSize& newWindowSize);


    void setViewport();
# 190 "Cacao/include/cocos2dx/CCDirector.h"
    inline bool isSendCleanupToScene(void) { return m_bSendCleanupToScene; }






    CCNode* getNotificationNode();
    void setNotificationNode(CCNode* node);




    CCDirectorDelegate* getDelegate() const;
    void setDelegate(CCDirectorDelegate* pDelegate);





    CCSize getWinSize(void);



    CCSize getWinSizeInPixels(void);





    CCSize getVisibleSize();



    CCPoint getVisibleOrigin();




    CCPoint convertToGL(const CCPoint& obPoint);




    CCPoint convertToUI(const CCPoint& obPoint);


    float getZEye(void);
# 247 "Cacao/include/cocos2dx/CCDirector.h"
    void runWithScene(CCScene* pScene);
# 256 "Cacao/include/cocos2dx/CCDirector.h"
    bool pushScene(CCScene* pScene);






    void popScene(void);





    void popToRootScene(void);






    void popToSceneStackLevel(int level);





    bool replaceScene(CCScene* pScene);




    void end(void);





    void pause(void);





    void resume(void);




    virtual void stopAnimation(void) = 0;





    virtual void startAnimation(void) = 0;




    void drawScene(void);







    void purgeCachedData(void);


    void setDefaultValues(void);




    void setGLDefaultValues(void);


    void setAlphaBlending(bool bOn);


    void setDepthTest(bool bOn);

    virtual void mainLoop(void) = 0;






    void setContentScaleFactor(float scaleFactor);
    float getContentScaleFactor(void);
private:
    float m_fScreenScaleFactor;
    float m_fScreenScaleFactorMax;
    float m_fScreenScaleFactorW;
    float m_fScreenScaleFactorH;
    float m_fScreenTop;
    float m_fScreenBottom;
    float m_fScreenLeft;
    float m_fScreenRight;
    uint32_t m_uSceneReference;

public:



    protected: CCScheduler* m_pScheduler;public: virtual CCScheduler* getScheduler(void);public: virtual void setScheduler(CCScheduler* var);;




    protected: CCActionManager* m_pActionManager;public: virtual CCActionManager* getActionManager(void);public: virtual void setActionManager(CCActionManager* var);;




    protected: CCTouchDispatcher* m_pTouchDispatcher;public: virtual CCTouchDispatcher* getTouchDispatcher(void);public: virtual void setTouchDispatcher(CCTouchDispatcher* var);;




    protected: CCKeypadDispatcher* m_pKeypadDispatcher;public: virtual CCKeypadDispatcher* getKeypadDispatcher(void);public: virtual void setKeypadDispatcher(CCKeypadDispatcher* var);;


    protected: CCKeyboardDispatcher* m_pKeyboardDispatcher;public: virtual CCKeyboardDispatcher* getKeyboardDispatcher(void);public: virtual void setKeyboardDispatcher(CCKeyboardDispatcher* var);;


    protected: CCMouseDispatcher* m_pMouseDispatcher;public: virtual CCMouseDispatcher* getMouseDispatcher(void);public: virtual void setMouseDispatcher(CCMouseDispatcher* var);;







    protected: CCAccelerometer* m_pAccelerometer;public: virtual CCAccelerometer* getAccelerometer(void);public: virtual void setAccelerometer(CCAccelerometer* var);;
protected:
    float m_fDeltaTime;
public:

    virtual float getDeltaTime(void);
    void setDeltaTime(float);



    protected: float m_fActualDeltaTime;public: float getActualDeltaTime(void);public: void setActualDeltaTime(float var);;

    protected: bool m_bIsTransitioning;public: virtual bool getIsTransitioning(void) const { return m_bIsTransitioning; }


public:



    static CCDirector* sharedDirector(void);

protected:

    void purgeDirector();
    bool m_bPurgeDirecotorInNextLoop;

    void setNextScene(void);

    void showStats();
    void createStatsLabel();
    void calculateMPF();
    void getFPSImageData(unsigned char** datapointer, unsigned int* length);


    void calculateDeltaTime();
protected:
    uint32_t m_uPadding00[2];

    CCEGLView* m_pobOpenGLView;

    uint32_t m_uPadding01;

    double m_dAnimationInterval;
    double m_dOldAnimationInterval;


    bool m_bLandscape;


    bool m_bDisplayStats;
    float m_fAccumDt;
    float m_fFrameRate;

    CCLabelAtlas* m_pFPSLabel;
    CCLabelAtlas* m_pSPFLabel;
    CCLabelAtlas* m_pDrawsLabel;


    bool m_bPaused;


    unsigned int m_uTotalFrames;
    unsigned int m_uFrames;
    float m_fSecondsPerFrame;


    CCScene* m_pRunningScene;



    CCScene* m_pNextScene;


    bool m_bSendCleanupToScene;


    CCArray* m_pobScenesStack;


    struct cc_timeval* m_pLastUpdate;


    bool m_bNextDeltaTimeZero;


    ccDirectorProjection m_eProjection;


    CCSize m_obWinSizeInPoints;


    float m_fContentScaleFactor;


    char* m_pszFPS;


    CCNode* m_pNotificationNode;


    CCDirectorDelegate* m_pProjectionDelegate;



    protected: CCSceneDelegate* m_pSceneDelegate;public: virtual CCSceneDelegate* getSceneDelegate(void) const;public: virtual void setSceneDelegate(CCSceneDelegate* var);;
protected:
    CCSize m_sUnknown04;
    CCSize m_sUnknown05;

    TextureQuality m_eTextureQuality;
    bool m_bWillSwitchToScene;



    friend class CCEGLViewProtocol;
public:

    bool getDontCallWillSwitch(void) const;



    TextureQuality getLoadedTextureQuality(void) const;

    CCScene* getNextScene(void);

    CCScene* getSceneReference(void) const;
    float getScreenBottom(void);
    float getScreenLeft(void);
    float getScreenRight(void);
    float getScreenScaleFactor(void);
    float getScreenScaleFactorH(void);
    float getScreenScaleFactorMax(void);
    float getScreenScaleFactorW(void);
    float getScreenTop(void);
    bool getSmoothFix(void) const;
    bool getSmoothFixCheck(void) const;
    int getSmoothFixCounter(void) const;
    int levelForSceneInStack(CCScene*);
    void popSceneWithTransition(float, PopTransition);
    int sceneCount(void);


    void setForceSmoothFix(bool);



    void setSceneReference(CCScene*);
    void setSmoothFix(bool);
    void setSmoothFixCheck(bool);
    void setupScreenScale(CCSize, CCSize, TextureQuality);
    void updateContentScale(TextureQuality);
    void updateScreenScale(CCSize);
    void willSwitchToScene(CCScene*);
};
# 558 "Cacao/include/cocos2dx/CCDirector.h"
class CCDisplayLinkDirector : public CCDirector
{
public:
    CCDisplayLinkDirector(void)
        : m_bInvalid(false)
    {}

    virtual void mainLoop(void);
    virtual void setAnimationInterval(double dValue);
    virtual void startAnimation(void);
    virtual void stopAnimation();

protected:
    bool m_bInvalid;
};




}
# 34 "Cacao/include/cocos2dx/effects/CCGrid.h" 2





namespace cocos2d {

class CCTexture2D;
class CCGrabber;
class CCGLProgram;
# 52 "Cacao/include/cocos2dx/effects/CCGrid.h"
class CCGridBase : public CCObject
{
public:




    virtual ~CCGridBase(void);




    inline bool isActive(void) { return m_bActive; }



    void setActive(bool bActive);




    inline int getReuseGrid(void) { return m_nReuseGrid; }



    inline void setReuseGrid(int nReuseGrid) { m_nReuseGrid = nReuseGrid; }




    inline const CCSize& getGridSize(void) { return m_sGridSize; }



    inline void setGridSize(const CCSize& gridSize) { m_sGridSize = gridSize; }




    inline const CCPoint& getStep(void) { return m_obStep; }



    inline void setStep(const CCPoint& step) { m_obStep = step; }




    inline bool isTextureFlipped(void) { return m_bIsTextureFlipped; }



    void setTextureFlipped(bool bFlipped);



    bool initWithSize(const CCSize& gridSize, CCTexture2D *pTexture, bool bFlipped);



    bool initWithSize(const CCSize& gridSize);



    void beforeDraw(void);



    void afterDraw(CCNode *pTarget);



    virtual void blit(void);



    virtual void reuse(void);



    virtual void calculateVertexPoints(void);

public:




    static CCGridBase* create(const CCSize& gridSize, CCTexture2D *texture, bool flipped);



    static CCGridBase* create(const CCSize& gridSize);



    void set2DProjection(void);

protected:
    bool m_bActive;
    int m_nReuseGrid;
    CCSize m_sGridSize;
    CCTexture2D *m_pTexture;
    CCPoint m_obStep;
    CCGrabber *m_pGrabber;
    bool m_bIsTextureFlipped;
    CCGLProgram* m_pShaderProgram;
    ccDirectorProjection m_directorProjection;
};






class CCGrid3D : public CCGridBase



{
public:
    CCGrid3D();
    ~CCGrid3D(void);


    ccVertex3F vertex(const CCPoint& pos);

    ccVertex3F originalVertex(const CCPoint& pos);

    void setVertex(const CCPoint& pos, const ccVertex3F& vertex);

    virtual void blit(void);
    virtual void reuse(void);
    virtual void calculateVertexPoints(void);

public:

    static CCGrid3D* create(const CCSize& gridSize, CCTexture2D *pTexture, bool bFlipped);

    static CCGrid3D* create(const CCSize& gridSize);

protected:
    GLvoid *m_pTexCoordinates;
    GLvoid *m_pVertices;
    GLvoid *m_pOriginalVertices;
    GLushort *m_pIndices;
};







class CCTiledGrid3D : public CCGridBase



{
public:
    CCTiledGrid3D();
    ~CCTiledGrid3D(void);


    ccQuad3 tile(const CCPoint& pos);

    ccQuad3 originalTile(const CCPoint& pos);

    void setTile(const CCPoint& pos, const ccQuad3& coords);

    virtual void blit(void);
    virtual void reuse(void);
    virtual void calculateVertexPoints(void);

public:


    static CCTiledGrid3D* create(const CCSize& gridSize, CCTexture2D *pTexture, bool bFlipped);

    static CCTiledGrid3D* create(const CCSize& gridSize);

protected:
    GLvoid *m_pTexCoordinates;
    GLvoid *m_pVertices;
    GLvoid *m_pOriginalVertices;
    GLushort *m_pIndices;
};




}
# 82 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/include/CCEventType.h" 1
# 85 "Cacao/include/cocos2dx/cocos2d.h" 2







# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/GL/matrix.h" 1
# 35 "Cacao/include/cocos2dx/kazmath/include/kazmath/GL/matrix.h"
typedef unsigned int kmGLEnum;





extern "C" {


void kmGLFreeAll(void);
void kmGLPushMatrix(void);
void kmGLPopMatrix(void);
void kmGLMatrixMode(kmGLEnum mode);
void kmGLLoadIdentity(void);
void kmGLLoadMatrix(const kmMat4* pIn);
void kmGLMultMatrix(const kmMat4* pIn);
void kmGLTranslatef(float x, float y, float z);
void kmGLRotatef(float angle, float x, float y, float z);
void kmGLScalef(float x, float y, float z);
void kmGLGetMatrix(kmGLEnum mode, kmMat4* pOut);


}
# 93 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h" 1
# 31 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h"
namespace cocos2d {
# 40 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h"
class CCKeypadDelegate
{
public:

    virtual void keyBackClicked() {}


    virtual void keyMenuClicked() {};
};
# 57 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h"
class CCKeypadHandler : public CCObject
{
public:
    virtual ~CCKeypadHandler(void);


    CCKeypadDelegate* getDelegate();
    void setDelegate(CCKeypadDelegate *pDelegate);


    virtual bool initWithDelegate(CCKeypadDelegate *pDelegate);

public:

    static CCKeypadHandler* handlerWithDelegate(CCKeypadDelegate *pDelegate);

protected:
    CCKeypadDelegate* m_pDelegate;
};




}
# 96 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDispatcher.h" 1
# 31 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDispatcher.h"
namespace cocos2d {






typedef enum {

    kTypeBackClicked = 1,
    kTypeMenuClicked,
} ccKeypadMSGType;

struct _ccCArray;






class CCKeypadDispatcher : public CCObject
{
public:
    CCKeypadDispatcher();
    ~CCKeypadDispatcher();




    void addDelegate(CCKeypadDelegate* pDelegate);




    void removeDelegate(CCKeypadDelegate* pDelegate);




    void forceAddDelegate(CCKeypadDelegate* pDelegate);




    void forceRemoveDelegate(CCKeypadDelegate* pDelegate);




    bool dispatchKeypadMSG(ccKeypadMSGType nMsgType);

protected:

    CCArray* m_pDelegates;
    bool m_bLocked;
    bool m_bToAdd;
    bool m_bToRemove;

    struct _ccCArray *m_pHandlersToAdd;
    struct _ccCArray *m_pHandlersToRemove;
};




}
# 97 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h" 1
# 28 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h"
# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h" 1
# 32 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
# 1 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h" 1
# 35 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h"
namespace cocos2d {

class CCTexture2D;
# 56 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h"
class CCTextureAtlas : public CCObject
{
protected:
    GLushort* m_pIndices;

    GLuint m_uVAOname;

    GLuint m_pBuffersVBO[2];
    bool m_bDirty;



    protected: unsigned int m_uTotalQuads;public: virtual unsigned int getTotalQuads(void);

    protected: unsigned int m_uCapacity;public: virtual unsigned int getCapacity(void);

    protected: CCTexture2D * m_pTexture;public: virtual CCTexture2D * getTexture(void);public: virtual void setTexture(CCTexture2D * var);

    protected: ccV3F_C4B_T2F_Quad * m_pQuads;public: virtual ccV3F_C4B_T2F_Quad * getQuads(void);public: virtual void setQuads(ccV3F_C4B_T2F_Quad * var);

public:



    CCTextureAtlas();




    virtual ~CCTextureAtlas();




    const char* description();




    static CCTextureAtlas* create(const char* file , unsigned int capacity);






    bool initWithFile(const char* file, unsigned int capacity);





    static CCTextureAtlas* createWithTexture(CCTexture2D *texture, unsigned int capacity);
# 117 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h"
    bool initWithTexture(CCTexture2D *texture, unsigned int capacity);





    void updateQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);





    void insertQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);






    void insertQuads(ccV3F_C4B_T2F_Quad* quads, unsigned int index, unsigned int amount);





    void insertQuadFromIndex(unsigned int fromIndex, unsigned int newIndex);





    void removeQuadAtIndex(unsigned int index);




    void removeQuadsAtIndex(unsigned int index, unsigned int amount);





    void removeAllQuads();







    bool resizeCapacity(unsigned int n);






    void increaseTotalQuadsWith(unsigned int amount);




    void moveQuadsFromIndex(unsigned int oldIndex, unsigned int amount, unsigned int newIndex);







    void moveQuadsFromIndex(unsigned int index, unsigned int newIndex);






    void fillWithEmptyQuadsFromIndex(unsigned int index, unsigned int amount);




    void drawNumberOfQuads(unsigned int n);






    void drawNumberOfQuads(unsigned int n, unsigned int start);



    void drawQuads();


    void listenBackToForeground(CCObject *obj);


    inline bool isDirty(void) { return m_bDirty; }

    inline void setDirty(bool bDirty) { m_bDirty = bDirty; }

private:
    void setupIndices();
    void mapBuffers();

    void setupVBOandVAO();



};




}
# 33 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h" 2







namespace cocos2d {

class CCSpriteBatchNode;
class CCSpriteFrame;
class CCAnimation;
class CCRect;
class CCPoint;
class CCSize;
class CCTexture2D;
struct transformValues_;
# 82 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
class CCSprite : public CCNodeRGBA, public CCTextureProtocol



{
public:
# 96 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* create();
# 107 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* create(const char *pszFileName);
# 116 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* create(const char *pszFileName, const CCRect& rect);
# 125 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* createWithTexture(CCTexture2D *pTexture);
# 137 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* createWithTexture(CCTexture2D *pTexture, const CCRect& rect);







    static CCSprite* createWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
# 156 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* createWithSpriteFrameName(const char *pszSpriteFrameName);
# 169 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    CCSprite(void);






    virtual ~CCSprite(void);




    virtual bool init(void);
# 192 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithTexture(CCTexture2D *pTexture);
# 204 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithTexture(CCTexture2D *pTexture, const CCRect& rect);
# 217 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithTexture(CCTexture2D *pTexture, const CCRect& rect, bool rotated);







    virtual bool initWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
# 236 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithSpriteFrameName(const char *pszSpriteFrameName);
# 249 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithFile(const char *pszFilename);
# 263 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithFile(const char *pszFilename, const CCRect& rect);





    virtual void setTexture(CCTexture2D *texture);
    virtual CCTexture2D* getTexture(void);
    inline void setBlendFunc(ccBlendFunc blendFunc) { m_sBlendFunc = blendFunc; }



    inline ccBlendFunc getBlendFunc(void) { return m_sBlendFunc; }



    virtual void setChildColor(const _ccColor3B&);
    virtual void setChildOpacity(unsigned char);



    virtual void setScaleX(float fScaleX);
    virtual void setScaleY(float fScaleY);



    virtual void setPosition(const CCPoint& pos);
    virtual void setRotation(float fRotation);
    virtual void setRotationX(float fRotationX);
    virtual void setRotationY(float fRotationY);
    virtual void setSkewX(float sx);
    virtual void setSkewY(float sy);
    virtual void removeChild(CCNode* pChild, bool bCleanup);
    virtual void removeAllChildrenWithCleanup(bool bCleanup);
    virtual void reorderChild(CCNode *pChild, int zOrder);
    virtual void addChild(CCNode *pChild);
    virtual void addChild(CCNode *pChild, int zOrder);
    virtual void addChild(CCNode *pChild, int zOrder, int tag);
    virtual void sortAllChildren();
    virtual void setScale(float fScale);
    virtual void setVertexZ(float fVertexZ);
    virtual void setAnchorPoint(const CCPoint& anchor);
    virtual void ignoreAnchorPointForPosition(bool value);
    virtual void setVisible(bool bVisible);
    virtual void draw(void);




    virtual void setColor(const ccColor3B& color3);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual void setOpacity(GLubyte opacity);
    virtual void setOpacityModifyRGB(bool modify);
    virtual bool isOpacityModifyRGB(void);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
# 327 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void updateTransform(void);







    virtual CCSpriteBatchNode* getBatchNode(void);
# 346 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setBatchNode(CCSpriteBatchNode *pobSpriteBatchNode);




    virtual void refreshTextureRect(void);
# 360 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setTextureRect(const CCRect& rect);





    virtual void setTextureRect(const CCRect& rect, bool rotated, const CCSize& untrimmedSize);







    virtual void setVertexRect(const CCRect& rect);
# 386 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setDisplayFrame(CCSpriteFrame *pNewFrame);




    virtual bool isFrameDisplayed(CCSpriteFrame *pFrame);





    virtual CCSpriteFrame* displayFrame(void);
# 408 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setDisplayFrameWithAnimationName(const char *animationName, int frameIndex);
# 420 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    inline virtual bool isDirty(void) { return m_bDirty; }




    inline virtual void setDirty(bool bDirty) { m_bDirty = bDirty; }





    inline ccV3F_C4B_T2F_Quad getQuad(void) { return m_sQuad; }




    inline bool isTextureRectRotated(void) { return m_bRectRotated; }




    inline unsigned int getAtlasIndex(void) { return m_uAtlasIndex; }





    inline void setAtlasIndex(unsigned int uAtlasIndex) { m_uAtlasIndex = uAtlasIndex; }




    inline const CCRect& getTextureRect(void) { return m_obRect; }




    inline CCTextureAtlas* getTextureAtlas(void) { return m_pobTextureAtlas; }




    inline void setTextureAtlas(CCTextureAtlas *pobTextureAtlas) { m_pobTextureAtlas = pobTextureAtlas; }




    inline const CCPoint& getOffsetPosition(void) { return m_obOffsetPosition; }
# 481 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    bool isFlipX(void);





    void setFlipX(bool bFlipX);
# 500 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    bool isFlipY(void);





    void setFlipY(bool bFlipY);




    float getBlVertexMod(void)const;
    float getBrVertexMod(void)const;
    bool getDontDraw(void)const;
    float getTlVertexMod(void)const;
    float getTrVertexMod(void)const;
    CCPoint const& getUnflippedOffsetPosition(void);
    void setBlVertexMod(float);
    void setBrVertexMod(float);
    void setDontDraw(bool);
    void setTlVertexMod(float);
    void setTrVertexMod(float);



protected:
    void updateColor(void);

    virtual void setTextureCoords(const CCRect& rect);
    virtual void updateBlendFunc(void);
    virtual void setReorderChildDirtyRecursively(void);
    virtual void setDirtyRecursively(bool bValue);




    CCTextureAtlas* m_pobTextureAtlas;
    unsigned int m_uAtlasIndex;
    CCSpriteBatchNode* m_pobBatchNode;

    bool m_bDirty;
    bool m_bRecursiveDirty;
    bool m_bHasChildren;
    bool m_bShouldBeHidden;
    CCAffineTransform m_transformToBatch;




    ccBlendFunc m_sBlendFunc;
    CCTexture2D* m_pobTexture;






    CCRect m_obRect;
    bool m_bRectRotated;


    CCPoint m_obOffsetPosition;
    CCPoint m_obUnflippedOffsetPositionFromCenter;


    ccV3F_C4B_T2F_Quad m_sQuad;


    bool m_bOpacityModifyRGB;


    bool m_bFlipX;
    bool m_bFlipY;


    bool m_bUnknown;
    uint32_t m_uUnknown0;
    uint32_t m_uUnknown1;
    uint32_t m_uUnknown2;
    uint32_t m_uUnknown3;
    uint32_t m_uUnknown4;
    uint32_t m_uUnknown5;
    uint32_t m_uUnknown6;
    uint32_t m_uUnknown8;
    uint8_t m_uUnknown9;
    uint32_t m_uUnknownA;

};





}
# 29 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h" 2


namespace cocos2d {
# 57 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h"
class CCLabelTTF : public CCSprite, public CCLabelProtocol
{
public:



    CCLabelTTF();




    virtual ~CCLabelTTF();




    const char* description();




    static CCLabelTTF * create(const char *string, const char *fontName, float fontSize);




    static CCLabelTTF * create(const char *string, const char *fontName, float fontSize,
                               const CCSize& dimensions, CCTextAlignment hAlignment);




    static CCLabelTTF * create(const char *string, const char *fontName, float fontSize,
                               const CCSize& dimensions, CCTextAlignment hAlignment,
                               CCVerticalTextAlignment vAlignment);



    static CCLabelTTF * createWithFontDefinition(const char *string, ccFontDefinition &textDefinition);


    bool initWithString(const char *string, const char *fontName, float fontSize);


    bool initWithString(const char *string, const char *fontName, float fontSize,
                        const CCSize& dimensions, CCTextAlignment hAlignment);


    bool initWithString(const char *string, const char *fontName, float fontSize,
                        const CCSize& dimensions, CCTextAlignment hAlignment,
                        CCVerticalTextAlignment vAlignment);


    bool initWithStringAndTextDefinition(const char *string, ccFontDefinition &textDefinition);


    void setTextDefinition(ccFontDefinition *theDefinition);


    ccFontDefinition * getTextDefinition();




    void enableShadow(const CCSize &shadowOffset, float shadowOpacity, float shadowBlur, bool mustUpdateTexture = true);


    void disableShadow(bool mustUpdateTexture = true);


    void enableStroke(const ccColor3B &strokeColor, float strokeSize, bool mustUpdateTexture = true);


    void disableStroke(bool mustUpdateTexture = true);


    void setFontFillColor(const ccColor3B &tintColor, bool mustUpdateTexture = true);




    bool init();



    static CCLabelTTF * create();




    virtual void setString(const char *label);
    virtual const char* getString(void);

    CCTextAlignment getHorizontalAlignment();
    void setHorizontalAlignment(CCTextAlignment alignment);

    CCVerticalTextAlignment getVerticalAlignment();
    void setVerticalAlignment(CCVerticalTextAlignment verticalAlignment);

    CCSize getDimensions();
    void setDimensions(const CCSize &dim);

    float getFontSize();
    void setFontSize(float fontSize);

    const char* getFontName();
    void setFontName(const char *fontName);

private:
    bool updateTexture();
protected:


    void _updateWithTextDefinition(ccFontDefinition & textDefinition, bool mustUpdateTexture = true);
    ccFontDefinition _prepareTextDefinition(bool adjustForResolution = false);


    CCSize m_tDimensions;

    CCTextAlignment m_hAlignment;

    CCVerticalTextAlignment m_vAlignment;

    std::string * m_pFontName;

    float m_fFontSize;

    std::string m_string;


    bool m_shadowEnabled;
    CCSize m_shadowOffset;
    float m_shadowOpacity;
    float m_shadowBlur;



    bool m_strokeEnabled;
    ccColor3B m_strokeColor;
    float m_strokeSize;


    ccColor3B m_textFillColor;


};






}
# 101 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h" 1
# 36 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h"
# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h" 1
# 37 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h"
namespace cocos2d {
# 46 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h"
class CCSprite;
# 63 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h"
class CCSpriteBatchNode : public CCNode, public CCTextureProtocol
{
public:



    CCSpriteBatchNode();




    ~CCSpriteBatchNode();




    inline CCTextureAtlas* getTextureAtlas(void) { return m_pobTextureAtlas; }
    inline void setTextureAtlas(CCTextureAtlas* textureAtlas)
    {
        if (textureAtlas != m_pobTextureAtlas)
        {
            do { if(textureAtlas) { (textureAtlas)->retain(); } } while(0);
            do { if(m_pobTextureAtlas) { (m_pobTextureAtlas)->release(); } } while(0);
            m_pobTextureAtlas = textureAtlas;
        }
    }

    inline CCArray* getDescendants(void) { return m_pobDescendants; }




    static CCSpriteBatchNode* createWithTexture(CCTexture2D* tex, unsigned int capacity);
    static CCSpriteBatchNode* createWithTexture(CCTexture2D* tex) {
        return CCSpriteBatchNode::createWithTexture(tex, 29);
    }





    static CCSpriteBatchNode* create(const char* fileImage, unsigned int capacity);
    static CCSpriteBatchNode* create(const char* fileImage) {
        return CCSpriteBatchNode::create(fileImage, 29);
    }




    bool initWithTexture(CCTexture2D *tex, unsigned int capacity);




    bool initWithFile(const char* fileImage, unsigned int capacity);
    bool init();

    void increaseAtlasCapacity();




    void removeChildAtIndex(unsigned int index, bool doCleanup);

    void insertChild(CCSprite *child, unsigned int index);
    void appendChild(CCSprite* sprite);
    void removeSpriteFromAtlas(CCSprite *sprite);

    unsigned int rebuildIndexInOrder(CCSprite *parent, unsigned int index);
    unsigned int highestAtlasIndexInChild(CCSprite *sprite);
    unsigned int lowestAtlasIndexInChild(CCSprite *sprite);
    unsigned int atlasIndexForChild(CCSprite *sprite, int z);

    void reorderBatch(bool reorder);

    virtual CCTexture2D* getTexture(void);
    virtual void setTexture(CCTexture2D *texture);
    virtual void setBlendFunc(ccBlendFunc blendFunc);



    virtual ccBlendFunc getBlendFunc(void);

    virtual void visit(void);
    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child, int zOrder, int tag);
    virtual void reorderChild(CCNode * child, int zOrder);

    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void removeAllChildrenWithCleanup(bool cleanup);
    virtual void sortAllChildren();
    virtual void draw(void);

protected:




    void insertQuadFromSprite(CCSprite *sprite, unsigned int index);




    void updateQuadFromSprite(CCSprite *sprite, unsigned int index);



    CCSpriteBatchNode * addSpriteWithoutQuad(CCSprite*child, unsigned int z, int aTag);


    bool getManualSortChildren(void)const;
    int getAtlasCapacity(void);
    int getUsedAtlasCapacity(void);
    void increaseAtlasCapacity(unsigned int);
    void manualSortAllChildren(void);
    void setManualSortChildren(bool);

private:
    void updateAtlasIndex(CCSprite* sprite, int* curIndex);
    void swap(int oldIndex, int newIndex);
    void updateBlendFunc();

protected:
    CCTextureAtlas *m_pobTextureAtlas;
    ccBlendFunc m_blendFunc;


    CCArray* m_pobDescendants;

    bool m_bManualSortChildren;
    bool m_bManualSortAllChildren;
};




}
# 37 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h" 2


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3




namespace std {
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:





      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 132 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 156 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 208 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   if (__testin)
     this->setg(this->eback(), this->gptr(), this->pptr());
   else
     this->setg(this->pptr(), this->pptr(), this->pptr());
      }
    };
# 265 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 303 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 323 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 345 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 378 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 416 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 436 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 458 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 491 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 527 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 545 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 567 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 1 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 2 3

namespace std {

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;



}
# 594 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 2 3
# 40 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h" 2



namespace cocos2d {
# 52 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h"
enum {
    kCCLabelAutomaticWidth = -1,
};

struct _FontDefHashElement;





typedef struct _BMFontDef {

    unsigned int charID;

    CCRect rect;

    short xOffset;

    short yOffset;

    short xAdvance;
} ccBMFontDef;





typedef struct _BMFontPadding {

    int left;

    int top;

    int right;

    int bottom;
} ccBMFontPadding;

typedef struct _FontDefHashElement
{
 unsigned int key;
 ccBMFontDef fontDef;
 UT_hash_handle hh;
} tCCFontDefHashElement;


typedef struct _KerningHashElement
{
 int key;
 int amount;
 UT_hash_handle hh;
} tCCKerningHashElement;






class CCBMFontConfiguration : public CCObject
{

public:

    tCCFontDefHashElement *m_pFontDefDictionary;


    int m_nCommonHeight;

    ccBMFontPadding m_tPadding;

    std::string m_sAtlasName;

    tCCKerningHashElement *m_pKerningDictionary;


    std::set<unsigned int> *m_pCharacterSet;
public:
    CCBMFontConfiguration();




    virtual ~CCBMFontConfiguration();




    const char * description();


    static CCBMFontConfiguration * create(const char *FNTfile);


    bool initWithFNTfile(const char *FNTfile);

    inline const char* getAtlasName(){ return m_sAtlasName.c_str(); }
    inline void setAtlasName(const char* atlasName) { m_sAtlasName = atlasName; }

    std::set<unsigned int>* getCharacterSet() const;
private:
    std::set<unsigned int>* parseConfigFile(const char *controlFile);
    void parseCharacterDefinition(std::string line, ccBMFontDef *characterDefinition);
    void parseInfoArguments(std::string line);
    void parseCommonArguments(std::string line);
    void parseImageFileName(std::string line, const char *fntFile);
    void parseKerningEntry(std::string line);
    void purgeKerningDictionary();
    void purgeFontDefDictionary();
};
# 192 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h"
class CCLabelBMFont : public CCSpriteBatchNode, public CCLabelProtocol, public CCRGBAProtocol
{
public:



    CCLabelBMFont();




    virtual ~CCLabelBMFont();




    static void purgeCachedData();


    static CCLabelBMFont * create(const char *str, const char *fntFile, float width, CCTextAlignment alignment, CCPoint imageOffset);

 static CCLabelBMFont * create(const char *str, const char *fntFile, float width, CCTextAlignment alignment);

 static CCLabelBMFont * create(const char *str, const char *fntFile, float width);

 static CCLabelBMFont * create(const char *str, const char *fntFile);



    static CCLabelBMFont * create();

    bool init();

    bool initWithString(const char *str, const char *fntFile, float width = kCCLabelAutomaticWidth, CCTextAlignment alignment = kCCTextAlignmentLeft, CCPoint imageOffset = CCPointZero);


    void createFontChars();

    virtual void setString(const char *newString);
    virtual void setString(const char *newString, bool needUpdateLabel);

    virtual const char* getString(void);
    virtual void setCString(const char *label);
    virtual void setAnchorPoint(const CCPoint& var);
    virtual void updateLabel();
    virtual void setAlignment(CCTextAlignment alignment);
    virtual void setWidth(float width);
    virtual void setLineBreakWithoutSpace(bool breakWithoutSpace);
    virtual void setScale(float scale);
    virtual void setScaleX(float scaleX);
    virtual void setScaleY(float scaleY);


    virtual bool isOpacityModifyRGB();
    virtual void setOpacityModifyRGB(bool isOpacityModifyRGB); virtual GLubyte getOpacity();
    virtual GLubyte getDisplayedOpacity();
    virtual void setOpacity(GLubyte opacity);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual bool isCascadeOpacityEnabled();
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
    virtual const ccColor3B& getColor(void);
    virtual const ccColor3B& getDisplayedColor();
    virtual void setColor(const ccColor3B& color);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual bool isCascadeColorEnabled();
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled);

    void setFntFile(const char* fntFile);
    const char* getFntFile();
 CCBMFontConfiguration* getConfiguration() const;


    static bool createBatched(char const*, char const*, CCArray*);
    bool getIsBatched(void)const;
    CCArray* getTargetArray(void)const;
    void limitLabelWidth(float, float, float);
    void setIsBatched(bool);
    void setTargetArray(CCArray*);




private:
    char * atlasNameFromFntFile(const char *fntFile);
    int kerningAmountForFirst(unsigned short first, unsigned short second);
    float getLetterPosXLeft( CCSprite* characterSprite );
    float getLetterPosXRight( CCSprite* characterSprite );

protected:
    virtual void setString(unsigned short *newString, bool needUpdateLabel);

    unsigned short* m_sString;


    std::string m_sFntFile;






    unsigned short* m_sInitialString;
    std::string m_sInitialStringUTF8;


    CCTextAlignment m_pAlignment;

    float m_fWidth;

    CCBMFontConfiguration *m_pConfiguration;

    bool m_bLineBreakWithoutSpaces;

    CCPoint m_tImageOffset;


    CCSprite *m_pReusedChar;


    GLubyte m_cDisplayedOpacity;
    GLubyte m_cRealOpacity;


    ccColor3B m_tDisplayedColor;
    ccColor3B m_tRealColor;
    bool m_bCascadeColorEnabled;
    bool m_bCascadeOpacityEnabled;

    bool m_bIsOpacityModifyRGB;

    bool m_bIsBatched;
    CCArray* m_pTargetArray;
    uint32_t m_uUnknown;




};



       CCBMFontConfiguration * FNTConfigLoadFile( const char *file );


       void FNTConfigRemoveCache( void );





}
# 102 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 1
# 32 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h" 1
# 32 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h"
namespace cocos2d {

class CCTouch;
class CCEvent;
class CCSet;
class CCTouchDispatcher;
# 46 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h"
class CCTouchDelegate
{
public:

    CCTouchDelegate() {}

    virtual ~CCTouchDelegate()
    {
    }

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent; return false;};


    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}


     virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}

};
# 86 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h"
 class CCTargetedTouchDelegate : public CCTouchDelegate
 {
 public:



     virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent) { (void)pTouch; (void)pEvent;return false;};


     virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
     virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
     virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
 };







 class CCStandardTouchDelegate : public CCTouchDelegate
 {
 public:

     virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
    virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
 };




}
# 33 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 2



# 1 "Cacao/include/cocos2dx/custom/Delegates/CCKeyboardDelegate.h" 1




namespace cocos2d {

enum enumKeyCodes {
  KEY_NONE = 0, KEY_PAUSE = 0x0013, KEY_SCROLL_LOCK = 0x1014, KEY_PRINT = 0x1061,
  KEY_SYSREQ = 0x106A, KEY_BREAK = 0x106B, KEY_ESCAPE = 0x001B, KEY_BACKSPACE = 0x0008,
  KEY_TAB = 0x0009, KEY_BACK_TAB = 0x0089, KEY_RETURN = 0x000D, KEY_CAPS_LOCK = 0x00E5,
  KEY_SHIFT = 0x00E1, KEY_CTRL = 0x00E3, KEY_ALT = 0x00E9, KEY_MENU = 0x1067,
  KEY_HYPER = 0x10ED, KEY_INSERT = 0x1063, KEY_HOME = 0x1050, KEY_PG_UP = 0x1055,
  KEY_DELETE = 0x10FF, KEY_END = 0x1057, KEY_PG_DOWN = 0x1056, KEY_LEFT_ARROW = 0x1051,
  KEY_RIGHT_ARROW = 0x1053, KEY_UP_ARROW = 0x1052, KEY_DOWN_ARROW = 0x1054, KEY_NUM_LOCK = 0x107F,
  KEY_KP_PLUS = 0x10AB, KEY_KP_MINUS = 0x10AD, KEY_KP_MULTIPLY = 0x10AA, KEY_KP_DIVIDE = 0x10AF,
  KEY_KP_ENTER = 0x108D, KEY_KP_HOME = 0x10B7, KEY_KP_UP = 0x10B8, KEY_KP_PG_UP = 0x10B9,
  KEY_KP_LEFT = 0x10B4, KEY_KP_FIVE = 0x10B5, KEY_KP_RIGHT = 0x10B6, KEY_KP_END = 0x10B1,
  KEY_KP_DOWN = 0x10B2, KEY_KP_PG_DOWN = 0x10B3, KEY_KP_INSERT = 0x10B0, KEY_KP_DELETE = 0x10AE,
  KEY_F1 = 0x00BE, KEY_F2 = 0x00BF, KEY_F3 = 0x00C0, KEY_F4 = 0x00C1,
  KEY_F5 = 0x00C2, KEY_F6 = 0x00C3, KEY_F7 = 0x00C4, KEY_F8 = 0x00C5,
  KEY_F9 = 0x00C6, KEY_F10 = 0x00C7, KEY_F11 = 0x00C8, KEY_F12 = 0x00C9,
  KEY_SPACE = ' ', KEY_EXCLAM = '!', KEY_QUOTE = '"', KEY_NUMBER = '#',
  KEY_DOLLAR = '$', KEY_PERCENT = '%', KEY_CIRCUMFLEX = '^', KEY_AMPERSAND = '&',
  KEY_APOSTROPHE = '\'', KEY_LEFT_PARENTHESIS = '(', KEY_RIGHT_PARENTHESIS = ')', KEY_ASTERISK = '*',
  KEY_PLUS = '+', KEY_COMMA = ',', KEY_MINUS = '-', KEY_PERIOD = '.',
  KEY_SLASH = '/', KEY_0 = '0', KEY_1 = '1', KEY_2 = '2',
  KEY_3 = '3', KEY_4 = '4', KEY_5 = '5', KEY_6 = '6',
  KEY_7 = '7', KEY_8 = '8', KEY_9 = '9', KEY_COLON = ':',
  KEY_SEMICOLON = ';', KEY_LESS_THAN = '<', KEY_EQUAL = '=', KEY_GREATER_THAN = '>',
  KEY_QUESTION = '?', KEY_AT = '@', KEY_CAPITAL_A = 'A', KEY_CAPITAL_B = 'B',
  KEY_CAPITAL_C = 'C', KEY_CAPITAL_D = 'D', KEY_CAPITAL_E = 'E', KEY_CAPITAL_F = 'F',
  KEY_CAPITAL_G = 'G', KEY_CAPITAL_H = 'H', KEY_CAPITAL_I = 'I', KEY_CAPITAL_J = 'J',
  KEY_CAPITAL_K = 'K', KEY_CAPITAL_L = 'L', KEY_CAPITAL_M = 'M', KEY_CAPITAL_N = 'N',
  KEY_CAPITAL_O = 'O', KEY_CAPITAL_P = 'P', KEY_CAPITAL_Q = 'Q', KEY_CAPITAL_R = 'R',
  KEY_CAPITAL_S = 'S', KEY_CAPITAL_T = 'T', KEY_CAPITAL_U = 'U', KEY_CAPITAL_V = 'V',
  KEY_CAPITAL_W = 'W', KEY_CAPITAL_X = 'X', KEY_CAPITAL_Y = 'Y', KEY_CAPITAL_Z = 'Z',
  KEY_LEFT_BRACKET = '[', KEY_BACK_SLASH = '\\', KEY_RIGHT_BRACKET = ']', KEY_UNDERSCORE = '_',
  KEY_GRAVE = '`', KEY_A = 'a', KEY_B = 'b', KEY_C = 'c',
  KEY_D = 'd', KEY_E = 'e', KEY_F = 'f', KEY_G = 'g',
  KEY_H = 'h', KEY_I = 'i', KEY_J = 'j', KEY_K = 'k',
  KEY_L = 'l', KEY_M = 'm', KEY_N = 'n', KEY_O = 'o',
  KEY_P = 'p', KEY_Q = 'q', KEY_R = 'r', KEY_S = 's',
  KEY_T = 't', KEY_U = 'u', KEY_V = 'v', KEY_W = 'w',
  KEY_X = 'x', KEY_Y = 'y', KEY_Z = 'z', KEY_LEFT_BRACE = '{',
  KEY_BAR = '|', KEY_RIGHT_BRACE = '}', KEY_TILDE = '~', KEY_EURO = 0x20AC,
  KEY_POUND = 0x00A3, KEY_YEN = 0x00A5, KEY_MIDDLE_DOT = 0x0095, KEY_SEARCH = 0xFFAA
};
class CCKeyboardDelegate {
public:
 virtual void keyDown(enumKeyCodes);
 virtual void keyUp(enumKeyCodes);
};

}
# 37 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 2
# 1 "Cacao/include/cocos2dx/custom/Delegates/CCMouseDelegate.h" 1




namespace cocos2d {

class CCMouseDelegate {
public:
 virtual void rightKeyDown(void);
 virtual void rightKeyUp(void);
 virtual void scrollWheel(float, float);
};

}
# 38 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 2




namespace cocos2d {

typedef enum {
 kCCTouchesAllAtOnce,
 kCCTouchesOneByOne,
} ccTouchesMode;






class CCTouchScriptHandlerEntry;
# 65 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayer : public CCNode, public CCTouchDelegate, public CCAccelerometerDelegate, public CCKeypadDelegate,
    public CCKeyboardDelegate, public CCMouseDelegate
{
public:



    CCLayer();




    virtual ~CCLayer();
    virtual bool init();


    static CCLayer *create(void);




    virtual void onEnter();




    virtual void onExit();




    virtual void onEnterTransitionDidFinish();


    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);


    virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent);




    virtual void didAccelerate(CCAcceleration* pAccelerationValue);
    void registerScriptAccelerateHandler(int nHandler);
    void unregisterScriptAccelerateHandler(void);
# 127 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
    virtual void registerWithTouchDispatcher(void);


    virtual void registerScriptTouchHandler(int nHandler, bool bIsMultiTouches = false, int nPriority = (-2147483647-1), bool bSwallowsTouches = false);

    virtual void unregisterScriptTouchHandler(void);






    virtual bool isTouchEnabled();
    virtual void setTouchEnabled(bool value);

    virtual void setTouchMode(ccTouchesMode mode);
    virtual int getTouchMode();


    virtual void setTouchPriority(int priority);
    virtual int getTouchPriority();





    virtual bool isAccelerometerEnabled();
    virtual void setAccelerometerEnabled(bool value);
    virtual void setAccelerometerInterval(double interval);





    virtual bool isKeypadEnabled();
    virtual void setKeypadEnabled(bool value);


    virtual bool isKeyboardEnabled();
    virtual void setKeyboardEnabled(bool value);
    virtual bool isMouseEnabled();
    virtual void setMouseEnabled(bool value);


    void registerScriptKeypadHandler(int nHandler);

    void unregisterScriptKeypadHandler(void);

    virtual void keyBackClicked(void);
    virtual void keyMenuClicked(void);


    virtual void keyDown(enumKeyCodes key);

    inline CCTouchScriptHandlerEntry* getScriptTouchHandlerEntry() { return m_pScriptTouchHandlerEntry; };
    inline CCScriptHandlerEntry* getScriptKeypadHandlerEntry() { return m_pScriptKeypadHandlerEntry; };
    inline CCScriptHandlerEntry* getScriptAccelerateHandlerEntry() { return m_pScriptAccelerateHandlerEntry; };
protected:
    bool m_bTouchEnabled;
    bool m_bAccelerometerEnabled;
    bool m_bKeypadEnabled;
    bool m_bKeyboardEnabled;
    bool m_bMouseEnabled;

private:

    CCTouchScriptHandlerEntry* m_pScriptTouchHandlerEntry;
    CCScriptHandlerEntry* m_pScriptKeypadHandlerEntry;
    CCScriptHandlerEntry* m_pScriptAccelerateHandlerEntry;

    int m_nTouchPriority;
    ccTouchesMode m_eTouchMode;

    int excuteScriptTouchHandler(int nEventType, CCTouch *pTouch);
    int excuteScriptTouchHandler(int nEventType, CCSet *pTouches);
};
# 216 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayerRGBA : public CCLayer, public CCRGBAProtocol
{
public:
    static CCLayerRGBA* create() { CCLayerRGBA *pRet = new CCLayerRGBA(); if (pRet && pRet->init()) { pRet->autorelease(); return pRet; } else { delete pRet; pRet = __null; return __null; } };



    CCLayerRGBA();




    virtual ~CCLayerRGBA();

    virtual bool init();

    virtual GLubyte getOpacity();
    virtual GLubyte getDisplayedOpacity();
    virtual void setOpacity(GLubyte opacity);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual bool isCascadeOpacityEnabled();
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);

    virtual const ccColor3B& getColor();
    virtual const ccColor3B& getDisplayedColor();
    virtual void setColor(const ccColor3B& color);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual bool isCascadeColorEnabled();
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled);

    virtual void setOpacityModifyRGB(bool bValue) {(void)bValue;}
    virtual bool isOpacityModifyRGB() { return false; }
protected:
 GLubyte _displayedOpacity, _realOpacity;
 ccColor3B _displayedColor, _realColor;
 bool _cascadeOpacityEnabled, _cascadeColorEnabled;
};
# 263 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayerColor : public CCLayerRGBA, public CCBlendProtocol



{
protected:
    ccVertex2F m_pSquareVertices[4];
    ccColor4F m_pSquareColors[4];

public:



    CCLayerColor();




    virtual ~CCLayerColor();

    virtual void draw();
    virtual void setContentSize(const CCSize & var);

    static CCLayerColor* create();


    static CCLayerColor * create(const ccColor4B& color, GLfloat width, GLfloat height);

    static CCLayerColor * create(const ccColor4B& color);

    virtual bool init();

    virtual bool initWithColor(const ccColor4B& color, GLfloat width, GLfloat height);

    virtual bool initWithColor(const ccColor4B& color);


    void changeWidth(GLfloat w);

    void changeHeight(GLfloat h);



    void changeWidthAndHeight(GLfloat w ,GLfloat h);


    protected: ccBlendFunc m_tBlendFunc;public: virtual ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(ccBlendFunc var);

    virtual void setColor(const ccColor3B &color);
    virtual void setOpacity(GLubyte opacity);

protected:
    virtual void updateColor();
};
# 340 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayerGradient : public CCLayerColor
{
public:


    static CCLayerGradient* create(const ccColor4B& start, const ccColor4B& end);


    static CCLayerGradient* create(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);

    virtual bool init();



    virtual bool initWithColor(const ccColor4B& start, const ccColor4B& end);




    virtual bool initWithColor(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);

    protected: ccColor3B m_startColor;public: virtual const ccColor3B& getStartColor(void);public: virtual void setStartColor(const ccColor3B& var);
    protected: ccColor3B m_endColor;public: virtual const ccColor3B& getEndColor(void);public: virtual void setEndColor(const ccColor3B& var);
    protected: GLubyte m_cStartOpacity;public: virtual GLubyte getStartOpacity(void);public: virtual void setStartOpacity(GLubyte var);
    protected: GLubyte m_cEndOpacity;public: virtual GLubyte getEndOpacity(void);public: virtual void setEndOpacity(GLubyte var);
    protected: CCPoint m_AlongVector;public: virtual const CCPoint& getVector(void);public: virtual void setVector(const CCPoint& var);




protected:
    bool m_bCompressedInterpolation;
public:
    virtual void setCompressedInterpolation(bool bCompressedInterpolation);
    virtual bool isCompressedInterpolation();

    static CCLayerGradient* create();

protected:
    virtual void updateColor();
};







class CCLayerMultiplex : public CCLayer
{
protected:
    unsigned int m_nEnabledLayer;
    CCArray* m_pLayers;
public:




    CCLayerMultiplex();




    virtual ~CCLayerMultiplex();



    static CCLayerMultiplex* create();





    static CCLayerMultiplex* createWithArray(CCArray* arrayOfLayers);




    static CCLayerMultiplex * create(CCLayer* layer, ... );





    static CCLayerMultiplex * createWithLayer(CCLayer* layer);

    void addLayer(CCLayer* layer);





    bool initWithLayers(CCLayer* layer, va_list params);
# 441 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
    bool initWithArray(CCArray* arrayOfLayers);

    void switchTo(unsigned int n);



    void switchToAndReleaseMe(unsigned int n);
};





}
# 105 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCScene.h" 1
# 32 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCScene.h"
namespace cocos2d {
# 49 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCScene.h"
class CCScene : public CCNode
{
public:



    CCScene();




    virtual ~CCScene();
    bool init();

    static CCScene *create(void);
};




}
# 106 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransition.h" 1
# 33 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransition.h"
namespace cocos2d {
# 44 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransition.h"
class CCActionInterval;
class CCNode;




class CCTransitionEaseScene
{
public:



    virtual CCActionInterval * easeActionWithAction(CCActionInterval * action) = 0;
};



typedef enum {

 kCCTransitionOrientationLeftOver = 0,

 kCCTransitionOrientationRightOver = 1,

 kCCTransitionOrientationUpOver = 0,

 kCCTransitionOrientationDownOver = 1,






} tOrientation;



class CCTransitionScene : public CCScene
{

protected:
    CCScene * m_pInScene;
    CCScene * m_pOutScene;
    float m_fDuration;
    bool m_bIsInSceneOnTop;
    bool m_bIsSendCleanupToScene;

public:



    CCTransitionScene();




    virtual ~CCTransitionScene();
    virtual void draw();




    virtual void onEnter();




    virtual void onExit();
    virtual void cleanup();


    static CCTransitionScene * create(float t, CCScene *scene);


    virtual bool initWithDuration(float t,CCScene* scene);


    void finish(void);


    void hideOutShowIn(void);

protected:
    virtual void sceneOrder();
private:
    void setNewScene(float dt);

};




class CCTransitionSceneOriented : public CCTransitionScene
{
protected:
    tOrientation m_eOrientation;

public:



    CCTransitionSceneOriented();




    virtual ~CCTransitionSceneOriented();


    static CCTransitionSceneOriented * create(float t,CCScene* scene, tOrientation orientation);


    virtual bool initWithDuration(float t,CCScene* scene,tOrientation orientation);
};




class CCTransitionRotoZoom : public CCTransitionScene
{
public:



    CCTransitionRotoZoom();




    virtual ~CCTransitionRotoZoom();




    virtual void onEnter();

    static CCTransitionRotoZoom* create(float t, CCScene* scene);
};




class CCTransitionJumpZoom : public CCTransitionScene
{
public:



    CCTransitionJumpZoom();




    virtual ~CCTransitionJumpZoom();




    virtual void onEnter();

    static CCTransitionJumpZoom* create(float t, CCScene* scene);
};




class CCTransitionMoveInL : public CCTransitionScene, public CCTransitionEaseScene
{
public:



    CCTransitionMoveInL();




    virtual ~CCTransitionMoveInL();

    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);




    virtual void onEnter();

    static CCTransitionMoveInL* create(float t, CCScene* scene);
};




class CCTransitionMoveInR : public CCTransitionMoveInL
{
public:



    CCTransitionMoveInR();




    virtual ~CCTransitionMoveInR();
    virtual void initScenes();

    static CCTransitionMoveInR* create(float t, CCScene* scene);
};




class CCTransitionMoveInT : public CCTransitionMoveInL
{
public:



    CCTransitionMoveInT();




    virtual ~CCTransitionMoveInT();
    virtual void initScenes();

    static CCTransitionMoveInT* create(float t, CCScene* scene);
};




class CCTransitionMoveInB : public CCTransitionMoveInL
{
public:



    CCTransitionMoveInB();




    virtual ~CCTransitionMoveInB();
    virtual void initScenes();

    static CCTransitionMoveInB* create(float t, CCScene* scene);
};




class CCTransitionSlideInL : public CCTransitionScene, public CCTransitionEaseScene
{
public:



    CCTransitionSlideInL();




    virtual ~CCTransitionSlideInL();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);




    virtual void onEnter();

    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);

    static CCTransitionSlideInL* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSlideInR : public CCTransitionSlideInL
{
public:



    CCTransitionSlideInR();




    virtual ~CCTransitionSlideInR();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    static CCTransitionSlideInR* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSlideInB : public CCTransitionSlideInL
{
public:



    CCTransitionSlideInB();




    virtual ~CCTransitionSlideInB();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    static CCTransitionSlideInB* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSlideInT : public CCTransitionSlideInL
{
public:



    CCTransitionSlideInT();




    virtual ~CCTransitionSlideInT();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    static CCTransitionSlideInT* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionShrinkGrow : public CCTransitionScene , public CCTransitionEaseScene
{
public:



    CCTransitionShrinkGrow();




    virtual ~CCTransitionShrinkGrow();




    virtual void onEnter();
    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);

    static CCTransitionShrinkGrow* create(float t, CCScene* scene);
};





class CCTransitionFlipX : public CCTransitionSceneOriented
{
public:



    CCTransitionFlipX();




    virtual ~CCTransitionFlipX();




    virtual void onEnter();

    static CCTransitionFlipX* create(float t, CCScene* s, tOrientation o);
    static CCTransitionFlipX* create(float t, CCScene* s);
};





class CCTransitionFlipY : public CCTransitionSceneOriented
{
public:



    CCTransitionFlipY();




    virtual ~CCTransitionFlipY();




    virtual void onEnter();

    static CCTransitionFlipY* create(float t, CCScene* s, tOrientation o);
    static CCTransitionFlipY* create(float t, CCScene* s);
};





class CCTransitionFlipAngular : public CCTransitionSceneOriented
{
public:



    CCTransitionFlipAngular();




    virtual ~CCTransitionFlipAngular();




    virtual void onEnter();

    static CCTransitionFlipAngular* create(float t, CCScene* s, tOrientation o);
    static CCTransitionFlipAngular* create(float t, CCScene* s);
};





class CCTransitionZoomFlipX : public CCTransitionSceneOriented
{
public:



    CCTransitionZoomFlipX();




    virtual ~CCTransitionZoomFlipX();




    virtual void onEnter();

    static CCTransitionZoomFlipX* create(float t, CCScene* s, tOrientation o);
    static CCTransitionZoomFlipX* create(float t, CCScene* s);
};





class CCTransitionZoomFlipY : public CCTransitionSceneOriented
{
public:



    CCTransitionZoomFlipY();




    virtual ~CCTransitionZoomFlipY();




    virtual void onEnter();

    static CCTransitionZoomFlipY* create(float t, CCScene* s, tOrientation o);
    static CCTransitionZoomFlipY* create(float t, CCScene* s);
};





class CCTransitionZoomFlipAngular : public CCTransitionSceneOriented
{
public:



    CCTransitionZoomFlipAngular();




    virtual ~CCTransitionZoomFlipAngular();




    virtual void onEnter();

    static CCTransitionZoomFlipAngular* create(float t, CCScene* s, tOrientation o);
    static CCTransitionZoomFlipAngular* create(float t, CCScene* s);
};




class CCTransitionFade : public CCTransitionScene
{
protected:
    ccColor4B m_tColor;

public:



    CCTransitionFade();




    virtual ~CCTransitionFade();




    static CCTransitionFade* create(float duration,CCScene* scene, const ccColor3B& color);
    static CCTransitionFade* create(float duration,CCScene* scene);


    virtual bool initWithDuration(float t, CCScene*scene ,const ccColor3B& color);

    virtual bool initWithDuration(float t,CCScene* scene);




    virtual void onEnter();




    virtual void onExit();
};

class CCRenderTexture;




class CCTransitionCrossFade : public CCTransitionScene
{
public :



    CCTransitionCrossFade();




    virtual ~CCTransitionCrossFade();

    virtual void draw();




    virtual void onEnter();




    virtual void onExit();

public:
    static CCTransitionCrossFade* create(float t, CCScene* scene);
};




class CCTransitionTurnOffTiles : public CCTransitionScene ,public CCTransitionEaseScene
{
public :



    CCTransitionTurnOffTiles();




    virtual ~CCTransitionTurnOffTiles();




    virtual void onEnter();
    virtual CCActionInterval * easeActionWithAction(CCActionInterval * action);

public:
    static CCTransitionTurnOffTiles* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSplitCols : public CCTransitionScene , public CCTransitionEaseScene
{
public:



    CCTransitionSplitCols();




    virtual ~CCTransitionSplitCols();

    virtual CCActionInterval* action(void);




    virtual void onEnter();
    virtual CCActionInterval * easeActionWithAction(CCActionInterval * action);

public:

    static CCTransitionSplitCols* create(float t, CCScene* scene);
};




class CCTransitionSplitRows : public CCTransitionSplitCols
{
public:



    CCTransitionSplitRows();




    virtual ~CCTransitionSplitRows();

    virtual CCActionInterval* action(void);

public:

    static CCTransitionSplitRows* create(float t, CCScene* scene);
};




class CCTransitionFadeTR : public CCTransitionScene , public CCTransitionEaseScene
{
public:



    CCTransitionFadeTR();




    virtual ~CCTransitionFadeTR();
    virtual CCActionInterval* actionWithSize(const CCSize& size);




    virtual void onEnter();
    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);

public:

    static CCTransitionFadeTR* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionFadeBL : public CCTransitionFadeTR
{
public:



    CCTransitionFadeBL();




    virtual ~CCTransitionFadeBL();
    virtual CCActionInterval* actionWithSize(const CCSize& size);

public:

    static CCTransitionFadeBL* create(float t, CCScene* scene);
};




class CCTransitionFadeUp : public CCTransitionFadeTR
{
public:



    CCTransitionFadeUp();




    virtual ~CCTransitionFadeUp();
    virtual CCActionInterval* actionWithSize(const CCSize& size);

public:

    static CCTransitionFadeUp* create(float t, CCScene* scene);
};




class CCTransitionFadeDown : public CCTransitionFadeTR
{
public:



    CCTransitionFadeDown();




    virtual ~CCTransitionFadeDown();
    virtual CCActionInterval* actionWithSize(const CCSize& size);

public:

    static CCTransitionFadeDown* create(float t, CCScene* scene);
};




}
# 107 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionPageTurn.h" 1
# 31 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionPageTurn.h"
namespace cocos2d {
# 49 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionPageTurn.h"
class CCTransitionPageTurn : public CCTransitionScene
{
protected:
    bool m_bBack;

public:



    CCTransitionPageTurn();




    virtual ~CCTransitionPageTurn();






    static CCTransitionPageTurn* create(float t,CCScene* scene,bool backwards);






    virtual bool initWithDuration(float t,CCScene* scene,bool backwards);

    CCActionInterval* actionWithSize(const CCSize& vector);




    virtual void onEnter();

protected:
    virtual void sceneOrder();
};




}
# 108 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionProgress.h" 1
# 32 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionProgress.h"
namespace cocos2d {

class CCProgressTimer;
class CCRenderTexture;






class CCTransitionProgress : public CCTransitionScene
{
public:
    static CCTransitionProgress* create(float t, CCScene* scene);



    CCTransitionProgress();




    virtual void onEnter();




    virtual void onExit();
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);
    virtual void setupTransition();
    virtual void sceneOrder();
    float m_fTo;
    float m_fFrom;
    CCScene* m_pSceneToBeModified;
};





class CCTransitionProgressRadialCCW : public CCTransitionProgress
{
public:
    static CCTransitionProgressRadialCCW* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};





class CCTransitionProgressRadialCW : public CCTransitionProgress
{
public:
    static CCTransitionProgressRadialCW* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};




class CCTransitionProgressHorizontal : public CCTransitionProgress
{
public:

    static CCTransitionProgressHorizontal* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};

class CCTransitionProgressVertical : public CCTransitionProgress
{
public:

    static CCTransitionProgressVertical* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};

class CCTransitionProgressInOut : public CCTransitionProgress
{
public:

    static CCTransitionProgressInOut* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);
    virtual void sceneOrder();
    virtual void setupTransition();
};

class CCTransitionProgressOutIn : public CCTransitionProgress
{
public:

    static CCTransitionProgressOutIn* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};




}
# 109 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h" 1
# 28 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h"
# 1 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h" 1
# 34 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
namespace cocos2d {

class CCLabelTTF;
class CCLabelAtlas;
class CCSprite;
class CCSpriteFrame;
# 53 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItem : public CCNodeRGBA
{
protected:



    bool m_bSelected;
    bool m_bEnabled;

public:



    CCMenuItem()
    : m_bSelected(false)
    , m_bEnabled(false)
    , m_pListener(__null)
    , m_pfnSelector(__null)
    , m_nScriptTapHandler(0)
    {}




    virtual ~CCMenuItem();





    static CCMenuItem* create();

    static CCMenuItem* create(CCObject *rec, SEL_MenuHandler selector);



    bool initWithTarget(CCObject *rec, SEL_MenuHandler selector);

    CCRect rect();

    virtual void activate();

    virtual void selected();

    virtual void unselected();


    virtual void registerScriptTapHandler(int nHandler);
    virtual void unregisterScriptTapHandler(void);
    int getScriptTapHandler() { return m_nScriptTapHandler; };

    virtual bool isEnabled();

    virtual void setEnabled(bool value);
    virtual bool isSelected();


    void setTarget(CCObject *rec, SEL_MenuHandler selector);

protected:
    CCObject* m_pListener;
    SEL_MenuHandler m_pfnSelector;
    int m_nScriptTapHandler;
};
# 125 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItemLabel : public CCMenuItem
{

    protected: ccColor3B m_tDisabledColor;public: virtual const ccColor3B& getDisabledColor(void);public: virtual void setDisabledColor(const ccColor3B& var);;

    protected: CCNode* m_pLabel;public: virtual CCNode* getLabel(void);public: virtual void setLabel(CCNode* var);;
public:



    CCMenuItemLabel()
    : m_pLabel(__null)
    , m_fOriginalScale(0.0)
    {}




    virtual ~CCMenuItemLabel();




    static CCMenuItemLabel * create(CCNode*label, CCObject* target, SEL_MenuHandler selector);

    static CCMenuItemLabel* create(CCNode *label);


    bool initWithLabel(CCNode* label, CCObject* target, SEL_MenuHandler selector);

    void setString(const char * label);

    virtual void activate();
    virtual void selected();
    virtual void unselected();



    virtual void setEnabled(bool enabled);

protected:
    ccColor3B m_tColorBackup;
    float m_fOriginalScale;
};





class CCMenuItemAtlasFont : public CCMenuItemLabel
{
public:



    CCMenuItemAtlasFont(){}




    virtual ~CCMenuItemAtlasFont(){}


    static CCMenuItemAtlasFont* create(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap);



    static CCMenuItemAtlasFont* create(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap, CCObject* target, SEL_MenuHandler selector);

    bool initWithString(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap, CCObject* target, SEL_MenuHandler selector);
};





class CCMenuItemFont : public CCMenuItemLabel
{
public:



    CCMenuItemFont() : m_uFontSize(0), m_strFontName(""){}




    virtual ~CCMenuItemFont(){}

    static void setFontSize(unsigned int s);

    static unsigned int fontSize();

    static void setFontName(const char *name);

    static const char *fontName();


    static CCMenuItemFont * create(const char *value);



    static CCMenuItemFont * create(const char *value, CCObject* target, SEL_MenuHandler selector);


    bool initWithString(const char *value, CCObject* target, SEL_MenuHandler selector);






    void setFontSizeObj(unsigned int s);




    unsigned int fontSizeObj();






    void setFontNameObj(const char* name);



    const char* fontNameObj();

protected:
    void recreateLabel();

    unsigned int m_uFontSize;
    std::string m_strFontName;
};
# 271 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItemSprite : public CCMenuItem
{

    protected: CCNode* m_pNormalImage;public: virtual CCNode* getNormalImage(void);public: virtual void setNormalImage(CCNode* var);;

    protected: CCNode* m_pSelectedImage;public: virtual CCNode* getSelectedImage(void);public: virtual void setSelectedImage(CCNode* var);;

    protected: CCNode* m_pDisabledImage;public: virtual CCNode* getDisabledImage(void);public: virtual void setDisabledImage(CCNode* var);;
public:



    CCMenuItemSprite()
    :m_pNormalImage(__null)
    ,m_pSelectedImage(__null)
    ,m_pDisabledImage(__null)
    {}


    static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite = __null);



    static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCObject* target, SEL_MenuHandler selector);



    static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite, CCObject* target, SEL_MenuHandler selector);


    bool initWithNormalSprite(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite, CCObject* target, SEL_MenuHandler selector);




    virtual void selected();
    virtual void unselected();
    virtual void setEnabled(bool bEnabled);

protected:
    virtual void updateImagesVisibility();
};
# 323 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItemImage : public CCMenuItemSprite
{
public:




    CCMenuItemImage(){}




    virtual ~CCMenuItemImage(){}


    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage);

    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, const char *disabledImage);



    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, CCObject* target, SEL_MenuHandler selector);



    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, const char *disabledImage, CCObject* target, SEL_MenuHandler selector);

    bool init();

    bool initWithNormalImage(const char *normalImage, const char *selectedImage, const char *disabledImage, CCObject* target, SEL_MenuHandler selector);

    void setNormalSpriteFrame(CCSpriteFrame* frame);

    void setSelectedSpriteFrame(CCSpriteFrame* frame);

    void setDisabledSpriteFrame(CCSpriteFrame* frame);




    static CCMenuItemImage* create();
};






class CCMenuItemToggle : public CCMenuItem
{

    protected: unsigned int m_uSelectedIndex;public: virtual unsigned int getSelectedIndex(void);public: virtual void setSelectedIndex(unsigned int var);;



    protected: CCArray* m_pSubItems;public: virtual CCArray* getSubItems(void);public: virtual void setSubItems(CCArray* var);;
public:



    CCMenuItemToggle()
    : m_uSelectedIndex(0)
    , m_pSubItems(__null)
    {}




    virtual ~CCMenuItemToggle();


    static CCMenuItemToggle * createWithTarget(CCObject* target, SEL_MenuHandler selector, CCArray* menuItems);


    static CCMenuItemToggle* createWithTarget(CCObject* target, SEL_MenuHandler selector, CCMenuItem* item, ...);





    static CCMenuItemToggle* create();


    bool initWithTarget(CCObject* target, SEL_MenuHandler selector, CCMenuItem* item, va_list args);


    static CCMenuItemToggle* create(CCMenuItem *item);


    bool initWithItem(CCMenuItem *item);

    void addSubItem(CCMenuItem *item);


    CCMenuItem* selectedItem();

    virtual void activate();
    virtual void selected();
    virtual void unselected();
    virtual void setEnabled(bool var);

};






}
# 29 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h" 2


namespace cocos2d {







typedef enum
{
    kCCMenuStateWaiting,
    kCCMenuStateTrackingTouch
} tCCMenuState;

enum {

    kCCMenuHandlerPriority = -128,
};







class CCMenu : public CCLayerRGBA
{

    bool m_bEnabled;

public:



    CCMenu() : m_pSelectedItem(__null) {}




    virtual ~CCMenu(){}


    static CCMenu* create();




    static CCMenu* create(CCMenuItem* item, ...);




    static CCMenu* createWithArray(CCArray* pArrayOfItems);






    static CCMenu* createWithItem(CCMenuItem* item);





    static CCMenu* createWithItems(CCMenuItem *firstItem, va_list args);


    bool init();




    bool initWithArray(CCArray* pArrayOfItems);


    void alignItemsVertically();



    void alignItemsVerticallyWithPadding(float padding);


    void alignItemsHorizontally();



    void alignItemsHorizontallyWithPadding(float padding);
# 127 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h"
    void alignItemsInColumns(unsigned int columns, ...);




    void alignItemsInColumns(unsigned int columns, va_list args);



    void alignItemsInColumnsWithArray(CCArray* rows);
# 145 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h"
    void alignItemsInRows(unsigned int rows, ...);




    void alignItemsInRows(unsigned int rows, va_list args);



    void alignItemsInRowsWithArray(CCArray* columns);


    void setHandlerPriority(int newPriority);


    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child, int zOrder, int tag);
    virtual void registerWithTouchDispatcher();
    virtual void removeChild(CCNode* child, bool cleanup);




    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* event);
    virtual void ccTouchEnded(CCTouch* touch, CCEvent* event);
    virtual void ccTouchCancelled(CCTouch *touch, CCEvent* event);
    virtual void ccTouchMoved(CCTouch* touch, CCEvent* event);







    virtual void onExit();

    virtual void setOpacityModifyRGB(bool bValue) {(void)bValue;}
    virtual bool isOpacityModifyRGB(void) { return false;}

    virtual bool isEnabled() { return m_bEnabled; }
    virtual void setEnabled(bool value) { m_bEnabled = value; };

protected:
    CCMenuItem* itemForTouch(CCTouch * touch);
    tCCMenuState m_eState;
    CCMenuItem *m_pSelectedItem;
};





}
# 112 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/misc_nodes/CCClippingNode.h" 1
# 34 "Cacao/include/cocos2dx/misc_nodes/CCClippingNode.h"
namespace cocos2d {






class CCClippingNode : public CCNode
{
protected:
    CCNode* m_pStencil;
    GLfloat m_fAlphaThreshold;
    bool m_bInverted;

public:


    static CCClippingNode* create();




    static CCClippingNode* create(CCNode *pStencil);




    virtual ~CCClippingNode();



    virtual bool init();




    virtual bool init(CCNode *pStencil);




    virtual void onEnter();




    virtual void onEnterTransitionDidFinish();




    virtual void onExitTransitionDidStart();




    virtual void onExit();
    virtual void visit();





    CCNode* getStencil() const;
    void setStencil(CCNode *pStencil);






    GLfloat getAlphaThreshold() const;
    void setAlphaThreshold(GLfloat fAlphaThreshold);





    bool isInverted() const;
    void setInverted(bool bInverted);

protected:
    CCClippingNode();
};

}
# 116 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/misc_nodes/CCMotionStreak.h" 1
# 36 "Cacao/include/cocos2dx/misc_nodes/CCMotionStreak.h"
namespace cocos2d {
# 46 "Cacao/include/cocos2dx/misc_nodes/CCMotionStreak.h"
class CCMotionStreak : public CCNodeRGBA, public CCTextureProtocol



{
public:



    CCMotionStreak();




    virtual ~CCMotionStreak();


    static CCMotionStreak* create(float fade, float minSeg, float stroke, const ccColor3B& color, const char* path);

    static CCMotionStreak* create(float fade, float minSeg, float stroke, const ccColor3B& color, CCTexture2D* texture);


    bool initWithFade(float fade, float minSeg, float stroke, const ccColor3B& color, const char* path);

    bool initWithFade(float fade, float minSeg, float stroke, const ccColor3B& color, CCTexture2D* texture);


    void tintWithColor(ccColor3B colors);


    void reset();


    virtual void setPosition(const CCPoint& position);
    virtual void draw();
    virtual void update(float delta);


    virtual CCTexture2D* getTexture(void);
    virtual void setTexture(CCTexture2D *texture);



    virtual void setBlendFunc(ccBlendFunc blendFunc);



    virtual ccBlendFunc getBlendFunc(void);
    virtual GLubyte getOpacity(void);
    virtual void setOpacity(GLubyte opacity);
    virtual void setOpacityModifyRGB(bool bValue);
    virtual bool isOpacityModifyRGB(void);


    inline bool isFastMode() { return m_bFastMode; }
    inline void setFastMode(bool bFastMode) { m_bFastMode = bFastMode; }

    inline bool isStartingPositionInitialized() { return m_bStartingPositionInitialized; }
    inline void setStartingPositionInitialized(bool bStartingPositionInitialized)
    {
        m_bStartingPositionInitialized = bStartingPositionInitialized;
    }
protected:
    bool m_bFastMode;
    bool m_bStartingPositionInitialized;
private:

    CCTexture2D* m_pTexture;
    ccBlendFunc m_tBlendFunc;
    CCPoint m_tPositionR;

    float m_fStroke;
    float m_fFadeDelta;
    float m_fMinSeg;

    unsigned int m_uMaxPoints;
    unsigned int m_uNuPoints;
    unsigned int m_uPreviousNuPoints;


    CCPoint* m_pPointVertexes;
    float* m_pPointState;


    ccVertex2F* m_pVertices;
    GLubyte* m_pColorPointer;
    ccTex2F* m_pTexCoords;
};




}
# 117 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h" 1
# 33 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
namespace cocos2d {
# 43 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
typedef enum {

    kCCProgressTimerTypeRadial,

    kCCProgressTimerTypeBar,
} CCProgressTimerType;







class CCProgressTimer : public CCNodeRGBA



{
public:



    CCProgressTimer();




    ~CCProgressTimer(void);


    inline CCProgressTimerType getType(void) { return m_eType; }


    inline float getPercentage(void) {return m_fPercentage; }


    inline CCSprite* getSprite(void) { return m_pSprite; }


    bool initWithSprite(CCSprite* sp);

    void setPercentage(float fPercentage);
    void setSprite(CCSprite *pSprite);
    void setType(CCProgressTimerType type);



    void setReverseProgress(bool reverse);

    virtual void draw(void);
    void setAnchorPoint(CCPoint anchorPoint);

    virtual void setColor(const ccColor3B& color);
    virtual const ccColor3B& getColor() const;
    virtual GLubyte getOpacity() const;
    virtual void setOpacity(GLubyte opacity);

    inline bool isReverseDirection() { return m_bReverseDirection; };
    inline void setReverseDirection(bool value) { m_bReverseDirection = value; };

public:

    static CCProgressTimer* create(CCSprite* sp);


    void updateColor(void);

protected:
    ccTex2F textureCoordFromAlphaPoint(CCPoint alpha);
    ccVertex2F vertexFromAlphaPoint(CCPoint alpha);
    void updateProgress(void);
    void updateBar(void);
    void updateRadial(void);

    CCPoint boundaryTexCoord(char index);

protected:
    CCProgressTimerType m_eType;
    float m_fPercentage;
    CCSprite *m_pSprite;
    int m_nVertexDataCount;
    ccV2F_C4B_T2F *m_pVertexData;
# 136 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
    protected: CCPoint m_tMidpoint;public: virtual CCPoint getMidpoint(void);public: virtual void setMidpoint(CCPoint var);;
# 146 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
    protected: CCPoint m_tBarChangeRate;public: CCPoint getBarChangeRate(void) const { return m_tBarChangeRate; }public: void setBarChangeRate(CCPoint var){ m_tBarChangeRate = var; };

    bool m_bReverseDirection;
};




}
# 118 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/misc_nodes/CCRenderTexture.h" 1
# 32 "Cacao/include/cocos2dx/misc_nodes/CCRenderTexture.h"
namespace cocos2d {






typedef enum eImageFormat
{
    kCCImageFormatJPEG = 0,
    kCCImageFormatPNG = 1,
} tCCImageFormat;
# 54 "Cacao/include/cocos2dx/misc_nodes/CCRenderTexture.h"
class CCRenderTexture : public CCNode
{





    protected: CCSprite* m_pSprite;public: virtual CCSprite* getSprite(void);public: virtual void setSprite(CCSprite* var);
public:



    CCRenderTexture();




    virtual ~CCRenderTexture();

    virtual void visit();
    virtual void draw();


    static CCRenderTexture * create(int w ,int h, CCTexture2DPixelFormat eFormat, GLuint uDepthStencilFormat);


    static CCRenderTexture * create(int w, int h, CCTexture2DPixelFormat eFormat);


    static CCRenderTexture * create(int w, int h);


    bool initWithWidthAndHeight(int w, int h, CCTexture2DPixelFormat eFormat);


    bool initWithWidthAndHeight(int w, int h, CCTexture2DPixelFormat eFormat, GLuint uDepthStencilFormat);


    void begin();



    void beginWithClear(float r, float g, float b, float a);



    void beginWithClear(float r, float g, float b, float a, float depthValue);



    void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue);


    inline void endToLua(){ end();};


    void end();


    void clear(float r, float g, float b, float a);


    void clearDepth(float depthValue);


    void clearStencil(int stencilValue);



    CCImage* newCCImage(bool flipImage = true);




    bool saveToFile(const char *szFilePath);




    bool saveToFile(const char *name, tCCImageFormat format);




    void listenToBackground(CCObject *obj);




    void listenToForeground(CCObject *obj);


    unsigned int getClearFlags() const;
    void setClearFlags(unsigned int uClearFlags);


    const ccColor4F& getClearColor() const;
    void setClearColor(const ccColor4F &clearColor);


    float getClearDepth() const;
    void setClearDepth(float fClearDepth);


    int getClearStencil() const;
    void setClearStencil(float fClearStencil);




    bool isAutoDraw() const;
    void setAutoDraw(bool bAutoDraw);

private:
    void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue, GLbitfield flags);

protected:
    GLuint m_uFBO;
    GLuint m_uDepthRenderBufffer;
    GLint m_nOldFBO;
    CCTexture2D* m_pTexture;
    CCTexture2D* m_pTextureCopy;
    CCImage* m_pUITextureImage;
    GLenum m_ePixelFormat;


    GLbitfield m_uClearFlags;
    ccColor4F m_sClearColor;
    GLclampf m_fClearDepth;
    GLint m_nClearStencil;
    bool m_bAutoDraw;
};




}
# 119 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleBatchNode.h" 1
# 35 "Cacao/include/cocos2dx/particle_nodes/CCParticleBatchNode.h"
namespace cocos2d {

class CCTexture2D;
class CCTextureAtlas;
class CCParticleSystem;
# 67 "Cacao/include/cocos2dx/particle_nodes/CCParticleBatchNode.h"
class CCParticleBatchNode : public CCNode, public CCTextureProtocol
{
public:



    CCParticleBatchNode();




    virtual ~CCParticleBatchNode();


    static CCParticleBatchNode* createWithTexture(CCTexture2D *tex, unsigned int capacity = 500);


    static CCParticleBatchNode* create(const char* fileImage, unsigned int capacity = 500);


    bool initWithTexture(CCTexture2D *tex, unsigned int capacity);


    bool initWithFile(const char* fileImage, unsigned int capacity);


    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child, int zOrder, int tag);


    void insertChild(CCParticleSystem* pSystem, unsigned int index);


    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void reorderChild(CCNode * child, int zOrder);
    void removeChildAtIndex(unsigned int index, bool doCleanup);
    void removeAllChildrenWithCleanup(bool doCleanup);

    void disableParticle(unsigned int particleIndex);
    virtual void draw(void);

    virtual CCTexture2D* getTexture(void);

    virtual void setTexture(CCTexture2D *texture);
    virtual void setBlendFunc(ccBlendFunc blendFunc);



    virtual ccBlendFunc getBlendFunc(void);

    void visit();

private:
    void updateAllAtlasIndexes();
    void increaseAtlasCapacityTo(unsigned int quantity);
    unsigned int searchNewPositionInChildrenForZ(int z);
    void getCurrentIndex(unsigned int* oldIndex, unsigned int* newIndex, CCNode* child, int z);
    unsigned int addChildHelper(CCParticleSystem* child, int z, int aTag);
    void updateBlendFunc(void);



    protected: CCTextureAtlas* m_pTextureAtlas;public: CCTextureAtlas* getTextureAtlas(void) const { return m_pTextureAtlas; }public: void setTextureAtlas(CCTextureAtlas* var){ m_pTextureAtlas = var; };
private:

    ccBlendFunc m_tBlendFunc;
};




}
# 122 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h" 1
# 34 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h"
namespace cocos2d {






class CCParticleBatchNode;


enum {

    kCCParticleDurationInfinity = -1,


    kCCParticleStartSizeEqualToEndSize = -1,


    kCCParticleStartRadiusEqualToEndRadius = -1,


    kParticleStartSizeEqualToEndSize = kCCParticleStartSizeEqualToEndSize,
    kParticleDurationInfinity = kCCParticleDurationInfinity,
};


enum {

    kCCParticleModeGravity,


    kCCParticleModeRadius,
};





typedef enum {

    kCCPositionTypeFree,




    kCCPositionTypeRelative,


    kCCPositionTypeGrouped,
}tCCPositionType;


enum {
    kPositionTypeFree = kCCPositionTypeFree,
    kPositionTypeGrouped = kCCPositionTypeGrouped,
};




typedef struct sCCParticle {
    CCPoint pos;
    CCPoint startPos;

    ccColor4F color;
    ccColor4F deltaColor;

    float size;
    float deltaSize;

    float rotation;
    float deltaRotation;

    float timeToLive;

    unsigned int atlasIndex;


    struct {
        CCPoint dir;
        float radialAccel;
        float tangentialAccel;
    } modeA;


    struct {
        float angle;
        float degreesPerSecond;
        float radius;
        float deltaRadius;
    } modeB;

}tCCParticle;



class CCTexture2D;
# 175 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h"
class CCParticleSystem : public CCNode, public CCTextureProtocol
{
protected:
    std::string m_sPlistFile;

    float m_fElapsed;



    struct {

        CCPoint gravity;

        float speed;

        float speedVar;

        float tangentialAccel;

        float tangentialAccelVar;

        float radialAccel;

        float radialAccelVar;

        bool rotationIsDir;
    } modeA;


    struct {

        float startRadius;

        float startRadiusVar;

        float endRadius;

        float endRadiusVar;

        float rotatePerSecond;

        float rotatePerSecondVar;
    } modeB;


    tCCParticle *m_pParticles;





    float m_fEmitCounter;


    unsigned int m_uParticleIdx;






    protected: CCParticleBatchNode* m_pBatchNode;public: virtual CCParticleBatchNode* getBatchNode(void);public: virtual void setBatchNode(CCParticleBatchNode* var);;



    protected: unsigned int m_uAtlasIndex;public: unsigned int getAtlasIndex(void) const { return m_uAtlasIndex; }public: void setAtlasIndex(unsigned int var){ m_uAtlasIndex = var; };


    bool m_bTransformSystemDirty;

    unsigned int m_uAllocatedParticles;


    bool m_bIsActive;

    protected: unsigned int m_uParticleCount;public: virtual unsigned int getParticleCount(void);

    protected: float m_fDuration;public: virtual float getDuration(void);public: virtual void setDuration(float var);

    protected: CCPoint m_tSourcePosition;public: virtual const CCPoint& getSourcePosition(void);public: virtual void setSourcePosition(const CCPoint& var);

    protected: CCPoint m_tPosVar;public: virtual const CCPoint& getPosVar(void);public: virtual void setPosVar(const CCPoint& var);

    protected: float m_fLife;public: virtual float getLife(void);public: virtual void setLife(float var);

    protected: float m_fLifeVar;public: virtual float getLifeVar(void);public: virtual void setLifeVar(float var);

    protected: float m_fAngle;public: virtual float getAngle(void);public: virtual void setAngle(float var);

    protected: float m_fAngleVar;public: virtual float getAngleVar(void);public: virtual void setAngleVar(float var);


public:

    virtual const CCPoint& getGravity();
    virtual void setGravity(const CCPoint& g);
    virtual float getSpeed();
    virtual void setSpeed(float speed);
    virtual float getSpeedVar();
    virtual void setSpeedVar(float speed);
    virtual float getTangentialAccel();
    virtual void setTangentialAccel(float t);
    virtual float getTangentialAccelVar();
    virtual void setTangentialAccelVar(float t);
    virtual float getRadialAccel();
    virtual void setRadialAccel(float t);
    virtual float getRadialAccelVar();
    virtual void setRadialAccelVar(float t);
    virtual bool getRotationIsDir();
    virtual void setRotationIsDir(bool t);

    virtual float getStartRadius();
    virtual void setStartRadius(float startRadius);
    virtual float getStartRadiusVar();
    virtual void setStartRadiusVar(float startRadiusVar);
    virtual float getEndRadius();
    virtual void setEndRadius(float endRadius);
    virtual float getEndRadiusVar();
    virtual void setEndRadiusVar(float endRadiusVar);
    virtual float getRotatePerSecond();
    virtual void setRotatePerSecond(float degrees);
    virtual float getRotatePerSecondVar();
    virtual void setRotatePerSecondVar(float degrees);

    virtual void setScale(float s);
    virtual void setRotation(float newRotation);
    virtual void setScaleX(float newScaleX);
    virtual void setScaleY(float newScaleY);

    virtual bool isActive();
    virtual bool isBlendAdditive();
    virtual void setBlendAdditive(bool value);



    protected: float m_fStartSize;public: virtual float getStartSize(void);public: virtual void setStartSize(float var);

    protected: float m_fStartSizeVar;public: virtual float getStartSizeVar(void);public: virtual void setStartSizeVar(float var);

    protected: float m_fEndSize;public: virtual float getEndSize(void);public: virtual void setEndSize(float var);

    protected: float m_fEndSizeVar;public: virtual float getEndSizeVar(void);public: virtual void setEndSizeVar(float var);

    protected: ccColor4F m_tStartColor;public: virtual const ccColor4F& getStartColor(void);public: virtual void setStartColor(const ccColor4F& var);

    protected: ccColor4F m_tStartColorVar;public: virtual const ccColor4F& getStartColorVar(void);public: virtual void setStartColorVar(const ccColor4F& var);

    protected: ccColor4F m_tEndColor;public: virtual const ccColor4F& getEndColor(void);public: virtual void setEndColor(const ccColor4F& var);

    protected: ccColor4F m_tEndColorVar;public: virtual const ccColor4F& getEndColorVar(void);public: virtual void setEndColorVar(const ccColor4F& var);

    protected: float m_fStartSpin;public: virtual float getStartSpin(void);public: virtual void setStartSpin(float var);

    protected: float m_fStartSpinVar;public: virtual float getStartSpinVar(void);public: virtual void setStartSpinVar(float var);

    protected: float m_fEndSpin;public: virtual float getEndSpin(void);public: virtual void setEndSpin(float var);

    protected: float m_fEndSpinVar;public: virtual float getEndSpinVar(void);public: virtual void setEndSpinVar(float var);

    protected: float m_fEmissionRate;public: virtual float getEmissionRate(void);public: virtual void setEmissionRate(float var);

    protected: unsigned int m_uTotalParticles;public: virtual unsigned int getTotalParticles(void);public: virtual void setTotalParticles(unsigned int var);

    protected: CCTexture2D* m_pTexture;public: virtual CCTexture2D* getTexture(void);public: virtual void setTexture(CCTexture2D* var);

    protected: ccBlendFunc m_tBlendFunc;public: virtual ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(ccBlendFunc var);

    protected: bool m_bOpacityModifyRGB;public: virtual bool getOpacityModifyRGB(void);public: virtual void setOpacityModifyRGB(bool var);
# 351 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h"
    bool m_bIsBlendAdditive;



    protected: tCCPositionType m_ePositionType;public: virtual tCCPositionType getPositionType(void);public: virtual void setPositionType(tCCPositionType var);




protected:
    bool m_bIsAutoRemoveOnFinish;
public:
    virtual bool isAutoRemoveOnFinish();
    virtual void setAutoRemoveOnFinish(bool var);





    protected: int m_nEmitterMode;public: virtual int getEmitterMode(void);public: virtual void setEmitterMode(int var);
private:

    float m_fUnknown01;
    float m_fUnknown02;
    float m_fUnknown03;
    float m_fUnknown04;
    float m_fUnknown05;
    float m_fUnknown06;
    uint32_t m_uUnknown7;
public:



    CCParticleSystem();




    virtual ~CCParticleSystem();






    static CCParticleSystem * create(const char *plistFile);


    static CCParticleSystem* createWithTotalParticles(unsigned int numberOfParticles);


    bool init();





    bool initWithFile(const char *plistFile);




    bool initWithDictionary(CCDictionary *dictionary);




    bool initWithDictionary(CCDictionary *dictionary, const char *dirname);


    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    bool addParticle();

    void initParticle(tCCParticle* particle);

    void stopSystem();

    void resetSystem();

    bool isFull();


    virtual void updateQuadWithParticle(tCCParticle* particle, const CCPoint& newPosition);

    virtual void postStep();

    virtual void update(float dt);
    virtual void updateWithNoTime(void);

protected:
    virtual void updateBlendFunc();
public:

    void loadDefaults(void);
    void loadScaledDefaults(float);
    void resumeSystem(void);
    void saveDefaults(void);

};




}
# 123 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleExamples.h" 1
# 29 "Cacao/include/cocos2dx/particle_nodes/CCParticleExamples.h"
# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystemQuad.h" 1
# 32 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystemQuad.h"
namespace cocos2d {

class CCSpriteFrame;
# 53 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystemQuad.h"
class CCParticleSystemQuad : public CCParticleSystem
{
protected:
    ccV3F_C4B_T2F_Quad *m_pQuads;
    GLushort *m_pIndices;


    GLuint m_uVAOname;


    GLuint m_pBuffersVBO[2];

public:



    CCParticleSystemQuad();




    virtual ~CCParticleSystemQuad();




    static CCParticleSystemQuad * create(const char *plistFile);


    void initIndices();


    void initTexCoordsWithRect(const CCRect& rect);





    void setDisplayFrame(CCSpriteFrame *spriteFrame);




    void setTextureWithRect(CCTexture2D *texture, const CCRect& rect);




    virtual bool initWithTotalParticles(unsigned int numberOfParticles);



    virtual void setTexture(CCTexture2D* texture);



    virtual void updateQuadWithParticle(tCCParticle* particle, const CCPoint& newPosition);



    virtual void postStep();




    virtual void draw();



    virtual void setBatchNode(CCParticleBatchNode* batchNode);



    virtual void setTotalParticles(unsigned int tp);





    void listenBackToForeground(CCObject *obj);

    static CCParticleSystemQuad * create();
    static CCParticleSystemQuad * createWithTotalParticles(unsigned int numberOfParticles);
private:

    void setupVBOandVAO();



    bool allocMemory();
};




}
# 30 "Cacao/include/cocos2dx/particle_nodes/CCParticleExamples.h" 2

namespace cocos2d {







class CCParticleFire : public CCParticleSystemQuad
{
public:



    CCParticleFire(){}




    virtual ~CCParticleFire(){}
    bool init(){ return initWithTotalParticles(250); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleFire* create();
    static CCParticleFire* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleFireworks : public CCParticleSystemQuad
{
public:



    CCParticleFireworks(){}




    virtual ~CCParticleFireworks(){}
    bool init(){ return initWithTotalParticles(1500); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleFireworks* create();
    static CCParticleFireworks* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSun : public CCParticleSystemQuad
{
public:



    CCParticleSun(){}




    virtual ~CCParticleSun(){}
    bool init(){ return initWithTotalParticles(350); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSun* create();
    static CCParticleSun* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleGalaxy : public CCParticleSystemQuad
{
public:



    CCParticleGalaxy(){}




    virtual ~CCParticleGalaxy(){}
    bool init(){ return initWithTotalParticles(200); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleGalaxy* create();
    static CCParticleGalaxy* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleFlower : public CCParticleSystemQuad
{
public:



    CCParticleFlower(){}




    virtual ~CCParticleFlower(){}
    bool init(){ return initWithTotalParticles(250); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleFlower* create();
    static CCParticleFlower* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleMeteor : public CCParticleSystemQuad
{
public:



    CCParticleMeteor(){}




    virtual ~CCParticleMeteor(){}
    bool init(){ return initWithTotalParticles(150); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleMeteor * create();
    static CCParticleMeteor* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSpiral : public CCParticleSystemQuad
{
public:



    CCParticleSpiral(){}




    virtual ~CCParticleSpiral(){}
    bool init(){ return initWithTotalParticles(500); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSpiral* create();
    static CCParticleSpiral* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleExplosion : public CCParticleSystemQuad
{
public:



    CCParticleExplosion(){}




    virtual ~CCParticleExplosion(){}
    bool init(){ return initWithTotalParticles(700); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleExplosion* create();
    static CCParticleExplosion* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSmoke : public CCParticleSystemQuad
{
public:



    CCParticleSmoke(){}




    virtual ~CCParticleSmoke(){}
    bool init(){ return initWithTotalParticles(200); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSmoke* create();
    static CCParticleSmoke* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSnow : public CCParticleSystemQuad
{
public:



    CCParticleSnow(){}




    virtual ~CCParticleSnow(){}
    bool init(){ return initWithTotalParticles(700); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSnow* create();
    static CCParticleSnow* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleRain : public CCParticleSystemQuad
{
public:



    CCParticleRain(){}




    virtual ~CCParticleRain(){}
    bool init(){ return initWithTotalParticles(1000); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleRain* create();
    static CCParticleRain* createWithTotalParticles(unsigned int numberOfParticles);
};




}
# 124 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/platform/CCDevice.h" 1





namespace cocos2d {




class CCDevice
{
private:
    CCDevice();
public:




    static int getDPI();
};


}
# 128 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/platform/CCFileUtils.h" 1
# 34 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
namespace cocos2d {

class CCDictionary;
class CCArray;






class CCFileUtils : public TypeInfo
{
    friend class CCArray;
    friend class CCDictionary;
public:







    virtual long getClassTypeInfo() {
  static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCFileUtils).name());
  return id;
    }





    static CCFileUtils* sharedFileUtils();




    static void purgeFileUtils();






    virtual ~CCFileUtils();
# 87 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void purgeCachedEntries();
# 99 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual unsigned char* getFileData(const char* pszFileName, const char* pszMode, unsigned long * pSize);
# 110 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual unsigned char* getFileDataFromZip(const char* pszZipFilePath, const char* pszFileName, unsigned long * pSize);
# 158 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual std::string fullPathForFilename(const char* pszFileName);
# 192 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void loadFilenameLookupDictionaryFromFile(const char* filename);
# 201 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void setFilenameLookupDictionary(CCDictionary* pFilenameLookupDict);
# 212 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual const char* fullPathFromRelativeFile(const char *pszFilename, const char *pszRelativeFile);
# 223 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void setSearchResolutionsOrder(const std::vector<std::string>& searchResolutionsOrder);







    virtual void addSearchResolutionsOrder(const char* order);
# 241 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual const std::vector<std::string>& getSearchResolutionsOrder();
# 262 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void setSearchPaths(const std::vector<std::string>& searchPaths);






     virtual void addSearchPath(const char* path);







  virtual void removeSearchPath(const char *path);







  void removeAllPaths();
# 295 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual const std::vector<std::string>& getSearchPaths();






    virtual std::string getWritablePath() = 0;
# 312 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual bool isFileExist(const std::string& strFilePath) = 0;
# 324 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual bool isAbsolutePath(const std::string& strPath);





    virtual void setPopupNotify(bool bNotify);
    virtual bool isPopupNotify();

protected:



    CCFileUtils();
# 347 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual bool init();







    virtual std::string getNewFilename(const char* pszFileName);
# 365 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual std::string getPathForFilename(const std::string& filename, const std::string& resolutionDirectory, const std::string& searchPath);
# 377 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual std::string getFullPathForDirectoryAndFilename(const std::string& strDirectory, const std::string& strFilename);





    virtual CCDictionary* createCCDictionaryWithContentsOfFile(const std::string& filename);





    virtual bool writeToFile(CCDictionary *dict, const std::string& fullPath);





    virtual CCArray* createCCArrayWithContentsOfFile(const std::string& filename);
# 404 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    CCDictionary* m_pFilenameLookupDict;





    std::vector<std::string> m_searchResolutionsOrderArray;





    std::vector<std::string> m_searchPathArray;
# 425 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    std::string m_strDefaultResRootPath;





    std::map<std::string, std::string> m_fullPathCache;




    static CCFileUtils* s_sharedFileUtils;

};




}
# 130 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/CCImage.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCImage.h"
namespace cocos2d {
# 41 "Cacao/include/cocos2dx/platform/CCImage.h"
class CCImage : public CCObject
{
public:



    CCImage();




    ~CCImage();

    typedef enum
    {
        kFmtJpg = 0,
        kFmtPng,
        kFmtTiff,
        kFmtWebp,
        kFmtRawData,
        kFmtUnKnown
    }EImageFormat;

    typedef enum
    {
        kAlignCenter = 0x33,
        kAlignTop = 0x13,
        kAlignTopRight = 0x12,
        kAlignRight = 0x32,
        kAlignBottomRight = 0x22,
        kAlignBottom = 0x23,
        kAlignBottomLeft = 0x21,
        kAlignLeft = 0x31,
        kAlignTopLeft = 0x11,
    }ETextAlign;







    bool initWithImageFile(const char * strPath, EImageFormat imageType = kFmtPng);
# 92 "Cacao/include/cocos2dx/platform/CCImage.h"
    bool initWithImageFileThreadSafe(const char *fullpath, EImageFormat imageType = kFmtPng);
# 104 "Cacao/include/cocos2dx/platform/CCImage.h"
    bool initWithImageData(void * pData,
                           int nDataLen,
                           EImageFormat eFmt = kFmtUnKnown,
                           int nWidth = 0,
                           int nHeight = 0,
                           int nBitsPerComponent = 8);
# 121 "Cacao/include/cocos2dx/platform/CCImage.h"
    bool initWithString(
        const char * pText,
        int nWidth = 0,
        int nHeight = 0,
        ETextAlign eAlignMask = kAlignCenter,
        const char * pFontName = 0,
        int nSize = 0);
# 160 "Cacao/include/cocos2dx/platform/CCImage.h"
    unsigned char * getData() { return m_pData; }
    int getDataLen() { return m_nWidth * m_nHeight; }


    bool hasAlpha() { return m_bHasAlpha; }
    bool isPremultipliedAlpha() { return m_bPreMulti; }







    bool saveToFile(const char *pszFilePath, bool bIsToRGB = true);

    protected: unsigned short m_nWidth;public: unsigned short getWidth(void) const { return m_nWidth; };
    protected: unsigned short m_nHeight;public: unsigned short getHeight(void) const { return m_nHeight; };
    protected: int m_nBitsPerComponent;public: int getBitsPerComponent(void) const { return m_nBitsPerComponent; };

protected:
    bool _initWithJpgData(void *pData, int nDatalen);
    bool _initWithPngData(void *pData, int nDatalen);
    bool _initWithTiffData(void *pData, int nDataLen);
    bool _initWithWebpData(void *pData, int nDataLen);

    bool _initWithRawData(void *pData, int nDatalen, int nWidth, int nHeight, int nBitsPerComponent, bool bPreMulti);

    bool _saveImageToPNG(const char *pszFilePath, bool bIsToRGB = true);
    bool _saveImageToJPG(const char *pszFilePath);

    unsigned char *m_pData;
    bool m_bHasAlpha;
    bool m_bPreMulti;





private:

    CCImage(const CCImage& rImg);
    CCImage & operator=(const CCImage&);


};




}
# 131 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/CCSAXParser.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCSAXParser.h"
namespace cocos2d {






typedef unsigned char CC_XML_CHAR;





class CCSAXDelegator
{
public:
    virtual void startElement(void *ctx, const char *name, const char **atts) = 0;
    virtual void endElement(void *ctx, const char *name) = 0;
    virtual void textHandler(void *ctx, const char *s, int len) = 0;
};





class CCSAXParser
{
    CCSAXDelegator* m_pDelegator;
public:

    CCSAXParser();
    ~CCSAXParser(void);

    bool init(const char *pszEncoding);
    bool parse(const char* pXMLData, unsigned int uDataLength);
    bool parse(const char *pszFile);
    void setDelegator(CCSAXDelegator* pDelegator);

    static void startElement(void *ctx, const CC_XML_CHAR *name, const CC_XML_CHAR **atts);
    static void endElement(void *ctx, const CC_XML_CHAR *name);
    static void textHandler(void *ctx, const CC_XML_CHAR *name, int len);
};




}
# 132 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/CCThread.h" 1
# 31 "Cacao/include/cocos2dx/platform/CCThread.h"
namespace cocos2d {
# 43 "Cacao/include/cocos2dx/platform/CCThread.h"
class CCThread
{
public:
    CCThread() : m_pAutoreasePool(0) {}
    ~CCThread();

    void createAutoreleasePool();

private:
    void *m_pAutoreasePool;
};




}
# 133 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/platform.h" 1
# 31 "Cacao/include/cocos2dx/platform/platform.h"
namespace cocos2d {






struct cc_timeval
{



    long tv_sec;

    int tv_usec;
};

class CCTime
{
public:
    static int gettimeofdayCocos2d(struct cc_timeval *tp, void *tzp);
    static double timersubCocos2d(struct cc_timeval *start, struct cc_timeval *end);
};




}
# 134 "Cacao/include/cocos2dx/cocos2d.h" 2
# 189 "Cacao/include/cocos2dx/cocos2d.h"
# 1 "Cacao/include/cocos2dx/platform/mac/CCApplication.h" 1
# 29 "Cacao/include/cocos2dx/platform/mac/CCApplication.h"
# 1 "Cacao/include/cocos2dx/platform/CCApplicationProtocol.h" 1
# 28 "Cacao/include/cocos2dx/platform/CCApplicationProtocol.h"
namespace cocos2d {

enum TargetPlatform
{
    kTargetWindows,
    kTargetLinux,
    kTargetMacOS,
    kTargetAndroid,
    kTargetIphone,
    kTargetIpad,
    kTargetBlackBerry,
    kTargetNaCl,
    kTargetEmscripten,
    kTargetTizen,
    kTargetWinRT,
    kTargetWP8
};
# 53 "Cacao/include/cocos2dx/platform/CCApplicationProtocol.h"
class CCApplicationProtocol
{
public:

    virtual ~CCApplicationProtocol() {}






    virtual bool applicationDidFinishLaunching() = 0;





    virtual void applicationDidEnterBackground() = 0;





    virtual void applicationWillEnterForeground() = 0;





    virtual void setAnimationInterval(double interval) = 0;





    virtual ccLanguageType getCurrentLanguage() = 0;




    virtual TargetPlatform getTargetPlatform() = 0;
};




}
# 30 "Cacao/include/cocos2dx/platform/mac/CCApplication.h" 2


namespace cocos2d {

class CCApplication : public CCApplicationProtocol
{
public:
    CCApplication();
    virtual ~CCApplication();





    virtual void setAnimationInterval(double interval);
# 53 "Cacao/include/cocos2dx/platform/mac/CCApplication.h"
    int run();





    static CCApplication* sharedApplication();





    virtual ccLanguageType getCurrentLanguage();




    virtual TargetPlatform getTargetPlatform();





    __attribute__((deprecated)) void setResourceRootPath(const std::string& rootResDir);





    __attribute__((deprecated)) const std::string& getResourceRootPath(void);

    void setStartupScriptFilename(const std::string& startupScriptFile);

    const std::string& getStartupScriptFilename(void);

protected:
    static CCApplication * sm_pSharedApplication;

    std::string m_resourceRootPath;
    std::string m_startupScriptFilename;
};

}
# 190 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/mac/CCEGLView.h" 1
# 29 "Cacao/include/cocos2dx/platform/mac/CCEGLView.h"
# 1 "Cacao/include/cocos2dx/platform/CCEGLViewProtocol.h" 1





enum ResolutionPolicy
{


    kResolutionExactFit,


    kResolutionNoBorder,


    kResolutionShowAll,




    kResolutionFixedHeight,




    kResolutionFixedWidth,

    kResolutionUnKnown,
};

namespace cocos2d {



class EGLTouchDelegate;
class CCSet;







class CCEGLViewProtocol
{
public:



    CCEGLViewProtocol();



    virtual ~CCEGLViewProtocol();




    virtual void end() = 0;




    virtual bool isOpenGLReady() = 0;




    virtual void swapBuffers() = 0;




    virtual void setIMEKeyboardState(bool bOpen) = 0;





    virtual const CCSize& getFrameSize() const;




    virtual void setFrameSize(float width, float height);




    virtual CCSize getVisibleSize() const;




    virtual CCPoint getVisibleOrigin() const;
# 106 "Cacao/include/cocos2dx/platform/CCEGLViewProtocol.h"
    virtual void setDesignResolutionSize(float width, float height, ResolutionPolicy resolutionPolicy);




    virtual const CCSize& getDesignResolutionSize() const;


    virtual void setTouchDelegate(EGLTouchDelegate * pDelegate);




    virtual void setViewPortInPoints(float x , float y , float w , float h);




    virtual void setScissorInPoints(float x , float y , float w , float h);





    virtual bool isScissorEnabled();





    virtual CCRect getScissorRect();



    virtual void setViewName(const char* pszViewName);



    const char* getViewName();




    virtual void handleTouchesBegin(int num, int ids[], float xs[], float ys[]);



    virtual void handleTouchesMove(int num, int ids[], float xs[], float ys[]);



    virtual void handleTouchesEnd(int num, int ids[], float xs[], float ys[]);



    virtual void handleTouchesCancel(int num, int ids[], float xs[], float ys[]);




    const CCRect& getViewPortRect() const;




    float getScaleX() const;




    float getScaleY() const;
private:
    void getSetOfTouchesEndOrCancel(CCSet& set, int num, int ids[], float xs[], float ys[]);

protected:
    EGLTouchDelegate* m_pDelegate;


    CCSize m_obScreenSize;

    CCSize m_obDesignResolutionSize;

    CCRect m_obViewPortRect;

    char m_szViewName[50];

    float m_fScaleX;
    float m_fScaleY;
    ResolutionPolicy m_eResolutionPolicy;
};




}
# 30 "Cacao/include/cocos2dx/platform/mac/CCEGLView.h" 2

namespace cocos2d {

class CCSet;
class CCTouch;
class CCSize;

class CCEGLView : public CCEGLViewProtocol
{
public:
    static CCEGLView* sharedOpenGLView(void);

    virtual ~CCEGLView(void);

    virtual bool isOpenGLReady(void);
    virtual bool setContentScaleFactor(float contentScaleFactor);
    virtual void end();
    virtual void swapBuffers(void);



    virtual void setViewPortInPoints(float x , float y , float w , float h);
    virtual void setScissorInPoints(float x , float y , float w , float h);

    virtual void setIMEKeyboardState(bool bOpen);
 virtual void setMultiTouchMask(bool mask);

private:
    static CCEGLView* s_sharedView;

    CCEGLView(void);
};

}
# 191 "Cacao/include/cocos2dx/cocos2d.h" 2
# 247 "Cacao/include/cocos2dx/cocos2d.h"
# 1 "Cacao/include/cocos2dx/shaders/CCShaderCache.h" 1
# 32 "Cacao/include/cocos2dx/shaders/CCShaderCache.h"
namespace cocos2d {

class CCGLProgram;
# 45 "Cacao/include/cocos2dx/shaders/CCShaderCache.h"
class CCShaderCache : public CCObject
{
public:



    CCShaderCache();




    virtual ~CCShaderCache();



    static CCShaderCache* sharedShaderCache();


    static void purgeSharedShaderCache();


    void loadDefaultShaders();


    void reloadDefaultShaders();






    CCGLProgram * programForKey(const char* key);


    void addProgram(CCGLProgram* program, const char* key);

private:
    bool init();
    void loadDefaultShader(CCGLProgram *program, int type);

    CCDictionary* m_pPrograms;

};




}
# 248 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/shaders/ccShaders.h" 1
# 31 "Cacao/include/cocos2dx/shaders/ccShaders.h"
namespace cocos2d {






extern const GLchar * ccPosition_uColor_frag;
extern const GLchar * ccPosition_uColor_vert;

extern const GLchar * ccPositionColor_frag;
extern const GLchar * ccPositionColor_vert;

extern const GLchar * ccPositionTexture_frag;
extern const GLchar * ccPositionTexture_vert;

extern const GLchar * ccPositionTextureA8Color_frag;
extern const GLchar * ccPositionTextureA8Color_vert;

extern const GLchar * ccPositionTextureColor_frag;
extern const GLchar * ccPositionTextureColor_vert;

extern const GLchar * ccPositionTextureColorAlphaTest_frag;

extern const GLchar * ccPositionTexture_uColor_frag;
extern const GLchar * ccPositionTexture_uColor_vert;

extern const GLchar * ccPositionColorLengthTexture_frag;
extern const GLchar * ccPositionColorLengthTexture_vert;

extern const GLchar * ccExSwitchMask_frag;




}
# 249 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/sprite_nodes/CCAnimationCache.h" 1
# 34 "Cacao/include/cocos2dx/sprite_nodes/CCAnimationCache.h"
namespace cocos2d {

class CCAnimation;
# 50 "Cacao/include/cocos2dx/sprite_nodes/CCAnimationCache.h"
class CCAnimationCache : public CCObject
{
public:



    CCAnimationCache();




    ~CCAnimationCache();



    static CCAnimationCache* sharedAnimationCache(void);



    static void purgeSharedAnimationCache(void);



    void addAnimation(CCAnimation *animation, const char * name);




    void removeAnimationByName(const char* name);






    CCAnimation* animationByName(const char* name);






    void addAnimationsWithDictionary(CCDictionary* dictionary,const char* plist = __null);






    void addAnimationsWithFile(const char* plist);

    bool init(void);

private:
    void parseVersion1(CCDictionary* animations);
    void parseVersion2(CCDictionary* animations);
private:
    CCDictionary* m_pAnimations;
    static CCAnimationCache* s_pSharedAnimationCache;
};




}
# 253 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrameCache.h" 1
# 43 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrameCache.h"
namespace cocos2d {

class CCDictionary;
class CCArray;
class CCSprite;
# 58 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrameCache.h"
class CCSpriteFrameCache : public CCObject
{
protected:




    CCSpriteFrameCache(void) : m_pSpriteFrames(__null), m_pSpriteFramesAliases(__null){}
public:
    bool init(void);




    ~CCSpriteFrameCache(void);

private:


    void addSpriteFramesWithDictionary(CCDictionary* pobDictionary, CCTexture2D *pobTexture);
public:





    void addSpriteFramesWithFile(const char *pszPlist);





    void addSpriteFramesWithFile(const char* plist, const char* textureFileName);




    void addSpriteFramesWithFile(const char *pszPlist, CCTexture2D *pobTexture);




    void addSpriteFrame(CCSpriteFrame *pobFrame, const char *pszFrameName);







    void removeSpriteFrames(void);





    void removeUnusedSpriteFrames(void);




    void removeSpriteFrameByName(const char *pszName);






    void removeSpriteFramesFromFile(const char* plist);

private:



    void removeSpriteFramesFromDictionary(CCDictionary* dictionary);
public:




    void removeSpriteFramesFromTexture(CCTexture2D* texture);






    CCSpriteFrame* spriteFrameByName(const char *pszName);

public:



    static CCSpriteFrameCache* sharedSpriteFrameCache(void);


    static void purgeSharedSpriteFrameCache(void);

private:


protected:
    CCDictionary* m_pSpriteFrames;
    CCDictionary* m_pSpriteFramesAliases;
    std::set<std::string>* m_pLoadedFileNames;
};




}
# 257 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/support/ccUTF8.h" 1
# 14 "Cacao/include/cocos2dx/support/ccUTF8.h"
namespace cocos2d {

       int cc_wcslen(const unsigned short* str);

       void cc_utf8_trim_ws(std::vector<unsigned short>* str);
# 27 "Cacao/include/cocos2dx/support/ccUTF8.h"
       bool isspace_unicode(unsigned short ch);
# 41 "Cacao/include/cocos2dx/support/ccUTF8.h"
       long
cc_utf8_strlen (const char * p, int max);







       unsigned int cc_utf8_find_last_not_char(std::vector<unsigned short> str, unsigned short c);

       std::vector<unsigned short> cc_utf16_vec_from_utf16_str(const unsigned short* str);
# 62 "Cacao/include/cocos2dx/support/ccUTF8.h"
       unsigned short* cc_utf8_to_utf16(const char* str_old, int length = -1, int* rUtf16Size = __null);
# 89 "Cacao/include/cocos2dx/support/ccUTF8.h"
       char *
cc_utf16_to_utf8 (const unsigned short *str,
                  long len,
                  long *items_read,
                  long *items_written);

}
# 260 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCNotificationCenter.h" 1
# 31 "Cacao/include/cocos2dx/support/CCNotificationCenter.h"
namespace cocos2d {



class CCNotificationCenter : public CCObject
{
public:

    CCNotificationCenter();


    ~CCNotificationCenter();


    static CCNotificationCenter *sharedNotificationCenter(void);


    static void purgeNotificationCenter(void);







    void addObserver(CCObject *target,
                     SEL_CallFuncO selector,
                     const char *name,
                     CCObject *obj);





    void removeObserver(CCObject *target,const char *name);





    int removeAllObservers(CCObject *target);





    void registerScriptObserver(CCObject *target,int handler,const char* name);


    void unregisterScriptObserver(CCObject *target,const char* name);




    void postNotification(const char *name);





    void postNotification(const char *name, CCObject *object);





    inline int getScriptHandler() { return m_scriptHandler; };





    int getObserverHandlerByName(const char* name);
private:



    bool observerExisted(CCObject *target,const char *name);



    CCArray *m_observers;
    int m_scriptHandler;
};





class CCNotificationObserver : public CCObject
{
public:






    CCNotificationObserver(CCObject *target,
                           SEL_CallFuncO selector,
                           const char *name,
                           CCObject *obj);


    ~CCNotificationObserver();


    void performSelector(CCObject *obj);
private:
    protected: CCObject * m_target;public: virtual CCObject * getTarget(void);;
    protected: SEL_CallFuncO m_selector;public: virtual SEL_CallFuncO getSelector(void);;
    protected: char * m_name;public: virtual char * getName(void);;
    protected: CCObject * m_object;public: virtual CCObject * getObject(void);;
    protected: int m_nHandler;public: virtual int getHandler(void);public: virtual void setHandler(int var);;
};

}
# 261 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCPointExtension.h" 1
# 49 "Cacao/include/cocos2dx/support/CCPointExtension.h"
namespace cocos2d {
# 66 "Cacao/include/cocos2dx/support/CCPointExtension.h"
static inline CCPoint
ccpNeg(const CCPoint& v)
{
    return -v;
}





static inline CCPoint
ccpAdd(const CCPoint& v1, const CCPoint& v2)
{
    return v1 + v2;
}





static inline CCPoint
ccpSub(const CCPoint& v1, const CCPoint& v2)
{
    return v1 - v2;
}





static inline CCPoint
ccpMult(const CCPoint& v, const float s)
{
    return v * s;
}





static inline CCPoint
ccpMidpoint(const CCPoint& v1, const CCPoint& v2)
{
    return (v1 + v2) / 2.f;
}





static inline float
ccpDot(const CCPoint& v1, const CCPoint& v2)
{
    return v1.dot(v2);
}





static inline float
ccpCross(const CCPoint& v1, const CCPoint& v2)
{
    return v1.cross(v2);
}





static inline CCPoint
ccpPerp(const CCPoint& v)
{
    return v.getPerp();
}





static inline CCPoint
ccpRPerp(const CCPoint& v)
{
    return v.getRPerp();
}





static inline CCPoint
ccpProject(const CCPoint& v1, const CCPoint& v2)
{
    return v1.project(v2);
}





static inline CCPoint
ccpRotate(const CCPoint& v1, const CCPoint& v2)
{
    return v1.rotate(v2);
}





static inline CCPoint
ccpUnrotate(const CCPoint& v1, const CCPoint& v2)
{
    return v1.unrotate(v2);
}





static inline float
ccpLengthSQ(const CCPoint& v)
{
    return v.getLengthSq();
}






static inline float
ccpDistanceSQ(const CCPoint p1, const CCPoint p2)
{
    return (p1 - p2).getLengthSq();
}






float ccpLength(const CCPoint& v);





float ccpDistance(const CCPoint& v1, const CCPoint& v2);





CCPoint ccpNormalize(const CCPoint& v);





CCPoint ccpForAngle(const float a);





float ccpToAngle(const CCPoint& v);





float clampf(float value, float min_inclusive, float max_inclusive);




CCPoint ccpClamp(const CCPoint& p, const CCPoint& from, const CCPoint& to);




CCPoint ccpFromSize(const CCSize& s);
# 257 "Cacao/include/cocos2dx/support/CCPointExtension.h"
CCPoint ccpCompOp(const CCPoint& p, float (*opFunc)(float));
# 266 "Cacao/include/cocos2dx/support/CCPointExtension.h"
CCPoint ccpLerp(const CCPoint& a, const CCPoint& b, float alpha);





bool ccpFuzzyEqual(const CCPoint& a, const CCPoint& b, float variance);






CCPoint ccpCompMult(const CCPoint& a, const CCPoint& b);




float ccpAngleSigned(const CCPoint& a, const CCPoint& b);




float ccpAngle(const CCPoint& a, const CCPoint& b);
# 298 "Cacao/include/cocos2dx/support/CCPointExtension.h"
CCPoint ccpRotateByAngle(const CCPoint& v, const CCPoint& pivot, float angle);
# 321 "Cacao/include/cocos2dx/support/CCPointExtension.h"
bool ccpLineIntersect(const CCPoint& p1, const CCPoint& p2,
                      const CCPoint& p3, const CCPoint& p4,
                      float *s, float *t);





bool ccpSegmentIntersect(const CCPoint& A, const CCPoint& B, const CCPoint& C, const CCPoint& D);





CCPoint ccpIntersectPoint(const CCPoint& A, const CCPoint& B, const CCPoint& C, const CCPoint& D);




}
# 262 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCProfiling.h" 1
# 34 "Cacao/include/cocos2dx/support/CCProfiling.h"
namespace cocos2d {






class CCProfilingTimer;
# 51 "Cacao/include/cocos2dx/support/CCProfiling.h"
class CCProfiler : public CCObject
{
public:
    ~CCProfiler(void);

    void displayTimers(void);
    bool init(void);

public:
    static CCProfiler* sharedProfiler(void);

    CCProfilingTimer* createAndAddTimerWithName(const char* timerName);

    void releaseTimer(const char* timerName);

    void releaseAllTimers();

    CCDictionary* m_pActiveTimers;
};




class CCProfilingTimer : public CCObject
{
public:
    CCProfilingTimer();
    ~CCProfilingTimer();
    bool initWithName(const char* timerName);
    const char* description(void);
    struct cc_timeval* getStartTime(void) { return &m_sStartTime; };

    void reset();

    std::string m_NameStr;
    int numberOfCalls;
    int m_dAverageTime1;
    int m_dAverageTime2;
    long long totalTime;
    int minTime;
    int maxTime;
    struct cc_timeval m_sStartTime;
};

extern void CCProfilingBeginTimingBlock(const char *timerName);
extern void CCProfilingEndTimingBlock(const char *timerName);
extern void CCProfilingResetTimingBlock(const char *timerName);






extern bool kCCProfilerCategorySprite;
extern bool kCCProfilerCategoryBatchSprite;
extern bool kCCProfilerCategoryParticles;




}
# 263 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/user_default/CCUserDefault.h" 1
# 30 "Cacao/include/cocos2dx/support/user_default/CCUserDefault.h"
namespace cocos2d {
# 45 "Cacao/include/cocos2dx/support/user_default/CCUserDefault.h"
class CCUserDefault
{
public:
    ~CCUserDefault();







    bool getBoolForKey(const char* pKey);
    bool getBoolForKey(const char* pKey, bool defaultValue);




    int getIntegerForKey(const char* pKey);
    int getIntegerForKey(const char* pKey, int defaultValue);




    float getFloatForKey(const char* pKey);
    float getFloatForKey(const char* pKey, float defaultValue);




    double getDoubleForKey(const char* pKey);
    double getDoubleForKey(const char* pKey, double defaultValue);




    std::string getStringForKey(const char* pKey);
    std::string getStringForKey(const char* pKey, const std::string & defaultValue);






    void setBoolForKey(const char* pKey, bool value);



    void setIntegerForKey(const char* pKey, int value);



    void setFloatForKey(const char* pKey, float value);



    void setDoubleForKey(const char* pKey, double value);



    void setStringForKey(const char* pKey, const std::string & value);



    void flush();

    static CCUserDefault* sharedUserDefault();
    static void purgeSharedUserDefault();
    const static std::string& getXMLFilePath();
    static bool isXMLFileExist();

private:
    CCUserDefault();
    static bool createXMLFile();
    static void initXMLFilePath();

    static CCUserDefault* m_spUserDefault;
    static std::string m_sFilePath;
    static bool m_sbIsFilePathInitialized;
};




}
# 264 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCVertex.h" 1
# 30 "Cacao/include/cocos2dx/support/CCVertex.h"
namespace cocos2d {
# 40 "Cacao/include/cocos2dx/support/CCVertex.h"
void ccVertexLineToPolygon(CCPoint *points, float stroke, ccVertex2F *vertices, unsigned int offset, unsigned int nuPoints);


bool ccVertexLineIntersect(float Ax, float Ay,
                             float Bx, float By,
                             float Cx, float Cy,
                             float Dx, float Dy, float *T);




}
# 265 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h" 1
# 104 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
static const int TIXML2_MAJOR_VERSION = 1;
static const int TIXML2_MINOR_VERSION = 0;
static const int TIXML2_PATCH_VERSION = 9;

namespace tinyxml2
{
class XMLDocument;
class XMLElement;
class XMLAttribute;
class XMLComment;
class XMLNode;
class XMLText;
class XMLDeclaration;
class XMLUnknown;

class XMLPrinter;







class StrPair
{
public:
    enum {
        NEEDS_ENTITY_PROCESSING = 0x01,
        NEEDS_NEWLINE_NORMALIZATION = 0x02,
        COLLAPSE_WHITESPACE = 0x04,

        TEXT_ELEMENT = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        TEXT_ELEMENT_LEAVE_ENTITIES = NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_NAME = 0,
        ATTRIBUTE_VALUE = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_VALUE_LEAVE_ENTITIES = NEEDS_NEWLINE_NORMALIZATION,
        COMMENT = NEEDS_NEWLINE_NORMALIZATION
    };

    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}
    ~StrPair();

    void Set( char* start, char* end, int flags ) {
        Reset();
        _start = start;
        _end = end;
        _flags = flags | NEEDS_FLUSH;
    }

    const char* GetStr();

    bool Empty() const {
        return _start == _end;
    }

    void SetInternedStr( const char* str ) {
        Reset();
        _start = const_cast<char*>(str);
    }

    void SetStr( const char* str, int flags=0 );

    char* ParseText( char* in, const char* endTag, int strFlags );
    char* ParseName( char* in );

private:
    void Reset();
    void CollapseWhitespace();

    enum {
        NEEDS_FLUSH = 0x100,
        NEEDS_DELETE = 0x200
    };


    int _flags;
    char* _start;
    char* _end;
};







template <class T, int INIT>
class DynArray
{
public:
    DynArray< T, INIT >() {
        _mem = _pool;
        _allocated = INIT;
        _size = 0;
    }

    ~DynArray() {
        if ( _mem != _pool ) {
            delete [] _mem;
        }
    }

    void Push( T t ) {
        EnsureCapacity( _size+1 );
        _mem[_size++] = t;
    }

    T* PushArr( int count ) {
        EnsureCapacity( _size+count );
        T* ret = &_mem[_size];
        _size += count;
        return ret;
    }

    T Pop() {
        return _mem[--_size];
    }

    void PopArr( int count ) {
        {};
        _size -= count;
    }

    bool Empty() const {
        return _size == 0;
    }

    T& operator[](int i) {
        {};
        return _mem[i];
    }

    const T& operator[](int i) const {
        {};
        return _mem[i];
    }

    int Size() const {
        return _size;
    }

    int Capacity() const {
        return _allocated;
    }

    const T* Mem() const {
        return _mem;
    }

    T* Mem() {
        return _mem;
    }

private:
    void EnsureCapacity( int cap ) {
        if ( cap > _allocated ) {
            int newAllocated = cap * 2;
            T* newMem = new T[newAllocated];
            memcpy( newMem, _mem, sizeof(T)*_size );
            if ( _mem != _pool ) {
                delete [] _mem;
            }
            _mem = newMem;
            _allocated = newAllocated;
        }
    }

    T* _mem;
    T _pool[INIT];
    int _allocated;
    int _size;
};






class MemPool
{
public:
    MemPool() {}
    virtual ~MemPool() {}

    virtual int ItemSize() const = 0;
    virtual void* Alloc() = 0;
    virtual void Free( void* ) = 0;
    virtual void SetTracked() = 0;
};





template< int SIZE >
class MemPoolT : public MemPool
{
public:
    MemPoolT() : _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0) {}
    ~MemPoolT() {

        for( int i=0; i<_blockPtrs.Size(); ++i ) {
            delete _blockPtrs[i];
        }
    }

    virtual int ItemSize() const {
        return SIZE;
    }
    int CurrentAllocs() const {
        return _currentAllocs;
    }

    virtual void* Alloc() {
        if ( !_root ) {

            Block* block = new Block();
            _blockPtrs.Push( block );

            for( int i=0; i<COUNT-1; ++i ) {
                block->chunk[i].next = &block->chunk[i+1];
            }
            block->chunk[COUNT-1].next = 0;
            _root = block->chunk;
        }
        void* result = _root;
        _root = _root->next;

        ++_currentAllocs;
        if ( _currentAllocs > _maxAllocs ) {
            _maxAllocs = _currentAllocs;
        }
        _nAllocs++;
        _nUntracked++;
        return result;
    }
    virtual void Free( void* mem ) {
        if ( !mem ) {
            return;
        }
        --_currentAllocs;
        Chunk* chunk = (Chunk*)mem;



        chunk->next = _root;
        _root = chunk;
    }
    void Trace( const char* name ) {
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
                name, _maxAllocs, _maxAllocs*SIZE/1024, _currentAllocs, SIZE, _nAllocs, _blockPtrs.Size() );
    }

    void SetTracked() {
        _nUntracked--;
    }

    int Untracked() const {
        return _nUntracked;
    }

    enum { COUNT = 1024/SIZE };

private:
    union Chunk {
        Chunk* next;
        char mem[SIZE];
    };
    struct Block {
        Chunk chunk[COUNT];
    };
    DynArray< Block*, 10 > _blockPtrs;
    Chunk* _root;

    int _currentAllocs;
    int _nAllocs;
    int _maxAllocs;
    int _nUntracked;
};
# 405 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLVisitor
{
public:
    virtual ~XMLVisitor() {}


    virtual bool VisitEnter( const XMLDocument& ) {
        return true;
    }

    virtual bool VisitExit( const XMLDocument& ) {
        return true;
    }


    virtual bool VisitEnter( const XMLElement& , const XMLAttribute* ) {
        return true;
    }

    virtual bool VisitExit( const XMLElement& ) {
        return true;
    }


    virtual bool Visit( const XMLDeclaration& ) {
        return true;
    }

    virtual bool Visit( const XMLText& ) {
        return true;
    }

    virtual bool Visit( const XMLComment& ) {
        return true;
    }

    virtual bool Visit( const XMLUnknown& ) {
        return true;
    }
};





class XMLUtil
{
public:


    static const char* SkipWhiteSpace( const char* p ) {
        while( !IsUTF8Continuation(*p) && isspace( *reinterpret_cast<const unsigned char*>(p) ) ) {
            ++p;
        }
        return p;
    }
    static char* SkipWhiteSpace( char* p ) {
        while( !IsUTF8Continuation(*p) && isspace( *reinterpret_cast<unsigned char*>(p) ) ) {
            ++p;
        }
        return p;
    }
    static bool IsWhiteSpace( char p ) {
        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );
    }

    inline static bool StringEqual( const char* p, const char* q, int nChar=2147483647 ) {
        int n = 0;
        if ( p == q ) {
            return true;
        }
        while( *p && *q && *p == *q && n<nChar ) {
            ++p;
            ++q;
            ++n;
        }
        if ( (n == nChar) || ( *p == 0 && *q == 0 ) ) {
            return true;
        }
        return false;
    }
    inline static int IsUTF8Continuation( const char p ) {
        return p & 0x80;
    }
    inline static int IsAlphaNum( unsigned char anyByte ) {
        return ( anyByte < 128 ) ? isalnum( anyByte ) : 1;
    }
    inline static int IsAlpha( unsigned char anyByte ) {
        return ( anyByte < 128 ) ? isalpha( anyByte ) : 1;
    }

    static const char* ReadBOM( const char* p, bool* hasBOM );


    static const char* GetCharacterRef( const char* p, char* value, int* length );
    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );


    static void ToStr( int v, char* buffer, int bufferSize );
    static void ToStr( unsigned v, char* buffer, int bufferSize );
    static void ToStr( bool v, char* buffer, int bufferSize );
    static void ToStr( float v, char* buffer, int bufferSize );
    static void ToStr( double v, char* buffer, int bufferSize );


    static bool ToInt( const char* str, int* value );
    static bool ToUnsigned( const char* str, unsigned* value );
    static bool ToBool( const char* str, bool* value );
    static bool ToFloat( const char* str, float* value );
    static bool ToDouble( const char* str, double* value );
};
# 543 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLNode
{
    friend class XMLDocument;
    friend class XMLElement;
public:


    const XMLDocument* GetDocument() const {
        return _document;
    }

    XMLDocument* GetDocument() {
        return _document;
    }


    virtual XMLElement* ToElement() {
        return 0;
    }

    virtual XMLText* ToText() {
        return 0;
    }

    virtual XMLComment* ToComment() {
        return 0;
    }

    virtual XMLDocument* ToDocument() {
        return 0;
    }

    virtual XMLDeclaration* ToDeclaration() {
        return 0;
    }

    virtual XMLUnknown* ToUnknown() {
        return 0;
    }

    virtual const XMLElement* ToElement() const {
        return 0;
    }
    virtual const XMLText* ToText() const {
        return 0;
    }
    virtual const XMLComment* ToComment() const {
        return 0;
    }
    virtual const XMLDocument* ToDocument() const {
        return 0;
    }
    virtual const XMLDeclaration* ToDeclaration() const {
        return 0;
    }
    virtual const XMLUnknown* ToUnknown() const {
        return 0;
    }
# 611 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    const char* Value() const {
        return _value.GetStr();
    }




    void SetValue( const char* val, bool staticMem=false );


    const XMLNode* Parent() const {
        return _parent;
    }

    XMLNode* Parent() {
        return _parent;
    }


    bool NoChildren() const {
        return !_firstChild;
    }


    const XMLNode* FirstChild() const {
        return _firstChild;
    }

    XMLNode* FirstChild() {
        return _firstChild;
    }




    const XMLElement* FirstChildElement( const char* value=0 ) const;

    XMLElement* FirstChildElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( value ));
    }


    const XMLNode* LastChild() const {
        return _lastChild;
    }

    XMLNode* LastChild() {
        return const_cast<XMLNode*>(const_cast<const XMLNode*>(this)->LastChild() );
    }




    const XMLElement* LastChildElement( const char* value=0 ) const;

    XMLElement* LastChildElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(value) );
    }


    const XMLNode* PreviousSibling() const {
        return _prev;
    }

    XMLNode* PreviousSibling() {
        return _prev;
    }


    const XMLElement* PreviousSiblingElement( const char* value=0 ) const ;

    XMLElement* PreviousSiblingElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( value ) );
    }


    const XMLNode* NextSibling() const {
        return _next;
    }

    XMLNode* NextSibling() {
        return _next;
    }


    const XMLElement* NextSiblingElement( const char* value=0 ) const;

    XMLElement* NextSiblingElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( value ) );
    }




    XMLNode* InsertEndChild( XMLNode* addThis );

    XMLNode* LinkEndChild( XMLNode* addThis ) {
        return InsertEndChild( addThis );
    }



    XMLNode* InsertFirstChild( XMLNode* addThis );



    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );




    void DeleteChildren();




    void DeleteChild( XMLNode* node );
# 738 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;







    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;
# 770 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    virtual bool Accept( XMLVisitor* visitor ) const = 0;


    virtual char* ParseDeep( char*, StrPair* );

protected:
    XMLNode( XMLDocument* );
    virtual ~XMLNode();
    XMLNode( const XMLNode& );
    XMLNode& operator=( const XMLNode& );

    XMLDocument* _document;
    XMLNode* _parent;
    mutable StrPair _value;

    XMLNode* _firstChild;
    XMLNode* _lastChild;

    XMLNode* _prev;
    XMLNode* _next;

private:
    MemPool* _memPool;
    void Unlink( XMLNode* child );
};
# 809 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLText : public XMLNode
{
    friend class XMLBase;
    friend class XMLDocument;
public:
    virtual bool Accept( XMLVisitor* visitor ) const;

    virtual XMLText* ToText() {
        return this;
    }
    virtual const XMLText* ToText() const {
        return this;
    }


    void SetCData( bool isCData ) {
        _isCData = isCData;
    }

    bool CData() const {
        return _isCData;
    }

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLText( XMLDocument* doc ) : XMLNode( doc ), _isCData( false ) {}
    virtual ~XMLText() {}
    XMLText( const XMLText& );
    XMLText& operator=( const XMLText& );

private:
    bool _isCData;
};



class XMLComment : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLComment* ToComment() {
        return this;
    }
    virtual const XMLComment* ToComment() const {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLComment( XMLDocument* doc );
    virtual ~XMLComment();
    XMLComment( const XMLComment& );
    XMLComment& operator=( const XMLComment& );

private:
};
# 886 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLDeclaration : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLDeclaration* ToDeclaration() {
        return this;
    }
    virtual const XMLDeclaration* ToDeclaration() const {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLDeclaration( XMLDocument* doc );
    virtual ~XMLDeclaration();
    XMLDeclaration( const XMLDeclaration& );
    XMLDeclaration& operator=( const XMLDeclaration& );
};
# 918 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLUnknown : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLUnknown* ToUnknown() {
        return this;
    }
    virtual const XMLUnknown* ToUnknown() const {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLUnknown( XMLDocument* doc );
    virtual ~XMLUnknown();
    XMLUnknown( const XMLUnknown& );
    XMLUnknown& operator=( const XMLUnknown& );
};


enum XMLError {
    XML_NO_ERROR = 0,
    XML_SUCCESS = 0,

    XML_NO_ATTRIBUTE,
    XML_WRONG_ATTRIBUTE_TYPE,

    XML_ERROR_FILE_NOT_FOUND,
    XML_ERROR_FILE_COULD_NOT_BE_OPENED,
    XML_ERROR_FILE_READ_ERROR,
    XML_ERROR_ELEMENT_MISMATCH,
    XML_ERROR_PARSING_ELEMENT,
    XML_ERROR_PARSING_ATTRIBUTE,
    XML_ERROR_IDENTIFYING_TAG,
    XML_ERROR_PARSING_TEXT,
    XML_ERROR_PARSING_CDATA,
    XML_ERROR_PARSING_COMMENT,
    XML_ERROR_PARSING_DECLARATION,
    XML_ERROR_PARSING_UNKNOWN,
    XML_ERROR_EMPTY_DOCUMENT,
    XML_ERROR_MISMATCHED_ELEMENT,
    XML_ERROR_PARSING,

    XML_CAN_NOT_CONVERT_TEXT,
    XML_NO_TEXT_NODE
};
# 977 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLAttribute
{
    friend class XMLElement;
public:

    const char* Name() const {
        return _name.GetStr();
    }

    const char* Value() const {
        return _value.GetStr();
    }

    const XMLAttribute* Next() const {
        return _next;
    }





    int IntValue() const {
        int i=0;
        QueryIntValue( &i );
        return i;
    }

    unsigned UnsignedValue() const {
        unsigned i=0;
        QueryUnsignedValue( &i );
        return i;
    }

    bool BoolValue() const {
        bool b=false;
        QueryBoolValue( &b );
        return b;
    }

    double DoubleValue() const {
        double d=0;
        QueryDoubleValue( &d );
        return d;
    }

    float FloatValue() const {
        float f=0;
        QueryFloatValue( &f );
        return f;
    }





    XMLError QueryIntValue( int* value ) const;

    XMLError QueryUnsignedValue( unsigned int* value ) const;

    XMLError QueryBoolValue( bool* value ) const;

    XMLError QueryDoubleValue( double* value ) const;

    XMLError QueryFloatValue( float* value ) const;


    void SetAttribute( const char* value );

    void SetAttribute( int value );

    void SetAttribute( unsigned value );

    void SetAttribute( bool value );

    void SetAttribute( double value );

    void SetAttribute( float value );

private:
    enum { BUF_SIZE = 200 };

    XMLAttribute() : _next( 0 ) {}
    virtual ~XMLAttribute() {}

    XMLAttribute( const XMLAttribute& );
    void operator=( const XMLAttribute& );
    void SetName( const char* name );

    char* ParseDeep( char* p, bool processEntities );

    mutable StrPair _name;
    mutable StrPair _value;
    XMLAttribute* _next;
    MemPool* _memPool;
};






class XMLElement : public XMLNode
{
    friend class XMLBase;
    friend class XMLDocument;
public:

    const char* Name() const {
        return Value();
    }

    void SetName( const char* str, bool staticMem=false ) {
        SetValue( str, staticMem );
    }

    virtual XMLElement* ToElement() {
        return this;
    }
    virtual const XMLElement* ToElement() const {
        return this;
    }
    virtual bool Accept( XMLVisitor* visitor ) const;
# 1123 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    const char* Attribute( const char* name, const char* value=0 ) const;






    int IntAttribute( const char* name ) const {
        int i=0;
        QueryIntAttribute( name, &i );
        return i;
    }

    unsigned UnsignedAttribute( const char* name ) const {
        unsigned i=0;
        QueryUnsignedAttribute( name, &i );
        return i;
    }

    bool BoolAttribute( const char* name ) const {
        bool b=false;
        QueryBoolAttribute( name, &b );
        return b;
    }

    double DoubleAttribute( const char* name ) const {
        double d=0;
        QueryDoubleAttribute( name, &d );
        return d;
    }

    float FloatAttribute( const char* name ) const {
        float f=0;
        QueryFloatAttribute( name, &f );
        return f;
    }
# 1173 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError QueryIntAttribute( const char* name, int* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryIntValue( value );
    }

    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryUnsignedValue( value );
    }

    XMLError QueryBoolAttribute( const char* name, bool* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryBoolValue( value );
    }

    XMLError QueryDoubleAttribute( const char* name, double* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryDoubleValue( value );
    }

    XMLError QueryFloatAttribute( const char* name, float* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryFloatValue( value );
    }


    void SetAttribute( const char* name, const char* value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, int value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, unsigned value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, bool value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, double value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }




    void DeleteAttribute( const char* name );


    const XMLAttribute* FirstAttribute() const {
        return _rootAttribute;
    }

    const XMLAttribute* FindAttribute( const char* name ) const;
# 1279 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    const char* GetText() const;
# 1307 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError QueryIntText( int* ival ) const;

    XMLError QueryUnsignedText( unsigned* uval ) const;

    XMLError QueryBoolText( bool* bval ) const;

    XMLError QueryDoubleText( double* dval ) const;

    XMLError QueryFloatText( float* fval ) const;


    enum {
        OPEN,
        CLOSED,
        CLOSING
    };
    int ClosingType() const {
        return _closingType;
    }
    char* ParseDeep( char* p, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

private:
    XMLElement( XMLDocument* doc );
    virtual ~XMLElement();
    XMLElement( const XMLElement& );
    void operator=( const XMLElement& );

    XMLAttribute* FindAttribute( const char* name );
    XMLAttribute* FindOrCreateAttribute( const char* name );

    char* ParseAttributes( char* p );

    int _closingType;



    XMLAttribute* _rootAttribute;
};


enum Whitespace {
    PRESERVE_WHITESPACE,
    COLLAPSE_WHITESPACE
};







class XMLDocument : public XMLNode
{
    friend class XMLElement;
public:

    XMLDocument( bool processEntities = true, Whitespace = PRESERVE_WHITESPACE );
    ~XMLDocument();

    virtual XMLDocument* ToDocument() {
        return this;
    }
    virtual const XMLDocument* ToDocument() const {
        return this;
    }
# 1385 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError Parse( const char* xml, size_t nBytes=(size_t)(-1) );






    XMLError LoadFile( const char* filename );
# 1401 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError LoadFile( FILE* );






    XMLError SaveFile( const char* filename, bool compact = false );
# 1417 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError SaveFile( FILE* fp, bool compact = false );

    bool ProcessEntities() const {
        return _processEntities;
    }
    Whitespace WhitespaceMode() const {
        return _whitespace;
    }




    bool HasBOM() const {
        return _writeBOM;
    }


    void SetBOM( bool useBOM ) {
        _writeBOM = useBOM;
    }




    XMLElement* RootElement() {
        return FirstChildElement();
    }
    const XMLElement* RootElement() const {
        return FirstChildElement();
    }
# 1462 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    void Print( XMLPrinter* streamer=0 );
    virtual bool Accept( XMLVisitor* visitor ) const;






    XMLElement* NewElement( const char* name );





    XMLComment* NewComment( const char* comment );





    XMLText* NewText( const char* text );
# 1494 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLDeclaration* NewDeclaration( const char* text=0 );





    XMLUnknown* NewUnknown( const char* text );





    void DeleteNode( XMLNode* node ) {
        node->_parent->DeleteChild( node );
    }

    void SetError( XMLError error, const char* str1, const char* str2 );


    bool Error() const {
        return _errorID != XML_NO_ERROR;
    }

    XMLError ErrorID() const {
        return _errorID;
    }

    const char* GetErrorStr1() const {
        return _errorStr1;
    }

    const char* GetErrorStr2() const {
        return _errorStr2;
    }

    void PrintError() const;


    char* Identify( char* p, XMLNode** node );

    virtual XMLNode* ShallowClone( XMLDocument* ) const {
        return 0;
    }
    virtual bool ShallowEqual( const XMLNode* ) const {
        return false;
    }

private:
    XMLDocument( const XMLDocument& );
    void operator=( const XMLDocument& );
    void InitDocument();

    bool _writeBOM;
    bool _processEntities;
    XMLError _errorID;
    Whitespace _whitespace;
    const char* _errorStr1;
    const char* _errorStr2;
    char* _charBuffer;

    MemPoolT< sizeof(XMLElement) > _elementPool;
    MemPoolT< sizeof(XMLAttribute) > _attributePool;
    MemPoolT< sizeof(XMLText) > _textPool;
    MemPoolT< sizeof(XMLComment) > _commentPool;
};
# 1616 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLHandle
{
public:

    XMLHandle( XMLNode* node ) {
        _node = node;
    }

    XMLHandle( XMLNode& node ) {
        _node = &node;
    }

    XMLHandle( const XMLHandle& ref ) {
        _node = ref._node;
    }

    XMLHandle& operator=( const XMLHandle& ref ) {
        _node = ref._node;
        return *this;
    }


    XMLHandle FirstChild() {
        return XMLHandle( _node ? _node->FirstChild() : 0 );
    }

    XMLHandle FirstChildElement( const char* value=0 ) {
        return XMLHandle( _node ? _node->FirstChildElement( value ) : 0 );
    }

    XMLHandle LastChild() {
        return XMLHandle( _node ? _node->LastChild() : 0 );
    }

    XMLHandle LastChildElement( const char* _value=0 ) {
        return XMLHandle( _node ? _node->LastChildElement( _value ) : 0 );
    }

    XMLHandle PreviousSibling() {
        return XMLHandle( _node ? _node->PreviousSibling() : 0 );
    }

    XMLHandle PreviousSiblingElement( const char* _value=0 ) {
        return XMLHandle( _node ? _node->PreviousSiblingElement( _value ) : 0 );
    }

    XMLHandle NextSibling() {
        return XMLHandle( _node ? _node->NextSibling() : 0 );
    }

    XMLHandle NextSiblingElement( const char* _value=0 ) {
        return XMLHandle( _node ? _node->NextSiblingElement( _value ) : 0 );
    }


    XMLNode* ToNode() {
        return _node;
    }

    XMLElement* ToElement() {
        return ( ( _node && _node->ToElement() ) ? _node->ToElement() : 0 );
    }

    XMLText* ToText() {
        return ( ( _node && _node->ToText() ) ? _node->ToText() : 0 );
    }

    XMLUnknown* ToUnknown() {
        return ( ( _node && _node->ToUnknown() ) ? _node->ToUnknown() : 0 );
    }

    XMLDeclaration* ToDeclaration() {
        return ( ( _node && _node->ToDeclaration() ) ? _node->ToDeclaration() : 0 );
    }

private:
    XMLNode* _node;
};






class XMLConstHandle
{
public:
    XMLConstHandle( const XMLNode* node ) {
        _node = node;
    }
    XMLConstHandle( const XMLNode& node ) {
        _node = &node;
    }
    XMLConstHandle( const XMLConstHandle& ref ) {
        _node = ref._node;
    }

    XMLConstHandle& operator=( const XMLConstHandle& ref ) {
        _node = ref._node;
        return *this;
    }

    const XMLConstHandle FirstChild() const {
        return XMLConstHandle( _node ? _node->FirstChild() : 0 );
    }
    const XMLConstHandle FirstChildElement( const char* value=0 ) const {
        return XMLConstHandle( _node ? _node->FirstChildElement( value ) : 0 );
    }
    const XMLConstHandle LastChild() const {
        return XMLConstHandle( _node ? _node->LastChild() : 0 );
    }
    const XMLConstHandle LastChildElement( const char* _value=0 ) const {
        return XMLConstHandle( _node ? _node->LastChildElement( _value ) : 0 );
    }
    const XMLConstHandle PreviousSibling() const {
        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );
    }
    const XMLConstHandle PreviousSiblingElement( const char* _value=0 ) const {
        return XMLConstHandle( _node ? _node->PreviousSiblingElement( _value ) : 0 );
    }
    const XMLConstHandle NextSibling() const {
        return XMLConstHandle( _node ? _node->NextSibling() : 0 );
    }
    const XMLConstHandle NextSiblingElement( const char* _value=0 ) const {
        return XMLConstHandle( _node ? _node->NextSiblingElement( _value ) : 0 );
    }


    const XMLNode* ToNode() const {
        return _node;
    }
    const XMLElement* ToElement() const {
        return ( ( _node && _node->ToElement() ) ? _node->ToElement() : 0 );
    }
    const XMLText* ToText() const {
        return ( ( _node && _node->ToText() ) ? _node->ToText() : 0 );
    }
    const XMLUnknown* ToUnknown() const {
        return ( ( _node && _node->ToUnknown() ) ? _node->ToUnknown() : 0 );
    }
    const XMLDeclaration* ToDeclaration() const {
        return ( ( _node && _node->ToDeclaration() ) ? _node->ToDeclaration() : 0 );
    }

private:
    const XMLNode* _node;
};
# 1807 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLPrinter : public XMLVisitor
{
public:






    XMLPrinter( FILE* file=0, bool compact = false );
    ~XMLPrinter() {}


    void PushHeader( bool writeBOM, bool writeDeclaration );



    void OpenElement( const char* name );

    void PushAttribute( const char* name, const char* value );
    void PushAttribute( const char* name, int value );
    void PushAttribute( const char* name, unsigned value );
    void PushAttribute( const char* name, bool value );
    void PushAttribute( const char* name, double value );

    void CloseElement();


    void PushText( const char* text, bool cdata=false );

    void PushText( int value );

    void PushText( unsigned value );

    void PushText( bool value );

    void PushText( float value );

    void PushText( double value );


    void PushComment( const char* comment );

    void PushDeclaration( const char* value );
    void PushUnknown( const char* value );

    virtual bool VisitEnter( const XMLDocument& );
    virtual bool VisitExit( const XMLDocument& ) {
        return true;
    }

    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute );
    virtual bool VisitExit( const XMLElement& element );

    virtual bool Visit( const XMLText& text );
    virtual bool Visit( const XMLComment& comment );
    virtual bool Visit( const XMLDeclaration& declaration );
    virtual bool Visit( const XMLUnknown& unknown );





    const char* CStr() const {
        return _buffer.Mem();
    }





    int CStrSize() const {
        return _buffer.Size();
    }

private:
    void SealElement();
    void PrintSpace( int depth );
    void PrintString( const char*, bool restrictedEntitySet );
    void Print( const char* format, ... );

    bool _elementJustOpened;
    bool _firstElement;
    FILE* _fp;
    int _depth;
    int _textDepth;
    bool _processEntities;
    bool _compactMode;

    enum {
        ENTITY_RANGE = 64,
        BUF_SIZE = 200
    };
    bool _entityFlag[ENTITY_RANGE];
    bool _restrictedEntityFlag[ENTITY_RANGE];

    DynArray< const char*, 10 > _stack;
    DynArray< char, 20 > _buffer;



};


}
# 266 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/text_input_node/CCIMEDelegate.h" 1
# 30 "Cacao/include/cocos2dx/text_input_node/CCIMEDelegate.h"
namespace cocos2d {






typedef struct
{
    CCRect begin;
    CCRect end;
    float duration;
} CCIMEKeyboardNotificationInfo;






class CCIMEDelegate
{
public:
    virtual ~CCIMEDelegate();

    virtual bool attachWithIME();
    virtual bool detachWithIME();

protected:
    friend class CCIMEDispatcher;






    virtual bool canAttachWithIME() { return false; }



    virtual void didAttachWithIME() {}




    virtual bool canDetachWithIME() { return false; }




    virtual void didDetachWithIME() {}




    virtual void insertText(const char * text, int len) {(void)text;(void)len;}




    virtual void deleteBackward() {}




    virtual const char * getContentText() { return 0; }




    virtual void keyboardWillShow(CCIMEKeyboardNotificationInfo& info) {(void)info;}
    virtual void keyboardDidShow(CCIMEKeyboardNotificationInfo& info) {(void)info;}
    virtual void keyboardWillHide(CCIMEKeyboardNotificationInfo& info) {(void)info;}
    virtual void keyboardDidHide(CCIMEKeyboardNotificationInfo& info) {(void)info;}

protected:
    CCIMEDelegate();
};




}
# 269 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h" 1
# 30 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h"
namespace cocos2d {
# 42 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h"
class CCIMEDispatcher
{
public:
    ~CCIMEDispatcher();




    static CCIMEDispatcher* sharedDispatcher();
# 60 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h"
    void dispatchInsertText(const char * pText, int nLen);




    void dispatchDeleteBackward();




    const char * getContentText();




    void dispatchKeyboardWillShow(CCIMEKeyboardNotificationInfo& info);
    void dispatchKeyboardDidShow(CCIMEKeyboardNotificationInfo& info);
    void dispatchKeyboardWillHide(CCIMEKeyboardNotificationInfo& info);
    void dispatchKeyboardDidHide(CCIMEKeyboardNotificationInfo& info);

protected:
    friend class CCIMEDelegate;




    void addDelegate(CCIMEDelegate * pDelegate);






    bool attachDelegateWithIME(CCIMEDelegate * pDelegate);
    bool detachDelegateWithIME(CCIMEDelegate * pDelegate);




    void removeDelegate(CCIMEDelegate * pDelegate);

private:
    CCIMEDispatcher();

    class Impl;
    Impl * m_pImpl;
};




}
# 270 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/text_input_node/CCTextFieldTTF.h" 1
# 32 "Cacao/include/cocos2dx/text_input_node/CCTextFieldTTF.h"
namespace cocos2d {

class CCTextFieldTTF;
# 43 "Cacao/include/cocos2dx/text_input_node/CCTextFieldTTF.h"
class CCTextFieldDelegate
{
public:



    virtual bool onTextFieldAttachWithIME(CCTextFieldTTF * sender)
    {
        (void)sender;
        return false;
    }




    virtual bool onTextFieldDetachWithIME(CCTextFieldTTF * sender)
    {
        (void)sender;
        return false;
    }




    virtual bool onTextFieldInsertText(CCTextFieldTTF * sender, const char * text, int nLen)
    {
        (void)sender;
        (void)text;
        (void)nLen;
        return false;
    }




    virtual bool onTextFieldDeleteBackward(CCTextFieldTTF * sender, const char * delText, int nLen)
    {
        (void)sender;
        (void)delText;
        (void)nLen;
        return false;
    }




    virtual bool onDraw(CCTextFieldTTF * sender)
    {
        (void)sender;
        return false;
    }
};





class CCTextFieldTTF : public CCLabelTTF, public CCIMEDelegate
{
public:



    CCTextFieldTTF();



    virtual ~CCTextFieldTTF();




    static CCTextFieldTTF * textFieldWithPlaceHolder(const char *placeholder, const CCSize& dimensions, CCTextAlignment alignment, const char *fontName, float fontSize);

    static CCTextFieldTTF * textFieldWithPlaceHolder(const char *placeholder, const char *fontName, float fontSize);

    bool initWithPlaceHolder(const char *placeholder, const CCSize& dimensions, CCTextAlignment alignment, const char *fontName, float fontSize);

    bool initWithPlaceHolder(const char *placeholder, const char *fontName, float fontSize);




    virtual bool attachWithIME();




    virtual bool detachWithIME();






    protected: CCTextFieldDelegate * m_pDelegate;public: CCTextFieldDelegate * getDelegate(void) const { return m_pDelegate; }public: void setDelegate(CCTextFieldDelegate * var){ m_pDelegate = var; };
    protected: int m_nCharCount;public: int getCharCount(void) const { return m_nCharCount; };
    virtual const ccColor3B& getColorSpaceHolder();
    virtual void setColorSpaceHolder(const ccColor3B& color);


public:
    virtual void setString(const char *text);
    virtual const char* getString(void);
protected:
    std::string * m_pInputText;



public:
    virtual void setPlaceHolder(const char * text);
    virtual const char * getPlaceHolder(void);
protected:
    std::string * m_pPlaceHolder;
    ccColor3B m_ColorSpaceHolder;
public:
    virtual void setSecureTextEntry(bool value);
    virtual bool isSecureTextEntry();

protected:
    bool m_bSecureTextEntry;
protected:

    virtual void draw();





    virtual bool canAttachWithIME();
    virtual bool canDetachWithIME();
    virtual void insertText(const char * text, int len);
    virtual void deleteBackward();
    virtual const char * getContentText();
private:
    class LengthStack;
    LengthStack * m_pLens;
};




}
# 271 "Cacao/include/cocos2dx/cocos2d.h" 2




# 1 "Cacao/include/cocos2dx/textures/CCTextureCache.h" 1
# 42 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
namespace cocos2d {

class CCLock;
class CCImage;
# 56 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
class CCTextureCache : public CCObject
{
protected:
    CCDictionary* m_pTextures;



private:

    void addImageAsyncCallBack(float dt);
public:




    CCTextureCache();




    virtual ~CCTextureCache();




    const char* description(void);



    CCDictionary* snapshotTextures();




    static CCTextureCache * sharedTextureCache();




    static void purgeSharedTextureCache();
# 105 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
    CCTexture2D* addImage(char const* filename, bool);
# 117 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
    void addImageAsync(const char *path, CCObject *target, SEL_CallFuncO selector);
# 133 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
    CCTexture2D* addUIImage(CCImage *image, const char *key);




    CCTexture2D* textureForKey(const char* key);







    bool reloadTexture(const char* fileName);







    void removeAllTextures();






    void removeUnusedTextures();



    void removeTexture(CCTexture2D* texture);




    void removeTextureForKey(const char *textureKeyName);






    void dumpCachedTextureInfo();





    CCTexture2D* addPVRImage(const char* filename);






    CCTexture2D* addETCImage(const char* filename);




    static void reloadAllTextures();

};
# 262 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
}
# 276 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/textures/CCTexturePVR.h" 1
# 34 "Cacao/include/cocos2dx/textures/CCTexturePVR.h"
namespace cocos2d {
# 44 "Cacao/include/cocos2dx/textures/CCTexturePVR.h"
struct CCPVRMipmap {
    unsigned char *address;
    unsigned int len;
};

typedef struct _ccPVRTexturePixelFormatInfo {
 GLenum internalFormat;
 GLenum format;
 GLenum type;
 uint32_t bpp;
 bool compressed;
 bool alpha;
 CCTexture2DPixelFormat ccPixelFormat;
} ccPVRTexturePixelFormatInfo;





enum {
    CC_PVRMIPMAP_MAX = 16,
};
# 92 "Cacao/include/cocos2dx/textures/CCTexturePVR.h"
class CCTexturePVR : public CCObject
{
public:
    CCTexturePVR();
    virtual ~CCTexturePVR();


    bool initWithContentsOfFile(const char* path);


    static CCTexturePVR* create(const char* path);




    inline unsigned int getName() { return m_uName; }

    inline unsigned int getWidth() { return m_uWidth; }

    inline unsigned int getHeight() { return m_uHeight; }

    inline bool hasAlpha() { return m_bHasAlpha; }

    inline bool hasPremultipliedAlpha() { return m_bHasPremultipliedAlpha; }

    inline bool isForcePremultipliedAlpha() { return m_bForcePremultipliedAlpha; }

    inline unsigned int getNumberOfMipmaps() { return m_uNumberOfMipmaps; }
    inline CCTexture2DPixelFormat getFormat() { return m_eFormat; }
    inline bool isRetainName() { return m_bRetainName; }
    inline void setRetainName(bool retainName) { m_bRetainName = retainName; }

private:
    bool unpackPVRv2Data(unsigned char* data, unsigned int len);
    bool unpackPVRv3Data(unsigned char* dataPointer, unsigned int dataLength);
    bool createGLTexture();

protected:
    struct CCPVRMipmap m_asMipmaps[CC_PVRMIPMAP_MAX];
    unsigned int m_uNumberOfMipmaps;

    unsigned int m_uWidth, m_uHeight;
    GLuint m_uName;
    bool m_bHasAlpha;
    bool m_bHasPremultipliedAlpha;
    bool m_bForcePremultipliedAlpha;


    bool m_bRetainName;
    CCTexture2DPixelFormat m_eFormat;

   const ccPVRTexturePixelFormatInfo *m_pPixelFormatInfo;
};




}
# 277 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCParallaxNode.h" 1
# 32 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCParallaxNode.h"
namespace cocos2d {

struct _ccArray;
# 46 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCParallaxNode.h"
class CCParallaxNode : public CCNode
{

    protected: struct _ccArray * m_pParallaxArray;public: virtual struct _ccArray * getParallaxArray(void) const { return m_pParallaxArray; }public: virtual void setParallaxArray(struct _ccArray * var){ m_pParallaxArray = var; }

public:





    CCParallaxNode();




    virtual ~CCParallaxNode();

    static CCParallaxNode * create();
    virtual void addChild(CCNode * child, unsigned int z, const CCPoint& parallaxRatio, const CCPoint& positionOffset);

    virtual void addChild(CCNode * child, unsigned int zOrder, int tag);
    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void removeAllChildrenWithCleanup(bool cleanup);
    virtual void visit(void);
private:
    CCPoint absolutePosition();
protected:
    CCPoint m_tLastPosition;
};




}
# 280 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h" 1
# 29 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXObjectGroup.h" 1
# 35 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXObjectGroup.h"
namespace cocos2d {
# 45 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXObjectGroup.h"
class CCTMXObjectGroup : public CCObject
{

    protected: CCPoint m_tPositionOffset;public: virtual const CCPoint& getPositionOffset(void) const { return m_tPositionOffset; }public: virtual void setPositionOffset(const CCPoint& var){ m_tPositionOffset = var; };

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;

    protected: CCArray* m_pObjects;public: virtual CCArray* getObjects(void);public: virtual void setObjects(CCArray* var);;
public:



    CCTMXObjectGroup();




    virtual ~CCTMXObjectGroup();

    inline const char* getGroupName(){ return m_sGroupName.c_str(); }
    inline void setGroupName(const char *groupName){ m_sGroupName = groupName; }


    CCString *propertyNamed(const char* propertyName);




    CCDictionary* objectNamed(const char *objectName);
protected:

    std::string m_sGroupName;
};




}
# 30 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h" 2


# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h" 1
# 38 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
namespace cocos2d {

class CCTMXObjectGroup;
# 55 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
enum {
    TMXLayerAttribNone = 1 << 0,
    TMXLayerAttribBase64 = 1 << 1,
    TMXLayerAttribGzip = 1 << 2,
    TMXLayerAttribZlib = 1 << 3,
};

enum {
    TMXPropertyNone,
    TMXPropertyMap,
    TMXPropertyLayer,
    TMXPropertyObjectGroup,
    TMXPropertyObject,
    TMXPropertyTile
};

typedef enum ccTMXTileFlags_ {
    kCCTMXTileHorizontalFlag = 0x80000000,
    kCCTMXTileVerticalFlag = 0x40000000,
    kCCTMXTileDiagonalFlag = 0x20000000,
    kCCFlipedAll = (kCCTMXTileHorizontalFlag|kCCTMXTileVerticalFlag|kCCTMXTileDiagonalFlag),
    kCCFlippedMask = ~(kCCFlipedAll)
} ccTMXTileFlags;
# 89 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
class CCTMXLayerInfo : public CCObject
{
    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:
    std::string m_sName;
    CCSize m_tLayerSize;
    unsigned int *m_pTiles;
    bool m_bVisible;
    unsigned char m_cOpacity;
    bool m_bOwnTiles;
    unsigned int m_uMinGID;
    unsigned int m_uMaxGID;
    CCPoint m_tOffset;
public:
    CCTMXLayerInfo();
    virtual ~CCTMXLayerInfo();
};
# 117 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
class CCTMXTilesetInfo : public CCObject
{
public:
    std::string m_sName;
    unsigned int m_uFirstGid;
    CCSize m_tTileSize;
    unsigned int m_uSpacing;
    unsigned int m_uMargin;

    std::string m_sSourceImage;

    CCSize m_tImageSize;
public:
    CCTMXTilesetInfo();
    virtual ~CCTMXTilesetInfo();
    CCRect rectForGID(unsigned int gid);
};
# 148 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
class CCTMXMapInfo : public CCObject, public CCSAXDelegator
{
public:

    protected: int m_nOrientation;public: virtual int getOrientation(void) const { return m_nOrientation; }public: virtual void setOrientation(int var){ m_nOrientation = var; };

    protected: CCSize m_tMapSize;public: virtual const CCSize& getMapSize(void) const { return m_tMapSize; }public: virtual void setMapSize(const CCSize& var){ m_tMapSize = var; };

    protected: CCSize m_tTileSize;public: virtual const CCSize& getTileSize(void) const { return m_tTileSize; }public: virtual void setTileSize(const CCSize& var){ m_tTileSize = var; };

    protected: CCArray* m_pLayers;public: virtual CCArray* getLayers(void);public: virtual void setLayers(CCArray* var);;

    protected: CCArray* m_pTilesets;public: virtual CCArray* getTilesets(void);public: virtual void setTilesets(CCArray* var);;

    protected: CCArray* m_pObjectGroups;public: virtual CCArray* getObjectGroups(void);public: virtual void setObjectGroups(CCArray* var);;

    protected: int m_nParentElement;public: virtual int getParentElement(void) const { return m_nParentElement; }public: virtual void setParentElement(int var){ m_nParentElement = var; };

    protected: unsigned int m_uParentGID;public: virtual unsigned int getParentGID(void) const { return m_uParentGID; }public: virtual void setParentGID(unsigned int var){ m_uParentGID = var; };

    protected: int m_nLayerAttribs;public: virtual int getLayerAttribs(void) const { return m_nLayerAttribs; }public: virtual void setLayerAttribs(int var){ m_nLayerAttribs = var; };

    protected: bool m_bStoringCharacters;public: virtual bool getStoringCharacters(void) const { return m_bStoringCharacters; }public: virtual void setStoringCharacters(bool var){ m_bStoringCharacters = var; };

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:




    CCTMXMapInfo();




    virtual ~CCTMXMapInfo();

    static CCTMXMapInfo * formatWithTMXFile(const char *tmxFile);

    static CCTMXMapInfo * formatWithXML(const char* tmxString, const char* resourcePath);



    bool initWithTMXFile(const char *tmxFile);



    bool initWithXML(const char* tmxString, const char* resourcePath);

    bool parseXMLFile(const char *xmlFilename);

    bool parseXMLString(const char *xmlString);

    CCDictionary* getTileProperties();
    void setTileProperties(CCDictionary* tileProperties);




    void startElement(void *ctx, const char *name, const char **atts);



    void endElement(void *ctx, const char *name);



    void textHandler(void *ctx, const char *ch, int len);

    inline const char* getCurrentString(){ return m_sCurrentString.c_str(); }
    inline void setCurrentString(const char *currentString){ m_sCurrentString = currentString; }
    inline const char* getTMXFileName(){ return m_sTMXFileName.c_str(); }
    inline void setTMXFileName(const char *fileName){ m_sTMXFileName = fileName; }
private:
    void internalInit(const char* tmxFileName, const char* resourcePath);
protected:

    std::string m_sTMXFileName;

    std::string m_sResources;

    std::string m_sCurrentString;

    CCDictionary* m_pTileProperties;
    unsigned int m_uCurrentFirstGID;
};




}
# 33 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h" 2
namespace cocos2d {

class CCTMXMapInfo;
class CCTMXLayerInfo;
class CCTMXTilesetInfo;
struct _ccCArray;
# 74 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
class CCTMXLayer : public CCSpriteBatchNode
{

    protected: CCSize m_tLayerSize;public: virtual const CCSize& getLayerSize(void) const { return m_tLayerSize; }public: virtual void setLayerSize(const CCSize& var){ m_tLayerSize = var; };

    protected: CCSize m_tMapTileSize;public: virtual const CCSize& getMapTileSize(void) const { return m_tMapTileSize; }public: virtual void setMapTileSize(const CCSize& var){ m_tMapTileSize = var; };

    protected: unsigned int* m_pTiles;public: virtual unsigned int* getTiles(void) const { return m_pTiles; }public: virtual void setTiles(unsigned int* var){ m_pTiles = var; };

    protected: CCTMXTilesetInfo* m_pTileSet;public: virtual CCTMXTilesetInfo* getTileSet(void);public: virtual void setTileSet(CCTMXTilesetInfo* var);;

    protected: unsigned int m_uLayerOrientation;public: virtual unsigned int getLayerOrientation(void) const { return m_uLayerOrientation; }public: virtual void setLayerOrientation(unsigned int var){ m_uLayerOrientation = var; };

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:




    CCTMXLayer();




    virtual ~CCTMXLayer();


    static CCTMXLayer * create(CCTMXTilesetInfo *tilesetInfo, CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);




    bool initWithTilesetInfo(CCTMXTilesetInfo *tilesetInfo, CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);





    void releaseMap();
# 122 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
    CCSprite* tileAt(const CCPoint& tileCoordinate);






    unsigned int tileGIDAt(const CCPoint& tileCoordinate);






    unsigned int tileGIDAt(const CCPoint& tileCoordinate, ccTMXTileFlags* flags);





    void setTileGID(unsigned int gid, const CCPoint& tileCoordinate);
# 151 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
    void setTileGID(unsigned int gid, const CCPoint& tileCoordinate, ccTMXTileFlags flags);


    void removeTileAt(const CCPoint& tileCoordinate);




    CCPoint positionAt(const CCPoint& tileCoordinate);




    CCString *propertyNamed(const char *propertyName);


    void setupTiles();





    virtual void addChild(CCNode * child, int zOrder, int tag);



    void removeChild(CCNode* child, bool cleanup);

    inline const char* getLayerName(){ return m_sLayerName.c_str(); }
    inline void setLayerName(const char *layerName){ m_sLayerName = layerName; }
private:
    CCPoint positionForIsoAt(const CCPoint& pos);
    CCPoint positionForOrthoAt(const CCPoint& pos);
    CCPoint positionForHexAt(const CCPoint& pos);

    CCPoint calculateLayerOffset(const CCPoint& offset);


    CCSprite* appendTileForGID(unsigned int gid, const CCPoint& pos);
    CCSprite* insertTileForGID(unsigned int gid, const CCPoint& pos);
    CCSprite* updateTileForGID(unsigned int gid, const CCPoint& pos);


    void parseInternalProperties();
    void setupTileSprite(CCSprite* sprite, CCPoint pos, unsigned int gid);
    CCSprite* reusedTileWithRect(CCRect rect);
    int vertexZForPos(const CCPoint& pos);


    unsigned int atlasIndexForExistantZ(unsigned int z);
    unsigned int atlasIndexForNewZ(int z);
protected:

    std::string m_sLayerName;

    unsigned char m_cOpacity;

    unsigned int m_uMinGID;
    unsigned int m_uMaxGID;


    int m_nVertexZvalue;
    bool m_bUseAutomaticVertexZ;


    CCSprite *m_pReusedTile;
    ccCArray *m_pAtlasIndexArray;


    float m_fContentScaleFactor;
};




}
# 281 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXTiledMap.h" 1
# 32 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXTiledMap.h"
namespace cocos2d {

class CCTMXObjectGroup;
class CCTMXLayer;
class CCTMXLayerInfo;
class CCTMXTilesetInfo;
class CCTMXMapInfo;







enum
{

    CCTMXOrientationOrtho,


    CCTMXOrientationHex,


    CCTMXOrientationIso,
};
# 109 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXTiledMap.h"
class CCTMXTiledMap : public CCNode
{

    protected: CCSize m_tMapSize;public: virtual const CCSize& getMapSize(void) const { return m_tMapSize; }public: virtual void setMapSize(const CCSize& var){ m_tMapSize = var; };

    protected: CCSize m_tTileSize;public: virtual const CCSize& getTileSize(void) const { return m_tTileSize; }public: virtual void setTileSize(const CCSize& var){ m_tTileSize = var; };

    protected: int m_nMapOrientation;public: virtual int getMapOrientation(void) const { return m_nMapOrientation; }public: virtual void setMapOrientation(int var){ m_nMapOrientation = var; };

    protected: CCArray* m_pObjectGroups;public: virtual CCArray* getObjectGroups(void);public: virtual void setObjectGroups(CCArray* var);;

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:



    CCTMXTiledMap();




    virtual ~CCTMXTiledMap();


    static CCTMXTiledMap* create(const char *tmxFile);


    static CCTMXTiledMap* createWithXML(const char* tmxString, const char* resourcePath);


    bool initWithTMXFile(const char *tmxFile);


    bool initWithXML(const char* tmxString, const char* resourcePath);




    CCTMXLayer* layerNamed(const char *layerName);




    CCTMXObjectGroup* objectGroupNamed(const char *groupName);




    CCString *propertyNamed(const char *propertyName);


    CCDictionary* propertiesForGID(int GID);

private:
    CCTMXLayer * parseLayer(CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);
    CCTMXTilesetInfo * tilesetForLayer(CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);
    void buildWithMapInfo(CCTMXMapInfo* mapInfo);
protected:

    CCDictionary* m_pTileProperties;

};




}
# 283 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTileMapAtlas.h" 1
# 32 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTileMapAtlas.h"
namespace cocos2d {

struct sImageTGA;
class CCDictionary;
# 57 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTileMapAtlas.h"
class CCTileMapAtlas : public CCAtlasNode
{

    protected: struct sImageTGA* m_pTGAInfo;public: virtual struct sImageTGA* getTGAInfo(void);public: virtual void setTGAInfo(struct sImageTGA* var);;
public:



    CCTileMapAtlas();




    virtual ~CCTileMapAtlas();




    static CCTileMapAtlas * create(const char *tile, const char *mapFile, int tileWidth, int tileHeight);




    bool initWithTileFile(const char *tile, const char *mapFile, int tileWidth, int tileHeight);




    ccColor3B tileAt(const CCPoint& position);



    void setTile(const ccColor3B& tile, const CCPoint& position);

    void releaseMap();
private:
    void loadTGAfile(const char *file);
    void calculateItemsToRender();
    void updateAtlasValueAt(const CCPoint& pos, const ccColor3B& value, unsigned int index);
    void updateAtlasValues();

protected:

    CCDictionary* m_pPosToAtlasIndex;

    int m_nItemsToRender;
};




}
# 285 "Cacao/include/cocos2dx/cocos2d.h" 2




# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDispatcher.h" 1
# 33 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDispatcher.h"
namespace cocos2d {






typedef enum
{
    ccTouchSelectorBeganBit = 1 << 0,
    ccTouchSelectorMovedBit = 1 << 1,
    ccTouchSelectorEndedBit = 1 << 2,
    ccTouchSelectorCancelledBit = 1 << 3,
    ccTouchSelectorAllBits = ( ccTouchSelectorBeganBit | ccTouchSelectorMovedBit | ccTouchSelectorEndedBit | ccTouchSelectorCancelledBit),
} ccTouchSelectorFlag;


enum {
    CCTOUCHBEGAN,
    CCTOUCHMOVED,
    CCTOUCHENDED,
    CCTOUCHCANCELLED,

    ccTouchMax,
};

class CCSet;
class CCEvent;

struct ccTouchHandlerHelperData {



    int m_type;
};




class EGLTouchDelegate
{
public:



    virtual void touchesBegan(CCSet* touches, CCEvent* pEvent) = 0;



    virtual void touchesMoved(CCSet* touches, CCEvent* pEvent) = 0;



    virtual void touchesEnded(CCSet* touches, CCEvent* pEvent) = 0;



    virtual void touchesCancelled(CCSet* touches, CCEvent* pEvent) = 0;



    virtual ~EGLTouchDelegate() {}
};

class CCTouchHandler;
struct _ccCArray;
# 116 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDispatcher.h"
class CCTouchDispatcher : public CCObject, public EGLTouchDelegate
{
public:



    ~CCTouchDispatcher();



    bool init(void);



    CCTouchDispatcher()
        : m_pTargetedHandlers(__null)
        , m_pStandardHandlers(__null)
        , m_pHandlersToAdd(__null)
        , m_pHandlersToRemove(__null)

    {}

public:

    bool isDispatchEvents(void);
    void setDispatchEvents(bool bDispatchEvents);






    void addStandardDelegate(CCTouchDelegate *pDelegate, int nPriority);






    void addTargetedDelegate(CCTouchDelegate *pDelegate, int nPriority, bool bSwallowsTouches);





    void removeDelegate(CCTouchDelegate *pDelegate);




    void removeAllDelegates(void);





    void setPriority(int nPriority, CCTouchDelegate *pDelegate);


    void incrementForcePrio(int nPrio);



    void touches(CCSet *pTouches, CCEvent *pEvent, unsigned int uIndex);



    virtual void touchesBegan(CCSet* touches, CCEvent* pEvent);



    virtual void touchesMoved(CCSet* touches, CCEvent* pEvent);



    virtual void touchesEnded(CCSet* touches, CCEvent* pEvent);



    virtual void touchesCancelled(CCSet* touches, CCEvent* pEvent);

public:



    CCTouchHandler* findHandler(CCTouchDelegate *pDelegate);
protected:
    void forceRemoveDelegate(CCTouchDelegate *pDelegate);
    void forceAddHandler(CCTouchHandler *pHandler, CCArray* pArray);
    void forceRemoveAllDelegates(void);
    void rearrangeHandlers(CCArray* pArray);
    CCTouchHandler* findHandler(CCArray* pArray, CCTouchDelegate *pDelegate);

protected:
     CCArray* m_pTargetedHandlers;
     CCArray* m_pStandardHandlers;

    bool m_bLocked;
    bool m_bToAdd;
    bool m_bToRemove;
     CCArray* m_pHandlersToAdd;
    struct _ccCArray *m_pHandlersToRemove;
    bool m_bToQuit;
    bool m_bDispatchEvents;


    struct ccTouchHandlerHelperData m_sHandlerHelperData[ccTouchMax];
};




}
# 290 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h" 1
# 34 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h"
namespace cocos2d {
# 47 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h"
class CCTouchHandler : public CCObject
{
public:
    virtual ~CCTouchHandler(void);


    CCTouchDelegate* getDelegate();
    void setDelegate(CCTouchDelegate *pDelegate);


    int getPriority(void);
    void setPriority(int nPriority);


    int getEnabledSelectors(void);
    void setEnalbedSelectors(int nValue);


    virtual bool initWithDelegate(CCTouchDelegate *pDelegate, int nPriority);

public:

    static CCTouchHandler* handlerWithDelegate(CCTouchDelegate *pDelegate, int nPriority);

protected:
    CCTouchDelegate *m_pDelegate;
    int m_nPriority;
    int m_nEnabledSelectors;
};






class CCStandardTouchHandler : public CCTouchHandler
{
public:

    virtual bool initWithDelegate(CCTouchDelegate *pDelegate, int nPriority);

public:

    static CCStandardTouchHandler* handlerWithDelegate(CCTouchDelegate *pDelegate, int nPriority);
};
# 100 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h"
class CCTargetedTouchHandler : public CCTouchHandler
{
public:
    ~CCTargetedTouchHandler(void);


    bool isSwallowsTouches(void);
    void setSwallowsTouches(bool bSwallowsTouches);


    CCSet* getClaimedTouches(void);


    bool initWithDelegate(CCTouchDelegate *pDelegate, int nPriority, bool bSwallow);

public:

    static CCTargetedTouchHandler* handlerWithDelegate(CCTouchDelegate *pDelegate, int nPriority, bool bSwallow);

protected:
    bool m_bSwallowsTouches;
    CCSet *m_pClaimedTouches;
};




}
# 291 "Cacao/include/cocos2dx/cocos2d.h" 2





# 1 "Cacao/include/cocos2dx/CCScheduler.h" 1
# 33 "Cacao/include/cocos2dx/CCScheduler.h"
namespace cocos2d {
# 46 "Cacao/include/cocos2dx/CCScheduler.h"
class CCSet;





class CCTimer : public CCObject
{
public:




    CCTimer(void);


    float getInterval(void) const;

    void setInterval(float fInterval);



    SEL_SCHEDULE getSelector() const;




    bool initWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector);




    bool initWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector, float fSeconds, unsigned int nRepeat, float fDelay);


    bool initWithScriptHandler(int nHandler, float fSeconds);


    void update(float dt);

public:



    static CCTimer* timerWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector);




    static CCTimer* timerWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector, float fSeconds);


    static CCTimer* timerWithScriptHandler(int nHandler, float fSeconds);



    inline int getScriptHandler() { return m_nScriptHandler; };

protected:
    CCObject *m_pTarget;
    float m_fElapsed;
    bool m_bRunForever;
    bool m_bUseDelay;
    unsigned int m_uTimesExecuted;
    unsigned int m_uRepeat;
    float m_fDelay;
    float m_fInterval;
    SEL_SCHEDULE m_pfnSelector;

    int m_nScriptHandler;
};




struct _listEntry;
struct _hashSelectorEntry;
struct _hashUpdateEntry;

class CCArray;
# 138 "Cacao/include/cocos2dx/CCScheduler.h"
class CCScheduler : public CCObject
{
public:
    CCScheduler();




    ~CCScheduler(void);

    inline float getTimeScale(void) { return m_fTimeScale; }







    inline void setTimeScale(float fTimeScale) { m_fTimeScale = fTimeScale; }






    void update(float dt);
# 176 "Cacao/include/cocos2dx/CCScheduler.h"
    void scheduleSelector(SEL_SCHEDULE pfnSelector, CCObject *pTarget, float fInterval, unsigned int repeat, float delay, bool bPaused);





    void scheduleSelector(SEL_SCHEDULE pfnSelector, CCObject *pTarget, float fInterval, bool bPaused);






    void scheduleUpdateForTarget(CCObject *pTarget, int nPriority, bool bPaused);






    void unscheduleSelector(SEL_SCHEDULE pfnSelector, CCObject *pTarget);





    void unscheduleUpdateForTarget(const CCObject *pTarget);







    void unscheduleAllForTarget(CCObject *pTarget);
# 219 "Cacao/include/cocos2dx/CCScheduler.h"
    void unscheduleAll(void);







    void unscheduleAllWithMinPriority(int nMinPriority);







    unsigned int scheduleScriptFunc(unsigned int nHandler, float fInterval, bool bPaused);




    void unscheduleScriptEntry(unsigned int uScheduleScriptEntryID);







    void pauseTarget(CCObject *pTarget);







    void resumeTarget(CCObject *pTarget);





    bool isTargetPaused(CCObject *pTarget);






    CCSet* pauseAllTargets();






    CCSet* pauseAllTargetsWithMinPriority(int nMinPriority);






    void resumeTargets(CCSet* targetsToResume);

private:
    void removeHashElement(struct _hashSelectorEntry *pElement);
    void removeUpdateFromHash(struct _listEntry *entry);



    void priorityIn(struct _listEntry **ppList, CCObject *pTarget, int nPriority, bool bPaused);
    void appendIn(struct _listEntry **ppList, CCObject *pTarget, bool bPaused);

protected:
    float m_fTimeScale;




    struct _listEntry *m_pUpdatesNegList;
    struct _listEntry *m_pUpdates0List;
    struct _listEntry *m_pUpdatesPosList;
    struct _hashUpdateEntry *m_pHashForUpdates;


    struct _hashSelectorEntry *m_pHashForTimers;
    struct _hashSelectorEntry *m_pCurrentTarget;
    bool m_bCurrentTargetSalvaged;

    bool m_bUpdateHashLocked;
    CCArray* m_pScriptHandlerEntries;
};




}
# 297 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/support/component/CCComponent.h" 1
# 31 "Cacao/include/cocos2dx/support/component/CCComponent.h"
namespace cocos2d {

class CCComponent : public CCObject
{
protected:
    CCComponent(void);
public:




    virtual ~CCComponent(void);
    virtual bool init();




    virtual void onEnter();




    virtual void onExit();
    virtual void update(float delta);
    virtual bool serialize(void* r);
    virtual bool isEnabled() const;
    virtual void setEnabled(bool b);
    static CCComponent* create(void);

    const char* getName() const;
 void setName(const char *pName);

    void setOwner(CCNode *pOwner);
    CCNode* getOwner() const;

protected:
    CCNode *m_pOwner;
    std::string m_strName;
    bool m_bEnabled;
};

}
# 300 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/component/CCComponentContainer.h" 1
# 30 "Cacao/include/cocos2dx/support/component/CCComponentContainer.h"
namespace cocos2d {

class CCComponent;
class CCNode;




class CCComponentContainer
{
protected:
    CCComponentContainer(CCNode *pNode);

public:
    virtual ~CCComponentContainer(void);
    virtual CCComponent* get(const char *pName) const;
    virtual bool add(CCComponent *pCom);
    virtual bool remove(const char *pName);
    virtual void removeAll();
    virtual void visit(float fDelta);
public:
    bool isEmpty() const;

private:
    void alloc(void);

private:
    CCDictionary *m_pComponents;
    CCNode *m_pOwner;

    friend class CCNode;
};

}
# 301 "Cacao/include/cocos2dx/cocos2d.h" 2

namespace cocos2d {

       const char* cocos2dVersion();

}
# 3 "Cacao/include/cocos2dx/custom/Sprites/CCMenuItemSpriteExtra/CCMenuItemSpriteExtra.h" 2

class CCMenuItemSpriteExtra : public cocos2d::CCMenuItemSprite{
private:
 float m_sizeMult = 1.25;
 float m_origScale = 1.f;
public:
 virtual void selected() override;
 virtual void unselected() override;
 virtual void activate() override;
 virtual void setScale(float scale) override;
 static CCMenuItemSpriteExtra* create(CCNode *normalSprite, CCNode *selectedSprite, CCObject *target, cocos2d::SEL_MenuHandler selector);
 void setSizeMult(float multiplier) { m_sizeMult = multiplier; }
};
# 10 "Cacao/include/cc_defs.hpp" 2

# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1



# 1 "Cacao/include/cocos2dext/ExtensionMacros.h" 1
# 5 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCBFileLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCInvocation.h" 1
# 36 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCInvocation.h"
namespace cocos2d { namespace extension {
# 45 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCInvocation.h"
typedef unsigned int CCControlEvent;

typedef void (CCObject::*SEL_CCControlHandler)(CCObject*, CCControlEvent);







class CCInvocation : public CCObject
{
    protected: SEL_CCControlHandler m_action;public: virtual SEL_CCControlHandler getAction(void) const { return m_action; };
    protected: CCObject* m_target;public: virtual CCObject* getTarget(void) const { return m_target; };
    protected: CCControlEvent m_controlEvent;public: virtual CCControlEvent getControlEvent(void) const { return m_controlEvent; };

public:
    static CCInvocation* create(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);
    CCInvocation(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);

    void invoke(CCObject* sender);
};





}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCBReader.h" 1







# 1 "Cacao/include/cocos2dext/CCBReader/CCBSequence.h" 1






# 1 "Cacao/include/cocos2dext/CCBReader/CCBSequenceProperty.h" 1





# 1 "Cacao/include/cocos2dext/CCBReader/CCBKeyframe.h" 1






namespace cocos2d { namespace extension {




class CCBKeyframe : public CCObject
{
private:
    CCObject *mValue;
    float mTime;
    int mEasingType;
    float mEasingOpt;

public:
    CCBKeyframe();
    ~CCBKeyframe();

    CCObject* getValue();
    void setValue(CCObject *pValue);

    float getTime();
    void setTime(float fTime);

    int getEasingType();
    void setEasingType(int nEasingType);

    float getEasingOpt();
    void setEasingOpt(float fEasingOpt);
};

}}
# 7 "Cacao/include/cocos2dext/CCBReader/CCBSequenceProperty.h" 2

namespace cocos2d { namespace extension {




class CCBSequenceProperty : public CCObject
{
private:
    std::string mName;
    int mType;
    CCArray *mKeyframes;

public:
    CCBSequenceProperty();
    ~CCBSequenceProperty();

    virtual bool init();

    const char* getName();
    void setName(const char* pName);

    int getType();
    void setType(int nType);

    CCArray* getKeyframes();
};

}}
# 8 "Cacao/include/cocos2dext/CCBReader/CCBSequence.h" 2

namespace cocos2d { namespace extension {




class CCBSequence : public CCObject
{
private:
    float mDuration;
    std::string mName;
    int mSequenceId;
    int mChainedSequenceId;
    CCBSequenceProperty* mCallbackChannel;
    CCBSequenceProperty* mSoundChannel;

public:
    CCBSequence();
    ~CCBSequence();
    float getDuration();
    void setDuration(float fDuration);

    CCBSequenceProperty* getCallbackChannel();
    void setCallbackChannel(CCBSequenceProperty* callbackChannel);

    CCBSequenceProperty* getSoundChannel();
    void setSoundChannel(CCBSequenceProperty* soundChannel);

    const char* getName();
    void setName(const char *pName);

    int getSequenceId();
    void setSequenceId(int nSequenceId);

    int getChainedSequenceId();
    void setChainedSequenceId(int nChainedSequenceId);
};


}}
# 9 "Cacao/include/cocos2dext/CCBReader/CCBReader.h" 2
# 1 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h" 1
# 34 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlUtils.h" 1
# 40 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlUtils.h"
namespace cocos2d { namespace extension {

typedef struct
{
    double r;
    double g;
    double b;
    double a;
} RGBA;

typedef struct
{
    double h;
    double s;
    double v;
} HSV;
# 68 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlUtils.h"
class CCColor3bObject : public CCObject
{
public:
    ccColor3B value;
    CCColor3bObject(ccColor3B s_value):value(s_value){}
};

class CCControlUtils
{
public:
    static CCSprite* addSpriteToTargetWithPosAndAnchor(const char* spriteName, CCNode * target, CCPoint pos, CCPoint anchor);
    static HSV HSVfromRGB(RGBA value);
    static RGBA RGBfromHSV(HSV value);
    static CCRect CCRectUnion(const CCRect& src1, const CCRect& src2);
};





}}
# 35 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h" 2


namespace cocos2d { namespace extension {

class CCInvocation;
# 52 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
enum
{
    CCControlEventTouchDown = 1 << 0,
    CCControlEventTouchDragInside = 1 << 1,
    CCControlEventTouchDragOutside = 1 << 2,
    CCControlEventTouchDragEnter = 1 << 3,
    CCControlEventTouchDragExit = 1 << 4,
    CCControlEventTouchUpInside = 1 << 5,
    CCControlEventTouchUpOutside = 1 << 6,
    CCControlEventTouchCancel = 1 << 7,
    CCControlEventValueChanged = 1 << 8
};
typedef unsigned int CCControlEvent;


enum
{
    CCControlStateNormal = 1 << 0,
    CCControlStateHighlighted = 1 << 1,
    CCControlStateDisabled = 1 << 2,
    CCControlStateSelected = 1 << 3
};
typedef unsigned int CCControlState;
# 88 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
class CCControl : public CCLayerRGBA
{


    bool m_bIsOpacityModifyRGB;


    protected: CCControlState m_eState;public: virtual CCControlState getState(void) const { return m_eState; };


protected:
    bool m_hasVisibleParents;

public:

    virtual void setEnabled(bool bEnabled);
    virtual bool isEnabled();

    virtual void setSelected(bool bSelected);
    virtual bool isSelected();

    virtual void setHighlighted(bool bHighlighted);
    virtual bool isHighlighted();
    bool hasVisibleParents();



    virtual void needsLayout();

    virtual bool isOpacityModifyRGB();
    virtual void setOpacityModifyRGB(bool bOpacityModifyRGB);

protected:
    bool m_bEnabled;
    bool m_bSelected;
    bool m_bHighlighted;






    CCDictionary* m_pDispatchTable;

public:



    CCControl();
    virtual bool init(void);




    virtual ~CCControl();





    virtual void onEnter();




    virtual void onExit();
    virtual void registerWithTouchDispatcher();







    virtual void sendActionsForControlEvents(CCControlEvent controlEvents);
# 177 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    virtual void addTargetWithActionForControlEvents(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvents);
# 191 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    virtual void removeTargetWithActionForControlEvents(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvents);






    virtual CCPoint getTouchLocation(CCTouch* touch);
# 209 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    virtual bool isTouchInside(CCTouch * touch);


protected:
# 226 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    CCInvocation* invocationWithTargetAndActionForControlEvent(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);
# 240 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    CCArray* dispatchListforControlEvent(CCControlEvent controlEvent);
# 254 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    void addTargetWithActionForControlEvent(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);
# 268 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    void removeTargetWithActionForControlEvent(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);

    static CCControl* create();
public:



    void addHandleOfControlEvent(int nFunID,CCControlEvent controlEvent);



    void removeHandleOfControlEvent(CCControlEvent controlEvent);
private:
    int getHandleOfControlEvent(CCControlEvent controlEvent);
private:
    std::map<int,int> m_mapHandleOfControlEvent;
};





}}
# 10 "Cacao/include/cocos2dext/CCBReader/CCBReader.h" 2
# 34 "Cacao/include/cocos2dext/CCBReader/CCBReader.h"
enum {
    kCCBPropTypePosition = 0,
    kCCBPropTypeSize,
    kCCBPropTypePoint,
    kCCBPropTypePointLock,
    kCCBPropTypeScaleLock,
    kCCBPropTypeDegrees,
    kCCBPropTypeInteger,
    kCCBPropTypeFloat,
    kCCBPropTypeFloatVar,
    kCCBPropTypeCheck,
    kCCBPropTypeSpriteFrame,
    kCCBPropTypeTexture,
    kCCBPropTypeByte,
    kCCBPropTypeColor3,
    kCCBPropTypeColor4FVar,
    kCCBPropTypeFlip,
    kCCBPropTypeBlendmode,
    kCCBPropTypeFntFile,
    kCCBPropTypeText,
    kCCBPropTypeFontTTF,
    kCCBPropTypeIntegerLabeled,
    kCCBPropTypeBlock,
 kCCBPropTypeAnimation,
    kCCBPropTypeCCBFile,
    kCCBPropTypeString,
    kCCBPropTypeBlockCCControl,
    kCCBPropTypeFloatScale,
    kCCBPropTypeFloatXY
};

enum {
    kCCBFloat0 = 0,
    kCCBFloat1,
    kCCBFloatMinus1,
    kCCBFloat05,
    kCCBFloatInteger,
    kCCBFloatFull
};

enum {
    kCCBPlatformAll = 0,
    kCCBPlatformIOS,
    kCCBPlatformMac
};

enum {
    kCCBTargetTypeNone = 0,
    kCCBTargetTypeDocumentRoot = 1,
    kCCBTargetTypeOwner = 2,
};

enum
{
    kCCBKeyframeEasingInstant,

    kCCBKeyframeEasingLinear,

    kCCBKeyframeEasingCubicIn,
    kCCBKeyframeEasingCubicOut,
    kCCBKeyframeEasingCubicInOut,

    kCCBKeyframeEasingElasticIn,
    kCCBKeyframeEasingElasticOut,
    kCCBKeyframeEasingElasticInOut,

    kCCBKeyframeEasingBounceIn,
    kCCBKeyframeEasingBounceOut,
    kCCBKeyframeEasingBounceInOut,

    kCCBKeyframeEasingBackIn,
    kCCBKeyframeEasingBackOut,
    kCCBKeyframeEasingBackInOut,
};

enum
{
    kCCBPositionTypeRelativeBottomLeft,
    kCCBPositionTypeRelativeTopLeft,
    kCCBPositionTypeRelativeTopRight,
    kCCBPositionTypeRelativeBottomRight,
    kCCBPositionTypePercent,
    kCCBPositionTypeMultiplyResolution,
};

enum
{
    kCCBSizeTypeAbsolute,
    kCCBSizeTypePercent,
    kCCBSizeTypeRelativeContainer,
    kCCBSizeTypeHorizontalPercent,
    kCCBSizeTypeVerticalPercent,
    kCCBSizeTypeMultiplyResolution,
};

enum
{
    kCCBScaleTypeAbsolute,
    kCCBScaleTypeMultiplyResolution
};


namespace cocos2d { namespace extension {
# 145 "Cacao/include/cocos2dext/CCBReader/CCBReader.h"
class CCBFile : public CCNode
{
private:
    CCNode *mCCBFileNode;

public:
    CCBFile();

    static CCBFile* create();

    CCNode* getCCBFileNode();
    void setCCBFileNode(CCNode *pNode);
};


class CCNodeLoader;
class CCNodeLoaderLibrary;
class CCNodeLoaderListener;
class CCBMemberVariableAssigner;
class CCBSelectorResolver;
class CCBAnimationManager;
class CCData;
class CCBKeyframe;




class CCBReader : public CCObject
{
private:

    CCData *mData;
    unsigned char *mBytes;
    int mCurrentByte;
    int mCurrentBit;

    std::vector<std::string> mStringCache;
    std::set<std::string> mLoadedSpriteSheets;

    CCObject *mOwner;

    CCBAnimationManager *mActionManager;
    CCDictionary* mActionManagers;

    std::set<std::string> *mAnimatedProps;

    CCNodeLoaderLibrary *mCCNodeLoaderLibrary;
    CCNodeLoaderListener *mCCNodeLoaderListener;
    CCBMemberVariableAssigner *mCCBMemberVariableAssigner;
    CCBSelectorResolver *mCCBSelectorResolver;

    std::vector<std::string> mOwnerOutletNames;
    CCArray* mOwnerOutletNodes;
    CCArray* mNodesWithAnimationManagers;
    CCArray* mAnimationManagersForNodes;

    std::vector<std::string> mOwnerCallbackNames;
    CCArray* mOwnerCallbackNodes;
    CCArray* mOwnerOwnerCallbackControlEvents;
    std::string mCCBRootPath;
    bool hasScriptingOwner;
    bool init();
public:

    bool jsControlled;




    CCBReader(CCNodeLoaderLibrary *pCCNodeLoaderLibrary, CCBMemberVariableAssigner *pCCBMemberVariableAssigner = __null, CCBSelectorResolver *pCCBSelectorResolver = __null, CCNodeLoaderListener *pCCNodeLoaderListener = __null);




    CCBReader(CCBReader *pCCBReader);




    virtual ~CCBReader();



    CCBReader();

    void setCCBRootPath(const char* pCCBRootPath);
    const std::string& getCCBRootPath() const;




    CCNode* readNodeGraphFromFile(const char *pCCBFileName);




    CCNode* readNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner);




    CCNode* readNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner, const CCSize &parentSize);




    CCNode* readNodeGraphFromData(CCData *pData, CCObject *pOwner, const CCSize &parentSize);




    CCScene* createSceneWithNodeGraphFromFile(const char *pCCBFileName);




    CCScene* createSceneWithNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner);




    CCScene* createSceneWithNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner, const CCSize &parentSize);




    CCBMemberVariableAssigner* getCCBMemberVariableAssigner();




    CCBSelectorResolver* getCCBSelectorResolver();



    CCBAnimationManager* getAnimationManager();



    void setAnimationManager(CCBAnimationManager *pAnimationManager);





    std::set<std::string>* getAnimatedProperties();




    std::set<std::string>& getLoadedSpriteSheet();
    CCObject* getOwner();





    static std::string lastPathComponent(const char* pString);




    static std::string deletePathExtension(const char* pString);




    static std::string toLowerCase(const char* pCCString);




    static bool endsWith(const char* pString, const char* pEnding);





    int readInt(bool pSigned);




    unsigned char readByte();




    bool readBool();
    std::string readUTF8();




    float readFloat();




    std::string readCachedString();




    bool isJSControlled();


    bool readCallbackKeyframesForSeq(CCBSequence* seq);
    bool readSoundKeyframesForSeq(CCBSequence* seq);



    CCArray* getOwnerCallbackNames();
    CCArray* getOwnerCallbackNodes();
    CCArray* getOwnerCallbackControlEvents();
    CCArray* getOwnerOutletNames();
    CCArray* getOwnerOutletNodes();
    CCArray* getNodesWithAnimationManagers();
    CCArray* getAnimationManagersForNodes();




    CCDictionary* getAnimationManagers();



    void setAnimationManagers(CCDictionary* x);




    void addOwnerCallbackName(const std::string& name);




    void addOwnerCallbackNode(CCNode *node);




    void addOwnerCallbackControlEvents(CCControlEvent type);




    void addDocumentCallbackName(const std::string& name);




    void addDocumentCallbackNode(CCNode *node);




    void addDocumentCallbackControlEvents(CCControlEvent eventType);




    static float getResolutionScale();
    static void setResolutionScale(float scale);




    CCNode* readFileWithCleanUp(bool bCleanUp, CCDictionary* am);

    void addOwnerOutletName(std::string name);
    void addOwnerOutletNode(CCNode *node);

private:
    void cleanUpNodeGraph(CCNode *pNode);
    bool readSequences();
    CCBKeyframe* readKeyframe(int type);

    bool readHeader();
    bool readStringCache();

    CCNode* readNodeGraph();
    CCNode* readNodeGraph(CCNode * pParent);

    bool getBit();
    void alignBits();

    friend class CCNodeLoader;
};




}}
# 7 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCBValue.h" 1
# 11 "Cacao/include/cocos2dext/CCBReader/CCBValue.h"
namespace cocos2d { namespace extension {




class ccColor3BWapper : public CCObject
{
private:
    ccColor3B color;

public:
    static ccColor3BWapper* create(const ccColor3B& color);

    const ccColor3B& getColor() const;
};

enum
{
    kIntValue,
    kFloatValue,
    kBoolValue,
    kUnsignedCharValue,
    kStringValue,
    kArrayValue
};




class CCBValue : public CCObject
{
private:
    union
    {
        int nValue;
        float fValue;
    } mValue;

    std::string m_strValue;
    CCArray* m_arrValue;
    int mType;

public:
    static CCBValue* create(int nValue);
    static CCBValue* create(bool bValue);
    static CCBValue* create(float fValue);
    static CCBValue* create(unsigned char byte);
    static CCBValue* create(const char* pStr);
    static CCBValue* create(CCArray* pArr);


    int getIntValue();
    float getFloatValue();
    bool getBoolValue();
    unsigned char getByteValue();
    const char* getStringValue();
    CCArray *getArrayValue();

    int getType();
};

}}
# 8 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 2

namespace cocos2d { namespace extension {
# 32 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h"
struct BlockData {
    SEL_MenuHandler mSELMenuHandler;
    CCObject * mTarget;
};

struct BlockCCControlData {
    SEL_CCControlHandler mSELCCControlHandler;
    CCObject * mTarget;
    int mControlEvents;
};


class CCBReader;




class CCNodeLoader : public CCObject {
    public:
        CCNodeLoader();
        virtual ~CCNodeLoader();
        static CCNodeLoader * loader() { CCNodeLoader * ptr = new CCNodeLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

        virtual CCNode * loadCCNode(CCNode *, CCBReader * pCCBReader);
        virtual void parseProperties(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCDictionary* getCustomProperties();

    protected:
        virtual CCNode * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCNode::create(); };

        virtual CCPoint parsePropTypePosition(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual CCPoint parsePropTypePoint(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCPoint parsePropTypePointLock(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCSize parsePropTypeSize(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float * parsePropTypeScaleLock(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual float parsePropTypeFloat(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float parsePropTypeDegrees(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual float parsePropTypeFloatScale(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual int parsePropTypeInteger(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual int parsePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float * parsePropTypeFloatVar(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual bool parsePropTypeCheck(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual CCSpriteFrame * parsePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual CCAnimation * parsePropTypeAnimation(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCTexture2D * parsePropTypeTexture(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual unsigned char parsePropTypeByte(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual ccColor3B parsePropTypeColor3(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual ccColor4F * parsePropTypeColor4FVar(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual bool * parsePropTypeFlip(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual ccBlendFunc parsePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeFntFile(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeString(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeText(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeFontTTF(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual BlockData * parsePropTypeBlock(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual BlockCCControlData * parsePropTypeBlockCCControl(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCNode * parsePropTypeCCBFile(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float * parsePropTypeFloatXY(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);


        virtual void onHandlePropTypePosition(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCPoint pPosition, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypePointLock(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCPoint pPointLock, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeScaleLock(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float * pScaleLock, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float pFloat, CCBReader * pCCBReader);
        virtual void onHandlePropTypeDegrees(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float pDegrees, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatScale(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float pFloatScale, CCBReader * pCCBReader);
        virtual void onHandlePropTypeInteger(CCNode * pNode, CCNode * pParent, const char* pPropertyName, int pInteger, CCBReader * pCCBReader);
        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char* pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatVar(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float * pFoatVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatXY(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float * pFoatVar, CCBReader * pCCBReader);

        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char* pPropertyName, bool pCheck, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeAnimation(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCAnimation * pCCAnimation, CCBReader * pCCBReader);
        virtual void onHandlePropTypeTexture(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCTexture2D * pCCTexture2D, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char* pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char* pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor4FVar(CCNode * pNode, CCNode * pParent, const char* pPropertyName, ccColor4F * pCCColor4FVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFlip(CCNode * pNode, CCNode * pParent, const char* pPropertyName, bool * pFlip, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char* pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFntFile(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pFntFile, CCBReader * pCCBReader);
        virtual void onHandlePropTypeString(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pString, CCBReader * pCCBReader);
        virtual void onHandlePropTypeText(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pText, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFontTTF(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pFontTTF, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlock(CCNode * pNode, CCNode * pParent, const char* pPropertyName, BlockData * pBlockData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlockCCControl(CCNode * pNode, CCNode * pParent, const char* pPropertyName, BlockCCControlData * pBlockCCControlData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCCBFile(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCNode * pCCBFileNode, CCBReader * pCCBReader);

protected:
        CCDictionary* m_pCustomProperties;
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCBFileLoader.h" 2


namespace cocos2d { namespace extension {


class CCBReader;




class CCBFileLoader : public CCNodeLoader {
    public:
        virtual ~CCBFileLoader() {};
        static CCBFileLoader * loader() { CCBFileLoader * ptr = new CCBFileLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCBFile * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCBFile::create(); };

        virtual void onHandlePropTypeCCBFile(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCNode * pCCBFileNode, CCBReader * pCCBReader);
};

}}
# 7 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h" 1






namespace cocos2d { namespace extension {
# 31 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h"
class CCBMemberVariableAssigner {
    public:
        virtual ~CCBMemberVariableAssigner() {};
# 43 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h"
        virtual bool onAssignCCBMemberVariable(CCObject* pTarget, const char* pMemberVariableName, CCNode* pNode) = 0;
# 53 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h"
        virtual bool onAssignCCBCustomProperty(CCObject* pTarget, const char* pMemberVariableName, CCBValue* pCCBValue) { return false; };
};

}}
# 8 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCBSelectorResolver.h" 1








namespace cocos2d { namespace extension {
# 26 "Cacao/include/cocos2dext/CCBReader/CCBSelectorResolver.h"
class CCBSelectorResolver {
    public:
        virtual ~CCBSelectorResolver() {};
    virtual SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName) = 0;
    virtual SEL_CallFuncN onResolveCCBCCCallFuncSelector(CCObject * pTarget, const char* pSelectorName) { return __null; };
    virtual SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName) = 0;
};





class CCBScriptOwnerProtocol {
public:
    virtual ~CCBScriptOwnerProtocol() {};
    virtual CCBSelectorResolver * createNew() = 0;
};

}}
# 10 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCControlButtonLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCControlLoader.h" 1






namespace cocos2d { namespace extension {


class CCBReader;




class CCControlLoader : public CCNodeLoader {
    public:
        virtual ~CCControlLoader() {};

    protected:
        virtual CCControl * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) = 0;

        virtual void onHandlePropTypeBlockCCControl(CCNode * pNode, CCNode * pParent, const char * pPropertyName, BlockCCControlData * pBlockCCControlData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCControlButtonLoader.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h" 1
# 35 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h" 1
# 34 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
namespace cocos2d { namespace extension {
# 53 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
class CCScale9Sprite : public CCNodeRGBA
{
public:
    CCScale9Sprite();
    virtual ~CCScale9Sprite();

public:

    protected: CCSize m_originalSize;public: virtual CCSize getOriginalSize(void) const { return m_originalSize; };



    protected: CCSize m_preferredSize;public: virtual CCSize getPreferredSize(void);public: virtual void setPreferredSize(CCSize var);;





    protected: CCRect m_capInsets;public: virtual CCRect getCapInsets(void);public: virtual void setCapInsets(CCRect var);;

    protected: float m_insetLeft;public: virtual float getInsetLeft(void);public: virtual void setInsetLeft(float var);;

    protected: float m_insetTop;public: virtual float getInsetTop(void);public: virtual void setInsetTop(float var);;

    protected: float m_insetRight;public: virtual float getInsetRight(void);public: virtual void setInsetRight(float var);;

    protected: float m_insetBottom;public: virtual float getInsetBottom(void);public: virtual void setInsetBottom(float var);;

protected:
    bool m_bSpritesGenerated;
    CCRect m_spriteRect;
    bool m_bSpriteFrameRotated;
    CCRect m_capInsetsInternal;
    bool m_positionsAreDirty;

    CCSpriteBatchNode* _scale9Image;
    CCSprite* _topLeft;
    CCSprite* _top;
    CCSprite* _topRight;
    CCSprite* _left;
    CCSprite* _centre;
    CCSprite* _right;
    CCSprite* _bottomLeft;
    CCSprite* _bottom;
    CCSprite* _bottomRight;

    bool _opacityModifyRGB;
    GLubyte _opacity;
    ccColor3B _color;

    void updateCapInset();
    void updatePositions();

public:

    virtual void setContentSize(const CCSize & size);



    virtual void visit();

    virtual bool init();

    virtual bool initWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);
    virtual bool initWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, CCRect capInsets);
# 131 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(const char* file, CCRect rect, CCRect capInsets);







    static CCScale9Sprite* create(const char* file, CCRect rect, CCRect capInsets);
# 153 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(const char* file, CCRect rect);







    static CCScale9Sprite* create(const char* file, CCRect rect);
# 173 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(CCRect capInsets, const char* file);







    static CCScale9Sprite* create(CCRect capInsets, const char* file);
# 193 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(const char* file);







    static CCScale9Sprite* create(const char* file);
# 213 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrame(CCSpriteFrame* spriteFrame, CCRect capInsets);
# 223 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrame(CCSpriteFrame* spriteFrame, CCRect capInsets);
# 232 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrame(CCSpriteFrame* spriteFrame);
# 242 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrame(CCSpriteFrame* spriteFrame);
# 254 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrameName(const char*spriteFrameName, CCRect capInsets);
# 265 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrameName(const char*spriteFrameName, CCRect capInsets);
# 275 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrameName(const char*spriteFrameName);
# 285 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrameName(const char*spriteFrameName);
# 295 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    CCScale9Sprite* resizableSpriteWithCapInsets(CCRect capInsets);

    static CCScale9Sprite* create();
# 307 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual void setOpacityModifyRGB(bool bValue);




    virtual bool isOpacityModifyRGB(void);
    virtual void setOpacity(GLubyte opacity);
 virtual GLubyte getOpacity();
    virtual void setColor(const ccColor3B& color);
 virtual const ccColor3B& getColor();

    virtual bool updateWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);

    virtual void setSpriteFrame(CCSpriteFrame * spriteFrame);

    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual void updateDisplayedColor(const cocos2d::ccColor3B& parentColor);
};





}}
# 36 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h" 2

namespace cocos2d { namespace extension {
# 53 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
class CCControlButton : public CCControl
{
public:
    CCControlButton();
    virtual ~CCControlButton();
    virtual void needsLayout(void);

    virtual void setEnabled(bool enabled);
    virtual void setSelected(bool enabled);
    virtual void setHighlighted(bool enabled);
protected:




    protected: CCString* m_currentTitle;public: virtual CCString* getCurrentTitle(void) const { return m_currentTitle; };


    protected: ccColor3B m_currentTitleColor;public: virtual const ccColor3B& getCurrentTitleColor(void) const { return m_currentTitleColor; };



    bool doesAdjustBackgroundImage();
    void setAdjustBackgroundImage(bool adjustBackgroundImage);
    bool m_doesAdjustBackgroundImage;


    private: CCNode* m_titleLabel; public: virtual CCNode* getTitleLabel(void) const { return m_titleLabel; } public: virtual void setTitleLabel(CCNode* var) { if (m_titleLabel != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleLabel) { (m_titleLabel)->release(); } } while(0); m_titleLabel = var; } };


    private: CCScale9Sprite* m_backgroundSprite; public: virtual CCScale9Sprite* getBackgroundSprite(void) const { return m_backgroundSprite; } public: virtual void setBackgroundSprite(CCScale9Sprite* var) { if (m_backgroundSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_backgroundSprite) { (m_backgroundSprite)->release(); } } while(0); m_backgroundSprite = var; } };


    protected: CCSize m_preferredSize;public: virtual CCSize getPreferredSize(void);public: virtual void setPreferredSize(CCSize var);;


    protected: bool m_zoomOnTouchDown;public: virtual bool getZoomOnTouchDown(void);public: virtual void setZoomOnTouchDown(bool var);;

    protected: CCPoint m_labelAnchorPoint;public: virtual CCPoint getLabelAnchorPoint(void);public: virtual void setLabelAnchorPoint(CCPoint var);;


    virtual GLubyte getOpacity(void);
    virtual void setOpacity(GLubyte var);
 virtual const ccColor3B& getColor(void);
 virtual void setColor(const ccColor3B&);


protected:
    bool m_isPushed;
    bool m_bParentInited;
public:
    bool isPushed() { return m_isPushed; }


    private: CCDictionary* m_titleDispatchTable; public: virtual CCDictionary* getTitleDispatchTable(void) const { return m_titleDispatchTable; } public: virtual void setTitleDispatchTable(CCDictionary* var) { if (m_titleDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleDispatchTable) { (m_titleDispatchTable)->release(); } } while(0); m_titleDispatchTable = var; } };

    private: CCDictionary* m_titleColorDispatchTable; public: virtual CCDictionary* getTitleColorDispatchTable(void) const { return m_titleColorDispatchTable; } public: virtual void setTitleColorDispatchTable(CCDictionary* var) { if (m_titleColorDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleColorDispatchTable) { (m_titleColorDispatchTable)->release(); } } while(0); m_titleColorDispatchTable = var; } };

    private: CCDictionary* m_titleLabelDispatchTable; public: virtual CCDictionary* getTitleLabelDispatchTable(void) const { return m_titleLabelDispatchTable; } public: virtual void setTitleLabelDispatchTable(CCDictionary* var) { if (m_titleLabelDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleLabelDispatchTable) { (m_titleLabelDispatchTable)->release(); } } while(0); m_titleLabelDispatchTable = var; } };

    private: CCDictionary* m_backgroundSpriteDispatchTable; public: virtual CCDictionary* getBackgroundSpriteDispatchTable(void) const { return m_backgroundSpriteDispatchTable; } public: virtual void setBackgroundSpriteDispatchTable(CCDictionary* var) { if (m_backgroundSpriteDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_backgroundSpriteDispatchTable) { (m_backgroundSpriteDispatchTable)->release(); } } while(0); m_backgroundSpriteDispatchTable = var; } };


    protected: int m_marginV;public: virtual int getVerticalMargin(void) const { return m_marginV; };

    protected: int m_marginH;public: virtual int getHorizontalOrigin(void) const { return m_marginH; };

    virtual void setMargins(int marginH, int marginV);


public:
    virtual bool init();
    virtual bool initWithLabelAndBackgroundSprite(CCNode* label, CCScale9Sprite* backgroundSprite);

    static CCControlButton* create(CCNode* label, CCScale9Sprite* backgroundSprite);

    virtual bool initWithTitleAndFontNameAndFontSize(std::string title, const char * fontName, float fontSize);

    static CCControlButton* create(std::string title, const char * fontName, float fontSize);

    virtual bool initWithBackgroundSprite(CCScale9Sprite* sprite);

    static CCControlButton* create(CCScale9Sprite* sprite);


    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
# 151 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual CCString* getTitleForState(CCControlState state);
# 162 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setTitleForState(CCString* title, CCControlState state);
# 173 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual const ccColor3B getTitleColorForState(CCControlState state);
# 182 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setTitleColorForState(ccColor3B color, CCControlState state);







    virtual CCNode* getTitleLabelForState(CCControlState state);
# 201 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setTitleLabelForState(CCNode* label, CCControlState state);

    virtual void setTitleTTFForState(const char * fntFile, CCControlState state);
    virtual const char * getTitleTTFForState(CCControlState state);

    virtual void setTitleTTFSizeForState(float size, CCControlState state);
    virtual float getTitleTTFSizeForState(CCControlState state);







    virtual void setTitleBMFontForState(const char * fntFile, CCControlState state);
    virtual const char * getTitleBMFontForState(CCControlState state);







    virtual CCScale9Sprite* getBackgroundSpriteForState(CCControlState state);
# 233 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setBackgroundSpriteForState(CCScale9Sprite* sprite, CCControlState state);
# 242 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setBackgroundSpriteFrameForState(CCSpriteFrame * spriteFrame, CCControlState state);

    static CCControlButton* create();
};





}}
# 6 "Cacao/include/cocos2dext/CCBReader/CCControlButtonLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;

class CCControlButtonLoader : public CCControlLoader {
    public:
        virtual ~CCControlButtonLoader() {};
        static CCControlButtonLoader * loader() { CCControlButtonLoader * ptr = new CCControlButtonLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCControlButton * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCControlButton::create(); };

        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
        virtual void onHandlePropTypeString(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pString, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFontTTF(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pFontTTF, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatScale(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloatScale, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
};

}}
# 11 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCLabelBMFontLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLabelBMFontLoader : public CCNodeLoader {
    public:
        virtual ~CCLabelBMFontLoader() {};
        static CCLabelBMFontLoader * loader() { CCLabelBMFontLoader * ptr = new CCLabelBMFontLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLabelBMFont * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLabelBMFont::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFntFile(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char* pFntFile, CCBReader * pCCBReader);
        virtual void onHandlePropTypeText(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char* pText, CCBReader * pCCBReader);
};

}}
# 13 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCLabelTTFLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLabelTTFLoader : public CCNodeLoader {
    public:
        virtual ~CCLabelTTFLoader() {};
        static CCLabelTTFLoader * loader() { CCLabelTTFLoader * ptr = new CCLabelTTFLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLabelTTF * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLabelTTF::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFontTTF(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pFontTTF, CCBReader * pCCBReader);
        virtual void onHandlePropTypeText(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pText, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatScale(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloatScale, CCBReader * pCCBReader);
        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
};

}}
# 14 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCLayerColorLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCLayerLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLayerLoader : public CCNodeLoader {
    public:
        virtual ~CCLayerLoader() {};
        static CCLayerLoader * loader() { CCLayerLoader * ptr = new CCLayerLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLayer * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLayer::create(); };

        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCLayerColorLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;




class CCLayerColorLoader : public CCLayerLoader {
    public:
        virtual ~CCLayerColorLoader() {};
        static CCLayerColorLoader * loader() { CCLayerColorLoader * ptr = new CCLayerColorLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLayerColor * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLayerColor::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
};

}}
# 15 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCLayerGradientLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLayerGradientLoader : public CCLayerLoader {
    public:
        virtual ~CCLayerGradientLoader() {};
        static CCLayerGradientLoader * loader() { CCLayerGradientLoader * ptr = new CCLayerGradientLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLayerGradient * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLayerGradient::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
};

}}
# 16 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCMenuItemImageLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCMenuItemLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCMenuItemLoader : public CCNodeLoader {
    public:
        virtual ~CCMenuItemLoader() {};

    protected:
        virtual CCMenuItem * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) = 0;

        virtual void onHandlePropTypeBlock(CCNode * pNode, CCNode * pParent, const char * pPropertyName, BlockData * pBlockData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCMenuItemImageLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;




class CCMenuItemImageLoader : public CCMenuItemLoader {
    public:
        virtual ~CCMenuItemImageLoader() {};
        static CCMenuItemImageLoader * loader() { CCMenuItemImageLoader * ptr = new CCMenuItemImageLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCMenuItemImage * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCMenuItemImage::create(); };

        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
};

}}
# 18 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCMenuLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCMenuLoader : public CCLayerLoader {
    public:
        virtual ~CCMenuLoader() {};
        static CCMenuLoader * loader() { CCMenuLoader * ptr = new CCMenuLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCMenu * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCMenu::create(); };
};

}}
# 20 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCNodeLoaderLibrary.h" 1






namespace cocos2d { namespace extension {

class CCNodeLoader;

typedef std::map<std::string, CCNodeLoader *> CCNodeLoaderMap;
typedef std::pair<std::string, CCNodeLoader *> CCNodeLoaderMapEntry;




class CCNodeLoaderLibrary : public CCObject {
    private:
        CCNodeLoaderMap mCCNodeLoaders;

    public:
        static CCNodeLoaderLibrary * library() { CCNodeLoaderLibrary * ptr = new CCNodeLoaderLibrary(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

        CCNodeLoaderLibrary();
        virtual ~CCNodeLoaderLibrary();

        void registerDefaultCCNodeLoaders();
        void registerCCNodeLoader(const char * pClassName, CCNodeLoader * pCCNodeLoader);

        void unregisterCCNodeLoader(const char * pClassName);

        CCNodeLoader * getCCNodeLoader(const char * pClassName);

        void purge(bool pDelete);

    public:
        static CCNodeLoaderLibrary * sharedCCNodeLoaderLibrary();
        static void purgeSharedCCNodeLoaderLibrary();

        static CCNodeLoaderLibrary * newDefaultCCNodeLoaderLibrary();
};

}}
# 22 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCNodeLoaderListener.h" 1





namespace cocos2d { namespace extension {




class CCNodeLoaderListener {
    public:
        virtual ~CCNodeLoaderListener() {};

        virtual void onNodeLoaded(CCNode * pNode, CCNodeLoader * pNodeLoader) = 0;
};

}}
# 23 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCParticleSystemQuadLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCParticleSystemQuadLoader : public CCNodeLoader {
    public:
        virtual ~CCParticleSystemQuadLoader() {};
        static CCParticleSystemQuadLoader * loader() { CCParticleSystemQuadLoader * ptr = new CCParticleSystemQuadLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCParticleSystemQuad * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCParticleSystemQuad::create(); };

        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloat, CCBReader * pCCBReader);
        virtual void onHandlePropTypeInteger(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pInteger, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatVar(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float * pFloatVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor4FVar(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor4F * pCCColor4FVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeTexture(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCTexture2D * pCCTexture2D, CCBReader * pCCBReader);
};

}}
# 24 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCScale9SpriteLoader.h" 1




# 1 "Cacao/include/cocos2dext/CCBReader/CCScale9SpriteLoader.h" 1
# 6 "Cacao/include/cocos2dext/CCBReader/CCScale9SpriteLoader.h" 2


namespace cocos2d { namespace extension {


class CCBReader;




class CCScale9SpriteLoader : public CCNodeLoader {
    public:
        virtual ~CCScale9SpriteLoader() {};
        static CCScale9SpriteLoader * loader() { CCScale9SpriteLoader * ptr = new CCScale9SpriteLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCScale9Sprite * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCScale9Sprite::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloat, CCBReader * pCCBReader);
};

}}
# 25 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCScrollViewLoader.h" 1




# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h" 1
# 32 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
namespace cocos2d { namespace extension {






typedef enum {
 kCCScrollViewDirectionNone = -1,
    kCCScrollViewDirectionHorizontal = 0,
    kCCScrollViewDirectionVertical,
    kCCScrollViewDirectionBoth
} CCScrollViewDirection;

class CCScrollView;




class CCScrollViewDelegate
{
public:
    virtual ~CCScrollViewDelegate() {}
    virtual void scrollViewDidScroll(CCScrollView* view) = 0;
    virtual void scrollViewDidZoom(CCScrollView* view) = 0;
};







class CCScrollView : public CCLayer
{
public:



    CCScrollView();




    virtual ~CCScrollView();

    bool init();
    virtual void registerWithTouchDispatcher();
# 88 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    static CCScrollView* create(CCSize size, CCNode* container = __null);
# 97 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    static CCScrollView* create();
# 106 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    bool initWithViewSize(CCSize size, CCNode* container = __null);
# 115 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    void setContentOffset(CCPoint offset, bool animated = false);
    CCPoint getContentOffset();







    void setContentOffsetInDuration(CCPoint offset, float dt);

    void setZoomScale(float s);






    void setZoomScale(float s, bool animated);

    float getZoomScale();







    void setZoomScaleInDuration(float s, float dt);



    CCPoint minContainerOffset();



    CCPoint maxContainerOffset();





    bool isNodeVisible(CCNode * node);



    void pause(CCObject* sender);



    void resume(CCObject* sender);


    bool isDragging() {return m_bDragging;}
    bool isTouchMoved() { return m_bTouchMoved; }
    bool isBounceable() { return m_bBounceable; }
    void setBounceable(bool bBounceable) { m_bBounceable = bBounceable; }






    CCSize getViewSize() { return m_tViewSize; }
    void setViewSize(CCSize size);

    CCNode * getContainer();
    void setContainer(CCNode * pContainer);




    CCScrollViewDirection getDirection() { return m_eDirection; }
    virtual void setDirection(CCScrollViewDirection eDirection) { m_eDirection = eDirection; }

    CCScrollViewDelegate* getDelegate() { return m_pDelegate; }
    void setDelegate(CCScrollViewDelegate* pDelegate) { m_pDelegate = pDelegate; }



    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

    virtual void setContentSize(const CCSize & size);
    virtual const CCSize& getContentSize() const;

 void updateInset();



    bool isClippingToBounds() { return m_bClippingToBounds; }
    void setClippingToBounds(bool bClippingToBounds) { m_bClippingToBounds = bClippingToBounds; }



    virtual void visit();
    virtual void addChild(CCNode * child, int zOrder, int tag);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child);
    void setTouchEnabled(bool e);
private:





    void relocateContainer(bool animated);






    void deaccelerateScrolling(float dt);



    void performedAnimatedScroll(float dt);



    void stoppedAnimatedScroll(CCNode* node);



    void beforeDraw();




    void afterDraw();



    void handleZoom();

protected:
    CCRect getViewRect();




    float m_fZoomScale;



    float m_fMinZoomScale;



    float m_fMaxZoomScale;



    CCScrollViewDelegate* m_pDelegate;

    CCScrollViewDirection m_eDirection;



    bool m_bDragging;




    CCPoint m_tContentOffset;




    CCNode* m_pContainer;



    bool m_bTouchMoved;



    CCPoint m_fMaxInset;



    CCPoint m_fMinInset;



    bool m_bBounceable;

    bool m_bClippingToBounds;




    CCPoint m_tScrollDistance;



    CCPoint m_tTouchPoint;



    float m_fTouchLength;



    CCArray* m_pTouches;





    CCSize m_tViewSize;



    float m_fMinScale, m_fMaxScale;



    CCRect m_tParentScissorRect;
    bool m_bScissorRestored;
public:
    enum ScrollViewScriptEventType
    {
        kScrollViewScroll = 0,
        kScrollViewZoom,
    };
    void registerScriptHandler(int nFunID,int nScriptEventType);
    void unregisterScriptHandler(int nScriptEventType);
    int getScriptHandler(int nScriptEventType);
private:
    std::map<int,int> m_mapScriptHandler;
};




}}
# 6 "Cacao/include/cocos2dext/CCBReader/CCScrollViewLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;




class CCScrollViewLoader : public CCNodeLoader {
    public:
        virtual ~CCScrollViewLoader() {};
        static CCScrollViewLoader * loader() { CCScrollViewLoader * ptr = new CCScrollViewLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCScrollView * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCScrollView::create(); };
  virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCCBFile(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCNode * pCCBFileNode, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloat, CCBReader * pCCBReader);
        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
};

}}
# 26 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCSpriteLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCSpriteLoader : public CCNodeLoader {
    public:
        virtual ~CCSpriteLoader() {};
        static CCSpriteLoader * loader() { CCSpriteLoader * ptr = new CCSpriteLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCSprite * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCSprite::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFlip(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool * pFlip, CCBReader * pCCBReader);
};

}}
# 27 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCBAnimationManager.h" 1
# 11 "Cacao/include/cocos2dext/CCBReader/CCBAnimationManager.h"
namespace cocos2d { namespace extension {




class CCBAnimationManagerDelegate
{
public:
    virtual void completedAnimationSequenceNamed(const char *name) = 0;
};

class CCBAnimationManager : public CCObject
{
private:
    CCArray *mSequences;
    CCDictionary *mNodeSequences;
    CCDictionary *mBaseValues;
    int mAutoPlaySequenceId;

    CCNode *mRootNode;

    CCSize mRootContainerSize;

    CCBAnimationManagerDelegate *mDelegate;
    CCBSequence *mRunningSequence;

    CCArray *mDocumentOutletNames;
    CCArray *mDocumentOutletNodes;
    CCArray *mDocumentCallbackNames;
    CCArray *mDocumentCallbackNodes;
    CCArray *mDocumentCallbackControlEvents;
    CCArray *mKeyframeCallbacks;
    CCDictionary *mKeyframeCallFuncs;

    std::string mDocumentControllerName;
    std::string lastCompletedSequenceName;

    SEL_CallFunc mAnimationCompleteCallbackFunc;
    CCObject *mTarget;


public:
    bool jsControlled;



    CCBAnimationManager();



    ~CCBAnimationManager();


    CCObject *mOwner;

    virtual bool init();

    CCArray* getSequences();
    void setSequences(CCArray* seq);


    int getAutoPlaySequenceId();
    void setAutoPlaySequenceId(int autoPlaySequenceId);

    CCNode* getRootNode();
    void setRootNode(CCNode* pRootNode);


    void addDocumentCallbackNode(CCNode *node);
    void addDocumentCallbackName(std::string name);
    void addDocumentCallbackControlEvents(CCControlEvent eventType);
    void addDocumentOutletNode(CCNode *node);
    void addDocumentOutletName(std::string name);

    void setDocumentControllerName(const std::string &name);

    std::string getDocumentControllerName();
    CCArray* getDocumentCallbackNames();
    CCArray* getDocumentCallbackNodes();
    CCArray* getDocumentCallbackControlEvents();
    CCArray* getDocumentOutletNames();
    CCArray* getDocumentOutletNodes();
    std::string getLastCompletedSequenceName();

    CCArray* getKeyframeCallbacks();

    const CCSize& getRootContainerSize();
    void setRootContainerSize(const CCSize &rootContainerSize);

    CCBAnimationManagerDelegate* getDelegate();
    void setDelegate(CCBAnimationManagerDelegate* pDelegate);

    const char* getRunningSequenceName();

    const CCSize& getContainerSize(CCNode* pNode);

    void addNode(CCNode *pNode, CCDictionary *pSeq);
    void setBaseValue(CCObject *pValue, CCNode *pNode, const char *pPropName);
    void moveAnimationsFromNode(CCNode* fromNode, CCNode* toNode);


    __attribute__((deprecated)) void runAnimations(const char *pName, float fTweenDuration);

    __attribute__((deprecated)) void runAnimations(const char *pName);

    __attribute__((deprecated)) void runAnimations(int nSeqId, float fTweenDuraiton);

    void runAnimationsForSequenceNamedTweenDuration(const char *pName, float fTweenDuration);
    void runAnimationsForSequenceNamed(const char *pName);
    void runAnimationsForSequenceIdTweenDuration(int nSeqId, float fTweenDuraiton);



    void setAnimationCompletedCallback(CCObject *target, SEL_CallFunc callbackFunc);

    void debug();



    void setCallFunc(CCCallFunc *callFunc, const std::string &callbackNamed);

    CCObject* actionForCallbackChannel(CCBSequenceProperty* channel);
    CCObject* actionForSoundChannel(CCBSequenceProperty* channel);

private:
    CCObject* getBaseValue(CCNode *pNode, const char* pPropName);
    int getSequenceId(const char* pSequenceName);
    CCBSequence* getSequence(int nSequenceId);
    CCActionInterval* getAction(CCBKeyframe *pKeyframe0, CCBKeyframe *pKeyframe1, const char *pPropName, CCNode *pNode);
    void setAnimatedProperty(const char *pPropName, CCNode *pNode, CCObject *pValue, float fTweenDuraion);
    void setFirstFrame(CCNode *pNode, CCBSequenceProperty *pSeqProp, float fTweenDuration);
    CCActionInterval* getEaseAction(CCActionInterval *pAction, int nEasingType, float fEasingOpt);
    void runAction(CCNode *pNode, CCBSequenceProperty *pSeqProp, float fTweenDuration);
    void sequenceCompleted();
};




class CCBSetSpriteFrame : public CCActionInstant
{
private:
    CCSpriteFrame *mSpriteFrame;

public:
    ~CCBSetSpriteFrame();


    static CCBSetSpriteFrame* create(CCSpriteFrame *pSpriteFrame);
    bool initWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
    virtual void update(float time);
    virtual CCObject* copyWithZone(CCZone *pZone);
};






class CCBSoundEffect : public CCActionInstant
{
private:
  std::string mSoundFile;
  float mPitch, mPan, mGain;

public:
    ~CCBSoundEffect();

    static CCBSoundEffect* actionWithSoundFile(const std::string &file, float pitch, float pan, float gain);
    bool initWithSoundFile(const std::string &file, float pitch, float pan, float gain);
    virtual void update(float time);
    virtual CCObject* copyWithZone(CCZone *pZone);
};





class CCBRotateTo : public CCActionInterval
{
private:
    float mStartAngle;
    float mDstAngle;
    float mDiffAngle;

public:
    static CCBRotateTo* create(float fDuration, float fAngle);
    bool initWithDuration(float fDuration, float fAngle);
    virtual void update(float time);
    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode *pNode);
};





class CCBRotateXTo: public CCActionInterval {
private:
    float mStartAngle;
    float mDstAngle;
    float mDiffAngle;
public:
    static CCBRotateXTo* create(float fDuration, float fAngle);
    bool initWithDuration(float fDuration, float fAngle);
    virtual void startWithTarget(CCNode *pNode);
    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void update(float time);
};





class CCBRotateYTo: public CCActionInterval {
private:
    float mStartAngle;
    float mDstAngle;
    float mDiffAngle;

public:
    static CCBRotateYTo* create(float fDuration, float fAngle);
    bool initWithDuration(float fDuration, float fAngle);
    virtual void startWithTarget(CCNode *pNode);
    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void update(float time);
};


class CCBEaseInstant : public CCActionEase
{
public:
    static CCBEaseInstant* create(CCActionInterval *pAction);

    virtual void update(float dt);
};


}}
# 28 "Cacao/include/cocos2dext/cocos-ext.h" 2




# 1 "Cacao/include/cocos2dext/CCBReader/CCData.h" 1







namespace cocos2d { namespace extension {




class CCData : public CCObject
{
public:
    CCData(unsigned char *pBytes, const unsigned long nSize);
    CCData(CCData *pData);
    ~CCData();

    unsigned char* getBytes();
    unsigned long getSize();

private:
    unsigned char* m_pBytes;
    unsigned long m_nSize;
};

}}
# 33 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCNode+CCBRelativePositioning.h" 1






namespace cocos2d { namespace extension {

extern CCPoint getAbsolutePosition(const CCPoint &pt, int nType, const CCSize &containerSize, const char *pPropName);

extern void setRelativeScale(CCNode *pNode, float fScaleX, float fScaleY, int nType, const char* pPropName);

}}
# 34 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 1
# 31 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h" 1
# 38 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlHuePicker.h" 1
# 39 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlHuePicker.h"
namespace cocos2d { namespace extension {
# 48 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlHuePicker.h"
class CCControlHuePicker : public CCControl
{

    protected: float m_hue;public: virtual float getHue(void) const { return m_hue; };
    virtual void setHue(float val);
    protected: float m_huePercentage;public: virtual float getHuePercentage(void) const { return m_huePercentage; };
    virtual void setHuePercentage(float val);



    private: CCSprite* m_background; public: virtual CCSprite* getBackground(void) const { return m_background; } public: virtual void setBackground(CCSprite* var) { if (m_background != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_background) { (m_background)->release(); } } while(0); m_background = var; } };
    private: CCSprite* m_slider; public: virtual CCSprite* getSlider(void) const { return m_slider; } public: virtual void setSlider(CCSprite* var) { if (m_slider != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_slider) { (m_slider)->release(); } } while(0); m_slider = var; } };
    protected: CCPoint m_startPos;public: virtual CCPoint getStartPos(void) const { return m_startPos; };

public:
    CCControlHuePicker();
    virtual ~CCControlHuePicker();
    virtual bool initWithTargetAndPos(CCNode* target, CCPoint pos);

    static CCControlHuePicker* create(CCNode* target, CCPoint pos);
    virtual void setEnabled(bool enabled);
protected:
    void updateSliderPosition(CCPoint location);
    bool checkSliderPosition(CCPoint location);

    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
};





}}
# 39 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSaturationBrightnessPicker.h" 1
# 39 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSaturationBrightnessPicker.h"
namespace cocos2d { namespace extension {
# 48 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSaturationBrightnessPicker.h"
class CCControlSaturationBrightnessPicker : public CCControl
{

    protected: float m_saturation;public: virtual float getSaturation(void) const { return m_saturation; };

    protected: float m_brightness;public: virtual float getBrightness(void) const { return m_brightness; };


    protected: CCSprite* m_background;public: virtual CCSprite* getBackground(void) const { return m_background; };
    protected: CCSprite* m_overlay;public: virtual CCSprite* getOverlay(void) const { return m_overlay; };
    protected: CCSprite* m_shadow;public: virtual CCSprite* getShadow(void) const { return m_shadow; };
    protected: CCSprite* m_slider;public: virtual CCSprite* getSlider(void) const { return m_slider; };
    protected: CCPoint m_startPos;public: virtual CCPoint getStartPos(void) const { return m_startPos; };

protected:
    int boxPos;
    int boxSize;

public:
    CCControlSaturationBrightnessPicker();
    virtual ~CCControlSaturationBrightnessPicker();
    virtual bool initWithTargetAndPos(CCNode* target, CCPoint pos);

    static CCControlSaturationBrightnessPicker* create(CCNode* target, CCPoint pos);

    virtual void setEnabled(bool enabled);
    virtual void updateWithHSV(HSV hsv);
    virtual void updateDraggerWithHSV(HSV hsv);

protected:
    void updateSliderPosition(CCPoint location);
    bool checkSliderPosition(CCPoint location);

    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
};





}}
# 40 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h" 2

namespace cocos2d { namespace extension {
# 50 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h"
class CCControlColourPicker: public CCControl
{
public:
    CCControlColourPicker();
    virtual ~CCControlColourPicker();
    virtual void setColor(const ccColor3B& colorValue);
    virtual void setEnabled(bool bEnabled);
protected:
    HSV m_hsv;
    private: CCControlSaturationBrightnessPicker* m_colourPicker; public: virtual CCControlSaturationBrightnessPicker* getcolourPicker(void) const { return m_colourPicker; } public: virtual void setcolourPicker(CCControlSaturationBrightnessPicker* var) { if (m_colourPicker != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_colourPicker) { (m_colourPicker)->release(); } } while(0); m_colourPicker = var; } }
    private: CCControlHuePicker* m_huePicker; public: virtual CCControlHuePicker* getHuePicker(void) const { return m_huePicker; } public: virtual void setHuePicker(CCControlHuePicker* var) { if (m_huePicker != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_huePicker) { (m_huePicker)->release(); } } while(0); m_huePicker = var; } }
    private: CCSprite* m_background; public: virtual CCSprite* getBackground(void) const { return m_background; } public: virtual void setBackground(CCSprite* var) { if (m_background != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_background) { (m_background)->release(); } } while(0); m_background = var; } }

public:

    static CCControlColourPicker* create();

    virtual bool init();

    void hueSliderValueChanged(CCObject * sender, CCControlEvent controlEvent);
    void colourSliderValueChanged(CCObject * sender, CCControlEvent controlEvent);

protected:
    void updateControlPicker();
    void updateHueAndControlPicker();
    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);

};





}}
# 32 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlPotentiometer.h" 1
# 32 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlPotentiometer.h"
namespace cocos2d { namespace extension {
# 42 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlPotentiometer.h"
class CCControlPotentiometer : public CCControl
{
public:
    CCControlPotentiometer();
    virtual ~CCControlPotentiometer();



    static CCControlPotentiometer* create(const char* backgroundFile, const char* progressFile, const char* thumbFile);







    bool initWithTrackSprite_ProgressTimer_ThumbSprite(CCSprite* trackSprite, CCProgressTimer* progressTimer, CCSprite* thumbSprite);
    void setValue(float value);
    float getValue();

    void setMinimumValue(float minimumValue);
    float getMinimumValue();

    void setMaximumValue(float maximumValue);
    float getMaximumValue();

    void setEnabled(bool enabled);

    virtual bool isTouchInside(CCTouch * touch);

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);

protected:
    private: CCSprite* m_pThumbSprite; public: virtual CCSprite* getThumbSprite(void) const { return m_pThumbSprite; } public: virtual void setThumbSprite(CCSprite* var) { if (m_pThumbSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pThumbSprite) { (m_pThumbSprite)->release(); } } while(0); m_pThumbSprite = var; } }
    private: CCProgressTimer* m_pProgressTimer; public: virtual CCProgressTimer* getProgressTimer(void) const { return m_pProgressTimer; } public: virtual void setProgressTimer(CCProgressTimer* var) { if (m_pProgressTimer != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pProgressTimer) { (m_pProgressTimer)->release(); } } while(0); m_pProgressTimer = var; } }
    protected: CCPoint m_tPreviousLocation;public: virtual CCPoint getPreviousLocation(void) const { return m_tPreviousLocation; }public: virtual void setPreviousLocation(CCPoint var){ m_tPreviousLocation = var; }

    float m_fValue;


    float m_fMinimumValue;


    float m_fMaximumValue;

    void potentiometerBegan(CCPoint location);
    void potentiometerMoved(CCPoint location);
    void potentiometerEnded(CCPoint location);


    float distanceBetweenPointAndPoint(CCPoint point1, CCPoint point2);

    float angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(
        CCPoint beginLineA,
        CCPoint endLineA,
        CCPoint beginLineB,
        CCPoint endLineB);

};





}}
# 33 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h" 1
# 36 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h"
namespace cocos2d { namespace extension {
# 45 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h"
class CCControlSlider: public CCControl
{


    protected: float m_value;public: virtual float getValue(void) const { return m_value; };
    virtual void setValue(float val);


    protected: float m_minimumValue;public: virtual float getMinimumValue(void) const { return m_minimumValue; };
    virtual void setMinimumValue(float val);


    protected: float m_maximumValue;public: virtual float getMaximumValue(void) const { return m_maximumValue; };
    virtual void setMaximumValue(float val);
    virtual void setEnabled(bool enabled);
    virtual bool isTouchInside(CCTouch * touch);
    CCPoint locationFromTouch(CCTouch* touch);

    protected: float m_minimumAllowedValue;public: virtual float getMinimumAllowedValue(void) const { return m_minimumAllowedValue; }public: virtual void setMinimumAllowedValue(float var){ m_minimumAllowedValue = var; };
    protected: float m_maximumAllowedValue;public: virtual float getMaximumAllowedValue(void) const { return m_maximumAllowedValue; }public: virtual void setMaximumAllowedValue(float var){ m_maximumAllowedValue = var; };


    private: CCSprite* m_thumbSprite; public: virtual CCSprite* getThumbSprite(void) const { return m_thumbSprite; } public: virtual void setThumbSprite(CCSprite* var) { if (m_thumbSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_thumbSprite) { (m_thumbSprite)->release(); } } while(0); m_thumbSprite = var; } };
    private: CCSprite* m_progressSprite; public: virtual CCSprite* getProgressSprite(void) const { return m_progressSprite; } public: virtual void setProgressSprite(CCSprite* var) { if (m_progressSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_progressSprite) { (m_progressSprite)->release(); } } while(0); m_progressSprite = var; } };
    private: CCSprite* m_backgroundSprite; public: virtual CCSprite* getBackgroundSprite(void) const { return m_backgroundSprite; } public: virtual void setBackgroundSprite(CCSprite* var) { if (m_backgroundSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_backgroundSprite) { (m_backgroundSprite)->release(); } } while(0); m_backgroundSprite = var; } };

public:
    CCControlSlider();
    virtual ~CCControlSlider();
# 83 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h"
    virtual bool initWithSprites(CCSprite * backgroundSprite, CCSprite* progressSprite, CCSprite* thumbSprite);





    static CCControlSlider* create(const char* bgFile, const char* progressFile, const char* thumbFile);







    static CCControlSlider* create(CCSprite * backgroundSprite, CCSprite* pogressSprite, CCSprite* thumbSprite);

    virtual void needsLayout();
protected:
    void sliderBegan(CCPoint location);
    void sliderMoved(CCPoint location);
    void sliderEnded(CCPoint location);

    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);


    float valueForLocation(CCPoint location);
};





}}
# 34 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlStepper.h" 1
# 33 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlStepper.h"
namespace cocos2d { namespace extension {
# 42 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlStepper.h"
typedef enum
{
    kCCControlStepperPartMinus,
    kCCControlStepperPartPlus,
    kCCControlStepperPartNone,
} CCControlStepperPart;

class CCControlStepper : public CCControl
{
public:
    CCControlStepper();
    virtual ~CCControlStepper();

    bool initWithMinusSpriteAndPlusSprite(CCSprite *minusSprite, CCSprite *plusSprite);
    static CCControlStepper* create(CCSprite *minusSprite, CCSprite *plusSprite);
    virtual void setWraps(bool wraps);
    virtual void setMinimumValue(double minimumValue);
    virtual void setMaximumValue(double maximumValue);
    virtual void setValue(double value);
    virtual double getValue();
    virtual void setStepValue(double stepValue);

    virtual void setValueWithSendingEvent(double value, bool send);
    virtual bool isContinuous();
    void update(float dt);


    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);

protected:

 private: CCSprite* m_pMinusSprite; public: virtual CCSprite* getMinusSprite(void) const { return m_pMinusSprite; } public: virtual void setMinusSprite(CCSprite* var) { if (m_pMinusSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pMinusSprite) { (m_pMinusSprite)->release(); } } while(0); m_pMinusSprite = var; } }
    private: CCSprite* m_pPlusSprite; public: virtual CCSprite* getPlusSprite(void) const { return m_pPlusSprite; } public: virtual void setPlusSprite(CCSprite* var) { if (m_pPlusSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pPlusSprite) { (m_pPlusSprite)->release(); } } while(0); m_pPlusSprite = var; } }
    private: CCLabelTTF* m_pMinusLabel; public: virtual CCLabelTTF* getMinusLabel(void) const { return m_pMinusLabel; } public: virtual void setMinusLabel(CCLabelTTF* var) { if (m_pMinusLabel != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pMinusLabel) { (m_pMinusLabel)->release(); } } while(0); m_pMinusLabel = var; } }
    private: CCLabelTTF* m_pPlusLabel; public: virtual CCLabelTTF* getPlusLabel(void) const { return m_pPlusLabel; } public: virtual void setPlusLabel(CCLabelTTF* var) { if (m_pPlusLabel != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pPlusLabel) { (m_pPlusLabel)->release(); } } while(0); m_pPlusLabel = var; } }


    void updateLayoutUsingTouchLocation(CCPoint location);


    void startAutorepeat();


    void stopAutorepeat();


    double m_dValue;

    bool m_bContinuous;

    bool m_bAutorepeat;

    bool m_bWraps;

    double m_dMinimumValue;

    double m_dMaximumValue;

    double m_dStepValue;
    bool m_bTouchInsideFlag;
    CCControlStepperPart m_eTouchedPart;
    int m_nAutorepeatCount;
};





}}
# 35 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h" 1
# 34 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h"
namespace cocos2d { class CCSprite; }
namespace cocos2d { class CCLabelTTF; }

namespace cocos2d { namespace extension {

class CCControlSwitchSprite;
# 49 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h"
class CCControlSwitch : public CCControl
{
public:
    CCControlSwitch();
    virtual ~CCControlSwitch();

    bool initWithMaskSprite(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite);


    static CCControlSwitch* create(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite);



    bool initWithMaskSprite(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);


    static CCControlSwitch* create(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);
# 76 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h"
    void setOn(bool isOn, bool animated);
    void setOn(bool isOn);
    bool isOn(void) { return m_bOn; }
    bool hasMoved() { return m_bMoved; }
    virtual void setEnabled(bool enabled);

    CCPoint locationFromTouch(CCTouch* touch);

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

protected:

    CCControlSwitchSprite* m_pSwitchSprite;
    float m_fInitialTouchXPosition;

    bool m_bMoved;

    bool m_bOn;
};





}}
# 36 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 36 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h" 1
# 30 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCTableViewCell.h" 1
# 30 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCTableViewCell.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h" 1
# 32 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
namespace cocos2d { namespace extension {




class CCSortableObject
{
public:
    virtual ~CCSortableObject() {}
    virtual void setObjectID(unsigned int objectID) = 0;
    virtual unsigned int getObjectID() = 0;
};




class CCArrayForObjectSorting : public CCArray
{
public:
    CCArrayForObjectSorting() : CCArray() {}
# 63 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    void insertSortedObject(CCSortableObject* object);
# 73 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    void removeSortedObject(CCSortableObject* object);
# 84 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    void setObjectID_ofSortedObject(unsigned int tag, CCSortableObject* object);

    CCSortableObject* objectWithObjectID(unsigned int tag);
# 96 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    CCSortableObject* getObjectWithObjectID(unsigned int tag);
# 109 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    unsigned int indexOfSortedObject(CCSortableObject* obj);

};

}}
# 31 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCTableViewCell.h" 2

namespace cocos2d { namespace extension {





class CCTableViewCell: public CCNode, public CCSortableObject
{
public:
    CCTableViewCell() {}



    unsigned int getIdx();
    void setIdx(unsigned int uIdx);



    void reset();

    void setObjectID(unsigned int uIdx);
    unsigned int getObjectID();
private:
    unsigned int m_uIdx;
};

}}
# 31 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h" 2




namespace cocos2d { namespace extension {

class CCTableView;
class CCArrayForObjectSorting;

typedef enum {
    kCCTableViewFillTopDown,
    kCCTableViewFillBottomUp
} CCTableViewVerticalFillOrder;






class CCTableViewDelegate : public CCScrollViewDelegate
{
public:






    virtual void tableCellTouched(CCTableView* table, CCTableViewCell* cell) = 0;







    virtual void tableCellHighlight(CCTableView* table, CCTableViewCell* cell){};







    virtual void tableCellUnhighlight(CCTableView* table, CCTableViewCell* cell){};
# 85 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
    virtual void tableCellWillRecycle(CCTableView* table, CCTableViewCell* cell){};

};






class CCTableViewDataSource
{
public:
    virtual ~CCTableViewDataSource() {}







    virtual CCSize tableCellSizeForIndex(CCTableView *table, unsigned int idx) {
        return cellSizeForTable(table);
    };






    virtual CCSize cellSizeForTable(CCTableView *table) {
        return CCSizeZero;
    };






    virtual CCTableViewCell* tableCellAtIndex(CCTableView *table, unsigned int idx) = 0;





    virtual unsigned int numberOfCellsInTableView(CCTableView *table) = 0;

};
# 140 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
class CCTableView : public CCScrollView, public CCScrollViewDelegate
{
public:



    CCTableView();



    virtual ~CCTableView();
# 159 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
    static CCTableView* create(CCTableViewDataSource* dataSource, CCSize size);
# 168 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
    static CCTableView* create(CCTableViewDataSource* dataSource, CCSize size, CCNode *container);





    CCTableViewDataSource* getDataSource() { return m_pDataSource; }
    void setDataSource(CCTableViewDataSource* source) { m_pDataSource = source; }




    CCTableViewDelegate* getDelegate() { return m_pTableViewDelegate; }
    void setDelegate(CCTableViewDelegate* pDelegate) { m_pTableViewDelegate = pDelegate; }




    void setVerticalFillOrder(CCTableViewVerticalFillOrder order);
    CCTableViewVerticalFillOrder getVerticalFillOrder();


    bool initWithViewSize(CCSize size, CCNode* container = __null);





    void updateCellAtIndex(unsigned int idx);





    void insertCellAtIndex(unsigned int idx);





    void removeCellAtIndex(unsigned int idx);



    void reloadData();





    CCTableViewCell *dequeueCell();







    CCTableViewCell *cellAtIndex(unsigned int idx);


    virtual void scrollViewDidScroll(CCScrollView* view);
    virtual void scrollViewDidZoom(CCScrollView* view) {}

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

protected:

    CCTableViewCell *m_pTouchedCell;



    CCTableViewVerticalFillOrder m_eVordering;




    std::set<unsigned int>* m_pIndices;




    std::vector<float> m_vCellsPositions;




    CCArrayForObjectSorting* m_pCellsUsed;



    CCArrayForObjectSorting* m_pCellsFreed;



    CCTableViewDataSource* m_pDataSource;



    CCTableViewDelegate* m_pTableViewDelegate;

 CCScrollViewDirection m_eOldDirection;

    int __indexFromOffset(CCPoint offset);
    unsigned int _indexFromOffset(CCPoint offset);
    CCPoint __offsetFromIndex(unsigned int index);
    CCPoint _offsetFromIndex(unsigned int index);

    void _moveCellOutOfSight(CCTableViewCell *cell);
    void _setIndexForCell(unsigned int index, CCTableViewCell *cell);
    void _addCellIfNecessary(CCTableViewCell * cell);

    void _updateCellPositions();
public:
    void _updateContentSize();

    enum TableViewScriptEventType
    {
        kTableViewScroll = 0,
        kTableViewZoom,
        kTableCellTouched,
        kTableCellHighLight,
        kTableCellUnhighLight,
        kTableCellWillRecycle,
        kTableCellSizeForIndex,
        kTableCellSizeAtIndex,
        kNumberOfCellsInTableView,
    };
    void unregisterAllScriptHandler();
};


}}
# 38 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h" 1
# 33 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
namespace cocos2d { namespace extension {


enum KeyboardReturnType {
    kKeyboardReturnTypeDefault = 0,
    kKeyboardReturnTypeDone,
    kKeyboardReturnTypeSend,
    kKeyboardReturnTypeSearch,
    kKeyboardReturnTypeGo
};






enum EditBoxInputMode
{



    kEditBoxInputModeAny = 0,




    kEditBoxInputModeEmailAddr,




    kEditBoxInputModeNumeric,




    kEditBoxInputModePhoneNumber,




    kEditBoxInputModeUrl,





    kEditBoxInputModeDecimal,




    kEditBoxInputModeSingleLine
};




enum EditBoxInputFlag
{




    kEditBoxInputFlagPassword = 0,







    kEditBoxInputFlagSensitive,





    kEditBoxInputFlagInitialCapsWord,





    kEditBoxInputFlagInitialCapsSentence,




    kEditBoxInputFlagInitialCapsAllCharacters

};


class CCEditBox;
class CCEditBoxImpl;





class CCEditBoxDelegate
{
public:
    virtual ~CCEditBoxDelegate() {};





    virtual void editBoxEditingDidBegin(CCEditBox* editBox) {};






    virtual void editBoxEditingDidEnd(CCEditBox* editBox) {};






    virtual void editBoxTextChanged(CCEditBox* editBox, const std::string& text) {};





    virtual void editBoxReturn(CCEditBox* editBox) = 0;

};
# 174 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
class CCEditBox
: public CCControlButton
, public CCIMEDelegate
{
public:



    CCEditBox(void);




    virtual ~CCEditBox(void);





    static CCEditBox* create(const CCSize& size, CCScale9Sprite* pNormal9SpriteBg, CCScale9Sprite* pPressed9SpriteBg = __null, CCScale9Sprite* pDisabled9SpriteBg = __null);





    bool initWithSizeAndBackgroundSprite(const CCSize& size, CCScale9Sprite* pNormal9SpriteBg);





    void setDelegate(CCEditBoxDelegate* pDelegate);




    CCEditBoxDelegate* getDelegate();
# 236 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
    void registerScriptEditBoxHandler(int handler);





    void unregisterScriptEditBoxHandler(void);




    int getScriptEditBoxHandler(void){ return m_nScriptEditBoxHandler ;}




    void setText(const char* pText);





    const char* getText(void);






 void setFont(const char* pFontName, int fontSize);





 void setFontName(const char* pFontName);





 void setFontSize(int fontSize);




    void setFontColor(const ccColor3B& color);






 void setPlaceholderFont(const char* pFontName, int fontSize);





 void setPlaceholderFontName(const char* pFontName);





 void setPlaceholderFontSize(int fontSize);





    void setPlaceholderFontColor(const ccColor3B& color);






    void setPlaceHolder(const char* pText);





    const char* getPlaceHolder(void);





    void setInputMode(EditBoxInputMode inputMode);
# 335 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
    void setMaxLength(int maxLength);






    int getMaxLength();





    void setInputFlag(EditBoxInputFlag inputFlag);





    void setReturnType(KeyboardReturnType returnType);


    virtual void setPosition(const CCPoint& pos);
    virtual void setVisible(bool visible);
    virtual void setContentSize(const CCSize& size);
 virtual void setAnchorPoint(const CCPoint& anchorPoint);



    virtual void visit(void);




 virtual void onEnter(void);




    virtual void onExit(void);




    virtual void keyboardWillShow(CCIMEKeyboardNotificationInfo& info);




    virtual void keyboardDidShow(CCIMEKeyboardNotificationInfo& info);




    virtual void keyboardWillHide(CCIMEKeyboardNotificationInfo& info);




    virtual void keyboardDidHide(CCIMEKeyboardNotificationInfo& info);




    void touchDownAction(CCObject *sender, CCControlEvent controlEvent);

protected:
    CCEditBoxImpl* m_pEditBoxImpl;
    CCEditBoxDelegate* m_pDelegate;

    EditBoxInputMode m_eEditBoxInputMode;
    EditBoxInputFlag m_eEditBoxInputFlag;
    KeyboardReturnType m_eKeyboardReturnType;

    std::string m_strText;
    std::string m_strPlaceHolder;

    std::string m_strFontName;
    std::string m_strPlaceholderFontName;

    int m_nFontSize;
    int m_nPlaceholderFontSize;

    ccColor3B m_colText;
    ccColor3B m_colPlaceHolder;

    int m_nMaxLength;
    float m_fAdjustHeight;
    int m_nScriptEditBoxHandler;
};

}}
# 39 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/network/HttpRequest.h" 1
# 31 "Cacao/include/cocos2dext/network/HttpRequest.h"
namespace cocos2d { namespace extension {

class CCHttpClient;
class CCHttpResponse;
typedef void (CCObject::*SEL_HttpResponse)(CCHttpClient* client, CCHttpResponse* response);
# 46 "Cacao/include/cocos2dext/network/HttpRequest.h"
class CCHttpRequest : public CCObject
{
public:

    typedef enum
    {
        kHttpGet,
        kHttpPost,
        kHttpPut,
        kHttpDelete,
        kHttpUnkown,
    } HttpRequestType;







    CCHttpRequest()
    {
        _requestType = kHttpUnkown;
        _url.clear();
        _requestData.clear();
        _tag.clear();
        _pTarget = __null;
        _pSelector = __null;
        _pUserData = __null;
    };


    virtual ~CCHttpRequest()
    {
        if (_pTarget)
        {
            _pTarget->release();
        }
    };


    CCObject* autorelease(void)
    {
        ((void)(false));

        return __null;
    }






    inline void setRequestType(HttpRequestType type)
    {
        _requestType = type;
    };

    inline HttpRequestType getRequestType()
    {
        return _requestType;
    };



    inline void setUrl(const char* url)
    {
        _url = url;
    };

    inline const char* getUrl()
    {
        return _url.c_str();
    };



    inline void setRequestData(const char* buffer, unsigned int len)
    {
        _requestData.assign(buffer, buffer + len);
    };

    inline char* getRequestData()
    {
        return &(_requestData.front());
    }

    inline int getRequestDataSize()
    {
        return _requestData.size();
    }



    inline void setTag(const char* tag)
    {
        _tag = tag;
    };



    inline const char* getTag()
    {
        return _tag.c_str();
    };




    inline void setUserData(void* pUserData)
    {
        _pUserData = pUserData;
    };



    inline void* getUserData()
    {
        return _pUserData;
    };



    __attribute__((deprecated)) inline void setResponseCallback(CCObject* pTarget, SEL_CallFuncND pSelector)
    {
        setResponseCallback(pTarget, (SEL_HttpResponse) pSelector);
    }

    inline void setResponseCallback(CCObject* pTarget, SEL_HttpResponse pSelector)
    {
        _pTarget = pTarget;
        _pSelector = pSelector;

        if (_pTarget)
        {
            _pTarget->retain();
        }
    }

    inline CCObject* getTarget()
    {
        return _pTarget;
    }



    class _prxy
    {
    public:
        _prxy( SEL_HttpResponse cb ) :_cb(cb) {}
        ~_prxy(){};
        operator SEL_HttpResponse() const { return _cb; }
        __attribute__((deprecated)) operator SEL_CallFuncND() const { return (SEL_CallFuncND) _cb; }
    protected:
        SEL_HttpResponse _cb;
    };


    inline _prxy getSelector()
    {
        return _prxy(_pSelector);
    }


    inline void setHeaders(std::vector<std::string> pHeaders)
    {
     _headers=pHeaders;
    }


    inline std::vector<std::string> getHeaders()
    {
     return _headers;
    }


protected:

    HttpRequestType _requestType;
    std::string _url;
    std::vector<char> _requestData;
    std::string _tag;
    CCObject* _pTarget;
    SEL_HttpResponse _pSelector;
    void* _pUserData;
    std::vector<std::string> _headers;
};

}}
# 41 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/network/HttpResponse.h" 1
# 32 "Cacao/include/cocos2dext/network/HttpResponse.h"
namespace cocos2d { namespace extension {
# 41 "Cacao/include/cocos2dext/network/HttpResponse.h"
class CCHttpResponse : public CCObject
{
public:



    CCHttpResponse(CCHttpRequest* request)
    {
        _pHttpRequest = request;
        if (_pHttpRequest)
        {
            _pHttpRequest->retain();
        }

        _succeed = false;
        _responseData.clear();
        _errorBuffer.clear();
    }




    virtual ~CCHttpResponse()
    {
        if (_pHttpRequest)
        {
            _pHttpRequest->release();
        }
    }


    CCObject* autorelease(void)
    {
        ((void)(false));

        return __null;
    }






    inline CCHttpRequest* getHttpRequest()
    {
        return _pHttpRequest;
    }





    inline bool isSucceed()
    {
        return _succeed;
    };


    inline std::vector<char>* getResponseData()
    {
        return &_responseData;
    }


    inline std::vector<char>* getResponseHeader()
    {
        return &_responseHeader;
    }




    inline int getResponseCode()
    {
        return _responseCode;
    }



    inline const char* getErrorBuffer()
    {
        return _errorBuffer.c_str();
    }
# 133 "Cacao/include/cocos2dext/network/HttpResponse.h"
    inline void setSucceed(bool value)
    {
        _succeed = value;
    };




    inline void setResponseData(std::vector<char>* data)
    {
        _responseData = *data;
    }



    inline void setResponseHeader(std::vector<char>* data)
    {
        _responseHeader = *data;
    }




    inline void setResponseCode(int value)
    {
        _responseCode = value;
    }




    inline void setErrorBuffer(const char* value)
    {
        _errorBuffer.clear();
        _errorBuffer.assign(value);
    };

protected:
    bool initWithRequest(CCHttpRequest* request);


    CCHttpRequest* _pHttpRequest;
    bool _succeed;
    std::vector<char> _responseData;
    std::vector<char> _responseHeader;
    int _responseCode;
    std::string _errorBuffer;

};

}}
# 42 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/network/HttpClient.h" 1
# 35 "Cacao/include/cocos2dext/network/HttpClient.h"
namespace cocos2d { namespace extension {
# 48 "Cacao/include/cocos2dext/network/HttpClient.h"
class CCHttpClient : public CCObject
{
public:

    static CCHttpClient *getInstance();


    static void destroyInstance();







    void send(CCHttpRequest* request);







    inline void setTimeoutForConnect(int value) {_timeoutForConnect = value;};






    inline int getTimeoutForConnect() {return _timeoutForConnect;}







    inline void setTimeoutForRead(int value) {_timeoutForRead = value;};






    inline int getTimeoutForRead() {return _timeoutForRead;};

private:
    CCHttpClient();
    virtual ~CCHttpClient();
    bool init(void);





    bool lazyInitThreadSemphore();

    void dispatchResponseCallbacks(float delta);

private:
    int _timeoutForConnect;
    int _timeoutForRead;


};




}}
# 43 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDefine.h" 1
# 65 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDefine.h"
namespace cocos2d { namespace extension {

const char *armatureVersion();

}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/../utils/CCTweenFunction.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/../utils/CCTweenFunction.h"
namespace cocos2d { namespace extension {

enum CCTweenType
{
    CUSTOM_EASING = -1,

    Linear,

    Sine_EaseIn,
    Sine_EaseOut,
    Sine_EaseInOut,


    Quad_EaseIn,
    Quad_EaseOut,
    Quad_EaseInOut,

    Cubic_EaseIn,
    Cubic_EaseOut,
    Cubic_EaseInOut,

    Quart_EaseIn,
    Quart_EaseOut,
    Quart_EaseInOut,

    Quint_EaseIn,
    Quint_EaseOut,
    Quint_EaseInOut,

    Expo_EaseIn,
    Expo_EaseOut,
    Expo_EaseInOut,

    Circ_EaseIn,
    Circ_EaseOut,
    Circ_EaseInOut,

    Elastic_EaseIn,
    Elastic_EaseOut,
    Elastic_EaseInOut,

    Back_EaseIn,
    Back_EaseOut,
    Back_EaseInOut,

    Bounce_EaseIn,
    Bounce_EaseOut,
    Bounce_EaseInOut,

    TWEEN_EASING_MAX = 10000
};




class CCTweenFunction
{
public:

    static float tweenTo(float time, CCTweenType type, float *easingParam);

    static float linear(float time);

    static float sineEaseIn(float time);
    static float sineEaseOut(float time);
    static float sineEaseInOut(float time);

    static float quadEaseIn(float time);
    static float quadEaseOut(float time);
    static float quadEaseInOut(float time);

    static float cubicEaseIn(float time);
    static float cubicEaseOut(float time);
    static float cubicEaseInOut(float time);

    static float quartEaseIn(float time);
    static float quartEaseOut(float time);
    static float quartEaseInOut(float time);

    static float quintEaseIn(float time);
    static float quintEaseOut(float time);
    static float quintEaseInOut(float time);

    static float expoEaseIn(float time);
    static float expoEaseOut(float time);
    static float expoEaseInOut(float time);

    static float circEaseIn(float time);
    static float circEaseOut(float time);
    static float circEaseInOut(float time);

    static float elasticEaseIn(float time, float *easingParam);
    static float elasticEaseOut(float time, float *easingParam);
    static float elasticEaseInOut(float time, float *easingParam);

    static float backEaseIn(float time);
    static float backEaseOut(float time);
    static float backEaseInOut(float time);

    static float bounceEaseIn(float time);
    static float bounceEaseOut(float time);
    static float bounceEaseInOut(float time);

    static float customEase(float time, float *easingParam);
};


}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h" 2
# 58 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
namespace cocos2d { namespace extension {





class CCBaseData : public CCObject
{
public:
    public: static inline CCBaseData *create(void){ CCBaseData *var = new CCBaseData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:



    CCBaseData();



    ~CCBaseData(void);





    virtual void copy(const CCBaseData *node);







    virtual void subtract(CCBaseData *from, CCBaseData *to, bool limit);

    virtual void setColor(const ccColor4B &color);
    virtual ccColor4B getColor();
public:
    float x;
    float y;
    int zOrder;






    float skewX;
    float skewY;
    float scaleX;
    float scaleY;

    float tweenRotate;

    bool isUseColorInfo;
    int a, r, g, b;

};





enum DisplayType
{
    CS_DISPLAY_SPRITE,
    CS_DISPLAY_ARMATURE,
    CS_DISPLAY_PARTICLE,

    CS_DISPLAY_MAX
};




class CCDisplayData : public CCObject
{
public:
    public: static inline CCDisplayData *create(void){ CCDisplayData *var = new CCDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}

    static const char *changeDisplayToTexture(const char *displayName);
public:
    CCDisplayData();
    virtual ~CCDisplayData(void) {};

    virtual void copy(CCDisplayData *displayData);

    DisplayType displayType;
    std::string displayName;
};






class CCSpriteDisplayData : public CCDisplayData
{
public:
    public: static inline CCSpriteDisplayData *create(void){ CCSpriteDisplayData *var = new CCSpriteDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCSpriteDisplayData();
    virtual ~CCSpriteDisplayData() {};

    void copy(CCDisplayData *displayData);
public:
    CCBaseData skinData;
};





class CCArmatureDisplayData : public CCDisplayData
{
public:
    public: static inline CCArmatureDisplayData *create(void){ CCArmatureDisplayData *var = new CCArmatureDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCArmatureDisplayData();
    virtual ~CCArmatureDisplayData() {};
};





class CCParticleDisplayData : public CCDisplayData
{
public:
    public: static inline CCParticleDisplayData *create(void){ CCParticleDisplayData *var = new CCParticleDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCParticleDisplayData();
    virtual ~CCParticleDisplayData() {};
public:
};
# 202 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCBoneData : public CCBaseData
{
public:
    public: static inline CCBoneData *create(void){ CCBoneData *var = new CCBoneData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCBoneData(void);
    ~CCBoneData(void);

    virtual bool init();

    void addDisplayData(CCDisplayData *displayData);
    CCDisplayData *getDisplayData(int index);
public:
    std::string name;
    std::string parentName;
    CCArray displayDataList;
    CCAffineTransform boneDataTransform;
};
# 229 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCArmatureData : public CCObject
{
public:
    public: static inline CCArmatureData *create(void){ CCArmatureData *var = new CCArmatureData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCArmatureData();
    ~CCArmatureData();

    bool init();
    void addBoneData(CCBoneData *boneData);
    CCBoneData *getBoneData(const char *boneName);
public:
    std::string name;
    CCDictionary boneDataDic;
    float dataVersion;
};

enum CCBlendType
{
    BLEND_NORMAL,
    BLEND_LAYER,
    BLEND_DARKEN,
    BLEND_MULTIPLY,
    BLEND_LIGHTEN,
    BLEND_SCREEN,
    BLEND_OVERLAY,
    BLEND_HARD_LIGHT,
    BLEND_ADD,
    BLEND_SUBSTRACT,
    BLEND_DIFFERENCE,
    BLEND_INVERT,
    BLEND_ALPHA,
    BLEND_ERASE
};





class CCFrameData : public CCBaseData
{
public:
    public: static inline CCFrameData *create(void){ CCFrameData *var = new CCFrameData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCFrameData();
    ~CCFrameData();

    virtual void copy(const CCBaseData *node);
public:
    int frameID;
    int duration;

    CCTweenType tweenEasing;
    int easingParamNumber;
    float *easingParams;

    bool isTween;





    int displayIndex;

    ccBlendFunc blendFunc;

    std::string strEvent;



    std::string strMovement;
    std::string strSound;
    std::string strSoundEffect;
};





class CCMovementBoneData : public CCObject
{
public:
    public: static inline CCMovementBoneData *create(void){ CCMovementBoneData *var = new CCMovementBoneData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCMovementBoneData();
    ~CCMovementBoneData(void);

    virtual bool init();

    void addFrameData(CCFrameData *frameData);
    CCFrameData *getFrameData(int index);
public:
    float delay;
    float scale;
    float duration;
    std::string name;

    CCArray frameList;
};





class CCMovementData : public CCObject
{
public:
    public: static inline CCMovementData *create(void){ CCMovementData *var = new CCMovementData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCMovementData(void);
    ~CCMovementData(void);

    void addMovementBoneData(CCMovementBoneData *movBoneData);
    CCMovementBoneData *getMovementBoneData(const char *boneName);
public:
    std::string name;
    int duration;
    float scale;







    int durationTo;







    int durationTween;

    bool loop;





    CCTweenType tweenEasing;






    CCDictionary movBoneDataDic;
};
# 388 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCAnimationData : public CCObject
{
public:
    public: static inline CCAnimationData *create(void){ CCAnimationData *var = new CCAnimationData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCAnimationData(void);
    ~CCAnimationData(void);

    void addMovement(CCMovementData *movData);
    CCMovementData *getMovement(const char *movementName);
    int getMovementCount();
public:
    std::string name;
    CCDictionary movementDataDic;
    std::vector<std::string> movementNames;
};


struct CCContourVertex2 : public CCObject
{
    CCContourVertex2(float xx, float yy)
    {
        this->x = xx;
        this->y = yy;
    }

    float x;
    float y;
};






class CCContourData : public CCObject
{
public:
    public: static inline CCContourData *create(void){ CCContourData *var = new CCContourData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCContourData();
    ~CCContourData(void);

    virtual bool init();
    virtual void addVertex(CCPoint *vertex);
public:
    CCArray vertexList;
};
# 445 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCTextureData : public CCObject
{
public:
    public: static inline CCTextureData *create(void){ CCTextureData *var = new CCTextureData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCTextureData();
    ~CCTextureData(void);

    virtual bool init();

    void addContourData(CCContourData *contourData);
    CCContourData *getContourData(int index);
public:

    float height;
    float width;

    float pivotX;
    float pivotY;

    std::string name;

    CCArray contourDataList;
};


}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h"
namespace cocos2d { namespace extension {

enum AnimationType
{
    SINGLE_FRAME = -4,
    ANIMATION_NO_LOOP,

    ANIMATION_TO_LOOP_FRONT,
    ANIMATION_TO_LOOP_BACK,

    ANIMATION_LOOP_FRONT,
    ANIMATION_LOOP_BACK,

    ANIMATION_MAX,

};





class CCProcessBase : public CCObject
{
public:
    CCProcessBase(void);
    ~CCProcessBase(void);
# 86 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h"
    virtual void play(int durationTo, int durationTween, int loop, int tweenEasing);




    virtual void pause();



    virtual void resume();



    virtual void stop();
# 109 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h"
    virtual void update(float dt);

    virtual int getCurrentFrameIndex();

protected:

    virtual void gotoFrame(int frameIndex);




    virtual void updateHandler() {};

protected:

    protected: float m_fProcessScale;public: virtual float getProcessScale(void) const { return m_fProcessScale; }public: virtual void setProcessScale(float var){ m_fProcessScale = var; };


    protected: bool m_bIsPause;public: virtual bool getIsPause(void) const { return m_bIsPause; }public: virtual void setIsPause(bool var){ m_bIsPause = var; };


    protected: bool m_bIsComplete;public: virtual bool getIsComplete(void) const { return m_bIsComplete; }public: virtual void setIsComplete(bool var){ m_bIsComplete = var; };


    protected: bool m_bIsPlaying;public: virtual bool getIsPlaying(void) const { return m_bIsPlaying; }public: virtual void setIsPlaying(bool var){ m_bIsPlaying = var; };


    protected: float m_fCurrentPercent;public: virtual float getCurrentPercent(void) const { return m_fCurrentPercent; }public: virtual void setCurrentPercent(float var){ m_fCurrentPercent = var; };


    protected: int m_iRawDuration;public: virtual int getRawDuration(void) const { return m_iRawDuration; }public: virtual void setRawDuration(int var){ m_iRawDuration = var; };


    protected: AnimationType m_eLoopType;public: virtual AnimationType getLoopType(void) const { return m_eLoopType; }public: virtual void setLoopType(AnimationType var){ m_eLoopType = var; };


    protected: CCTweenType m_eTweenEasing;public: virtual CCTweenType getTweenEasing(void) const { return m_eTweenEasing; }public: virtual void setTweenEasing(CCTweenType var){ m_eTweenEasing = var; };

protected:

    int m_iDurationTween;


    float m_fCurrentFrame;

    int m_iCurFrameIndex;


    int m_iNextFrameIndex;


    bool m_bIsLoopBack;


    float m_fAnimationInternal;
};

}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h" 2


namespace cocos2d { namespace extension {

class CCBone;
class CCArmatureAnimation;




class CCTween : public CCProcessBase
{
public:




    static CCTween *create(CCBone *bone);
public:
    CCTween(void);
    virtual ~CCTween(void);





    virtual bool init(CCBone *bone);

    using CCProcessBase::play;
# 81 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h"
    virtual void play(CCMovementBoneData *movementBoneData, int durationTo, int durationTween, int loop, int tweenEasing);

    virtual void gotoAndPlay(int frameIndex);
    virtual void gotoAndPause(int frameIndex);

    inline void setAnimation(CCArmatureAnimation *animation) { m_pAnimation = animation; }
    inline CCArmatureAnimation *getAnimation() const { return m_pAnimation; }
protected:




    virtual void updateHandler();




    virtual float updateFrameData(float currentPercent);




    virtual void setBetween(CCFrameData *from, CCFrameData *to, bool limit = true);




    virtual CCFrameData *tweenNodeTo(float percent, CCFrameData *node = __null);




    virtual void tweenColorTo(float percent, CCFrameData *node);




    virtual void arriveKeyFrame(CCFrameData *keyFrameData);
protected:

    protected: CCMovementBoneData * m_pMovementBoneData;public: virtual CCMovementBoneData * getMovementBoneData(void) const { return m_pMovementBoneData; }public: virtual void setMovementBoneData(CCMovementBoneData * var){ m_pMovementBoneData = var; }

    CCFrameData *m_pTweenData;
    CCFrameData *m_pFrom;
    CCFrameData *m_pTo;
    CCFrameData *m_pBetween;


    CCBone *m_pBone;

    CCTweenType m_eFrameTweenEasing;

    int m_iBetweenDuration;
    int m_iTotalDuration;


    int m_iFromIndex;
    int m_iToIndex;

    CCArmatureAnimation *m_pAnimation;

    bool m_bPassLastFrame;
};

}}
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayFactory.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayFactory.h"
namespace cocos2d { namespace extension {

class CCSkin;
class CCBone;
class CCDecorativeDisplay;
class CCDisplayData;




class CCDisplayFactory
{
public:
    static void addDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void updateDisplay(CCBone *bone, float dt, bool dirty);

    static void addSpriteDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createSpriteDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void initSpriteDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, const char *displayName, CCSkin *skin);


    static void addArmatureDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createArmatureDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void updateArmatureDisplay(CCBone *bone, CCNode *display, float dt);

    static void addParticleDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createParticleDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void updateParticleDisplay(CCBone *bone, CCNode *display, float dt);
};


}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h" 2




# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h" 1
# 45 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h"
namespace cocos2d { namespace extension {

class CCBone;




class CCColliderFilter
{
public:
    ~CCColliderFilter() { }
# 73 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h"
};





class ColliderBody : public CCObject
{
public:





    protected: CCArray * m_pCalculatedVertexList;public: virtual CCArray * getCalculatedVertexList(void) const { return m_pCalculatedVertexList; };


public:
    ColliderBody(CCContourData *contourData);
    ~ColliderBody();

    inline CCContourData *getContourData() { return m_pContourData; }
# 103 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h"
private:
    CCContourData *m_pContourData;
};






class CCColliderDetector : public CCObject
{
public:
    static CCColliderDetector *create();
    static CCColliderDetector *create(CCBone *bone);
public:
    CCColliderDetector();
    ~CCColliderDetector(void);

    virtual bool init();
    virtual bool init(CCBone *bone);

    void addContourData(CCContourData *contourData);
    void addContourDataList(CCArray *contourDataList);

    void removeContourData(CCContourData *contourData);
    void removeAll();

    void updateTransform(CCAffineTransform &t);

    void setActive(bool active);
    bool getActive();

    CCArray *getColliderBodyList();







protected:
    CCArray *m_pColliderBodyList;

    protected: CCBone * m_pBone;public: virtual CCBone * getBone(void) const { return m_pBone; }public: virtual void setBone(CCBone * var){ m_pBone = var; };







protected:
    bool m_bActive;
};

}}
# 35 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h" 2


namespace cocos2d { namespace extension {




class CCDecorativeDisplay: public CCObject
{
public:
    static CCDecorativeDisplay *create();
public:
    CCDecorativeDisplay(void);
    ~CCDecorativeDisplay(void);

    virtual bool init();

protected:

    private: CCNode * m_pDisplay; public: virtual CCNode * getDisplay(void) const { return m_pDisplay; } public: virtual void setDisplay(CCNode * var) { if (m_pDisplay != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pDisplay) { (m_pDisplay)->release(); } } while(0); m_pDisplay = var; } };
    private: CCDisplayData * m_pDisplayData; public: virtual CCDisplayData * getDisplayData(void) const { return m_pDisplayData; } public: virtual void setDisplayData(CCDisplayData * var) { if (m_pDisplayData != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pDisplayData) { (m_pDisplayData)->release(); } } while(0); m_pDisplayData = var; } };


    private: CCColliderDetector * m_pColliderDetector; public: virtual CCColliderDetector * getColliderDetector(void) const { return m_pColliderDetector; } public: virtual void setColliderDetector(CCColliderDetector * var) { if (m_pColliderDetector != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pColliderDetector) { (m_pColliderDetector)->release(); } } while(0); m_pColliderDetector = var; } };

};

}}
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h"
namespace cocos2d { namespace extension {

class CCBone;





class CCDisplayManager : public CCObject
{
public:
    static CCDisplayManager *create(CCBone *bone);

public:
    CCDisplayManager();
    ~CCDisplayManager();

    bool init(CCBone *bone);






    virtual void initDisplayList(CCBoneData *boneData);
# 69 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h"
    void addDisplay(CCDisplayData *displayData, int index);

    void addDisplay(CCNode *display, int index);

    void removeDisplay(int index);

    CCArray *getDecorativeDisplayList();




    __attribute__((deprecated)) void changeDisplayByIndex(int index, bool force);
    __attribute__((deprecated)) void changeDisplayByName(const char *name, bool force);
# 92 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h"
    void changeDisplayWithIndex(int index, bool force);
    void changeDisplayWithName(const char *name, bool force);

    CCNode *getDisplayRenderNode();
    DisplayType getDisplayRenderNodeType();

    int getCurrentDisplayIndex();

    virtual void setCurrentDecorativeDisplay(CCDecorativeDisplay *decoDisplay);
    virtual CCDecorativeDisplay *getCurrentDecorativeDisplay();
    virtual CCDecorativeDisplay *getDecorativeDisplayByIndex( int index);







    virtual void setVisible(bool visible);






    virtual bool isVisible();

    CCSize getContentSize();
    CCRect getBoundingBox();

    CCPoint getAnchorPoint();
    CCPoint getAnchorPointInPoints();




    virtual bool containPoint(CCPoint &_point);




    virtual bool containPoint(float x, float y);

protected:
    CCArray *m_pDecoDisplayList;

    CCNode *m_pDisplayRenderNode;

    DisplayType m_eDisplayType;

    CCDecorativeDisplay *m_pCurrentDecoDisplay;

    int m_iDisplayIndex;

    protected: bool m_bForceChangeDisplay;public: virtual bool getForceChangeDisplay(void) const { return m_bForceChangeDisplay; }public: virtual void setForceChangeDisplay(bool var){ m_bForceChangeDisplay = var; }


    bool m_bVisible;

    CCBone *m_pBone;
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2

namespace cocos2d { namespace extension {

class CCArmature;



class CCBone : public CCNodeRGBA
{
public:




    static CCBone *create();






    static CCBone *create(const char *name);

public:



    CCBone();



    virtual ~CCBone(void);




    virtual bool init();





    virtual bool init(const char *name);
# 88 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h"
    void addDisplay(CCDisplayData *displayData, int index);

    void addDisplay(CCNode *display, int index);

    void removeDisplay(int index);




    __attribute__((deprecated)) void changeDisplayByIndex(int index, bool force);
    __attribute__((deprecated)) void changeDisplayByName(const char *name, bool force);

    void changeDisplayWithIndex(int index, bool force);
    void changeDisplayWithName(const char *name, bool force);





    void addChildBone(CCBone *child);
# 117 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h"
    void setParentBone(CCBone *parent);





    CCBone *getParentBone();

    using CCNode::removeFromParent;




    void removeFromParent(bool recursion);





    void removeChildBone(CCBone *bone, bool recursion);

    void update(float delta);

    void updateDisplayedColor(const ccColor3B &parentColor);
    void updateDisplayedOpacity(GLubyte parentOpacity);

    void setColor(const ccColor3B &color);
    void setOpacity(GLubyte opacity);


    void updateColor();


    void updateZOrder();

    virtual void setZOrder(int zOrder);

    CCTween *getTween();




    virtual inline void setTransformDirty(bool dirty) { m_bBoneTransformDirty = dirty; }
    virtual inline bool isTransformDirty() { return m_bBoneTransformDirty; }




    virtual void setBlendFunc(const ccBlendFunc& blendFunc);
    virtual ccBlendFunc getBlendFunc(void) { return m_sBlendFunc; }




    virtual void setBlendDirty(bool dirty) { m_bBlendDirty = dirty; }
    virtual bool isBlendDirty(void) { return m_bBlendDirty; }

    virtual CCAffineTransform nodeToArmatureTransform();
    virtual CCAffineTransform nodeToWorldTransform();

    CCNode *getDisplayRenderNode();
    DisplayType getDisplayRenderNodeType();




    virtual CCArray *getColliderBodyList();






public:




    protected: CCBoneData * m_pBoneData;public: virtual CCBoneData * getBoneData(void);public: virtual void setBoneData(CCBoneData * var);;


    protected: CCArmature * m_pArmature;public: virtual CCArmature * getArmature(void);public: virtual void setArmature(CCArmature * var);;


    protected: CCArmature * m_pChildArmature;public: virtual CCArmature * getChildArmature(void);public: virtual void setChildArmature(CCArmature * var);;

    protected: CCDisplayManager * m_pDisplayManager;public: virtual CCDisplayManager * getDisplayManager(void) const { return m_pDisplayManager; }public: virtual void setDisplayManager(CCDisplayManager * var){ m_pDisplayManager = var; }





    protected: bool m_bIgnoreMovementBoneData;public: virtual bool getIgnoreMovementBoneData(void) const { return m_bIgnoreMovementBoneData; }public: virtual void setIgnoreMovementBoneData(bool var){ m_bIgnoreMovementBoneData = var; }

protected:
    virtual void applyParentTransform(CCBone *parent);

    CCTween *m_pTween;


    protected: CCFrameData * m_pTweenData;public: virtual CCFrameData * getTweenData(void) const { return m_pTweenData; };

    protected: std::string m_strName;public: virtual std::string getName(void) const { return m_strName; }public: virtual void setName(std::string var){ m_strName = var; };

    CCBone *m_pParentBone;
    bool m_bBoneTransformDirty;


    CCAffineTransform m_tWorldTransform;


    protected: CCBaseData * m_tWorldInfo;public: virtual CCBaseData * getWorldInfo(void) const { return m_tWorldInfo; };


    CCBone *m_pArmatureParentBone;


    float m_fDataVersion;

    ccBlendFunc m_sBlendFunc;
    bool m_bBlendDirty;
};

}}
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCBatchNode.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCBatchNode.h"
namespace cocos2d { namespace extension {



class CCBatchNode : public CCNode
{
public:
    static CCBatchNode *create();
public:



    CCBatchNode();



    ~CCBatchNode();



    virtual bool init();
    virtual void addChild(CCNode *pChild);
    virtual void addChild(CCNode *pChild, int zOrder);
    virtual void addChild(CCNode *pChild, int zOrder, int tag);
    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void visit();



    void draw();

    virtual CCTextureAtlas *getTexureAtlasWithTexture(CCTexture2D *texture);
protected:
    CCTextureAtlas *m_pAtlas;
    CCDictionary *m_pTextureAtlasDic;
};

}}
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 3
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 3






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
namespace std {
# 83 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
# 101 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) {}

      _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) {}

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }







      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value);
# 370 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 478 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 628 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;






      using _Base::_M_impl;

    public:





      explicit
      deque(const allocator_type& __a = allocator_type())
      : _Base(__a, 0) {}
# 693 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 706 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 726 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 751 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 764 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 780 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }



      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 886 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }





      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 916 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 931 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 956 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 974 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1031 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1052 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1073 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1094 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1165 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1184 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1196 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:



      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(__n);
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1257 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1281 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);





      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }







      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);

      void _M_pop_back_aux();

      void _M_pop_front_aux();






      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);


      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);

      void
      _M_destroy_data_dispatch(iterator, iterator, __true_type) { }

      void
      _M_destroy_data_dispatch(iterator __first, iterator __last, __false_type)
      { _M_destroy_data_aux(__first, __last); }



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 typedef typename std::__is_scalar<value_type>::__type
   _Has_trivial_destructor;
 _M_destroy_data_dispatch(__first, __last, _Has_trivial_destructor());
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }
# 1477 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1515 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1547 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1565 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/deque.tcc" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/deque.tcc" 3
namespace std {

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_back_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_back();
      *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t_copy);
          this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
           + 1);
          this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
        }
      catch(...)
        {
          _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_front_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_front();
      *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
          - 1);
          this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
          this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t_copy);
        }
      catch(...)
        {
          ++this->_M_impl._M_start;
          _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, const value_type& __x)
    {
      difference_type __index = __pos - this->_M_impl._M_start;
      value_type __x_copy = __x;
      if (static_cast<size_type>(__index) < size() / 2)
 {
   push_front(front());
   iterator __front1 = this->_M_impl._M_start;
   ++__front1;
   iterator __front2 = __front1;
   ++__front2;
   __pos = this->_M_impl._M_start + __index;
   iterator __pos1 = __pos;
   ++__pos1;
   std::copy(__front2, __pos1, __front1);
 }
      else
 {
   push_back(back());
   iterator __back1 = this->_M_impl._M_finish;
   --__back1;
   iterator __back2 = __back1;
   --__back2;
   __pos = this->_M_impl._M_start + __index;
   std::copy_backward(__pos, __back2, __back1);
 }
      *__pos = __x_copy;
      return __pos;
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_copy_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_copy_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_copy(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_copy_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_copy(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

}
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 2 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
namespace std {
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;





      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      _Sequence c;

    public:



      explicit
      queue(const _Sequence& __c = _Sequence()) : c(__c) {}




      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
                              ;
 return c.front();
      }





      const_reference
      front() const
      {
                              ;
 return c.front();
      }





      reference
      back()
      {
                              ;
 return c.back();
      }





      const_reference
      back() const
      {
                              ;
 return c.back();
      }
# 202 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }
# 217 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      pop()
      {
                              ;
 c.pop_front();
      }
    };
# 237 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 255 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }
# 320 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;







    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;
      _Compare comp;

    public:



      explicit
      priority_queue(const _Compare& __x = _Compare(),
       const _Sequence& __s = _Sequence())
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }
# 370 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         const _Sequence& __s = _Sequence())
 : c(__s), comp(__x)
        {
                                                  ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }




      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
                              ;
 return c.front();
      }
# 412 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }
# 430 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      pop()
      {
                              ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }
    };



}
# 76 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 2 3
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h" 2

namespace cocos2d { namespace extension {


enum MovementEventType
{
    START,
    COMPLETE,
    LOOP_COMPLETE
};


class CCArmature;
class CCBone;

typedef void (CCObject::*SEL_MovementEventCallFunc)(CCArmature *, MovementEventType, const char *);
typedef void (CCObject::*SEL_FrameEventCallFunc)(CCBone *, const char *, int, int);




struct CCFrameEvent
{
    CCBone *bone;
    const char *frameEventName;
    int originFrameIndex;
    int currentFrameIndex;
};

struct CCMovementEvent
{
    CCArmature *armature;
    MovementEventType movementType;
    const char *movementID;
};




class CCArmatureAnimation : public CCProcessBase
{
public:




    static CCArmatureAnimation *create(CCArmature *armature);
public:



    CCArmatureAnimation();



    virtual ~CCArmatureAnimation(void);





    virtual bool init(CCArmature *armature);






    __attribute__((deprecated)) virtual void setAnimationScale(float animationScale);
    __attribute__((deprecated)) virtual float getAnimationScale() const;





    virtual void setSpeedScale(float speedScale);
    virtual float getSpeedScale() const;


    __attribute__((deprecated)) virtual void setAnimationInternal(float animationInternal) {};

    using CCProcessBase::play;
# 141 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    virtual void play(const char *animationName, int durationTo = -1, int durationTween = -1, int loop = -1, int tweenEasing = TWEEN_EASING_MAX);






    __attribute__((deprecated)) virtual void playByIndex(int animationIndex, int durationTo = -1, int durationTween = -1, int loop = -1, int tweenEasing = TWEEN_EASING_MAX);
    virtual void playWithIndex(int animationIndex, int durationTo = -1, int durationTween = -1, int loop = -1, int tweenEasing = TWEEN_EASING_MAX);




    virtual void playWithNames(const std::vector<std::string>& movementNames, int durationTo = -1, bool loop = true);




    virtual void playWithIndexes(const std::vector<int>& movementIndexes, int durationTo = -1, bool loop = true);



    virtual void playWithArray(cocos2d::CCArray *movementNames, int durationTo = -1, bool loop = true);
    virtual void playWithIndexArray(cocos2d::CCArray *movementIndexes, int durationTo = -1, bool loop = true);
# 176 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    virtual void gotoAndPlay(int frameIndex);




    virtual void gotoAndPause(int frameIndex);




    virtual void pause();



    virtual void resume();



    virtual void stop();





    int getMovementCount();

    void update(float dt);





    std::string getCurrentMovementID();





    void setMovementEventCallFunc(CCObject *target, SEL_MovementEventCallFunc callFunc);





    void setFrameEventCallFunc(CCObject *target, SEL_FrameEventCallFunc callFunc);







    virtual CCObject* getUserObject();
# 238 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    virtual void setUserObject(CCObject *pUserObject);
protected:





    void updateHandler();





    void updateFrameData(float currentPercent);





    void frameEvent(CCBone *bone, const char *frameEventName, int originFrameIndex, int currentFrameIndex);




    void movementEvent(CCArmature *armature, MovementEventType movementType, const char *movementID);

    void updateMovementList();

    inline bool isIgnoreFrameEvent() { return m_bIgnoreFrameEvent; }

    friend class CCTween;
protected:

    private: CCAnimationData * m_pAnimationData; public: virtual CCAnimationData * getAnimationData(void) const { return m_pAnimationData; } public: virtual void setAnimationData(CCAnimationData * var) { if (m_pAnimationData != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pAnimationData) { (m_pAnimationData)->release(); } } while(0); m_pAnimationData = var; } };


    float m_fSpeedScale;

    CCMovementData *m_pMovementData;

    CCArmature *m_pArmature;

    std::string m_strMovementID;

    int m_iToIndex;

    CCArray *m_pTweenList;

    bool m_bIgnoreFrameEvent;

    std::queue<CCFrameEvent*> m_sFrameEventQueue;
    std::queue<CCMovementEvent*> m_sMovementEventQueue;

    std::vector<std::string> m_sMovementList;

    bool m_bOnMovementList;
    bool m_bMovementListLoop;
    unsigned int m_uMovementIndex;
 int m_iMovementListDurationTo;

    CCObject *m_pUserObject;
protected:






    SEL_MovementEventCallFunc m_sMovementEventCallFunc;
# 315 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    SEL_FrameEventCallFunc m_sFrameEventCallFunc;


    CCObject *m_sMovementEventTarget;
    CCObject *m_sFrameEventTarget;
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2

class b2Body;
struct cpBody;

namespace cocos2d { namespace extension {



class CCArmature : public CCNodeRGBA, public CCBlendProtocol
{

public:





    static CCArmature *create();







    static CCArmature *create(const char *name);

    static CCArmature *create(const char *name, CCBone *parentBone);

public:



    CCArmature();



    ~CCArmature(void);




    virtual bool init();





    virtual bool init(const char *name);

    virtual bool init(const char *name, CCBone *parentBone);






    virtual void addBone(CCBone *bone, const char *parentName);





    virtual CCBone *getBone(const char *name) const;






    virtual void changeBoneParent(CCBone *bone, const char *parentName);






    virtual void removeBone(CCBone *bone, bool recursion);





    CCDictionary *getBoneDic();




    virtual CCRect boundingBox();

    CCBone *getBoneAtPoint(float x, float y);

    virtual void visit();
    virtual void update(float dt);
    virtual void draw();

    virtual const CCAffineTransform nodeToParentTransform();

    virtual void onEnter();
    virtual void onExit();




    virtual void updateOffsetPoint();

    inline void setBlendFunc(ccBlendFunc blendFunc)
    {
        m_sBlendFunc = blendFunc;
    }
    inline ccBlendFunc getBlendFunc(void)
    {
        return m_sBlendFunc;
    }

    virtual void setAnimation(CCArmatureAnimation *animation);
    virtual CCArmatureAnimation *getAnimation();

    virtual CCTextureAtlas *getTexureAtlasWithTexture(CCTexture2D *texture);




    virtual void drawContour();
# 171 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h"
protected:





    CCBone *createBone(const char *boneName );

    protected: CCArmatureData * m_pArmatureData;public: virtual CCArmatureData * getArmatureData(void) const { return m_pArmatureData; }public: virtual void setArmatureData(CCArmatureData * var){ m_pArmatureData = var; };

    protected: CCBatchNode * m_pBatchNode;public: virtual CCBatchNode * getBatchNode(void) const { return m_pBatchNode; }public: virtual void setBatchNode(CCBatchNode * var){ m_pBatchNode = var; };

    protected: std::string m_strName;public: virtual std::string getName(void) const { return m_strName; }public: virtual void setName(std::string var){ m_strName = var; };

    protected: CCTextureAtlas * m_pAtlas;public: virtual CCTextureAtlas * getTextureAtlas(void) const { return m_pAtlas; }public: virtual void setTextureAtlas(CCTextureAtlas * var){ m_pAtlas = var; };

    protected: CCBone * m_pParentBone;public: virtual CCBone * getParentBone(void);public: virtual void setParentBone(CCBone * var);;

    protected: float m_fVersion;public: virtual float getVersion(void) const { return m_fVersion; }public: virtual void setVersion(float var){ m_fVersion = var; };

    protected: bool m_bArmatureTransformDirty;public: virtual bool getArmatureTransformDirty(void) const { return m_bArmatureTransformDirty; };
protected:
    CCDictionary *m_pBoneDic;

    CCArray *m_pTopBoneList;

    static std::map<int, CCArmature *> m_sArmatureIndexDic;

    ccBlendFunc m_sBlendFunc;

    CCPoint m_pOffsetPoint;

    CCArmatureAnimation *m_pAnimation;

    CCDictionary *m_pTextureAtlasDic;






};

}}
# 45 "Cacao/include/cocos2dext/cocos-ext.h" 2






# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCSkin.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCSkin.h"
namespace cocos2d { namespace extension {



class CCSkin : public CCSprite
{
public:
    static CCSkin *create();
    static CCSkin *createWithSpriteFrameName(const char *pszSpriteFrameName);
    static CCSkin *create(const char *pszFileName);
public:



    CCSkin();

    bool initWithSpriteFrameName(const char *pszSpriteFrameName);
    bool initWithFile(const char *pszFilename);

    void updateArmatureTransform();
    void updateTransform();

    CCAffineTransform nodeToWorldTransform();
    CCAffineTransform nodeToWorldTransformAR();

    protected: CCBaseData m_sSkinData;public: virtual const CCBaseData& getSkinData(void);public: virtual void setSkinData(const CCBaseData& var);;
    protected: CCBone * m_pBone;public: virtual CCBone * getBone(void);public: virtual void setBone(CCBone * var);;

protected:
    CCArmature *m_pArmature;
    CCAffineTransform m_tSkinTransform;
    protected: std::string m_strDisplayName;public: virtual std::string getDisplayName(void) const { return m_strDisplayName; }
};

}}
# 52 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDataManager.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDataManager.h"
namespace cocos2d { namespace extension {

struct CCRelativeData
{
    std::vector<std::string> plistFiles;
    std::vector<std::string> armatures;
    std::vector<std::string> animations;
    std::vector<std::string> textures;
};





class CCArmatureDataManager : public CCObject
{
public:



    static CCArmatureDataManager *sharedArmatureDataManager();

    static void purge();
private:
    CCArmatureDataManager(void);
    ~CCArmatureDataManager(void);

public:




    virtual bool init();
# 73 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDataManager.h"
    void addArmatureData(const char *id, CCArmatureData *armatureData, const char *configFilePath = "");






    CCArmatureData *getArmatureData(const char *id);





    void removeArmatureData(const char *id);






    void addAnimationData(const char *id, CCAnimationData *animationData, const char *configFilePath = "");






    CCAnimationData *getAnimationData(const char *id);





    void removeAnimationData(const char *id);






    void addTextureData(const char *id, CCTextureData *textureData, const char *configFilePath = "");






    CCTextureData *getTextureData(const char *id);





    void removeTextureData(const char *id);




    void addArmatureFileInfo(const char *configFilePath);





    void addArmatureFileInfoAsync(const char *configFilePath, CCObject *target, SEL_SCHEDULE selector);




    void addArmatureFileInfo(const char *imagePath, const char *plistPath, const char *configFilePath);





    void addArmatureFileInfoAsync(const char *imagePath, const char *plistPath, const char *configFilePath, CCObject *target, SEL_SCHEDULE selector);


    virtual void removeArmatureFileInfo(const char *configFilePath);





    void addSpriteFrameFromFile(const char *plistPath, const char *imagePath, const char *configFilePath = "");





    bool isAutoLoadSpriteFile();


    CCDictionary *getArmatureDatas() const;
    CCDictionary *getAnimationDatas() const;
    CCDictionary *getTextureDatas() const;

protected:
    void addRelativeData(const char* configFilePath);
    CCRelativeData *getRelativeData(const char* configFilePath);
private:





    CCDictionary *m_pArmarureDatas;






    CCDictionary *m_pAnimationDatas;






    CCDictionary *m_pTextureDatas;

    bool m_bAutoLoadSpriteFile;

    std::map<std::string, CCRelativeData> m_sRelativeDatas;
};


}}
# 54 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCDataReaderHelper.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCDataReaderHelper.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/DictionaryHelper.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/DictionaryHelper.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h" 1



# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 1






# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h" 1
# 63 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
namespace rapidjson {



typedef unsigned SizeType;
}
# 79 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cassert" 1 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cassert" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 1 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 3
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));



}
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cassert" 2 3
# 80 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h" 2
# 90 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
namespace rapidjson {
# 132 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
class CrtAllocator {
public:
 static const bool kNeedFree = true;
 void* Malloc(size_t size) { return malloc(size); }
 void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) { (void)originalSize; return realloc(originalPtr, newSize); }
 static void Free(void *ptr) { free(ptr); }
};
# 159 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template <typename BaseAllocator = CrtAllocator>
class MemoryPoolAllocator {
public:
 static const bool kNeedFree = false;





 MemoryPoolAllocator(size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :
  chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(0), baseAllocator_(baseAllocator), ownBaseAllocator_(0)
 {
  if (!baseAllocator_)
   ownBaseAllocator_ = baseAllocator_ = new BaseAllocator();
  AddChunk(chunk_capacity_);
 }
# 186 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
 MemoryPoolAllocator(char *buffer, size_t size, size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :
  chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(buffer), baseAllocator_(baseAllocator), ownBaseAllocator_(0)
 {
  (__builtin_expect(!(buffer != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 189, "buffer != 0") : (void)0);
  (__builtin_expect(!(size > sizeof(ChunkHeader)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 190, "size > sizeof(ChunkHeader)") : (void)0);
  chunkHead_ = (ChunkHeader*)buffer;
  chunkHead_->capacity = size - sizeof(ChunkHeader);
  chunkHead_->size = 0;
  chunkHead_->next = 0;
 }




 ~MemoryPoolAllocator() {
  Clear();
  delete ownBaseAllocator_;
 }


 void Clear() {
  while(chunkHead_ != 0 && chunkHead_ != (ChunkHeader *)userBuffer_) {
   ChunkHeader* next = chunkHead_->next;
   baseAllocator_->Free(chunkHead_);
   chunkHead_ = next;
  }
 }




 size_t Capacity() {
  size_t capacity = 0;
  for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)
   capacity += c->capacity;
  return capacity;
 }




 size_t Size() {
  size_t size = 0;
  for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)
   size += c->size;
  return size;
 }


 void* Malloc(size_t size) {
  size = (size + 3) & ~3;

  if (chunkHead_->size + size > chunkHead_->capacity)
   AddChunk(chunk_capacity_ > size ? chunk_capacity_ : size);

  char *buffer = (char *)(chunkHead_ + 1) + chunkHead_->size;
  (__builtin_expect(!(((uintptr_t)buffer & 3) == 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 242, "((uintptr_t)buffer & 3) == 0") : (void)0);
  chunkHead_->size += size;

  return buffer;
 }


 void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {
  if (originalPtr == 0)
   return Malloc(newSize);


  if (originalSize >= newSize)
   return originalPtr;


  if (originalPtr == (char *)(chunkHead_ + 1) + chunkHead_->size - originalSize) {
   size_t increment = newSize - originalSize;
   increment = (increment + 3) & ~3;
   if (chunkHead_->size + increment <= chunkHead_->capacity) {
    chunkHead_->size += increment;
    (__builtin_expect(!(((uintptr_t)originalPtr & 3) == 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 263, "((uintptr_t)originalPtr & 3) == 0") : (void)0);
    return originalPtr;
   }
  }


  void* newBuffer = Malloc(newSize);
  (__builtin_expect(!(newBuffer != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 270, "newBuffer != 0") : (void)0);
  return memcpy(newBuffer, originalPtr, originalSize);
 }


 static void Free(void *) {}

private:



 void AddChunk(size_t capacity) {
  ChunkHeader* chunk = (ChunkHeader*)baseAllocator_->Malloc(sizeof(ChunkHeader) + capacity);
  chunk->capacity = capacity;
  chunk->size = 0;
  chunk->next = chunkHead_;
  chunkHead_ = chunk;
 }

 static const int kDefaultChunkCapacity = 64 * 1024;




 struct ChunkHeader {
  size_t capacity;
  size_t size;
  ChunkHeader *next;
 };

 ChunkHeader *chunkHead_;
 size_t chunk_capacity_;
 char *userBuffer_;
 BaseAllocator* baseAllocator_;
 BaseAllocator* ownBaseAllocator_;
};
# 334 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename CharType = char>
struct UTF8 {
 typedef CharType Ch;

 static Ch* Encode(Ch *buffer, unsigned codepoint) {
  if (codepoint <= 0x7F)
   *buffer++ = codepoint & 0xFF;
  else if (codepoint <= 0x7FF) {
   *buffer++ = 0xC0 | ((codepoint >> 6) & 0xFF);
   *buffer++ = 0x80 | ((codepoint & 0x3F));
  }
  else if (codepoint <= 0xFFFF) {
   *buffer++ = 0xE0 | ((codepoint >> 12) & 0xFF);
   *buffer++ = 0x80 | ((codepoint >> 6) & 0x3F);
   *buffer++ = 0x80 | (codepoint & 0x3F);
  }
  else {
   (__builtin_expect(!(codepoint <= 0x10FFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 351, "codepoint <= 0x10FFFF") : (void)0);
   *buffer++ = 0xF0 | ((codepoint >> 18) & 0xFF);
   *buffer++ = 0x80 | ((codepoint >> 12) & 0x3F);
   *buffer++ = 0x80 | ((codepoint >> 6) & 0x3F);
   *buffer++ = 0x80 | (codepoint & 0x3F);
  }
  return buffer;
 }
};
# 369 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename CharType = wchar_t>
struct UTF16 {
 typedef CharType Ch;

 static Ch* Encode(Ch* buffer, unsigned codepoint) {
  if (codepoint <= 0xFFFF) {
   (__builtin_expect(!(codepoint < 0xD800 || codepoint > 0xDFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 375, "codepoint < 0xD800 || codepoint > 0xDFFF") : (void)0);
   *buffer++ = static_cast<Ch>(codepoint);
  }
  else {
   (__builtin_expect(!(codepoint <= 0x10FFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 379, "codepoint <= 0x10FFFF") : (void)0);
   unsigned v = codepoint - 0x10000;
   *buffer++ = static_cast<Ch>((v >> 10) + 0xD800);
   *buffer++ = (v & 0x3FF) + 0xDC00;
  }
  return buffer;
 }
};
# 396 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename CharType = unsigned>
struct UTF32 {
 typedef CharType Ch;

 static Ch *Encode(Ch* buffer, unsigned codepoint) {
  (__builtin_expect(!(codepoint <= 0x10FFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 401, "codepoint <= 0x10FFFF") : (void)0);
  *buffer++ = codepoint;
  return buffer;
 }
};
# 447 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename Stream, typename Ch>
inline void PutN(Stream& stream, Ch c, size_t n) {
 for (size_t i = 0; i < n; i++)
  stream.Put(c);
}







template <typename Encoding>
struct GenericStringStream {
 typedef typename Encoding::Ch Ch;

 GenericStringStream(const Ch *src) : src_(src), head_(src) {}

 Ch Peek() const { return *src_; }
 Ch Take() { return *src_++; }
 size_t Tell() const { return src_ - head_; }

 Ch* PutBegin() { (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 469, "false") : (void)0); return 0; }
 void Put(Ch) { (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 470, "false") : (void)0); }
 size_t PutEnd(Ch*) { (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 471, "false") : (void)0); return 0; }

 const Ch* src_;
 const Ch* head_;
};

typedef GenericStringStream<UTF8<> > StringStream;
# 486 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template <typename Encoding>
struct GenericInsituStringStream {
 typedef typename Encoding::Ch Ch;

 GenericInsituStringStream(Ch *src) : src_(src), dst_(0), head_(src) {}


 Ch Peek() { return *src_; }
 Ch Take() { return *src_++; }
 size_t Tell() { return src_ - head_; }


 Ch* PutBegin() { return dst_ = src_; }
 void Put(Ch c) { (__builtin_expect(!(dst_ != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 499, "dst_ != 0") : (void)0); *dst_++ = c; }
 size_t PutEnd(Ch* begin) { return dst_ - begin; }

 Ch* src_;
 Ch* dst_;
 Ch* head_;
};

typedef GenericInsituStringStream<UTF8<> > InsituStringStream;





enum Type {
 kNullType = 0,
 kFalseType = 1,
 kTrueType = 2,
 kObjectType = 3,
 kArrayType = 4,
 kStringType = 5,
 kNumberType = 6,
};

}
# 8 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/pow10.h" 1



namespace rapidjson {
namespace internal {






inline double Pow10(int n) {
 static const double e[] = {
  1e-308,1e-307,1e-306,1e-305,1e-304,1e-303,1e-302,1e-301,1e-300,
  1e-299,1e-298,1e-297,1e-296,1e-295,1e-294,1e-293,1e-292,1e-291,1e-290,1e-289,1e-288,1e-287,1e-286,1e-285,1e-284,1e-283,1e-282,1e-281,1e-280,
  1e-279,1e-278,1e-277,1e-276,1e-275,1e-274,1e-273,1e-272,1e-271,1e-270,1e-269,1e-268,1e-267,1e-266,1e-265,1e-264,1e-263,1e-262,1e-261,1e-260,
  1e-259,1e-258,1e-257,1e-256,1e-255,1e-254,1e-253,1e-252,1e-251,1e-250,1e-249,1e-248,1e-247,1e-246,1e-245,1e-244,1e-243,1e-242,1e-241,1e-240,
  1e-239,1e-238,1e-237,1e-236,1e-235,1e-234,1e-233,1e-232,1e-231,1e-230,1e-229,1e-228,1e-227,1e-226,1e-225,1e-224,1e-223,1e-222,1e-221,1e-220,
  1e-219,1e-218,1e-217,1e-216,1e-215,1e-214,1e-213,1e-212,1e-211,1e-210,1e-209,1e-208,1e-207,1e-206,1e-205,1e-204,1e-203,1e-202,1e-201,1e-200,
  1e-199,1e-198,1e-197,1e-196,1e-195,1e-194,1e-193,1e-192,1e-191,1e-190,1e-189,1e-188,1e-187,1e-186,1e-185,1e-184,1e-183,1e-182,1e-181,1e-180,
  1e-179,1e-178,1e-177,1e-176,1e-175,1e-174,1e-173,1e-172,1e-171,1e-170,1e-169,1e-168,1e-167,1e-166,1e-165,1e-164,1e-163,1e-162,1e-161,1e-160,
  1e-159,1e-158,1e-157,1e-156,1e-155,1e-154,1e-153,1e-152,1e-151,1e-150,1e-149,1e-148,1e-147,1e-146,1e-145,1e-144,1e-143,1e-142,1e-141,1e-140,
  1e-139,1e-138,1e-137,1e-136,1e-135,1e-134,1e-133,1e-132,1e-131,1e-130,1e-129,1e-128,1e-127,1e-126,1e-125,1e-124,1e-123,1e-122,1e-121,1e-120,
  1e-119,1e-118,1e-117,1e-116,1e-115,1e-114,1e-113,1e-112,1e-111,1e-110,1e-109,1e-108,1e-107,1e-106,1e-105,1e-104,1e-103,1e-102,1e-101,1e-100,
  1e-99, 1e-98, 1e-97, 1e-96, 1e-95, 1e-94, 1e-93, 1e-92, 1e-91, 1e-90, 1e-89, 1e-88, 1e-87, 1e-86, 1e-85, 1e-84, 1e-83, 1e-82, 1e-81, 1e-80,
  1e-79, 1e-78, 1e-77, 1e-76, 1e-75, 1e-74, 1e-73, 1e-72, 1e-71, 1e-70, 1e-69, 1e-68, 1e-67, 1e-66, 1e-65, 1e-64, 1e-63, 1e-62, 1e-61, 1e-60,
  1e-59, 1e-58, 1e-57, 1e-56, 1e-55, 1e-54, 1e-53, 1e-52, 1e-51, 1e-50, 1e-49, 1e-48, 1e-47, 1e-46, 1e-45, 1e-44, 1e-43, 1e-42, 1e-41, 1e-40,
  1e-39, 1e-38, 1e-37, 1e-36, 1e-35, 1e-34, 1e-33, 1e-32, 1e-31, 1e-30, 1e-29, 1e-28, 1e-27, 1e-26, 1e-25, 1e-24, 1e-23, 1e-22, 1e-21, 1e-20,
  1e-19, 1e-18, 1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e+0,
  1e+1, 1e+2, 1e+3, 1e+4, 1e+5, 1e+6, 1e+7, 1e+8, 1e+9, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20,
  1e+21, 1e+22, 1e+23, 1e+24, 1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31, 1e+32, 1e+33, 1e+34, 1e+35, 1e+36, 1e+37, 1e+38, 1e+39, 1e+40,
  1e+41, 1e+42, 1e+43, 1e+44, 1e+45, 1e+46, 1e+47, 1e+48, 1e+49, 1e+50, 1e+51, 1e+52, 1e+53, 1e+54, 1e+55, 1e+56, 1e+57, 1e+58, 1e+59, 1e+60,
  1e+61, 1e+62, 1e+63, 1e+64, 1e+65, 1e+66, 1e+67, 1e+68, 1e+69, 1e+70, 1e+71, 1e+72, 1e+73, 1e+74, 1e+75, 1e+76, 1e+77, 1e+78, 1e+79, 1e+80,
  1e+81, 1e+82, 1e+83, 1e+84, 1e+85, 1e+86, 1e+87, 1e+88, 1e+89, 1e+90, 1e+91, 1e+92, 1e+93, 1e+94, 1e+95, 1e+96, 1e+97, 1e+98, 1e+99, 1e+100,
  1e+101,1e+102,1e+103,1e+104,1e+105,1e+106,1e+107,1e+108,1e+109,1e+110,1e+111,1e+112,1e+113,1e+114,1e+115,1e+116,1e+117,1e+118,1e+119,1e+120,
  1e+121,1e+122,1e+123,1e+124,1e+125,1e+126,1e+127,1e+128,1e+129,1e+130,1e+131,1e+132,1e+133,1e+134,1e+135,1e+136,1e+137,1e+138,1e+139,1e+140,
  1e+141,1e+142,1e+143,1e+144,1e+145,1e+146,1e+147,1e+148,1e+149,1e+150,1e+151,1e+152,1e+153,1e+154,1e+155,1e+156,1e+157,1e+158,1e+159,1e+160,
  1e+161,1e+162,1e+163,1e+164,1e+165,1e+166,1e+167,1e+168,1e+169,1e+170,1e+171,1e+172,1e+173,1e+174,1e+175,1e+176,1e+177,1e+178,1e+179,1e+180,
  1e+181,1e+182,1e+183,1e+184,1e+185,1e+186,1e+187,1e+188,1e+189,1e+190,1e+191,1e+192,1e+193,1e+194,1e+195,1e+196,1e+197,1e+198,1e+199,1e+200,
  1e+201,1e+202,1e+203,1e+204,1e+205,1e+206,1e+207,1e+208,1e+209,1e+210,1e+211,1e+212,1e+213,1e+214,1e+215,1e+216,1e+217,1e+218,1e+219,1e+220,
  1e+221,1e+222,1e+223,1e+224,1e+225,1e+226,1e+227,1e+228,1e+229,1e+230,1e+231,1e+232,1e+233,1e+234,1e+235,1e+236,1e+237,1e+238,1e+239,1e+240,
  1e+241,1e+242,1e+243,1e+244,1e+245,1e+246,1e+247,1e+248,1e+249,1e+250,1e+251,1e+252,1e+253,1e+254,1e+255,1e+256,1e+257,1e+258,1e+259,1e+260,
  1e+261,1e+262,1e+263,1e+264,1e+265,1e+266,1e+267,1e+268,1e+269,1e+270,1e+271,1e+272,1e+273,1e+274,1e+275,1e+276,1e+277,1e+278,1e+279,1e+280,
  1e+281,1e+282,1e+283,1e+284,1e+285,1e+286,1e+287,1e+288,1e+289,1e+290,1e+291,1e+292,1e+293,1e+294,1e+295,1e+296,1e+297,1e+298,1e+299,1e+300,
  1e+301,1e+302,1e+303,1e+304,1e+305,1e+306,1e+307,1e+308
 };
 (__builtin_expect(!(n <= 308), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/pow10.h", 47, "n <= 308") : (void)0);
 return n < -308 ? 0.0 : e[n + 308];
}

}
}
# 9 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h" 1



namespace rapidjson {
namespace internal {







template <typename Allocator>
class Stack {
public:
 Stack(Allocator* allocator, size_t stack_capacity) : allocator_(allocator), own_allocator_(0), stack_(0), stack_top_(0), stack_end_(0), stack_capacity_(stack_capacity) {
  (__builtin_expect(!(stack_capacity_ > 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h", 17, "stack_capacity_ > 0") : (void)0);
  if (!allocator_)
   own_allocator_ = allocator_ = new Allocator();
  stack_top_ = stack_ = (char*)allocator_->Malloc(stack_capacity_);
  stack_end_ = stack_ + stack_capacity_;
 }

 ~Stack() {
  Allocator::Free(stack_);
  delete own_allocator_;
 }

 void Clear() { stack_top_ = stack_; }

 template<typename T>
 T* Push(size_t count = 1) {

  if (stack_top_ + sizeof(T) * count >= stack_end_) {
   size_t new_capacity = stack_capacity_ * 2;
   size_t size = GetSize();
   size_t new_size = GetSize() + sizeof(T) * count;
   if (new_capacity < new_size)
    new_capacity = new_size;
   stack_ = (char*)allocator_->Realloc(stack_, stack_capacity_, new_capacity);
   stack_capacity_ = new_capacity;
   stack_top_ = stack_ + size;
   stack_end_ = stack_ + stack_capacity_;
  }
  T* ret = (T*)stack_top_;
  stack_top_ += sizeof(T) * count;
  return ret;
 }

 template<typename T>
 T* Pop(size_t count) {
  (__builtin_expect(!(GetSize() >= count * sizeof(T)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h", 52, "GetSize() >= count * sizeof(T)") : (void)0);
  stack_top_ -= count * sizeof(T);
  return (T*)stack_top_;
 }

 template<typename T>
 T* Top() {
  (__builtin_expect(!(GetSize() >= sizeof(T)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h", 59, "GetSize() >= sizeof(T)") : (void)0);
  return (T*)(stack_top_ - sizeof(T));
 }

 template<typename T>
 T* Bottom() { return (T*)stack_; }

 Allocator& GetAllocator() { return *allocator_; }
 size_t GetSize() const { return stack_top_ - stack_; }
 size_t GetCapacity() const { return stack_capacity_; }

private:
 Allocator* allocator_;
 Allocator* own_allocator_;
 char *stack_;
 char *stack_top_;
 char *stack_end_;
 size_t stack_capacity_;
};

}
}
# 10 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/setjmp.h" 1 3
# 26 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/setjmp.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/setjmp.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/setjmp.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/setjmp.h" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/setjmp.h" 3
typedef int jmp_buf[((9 * 2) + 3 + 16)];
typedef int sigjmp_buf[((9 * 2) + 3 + 16) + 1];
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/setjmp.h" 3
extern "C" {
int setjmp(jmp_buf);
void longjmp(jmp_buf, int);


int _setjmp(jmp_buf);
void _longjmp(jmp_buf, int);
int sigsetjmp(sigjmp_buf, int);
void siglongjmp(sigjmp_buf, int);



void longjmperror(void);

}
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/setjmp.h" 2 3
# 27 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/setjmp.h" 2 3
# 11 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
namespace rapidjson {





enum ParseFlag {
 kParseDefaultFlags = 0,
 kParseInsituFlag = 1
};
# 74 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
template<typename Encoding = UTF8<> >
struct BaseReaderHandler {
 typedef typename Encoding::Ch Ch;

 void Default() {}
 void Null() { Default(); }
 void Bool(bool) { Default(); }
 void Int(int) { Default(); }
 void Uint(unsigned) { Default(); }
 void Int64(int64_t) { Default(); }
 void Uint64(uint64_t) { Default(); }
 void Double(double) { Default(); }
 void String(const Ch*, SizeType, bool) { Default(); }
 void StartObject() { Default(); }
 void EndObject(SizeType) { Default(); }
 void StartArray() { Default(); }
 void EndArray(SizeType) { Default(); }
};
# 100 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
template<typename Stream>
void SkipWhitespace(Stream& stream) {
 Stream s = stream;
 while (s.Peek() == ' ' || s.Peek() == '\n' || s.Peek() == '\r' || s.Peek() == '\t')
  s.Take();
 stream = s;
}
# 201 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >
class GenericReader {
public:
 typedef typename Encoding::Ch Ch;





 GenericReader(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity) : stack_(allocator, stackCapacity), parseError_(0), errorOffset_(0) {}
# 220 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
 template <unsigned parseFlags, typename Stream, typename Handler>
 bool Parse(Stream& stream, Handler& handler) {
  parseError_ = 0;
  errorOffset_ = 0;





  if (setjmp(jmpbuf_)) {



   stack_.Clear();
   return false;
  }

  SkipWhitespace(stream);

  if (stream.Peek() == '\0')
   do { parseError_ = "Text only contains white space(s)"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
  else {
   switch (stream.Peek()) {
    case '{': ParseObject<parseFlags>(stream, handler); break;
    case '[': ParseArray<parseFlags>(stream, handler); break;
    default: do { parseError_ = "Expect either an object or array at root"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   }
   SkipWhitespace(stream);

   if (stream.Peek() != '\0')
    do { parseError_ = "Nothing should follow the root object or array."; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
  }

  return true;
 }

 bool HasParseError() const { return parseError_ != 0; }
 const char* GetParseError() const { return parseError_; }
 size_t GetErrorOffset() const { return errorOffset_; }

private:

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseObject(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == '{'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 264, "stream.Peek() == '{'") : (void)0);
  stream.Take();
  handler.StartObject();
  SkipWhitespace(stream);

  if (stream.Peek() == '}') {
   stream.Take();
   handler.EndObject(0);
   return;
  }

  for (SizeType memberCount = 0;;) {
   if (stream.Peek() != '"') {
    do { parseError_ = "Name of an object member must be a string"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    break;
   }

   ParseString<parseFlags>(stream, handler);
   SkipWhitespace(stream);

   if (stream.Take() != ':') {
    do { parseError_ = "There must be a colon after the name of object member"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    break;
   }
   SkipWhitespace(stream);

   ParseValue<parseFlags>(stream, handler);
   SkipWhitespace(stream);

   ++memberCount;

   switch(stream.Take()) {
    case ',': SkipWhitespace(stream); break;
    case '}': handler.EndObject(memberCount); return;
    default: do { parseError_ = "Must be a comma or '}' after an object member"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   }
  }
 }


 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseArray(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == '['), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 306, "stream.Peek() == '['") : (void)0);
  stream.Take();
  handler.StartArray();
  SkipWhitespace(stream);

  if (stream.Peek() == ']') {
   stream.Take();
   handler.EndArray(0);
   return;
  }

  for (SizeType elementCount = 0;;) {
   ParseValue<parseFlags>(stream, handler);
   ++elementCount;
   SkipWhitespace(stream);

   switch (stream.Take()) {
    case ',': SkipWhitespace(stream); break;
    case ']': handler.EndArray(elementCount); return;
    default: do { parseError_ = "Must be a comma or ']' after an array element."; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   }
  }
 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseNull(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == 'n'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 332, "stream.Peek() == 'n'") : (void)0);
  stream.Take();

  if (stream.Take() == 'u' && stream.Take() == 'l' && stream.Take() == 'l')
   handler.Null();
  else
   do { parseError_ = "Invalid value"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseTrue(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == 't'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 343, "stream.Peek() == 't'") : (void)0);
  stream.Take();

  if (stream.Take() == 'r' && stream.Take() == 'u' && stream.Take() == 'e')
   handler.Bool(true);
  else
   do { parseError_ = "Invalid value"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseFalse(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == 'f'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 354, "stream.Peek() == 'f'") : (void)0);
  stream.Take();

  if (stream.Take() == 'a' && stream.Take() == 'l' && stream.Take() == 's' && stream.Take() == 'e')
   handler.Bool(false);
  else
   do { parseError_ = "Invalid value"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
 }


 template<typename Stream>
 unsigned ParseHex4(Stream& stream) {
  Stream s = stream;
  unsigned codepoint = 0;
  for (int i = 0; i < 4; i++) {
   Ch c = s.Take();
   codepoint <<= 4;
   codepoint += c;
   if (c >= '0' && c <= '9')
    codepoint -= '0';
   else if (c >= 'A' && c <= 'F')
    codepoint -= 'A' - 10;
   else if (c >= 'a' && c <= 'f')
    codepoint -= 'a' - 10;
   else
    do { parseError_ = "Incorrect hex digit after \\u escape"; errorOffset_ = s.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
  }
  stream = s;
  return codepoint;
 }


 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseString(Stream& stream, Handler& handler) {

  static const Ch escape[256] = {
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,'\"', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'/',
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
   0, 0,'\b', 0, 0, 0,'\f', 0, 0, 0, 0, 0, 0, 0,'\n', 0,
   0, 0,'\r', 0,'\t', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  };


  Stream s = stream;
  (__builtin_expect(!(s.Peek() == '\"'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 399, "s.Peek() == '\\\"'") : (void)0);
  s.Take();
  Ch *head;
  SizeType len;
  if (parseFlags & kParseInsituFlag)
   head = s.PutBegin();
  else
   len = 0;
# 418 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
  for (;;) {
   Ch c = s.Take();
   if (c == '\\') {
    Ch e = s.Take();
    if ((sizeof(Ch) == 1 || e < 256) && escape[(unsigned char)e])
     do { if (parseFlags & kParseInsituFlag) s.Put(escape[(unsigned char)e]); else { *stack_.template Push<Ch>() = escape[(unsigned char)e]; ++len; } } while(false);
    else if (e == 'u') {
     unsigned codepoint = ParseHex4(s);
     if (codepoint >= 0xD800 && codepoint <= 0xDBFF) {
      if (s.Take() != '\\' || s.Take() != 'u') {
       do { parseError_ = "Missing the second \\u in surrogate pair"; errorOffset_ = s.Tell() - 2; longjmp(jmpbuf_, 1); } while((void)0, 0);
       return;
      }
      unsigned codepoint2 = ParseHex4(s);
      if (codepoint2 < 0xDC00 || codepoint2 > 0xDFFF) {
       do { parseError_ = "The second \\u in surrogate pair is invalid"; errorOffset_ = s.Tell() - 2; longjmp(jmpbuf_, 1); } while((void)0, 0);
       return;
      }
      codepoint = (((codepoint - 0xD800) << 10) | (codepoint2 - 0xDC00)) + 0x10000;
     }

     Ch buffer[4];
     SizeType count = SizeType(Encoding::Encode(buffer, codepoint) - &buffer[0]);

     if (parseFlags & kParseInsituFlag)
      for (SizeType i = 0; i < count; i++)
       s.Put(buffer[i]);
     else {
      memcpy(stack_.template Push<Ch>(count), buffer, count * sizeof(Ch));
      len += count;
     }
    }
    else {
     do { parseError_ = "Unknown escape character"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
     return;
    }
   }
   else if (c == '"') {
    if (parseFlags & kParseInsituFlag) {
     size_t length = s.PutEnd(head);
     (__builtin_expect(!(length <= 0xFFFFFFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 458, "length <= 0xFFFFFFFF") : (void)0);
     do { if (parseFlags & kParseInsituFlag) s.Put('\0'); else { *stack_.template Push<Ch>() = '\0'; ++len; } } while(false);
     handler.String(head, SizeType(length), false);
    }
    else {
     do { if (parseFlags & kParseInsituFlag) s.Put('\0'); else { *stack_.template Push<Ch>() = '\0'; ++len; } } while(false);
     handler.String(stack_.template Pop<Ch>(len), len - 1, true);
    }
    stream = s;
    return;
   }
   else if (c == '\0') {
    do { parseError_ = "lacks ending quotation before the end of string"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }
   else if ((unsigned)c < 0x20) {
    do { parseError_ = "Incorrect unescaped character in string"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }
   else
    do { if (parseFlags & kParseInsituFlag) s.Put(c); else { *stack_.template Push<Ch>() = c; ++len; } } while(false);
  }

 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseNumber(Stream& stream, Handler& handler) {
  Stream s = stream;

  bool minus = false;
  if (s.Peek() == '-') {
   minus = true;
   s.Take();
  }


  unsigned i;
  bool try64bit = false;
  if (s.Peek() == '0') {
   i = 0;
   s.Take();
  }
  else if (s.Peek() >= '1' && s.Peek() <= '9') {
   i = s.Take() - '0';

   if (minus)
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i >= 214748364) {
      if (i != 214748364 || s.Peek() > '8') {
       try64bit = true;
       break;
      }
     }
     i = i * 10 + (s.Take() - '0');
    }
   else
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i >= 429496729) {
      if (i != 429496729 || s.Peek() > '5') {
       try64bit = true;
       break;
      }
     }
     i = i * 10 + (s.Take() - '0');
    }
  }
  else {
   do { parseError_ = "Expect a value here."; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   return;
  }


  uint64_t i64 = 0;
  bool useDouble = false;
  if (try64bit) {
   i64 = i;
   if (minus)
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i64 >= 922337203685477580uLL)
      if (i64 != 922337203685477580uLL || s.Peek() > '8') {
       useDouble = true;
       break;
      }
     i64 = i64 * 10 + (s.Take() - '0');
    }
   else
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i64 >= 1844674407370955161uLL)
      if (i64 != 1844674407370955161uLL || s.Peek() > '5') {
       useDouble = true;
       break;
      }
     i64 = i64 * 10 + (s.Take() - '0');
    }
  }


  double d = 0.0;
  if (useDouble) {
   d = (double)i64;
   while (s.Peek() >= '0' && s.Peek() <= '9') {
    if (d >= 1E307) {
     do { parseError_ = "Number too big to store in double"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
     return;
    }
    d = d * 10 + (s.Take() - '0');
   }
  }


  int expFrac = 0;
  if (s.Peek() == '.') {
   if (!useDouble) {
    d = try64bit ? (double)i64 : (double)i;
    useDouble = true;
   }
   s.Take();

   if (s.Peek() >= '0' && s.Peek() <= '9') {
    d = d * 10 + (s.Take() - '0');
    --expFrac;
   }
   else {
    do { parseError_ = "At least one digit in fraction part"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }

   while (s.Peek() >= '0' && s.Peek() <= '9') {
    if (expFrac > -16) {
     d = d * 10 + (s.Peek() - '0');
     --expFrac;
    }
    s.Take();
   }
  }


  int exp = 0;
  if (s.Peek() == 'e' || s.Peek() == 'E') {
   if (!useDouble) {
    d = try64bit ? (double)i64 : (double)i;
    useDouble = true;
   }
   s.Take();

   bool expMinus = false;
   if (s.Peek() == '+')
    s.Take();
   else if (s.Peek() == '-') {
    s.Take();
    expMinus = true;
   }

   if (s.Peek() >= '0' && s.Peek() <= '9') {
    exp = s.Take() - '0';
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     exp = exp * 10 + (s.Take() - '0');
     if (exp > 308) {
      do { parseError_ = "Number too big to store in double"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
      return;
     }
    }
   }
   else {
    do { parseError_ = "At least one digit in exponent"; errorOffset_ = s.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }

   if (expMinus)
    exp = -exp;
  }


  if (useDouble) {
   d *= internal::Pow10(exp + expFrac);
   handler.Double(minus ? -d : d);
  }
  else {
   if (try64bit) {
    if (minus)
     handler.Int64(-(int64_t)i64);
    else
     handler.Uint64(i64);
   }
   else {
    if (minus)
     handler.Int(-(int)i);
    else
     handler.Uint(i);
   }
  }

  stream = s;
 }


 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseValue(Stream& stream, Handler& handler) {
  switch (stream.Peek()) {
   case 'n': ParseNull <parseFlags>(stream, handler); break;
   case 't': ParseTrue <parseFlags>(stream, handler); break;
   case 'f': ParseFalse <parseFlags>(stream, handler); break;
   case '"': ParseString<parseFlags>(stream, handler); break;
   case '{': ParseObject<parseFlags>(stream, handler); break;
   case '[': ParseArray <parseFlags>(stream, handler); break;
   default : ParseNumber<parseFlags>(stream, handler);
  }
 }

 static const size_t kDefaultStackCapacity = 256;
 internal::Stack<Allocator> stack_;
 jmp_buf jmpbuf_;
 const char* parseError_;
 size_t errorOffset_;
};


typedef GenericReader<UTF8<> > Reader;

}
# 5 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/strfunc.h" 1



namespace rapidjson {
namespace internal {







template <typename Ch>
inline SizeType StrLen(const Ch* s) {
 const Ch* p = s;
 while (*p != '\0')
  ++p;
 return SizeType(p - s);
}

}
}
# 6 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h" 2







namespace rapidjson {
# 28 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
#pragma pack (push, 4)
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >
class GenericValue {
public:

 struct Member {
  GenericValue<Encoding, Allocator> name;
  GenericValue<Encoding, Allocator> value;
 };

 typedef Encoding EncodingType;
 typedef Allocator AllocatorType;
 typedef typename Encoding::Ch Ch;
 typedef Member* MemberIterator;
 typedef const Member* ConstMemberIterator;
 typedef GenericValue* ValueIterator;
 typedef const GenericValue* ConstValueIterator;





 GenericValue() : flags_(kNullFlag) {}


private:
 GenericValue(const GenericValue& rhs);

public:






 GenericValue(Type type) {
  static const unsigned defaultFlags[7] = {
   kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kConstStringFlag,
   kNumberFlag | kIntFlag | kUintFlag | kInt64Flag | kUint64Flag | kDoubleFlag
  };
  (__builtin_expect(!(type <= kNumberType), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 68, "type <= kNumberType") : (void)0);
  flags_ = defaultFlags[type];
  memset(&data_, 0, sizeof(data_));
 }


 GenericValue(bool b) : flags_(b ? kTrueFlag : kFalseFlag) {}


 GenericValue(int i) : flags_(kNumberIntFlag) {
  data_.n.i64 = i;
  if (i >= 0)
   flags_ |= kUintFlag | kUint64Flag;
 }


 GenericValue(unsigned u) : flags_(kNumberUintFlag) {
  data_.n.u64 = u;
  if (!(u & 0x80000000))
   flags_ |= kIntFlag | kInt64Flag;
 }


 GenericValue(int64_t i64) : flags_(kNumberInt64Flag) {
  data_.n.i64 = i64;
  if (i64 >= 0) {
   flags_ |= kNumberUint64Flag;
   if (!(i64 & 0xFFFFFFFF00000000LL))
    flags_ |= kUintFlag;
   if (!(i64 & 0xFFFFFFFF80000000LL))
    flags_ |= kIntFlag;
  }
  else if (i64 >= -2147483648LL)
   flags_ |= kIntFlag;
 }


 GenericValue(uint64_t u64) : flags_(kNumberUint64Flag) {
  data_.n.u64 = u64;
  if (!(u64 & 0x8000000000000000ULL))
   flags_ |= kInt64Flag;
  if (!(u64 & 0xFFFFFFFF00000000ULL))
   flags_ |= kUintFlag;
  if (!(u64 & 0xFFFFFFFF80000000ULL))
   flags_ |= kIntFlag;
 }


 GenericValue(double d) : flags_(kNumberDoubleFlag) { data_.n.d = d; }


 GenericValue(const Ch* s, SizeType length) {
  (__builtin_expect(!(s != __null), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 120, "s != __null") : (void)0);
  flags_ = kConstStringFlag;
  data_.s.str = s;
  data_.s.length = length;
 }


 GenericValue(const Ch* s) { SetStringRaw(s, internal::StrLen(s)); }


 GenericValue(const Ch* s, SizeType length, Allocator& allocator) { SetStringRaw(s, length, allocator); }


 GenericValue(const Ch*s, Allocator& allocator) { SetStringRaw(s, internal::StrLen(s), allocator); }




 ~GenericValue() {
  if (Allocator::kNeedFree) {
   switch(flags_) {
   case kArrayFlag:
    for (GenericValue* v = data_.a.elements; v != data_.a.elements + data_.a.size; ++v)
     v->~GenericValue();
    Allocator::Free(data_.a.elements);
    break;

   case kObjectFlag:
    for (Member* m = data_.o.members; m != data_.o.members + data_.o.size; ++m) {
     m->name.~GenericValue();
     m->value.~GenericValue();
    }
    Allocator::Free(data_.o.members);
    break;

   case kCopyStringFlag:
    Allocator::Free(const_cast<Ch*>(data_.s.str));
    break;
   }
  }
 }
# 170 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& operator=(GenericValue& rhs) {
  (__builtin_expect(!(this != &rhs), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 171, "this != &rhs") : (void)0);
  this->~GenericValue();
  memcpy(this, &rhs, sizeof(GenericValue));
  rhs.flags_ = kNullFlag;
  return *this;
 }





 template <typename T>
 GenericValue& operator=(T value) {
  this->~GenericValue();
  new (this) GenericValue(value);
  return *this;
 }





 Type GetType() const { return static_cast<Type>(flags_ & kTypeMask); }
 bool IsNull() const { return flags_ == kNullFlag; }
 bool IsFalse() const { return flags_ == kFalseFlag; }
 bool IsTrue() const { return flags_ == kTrueFlag; }
 bool IsBool() const { return (flags_ & kBoolFlag) != 0; }
 bool IsObject() const { return flags_ == kObjectFlag; }
 bool IsArray() const { return flags_ == kArrayFlag; }
 bool IsNumber() const { return (flags_ & kNumberFlag) != 0; }
 bool IsInt() const { return (flags_ & kIntFlag) != 0; }
 bool IsUint() const { return (flags_ & kUintFlag) != 0; }
 bool IsInt64() const { return (flags_ & kInt64Flag) != 0; }
 bool IsUint64() const { return (flags_ & kUint64Flag) != 0; }
 bool IsDouble() const { return (flags_ & kDoubleFlag) != 0; }
 bool IsString() const { return (flags_ & kStringFlag) != 0; }






 GenericValue& SetNull() { this->~GenericValue(); new (this) GenericValue(); return *this; }






 bool GetBool() const { (__builtin_expect(!(IsBool()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 220, "IsBool()") : (void)0); return flags_ == kTrueFlag; }
 GenericValue& SetBool(bool b) { this->~GenericValue(); new (this) GenericValue(b); return *this; }







 GenericValue& SetObject() { this->~GenericValue(); new (this) GenericValue(kObjectType); return *this; }


 GenericValue& operator[](const Ch* name) {
  if (Member* member = FindMember(name))
   return member->value;
  else {
   static GenericValue NullValue;
   return NullValue;
  }
 }
 const GenericValue& operator[](const Ch* name) const { return const_cast<GenericValue&>(*this)[name]; }


 ConstMemberIterator MemberonBegin() const { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 243, "IsObject()") : (void)0); return data_.o.members; }
 ConstMemberIterator MemberonEnd() const { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 244, "IsObject()") : (void)0); return data_.o.members + data_.o.size; }
 MemberIterator MemberonBegin() { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 245, "IsObject()") : (void)0); return data_.o.members; }
 MemberIterator MemberonEnd() { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 246, "IsObject()") : (void)0); return data_.o.members + data_.o.size; }


 bool HasMember(const Ch* name) const { return FindMember(name) != 0; }
# 258 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& AddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {
  (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 259, "IsObject()") : (void)0);
  (__builtin_expect(!(name.IsString()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 260, "name.IsString()") : (void)0);
  Object& o = data_.o;
  if (o.size >= o.capacity) {
   if (o.capacity == 0) {
    o.capacity = kDefaultObjectCapacity;
    o.members = (Member*)allocator.Malloc(o.capacity * sizeof(Member));
   }
   else {
    SizeType oldCapacity = o.capacity;
    o.capacity *= 2;
    o.members = (Member*)allocator.Realloc(o.members, oldCapacity * sizeof(Member), o.capacity * sizeof(Member));
   }
  }
  o.members[o.size].name.RawAssign(name);
  o.members[o.size].value.RawAssign(value);
  o.size++;
  return *this;
 }

 GenericValue& AddMember(const Ch* name, Allocator& nameAllocator, GenericValue& value, Allocator& allocator) {
  GenericValue n(name, internal::StrLen(name), nameAllocator);
  return AddMember(n, value, allocator);
 }

 GenericValue& AddMember(const Ch* name, GenericValue& value, Allocator& allocator) {
  GenericValue n(name, internal::StrLen(name));
  return AddMember(n, value, allocator);
 }

 template <typename T>
 GenericValue& AddMember(const Ch* name, T value, Allocator& allocator) {
  GenericValue n(name, internal::StrLen(name));
  GenericValue v(value);
  return AddMember(n, v, allocator);
 }






 bool RemoveMember(const Ch* name) {
  (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 302, "IsObject()") : (void)0);
  if (Member* m = FindMember(name)) {
   (__builtin_expect(!(data_.o.size > 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 304, "data_.o.size > 0") : (void)0);
   (__builtin_expect(!(data_.o.members != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 305, "data_.o.members != 0") : (void)0);

   Member* last = data_.o.members + (data_.o.size - 1);
   if (data_.o.size > 1 && m != last) {

    m->name = last->name;
    m->value = last->value;
   }
   else {

    m->name.~GenericValue();
    m->value.~GenericValue();
   }
   --data_.o.size;
   return true;
  }
  return false;
 }







 GenericValue& SetArray() { this->~GenericValue(); new (this) GenericValue(kArrayType); return *this; }


 SizeType Size() const { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 333, "IsArray()") : (void)0); return data_.a.size; }


 SizeType Capacity() const { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 336, "IsArray()") : (void)0); return data_.a.capacity; }


 bool Empty() const { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 339, "IsArray()") : (void)0); return data_.a.size == 0; }




 void Clear() {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 345, "IsArray()") : (void)0);
  for (SizeType i = 0; i < data_.a.size; ++i)
   data_.a.elements[i].~GenericValue();
  data_.a.size = 0;
 }
# 362 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& operator[](SizeType index) {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 363, "IsArray()") : (void)0);
  (__builtin_expect(!(index < data_.a.size), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 364, "index < data_.a.size") : (void)0);
  return data_.a.elements[index];
 }
 const GenericValue& operator[](SizeType index) const { return const_cast<GenericValue&>(*this)[index]; }


 ValueIterator onBegin() { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 370, "IsArray()") : (void)0); return data_.a.elements; }
 ValueIterator onEnd() { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 371, "IsArray()") : (void)0); return data_.a.elements + data_.a.size; }
 ConstValueIterator onBegin() const { return const_cast<GenericValue&>(*this).onBegin(); }
 ConstValueIterator onEnd() const { return const_cast<GenericValue&>(*this).onEnd(); }






 GenericValue& Reserve(SizeType newCapacity, Allocator &allocator) {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 381, "IsArray()") : (void)0);
  if (newCapacity > data_.a.capacity) {
   data_.a.elements = (GenericValue*)allocator.Realloc(data_.a.elements, data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue));
   data_.a.capacity = newCapacity;
  }
  return *this;
 }
# 396 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& PushBack(GenericValue& value, Allocator& allocator) {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 397, "IsArray()") : (void)0);
  if (data_.a.size >= data_.a.capacity)
   Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : data_.a.capacity * 2, allocator);
  data_.a.elements[data_.a.size++].RawAssign(value);
  return *this;
 }

 template <typename T>
 GenericValue& PushBack(T value, Allocator& allocator) {
  GenericValue v(value);
  return PushBack(v, allocator);
 }


 GenericValue& PopBack() {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 412, "IsArray()") : (void)0);
  (__builtin_expect(!(!Empty()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 413, "!Empty()") : (void)0);
  data_.a.elements[--data_.a.size].~GenericValue();
  return *this;
 }





 int GetInt() const { (__builtin_expect(!(flags_ & kIntFlag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 422, "flags_ & kIntFlag") : (void)0); return data_.n.i.i; }
 unsigned GetUint() const { (__builtin_expect(!(flags_ & kUintFlag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 423, "flags_ & kUintFlag") : (void)0); return data_.n.u.u; }
 int64_t GetInt64() const { (__builtin_expect(!(flags_ & kInt64Flag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 424, "flags_ & kInt64Flag") : (void)0); return data_.n.i64; }
 uint64_t GetUint64() const { (__builtin_expect(!(flags_ & kUint64Flag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 425, "flags_ & kUint64Flag") : (void)0); return data_.n.u64; }

 double GetDouble() const {
  (__builtin_expect(!(IsNumber()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 428, "IsNumber()") : (void)0);
  if ((flags_ & kDoubleFlag) != 0) return data_.n.d;
  if ((flags_ & kIntFlag) != 0) return data_.n.i.i;
  if ((flags_ & kUintFlag) != 0) return data_.n.u.u;
  if ((flags_ & kInt64Flag) != 0) return (double)data_.n.i64;
  (__builtin_expect(!((flags_ & kUint64Flag) != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 433, "(flags_ & kUint64Flag) != 0") : (void)0); return (double)data_.n.u64;
 }

 GenericValue& SetInt(int i) { this->~GenericValue(); new (this) GenericValue(i); return *this; }
 GenericValue& SetUint(unsigned u) { this->~GenericValue(); new (this) GenericValue(u); return *this; }
 GenericValue& SetInt64(int64_t i64) { this->~GenericValue(); new (this) GenericValue(i64); return *this; }
 GenericValue& SetUint64(uint64_t u64) { this->~GenericValue(); new (this) GenericValue(u64); return *this; }
 GenericValue& SetDouble(double d) { this->~GenericValue(); new (this) GenericValue(d); return *this; }






 const Ch* GetString() const { (__builtin_expect(!(IsString()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 447, "IsString()") : (void)0); return data_.s.str; }




 SizeType GetStringLength() const { (__builtin_expect(!(IsString()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 452, "IsString()") : (void)0); return data_.s.length; }







 GenericValue& SetString(const Ch* s, SizeType length) { this->~GenericValue(); SetStringRaw(s, length); return *this; }





 GenericValue& SetString(const Ch* s) { return SetString(s, internal::StrLen(s)); }
# 475 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& SetString(const Ch* s, SizeType length, Allocator& allocator) { this->~GenericValue(); SetStringRaw(s, length, allocator); return *this; }






 GenericValue& SetString(const Ch* s, Allocator& allocator) { SetString(s, internal::StrLen(s), allocator); return *this; }
# 493 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 template <typename Handler>
 const GenericValue& Accept(Handler& handler) const {
  switch(GetType()) {
  case kNullType: handler.Null(); break;
  case kFalseType: handler.Bool(false); break;
  case kTrueType: handler.Bool(true); break;

  case kObjectType:
   handler.StartObject();
   for (Member* m = data_.o.members; m != data_.o.members + data_.o.size; ++m) {
    handler.String(m->name.data_.s.str, m->name.data_.s.length, false);
    m->value.Accept(handler);
   }
   handler.EndObject(data_.o.size);
   break;

  case kArrayType:
   handler.StartArray();
   for (GenericValue* v = data_.a.elements; v != data_.a.elements + data_.a.size; ++v)
    v->Accept(handler);
   handler.EndArray(data_.a.size);
   break;

  case kStringType:
   handler.String(data_.s.str, data_.s.length, false);
   break;

  case kNumberType:
   if (IsInt()) handler.Int(data_.n.i.i);
   else if (IsUint()) handler.Uint(data_.n.u.u);
   else if (IsInt64()) handler.Int64(data_.n.i64);
   else if (IsUint64()) handler.Uint64(data_.n.u64);
   else handler.Double(data_.n.d);
   break;
  }
  return *this;
 }

private:
 template <typename, typename>
 friend class GenericDocument;

 enum {
  kBoolFlag = 0x100,
  kNumberFlag = 0x200,
  kIntFlag = 0x400,
  kUintFlag = 0x800,
  kInt64Flag = 0x1000,
  kUint64Flag = 0x2000,
  kDoubleFlag = 0x4000,
  kStringFlag = 0x100000,
  kCopyFlag = 0x200000,


  kNullFlag = kNullType,
  kTrueFlag = kTrueType | kBoolFlag,
  kFalseFlag = kFalseType | kBoolFlag,
  kNumberIntFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag,
  kNumberUintFlag = kNumberType | kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag,
  kNumberInt64Flag = kNumberType | kNumberFlag | kInt64Flag,
  kNumberUint64Flag = kNumberType | kNumberFlag | kUint64Flag,
  kNumberDoubleFlag = kNumberType | kNumberFlag | kDoubleFlag,
  kConstStringFlag = kStringType | kStringFlag,
  kCopyStringFlag = kStringType | kStringFlag | kCopyFlag,
  kObjectFlag = kObjectType,
  kArrayFlag = kArrayType,

  kTypeMask = 0xFF
 };

 static const SizeType kDefaultArrayCapacity = 16;
 static const SizeType kDefaultObjectCapacity = 16;

 struct String {
  const Ch* str;
  SizeType length;
  unsigned hashcode;
 };


 union Number {

  struct I {
   int i;
   char padding[4];
  }i;
  struct U {
   unsigned u;
   char padding2[4];
  }u;
# 593 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
  int64_t i64;
  uint64_t u64;
  double d;
 };

 struct Object {
  Member* members;
  SizeType size;
  SizeType capacity;
 };

 struct Array {
  GenericValue<Encoding, Allocator>* elements;
  SizeType size;
  SizeType capacity;
 };

 union Data {
  String s;
  Number n;
  Object o;
  Array a;
 };


 Member* FindMember(const Ch* name) {
  (__builtin_expect(!(name), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 619, "name") : (void)0);
  (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 620, "IsObject()") : (void)0);

  SizeType length = internal::StrLen(name);

  Object& o = data_.o;
  for (Member* member = o.members; member != data_.o.members + data_.o.size; ++member)
   if (length == member->name.data_.s.length && memcmp(member->name.data_.s.str, name, length * sizeof(Ch)) == 0)
    return member;

  return 0;
 }
 const Member* FindMember(const Ch* name) const { return const_cast<GenericValue&>(*this).FindMember(name); }


 void SetArrayRaw(GenericValue* values, SizeType count, Allocator& alloctaor) {
  flags_ = kArrayFlag;
  data_.a.elements = (GenericValue*)alloctaor.Malloc(count * sizeof(GenericValue));
  memcpy(data_.a.elements, values, count * sizeof(GenericValue));
  data_.a.size = data_.a.capacity = count;
 }


 void SetObjectRaw(Member* members, SizeType count, Allocator& alloctaor) {
  flags_ = kObjectFlag;
  data_.o.members = (Member*)alloctaor.Malloc(count * sizeof(Member));
  memcpy(data_.o.members, members, count * sizeof(Member));
  data_.o.size = data_.o.capacity = count;
 }


 void SetStringRaw(const Ch* s, SizeType length) {
  (__builtin_expect(!(s != __null), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 651, "s != __null") : (void)0);
  flags_ = kConstStringFlag;
  data_.s.str = s;
  data_.s.length = length;
 }


 void SetStringRaw(const Ch* s, SizeType length, Allocator& allocator) {
  (__builtin_expect(!(s != __null), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 659, "s != __null") : (void)0);
  flags_ = kCopyStringFlag;
  data_.s.str = (Ch *)allocator.Malloc((length + 1) * sizeof(Ch));
  data_.s.length = length;
  memcpy(const_cast<Ch*>(data_.s.str), s, length * sizeof(Ch));
  const_cast<Ch*>(data_.s.str)[length] = '\0';
 }


 void RawAssign(GenericValue& rhs) {
  memcpy(this, &rhs, sizeof(GenericValue));
  rhs.flags_ = kNullFlag;
 }

 Data data_;
 unsigned flags_;
};
#pragma pack (pop)


typedef GenericValue<UTF8<> > Value;
# 690 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >
class GenericDocument : public GenericValue<Encoding, Allocator> {
public:
 typedef typename Encoding::Ch Ch;
 typedef GenericValue<Encoding, Allocator> ValueType;
 typedef Allocator AllocatorType;





 GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity) : stack_(allocator, stackCapacity), parseError_(0), errorOffset_(0) {}






 template <unsigned parseFlags, typename Stream>
 GenericDocument& ParseStream(Stream& stream) {
  ValueType::SetNull();
  GenericReader<Encoding, Allocator> reader;
  if (reader.template Parse<parseFlags>(stream, *this)) {
   (__builtin_expect(!(stack_.GetSize() == sizeof(ValueType)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 713, "stack_.GetSize() == sizeof(ValueType)") : (void)0);
   this->RawAssign(*stack_.template Pop<ValueType>(1));
   parseError_ = 0;
   errorOffset_ = 0;
  }
  else {
   parseError_ = reader.GetParseError();
   errorOffset_ = reader.GetErrorOffset();
   ClearStack();
  }
  return *this;
 }






 template <unsigned parseFlags>
 GenericDocument& ParseInsitu(Ch* str) {
  GenericInsituStringStream<Encoding> s(str);
  return ParseStream<parseFlags | kParseInsituFlag>(s);
 }





 template <unsigned parseFlags>
 GenericDocument& Parse(const Ch* str) {
  (__builtin_expect(!(!(parseFlags & kParseInsituFlag)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 743, "!(parseFlags & kParseInsituFlag)") : (void)0);
  GenericStringStream<Encoding> s(str);
  return ParseStream<parseFlags>(s);
 }


 bool HasParseError() const { return parseError_ != 0; }


 const char* GetParseError() const { return parseError_; }


 size_t GetErrorOffset() const { return errorOffset_; }


 Allocator& GetAllocator() { return stack_.GetAllocator(); }


 size_t GetStackCapacity() const { return stack_.GetCapacity(); }

private:

 GenericDocument& operator=(const GenericDocument&);

 friend class GenericReader<Encoding, Allocator>;


 void Null() { new (stack_.template Push<ValueType>()) ValueType(); }
 void Bool(bool b) { new (stack_.template Push<ValueType>()) ValueType(b); }
 void Int(int i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Uint(unsigned i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Int64(int64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Uint64(uint64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Double(double d) { new (stack_.template Push<ValueType>()) ValueType(d); }

 void String(const Ch* str, SizeType length, bool copy) {
  if (copy)
   new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
  else
   new (stack_.template Push<ValueType>()) ValueType(str, length);
 }

 void StartObject() { new (stack_.template Push<ValueType>()) ValueType(kObjectType); }

 void EndObject(SizeType memberCount) {
  typename ValueType::Member* members = stack_.template Pop<typename ValueType::Member>(memberCount);
  stack_.template Top<ValueType>()->SetObjectRaw(members, (SizeType)memberCount, GetAllocator());
 }

 void StartArray() { new (stack_.template Push<ValueType>()) ValueType(kArrayType); }

 void EndArray(SizeType elementCount) {
  ValueType* elements = stack_.template Pop<ValueType>(elementCount);
  stack_.template Top<ValueType>()->SetArrayRaw(elements, elementCount, GetAllocator());
 }

 void ClearStack() {
  if (Allocator::kNeedFree)
   while (stack_.GetSize() > 0)
    (stack_.template Pop<ValueType>(1))->~ValueType();
  else
   stack_.Clear();
 }

 static const size_t kDefaultStackCapacity = 1024;
 internal::Stack<Allocator> stack_;
 const char* parseError_;
 size_t errorOffset_;
};

typedef GenericDocument<UTF8<> > Document;

}
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/DictionaryHelper.h" 2



namespace cocos2d { namespace extension {




class DictionaryHelper
{
public:
    DictionaryHelper();
    ~DictionaryHelper();
    static DictionaryHelper* shareHelper();
 static void purgeDictionaryHelper();
    cocos2d::CCDictionary* getSubDictionary(cocos2d::CCDictionary* root,const char* key);
    int getIntValue(cocos2d::CCDictionary* root,const char* key);
    float getFloatValue(cocos2d::CCDictionary* root,const char* key);
    const char* getStringValue(cocos2d::CCDictionary* root,const char* key);
    bool getBooleanValue(cocos2d::CCDictionary* root,const char* key);
    cocos2d::CCArray* getArrayValue(cocos2d::CCDictionary* root,const char* key);
    cocos2d::CCObject* checkObjectExist(cocos2d::CCDictionary* root,const char* key);
    int objectToIntValue(cocos2d::CCObject* obj);
    float objectToFloatValue(cocos2d::CCObject* obj);
    const char* objectToStringValue(cocos2d::CCObject* obj);
    bool objectToBooleanValue(cocos2d::CCObject* obj);
    cocos2d::CCArray* objectToCCArray(cocos2d::CCObject* obj);

 const rapidjson::Value& getSubDictionary_json(const rapidjson::Value &root, const char* key);
    const rapidjson::Value& getSubDictionary_json(const rapidjson::Value &root, const char* key, int idx);
    const rapidjson::Value& getSubDictionary_json(const rapidjson::Value &root, int idx);

 int getIntValue_json(const rapidjson::Value& root, const char* key, int def = 0);
 float getFloatValue_json(const rapidjson::Value& root,const char* key, float def = 0.0f);
    bool getBooleanValue_json(const rapidjson::Value& root,const char* key, bool def = false);
    const char* getStringValue_json(const rapidjson::Value& root,const char* key, const char *def = __null);
    int getArrayCount_json(const rapidjson::Value& root,const char* key, int def = 0);

    int getIntValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, int def = 0);
 float getFloatValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, float def = 0.0f);
 bool getBoolValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, bool def = false);
 const char* getStringValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, const char *def = __null);
 const rapidjson::Value &getDictionaryFromArray_json(const rapidjson::Value &root, const char* key,int idx);
 bool checkObjectExist_json(const rapidjson::Value &root);
    bool checkObjectExist_json(const rapidjson::Value &root, const char* key);
    bool checkObjectExist_json(const rapidjson::Value &root, int index);
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCDataReaderHelper.h" 2


namespace tinyxml2
{
    class XMLElement;
}

namespace cocos2d { namespace extension {

typedef struct _DataInfo DataInfo;




class CCDataReaderHelper : CCObject
{
public:
    static CCDataReaderHelper *sharedDataReaderHelper();





    static void setPositionReadScale(float scale);
    static float getPositionReadScale();

    static void purge();

public:
    ~CCDataReaderHelper();

    void addDataFromFile(const char *filePath);
    void addDataFromFileAsync(const char *imagePath, const char *plistPath, const char *filePath, CCObject *target, SEL_SCHEDULE selector);

    void addDataAsyncCallBack(float dt);

    void removeConfigFile(const char *configFile);
public:







    static void addDataFromCache(const char *pFileContent, DataInfo *dataInfo = __null);






    static CCArmatureData *decodeArmature(tinyxml2::XMLElement *armatureXML, DataInfo *dataInfo);
    static CCBoneData *decodeBone(tinyxml2::XMLElement *boneXML, tinyxml2::XMLElement *parentXML, DataInfo *dataInfo);
    static CCDisplayData *decodeBoneDisplay(tinyxml2::XMLElement *displayXML, DataInfo *dataInfo);





    static CCAnimationData *decodeAnimation(tinyxml2::XMLElement *animationXML, DataInfo *dataInfo);
    static CCMovementData *decodeMovement(tinyxml2::XMLElement *movementXML, CCArmatureData *armatureData, DataInfo *dataInfo);
    static CCMovementBoneData *decodeMovementBone(tinyxml2::XMLElement *movBoneXml, tinyxml2::XMLElement *parentXml, CCBoneData *boneData, DataInfo *dataInfo);
    static CCFrameData *decodeFrame(tinyxml2::XMLElement *frameXML, tinyxml2::XMLElement *parentFrameXml, CCBoneData *boneData, DataInfo *dataInfo);





    static CCTextureData *decodeTexture(tinyxml2::XMLElement *textureXML, DataInfo *dataInfo);




    static CCContourData *decodeContour(tinyxml2::XMLElement *contourXML, DataInfo *dataInfo);

public:
    static void addDataFromJsonCache(const char *fileContent, DataInfo *dataInfo = __null);

 static CCArmatureData *decodeArmature(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCBoneData *decodeBone(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCDisplayData *decodeBoneDisplay(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCAnimationData *decodeAnimation(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCMovementData *decodeMovement(const rapidjson::Value &json, DataInfo *dataInfo);

 static CCMovementBoneData *decodeMovementBone(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCFrameData *decodeFrame(const rapidjson::Value &json, DataInfo *dataInfo);

 static CCTextureData *decodeTexture(const rapidjson::Value &json);
 static CCContourData *decodeContour(const rapidjson::Value &json);

 static void decodeNode(CCBaseData *node, const rapidjson::Value &json, DataInfo *dataInfo);
private:
    static std::vector<std::string> s_arrConfigFileList;

    static CCDataReaderHelper *s_DataReaderHelper;
};

}}
# 55 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/external_tool/sigslot.h" 1
# 110 "Cacao/include/cocos2dext/CocoStudio/Armature/external_tool/sigslot.h"
namespace sigslot {

 class single_threaded
 {
 public:
  single_threaded()
  {
   ;
  }

  virtual ~single_threaded()
  {
   ;
  }

  virtual void lock()
  {
   ;
  }

  virtual void unlock()
  {
   ;
  }
 };
# 215 "Cacao/include/cocos2dext/CocoStudio/Armature/external_tool/sigslot.h"
 class multi_threaded_global
 {
 public:
  multi_threaded_global()
  {
   pthread_mutex_init(get_mutex(), __null);
  }

  multi_threaded_global(const multi_threaded_global&)
  {
   ;
  }

  virtual ~multi_threaded_global()
  {
   ;
  }

  virtual void lock()
  {
   pthread_mutex_lock(get_mutex());
  }

  virtual void unlock()
  {
   pthread_mutex_unlock(get_mutex());
  }

 private:
  pthread_mutex_t* get_mutex()
  {
   static pthread_mutex_t g_mutex;
   return &g_mutex;
  }
 };

 class multi_threaded_local
 {
 public:
  multi_threaded_local()
  {
   pthread_mutex_init(&m_mutex, __null);
  }

  multi_threaded_local(const multi_threaded_local&)
  {
   pthread_mutex_init(&m_mutex, __null);
  }

  virtual ~multi_threaded_local()
  {
   pthread_mutex_destroy(&m_mutex);
  }

  virtual void lock()
  {
   pthread_mutex_lock(&m_mutex);
  }

  virtual void unlock()
  {
   pthread_mutex_unlock(&m_mutex);
  }

 private:
  pthread_mutex_t m_mutex;
 };


 template<class mt_policy>
 class lock_block
 {
 public:
  mt_policy *m_mutex;

  lock_block(mt_policy *mtx)
        : m_mutex(mtx)
  {
   m_mutex->lock();
  }

  ~lock_block()
  {
   m_mutex->unlock();
  }
 };

 template<class mt_policy>
 class has_slots;

 template<class mt_policy>
 class _connection_base0
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit() = 0;
  virtual _connection_base0* clone() = 0;
  virtual _connection_base0* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class mt_policy>
 class _connection_base1
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type) = 0;
  virtual _connection_base1<arg1_type, mt_policy>* clone() = 0;
  virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class mt_policy>
 class _connection_base2
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type) = 0;
  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone() = 0;
  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _connection_base3
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type) = 0;
  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone() = 0;
  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
 class _connection_base4
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type) = 0;
  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone() = 0;
  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy>
 class _connection_base5
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type,
                          arg5_type) = 0;
  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* clone() = 0;
  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy>
 class _connection_base6
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
                          arg6_type) = 0;
  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* clone() = 0;
  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _connection_base7
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
                          arg6_type, arg7_type) = 0;
  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* clone() = 0;
  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
 class _connection_base8
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
                          arg6_type, arg7_type, arg8_type) = 0;
  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone() = 0;
  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class mt_policy>
 class _signal_base : public mt_policy
 {
 public:
  virtual void slot_disconnect(has_slots<mt_policy>* pslot) = 0;
  virtual void slot_duplicate(const has_slots<mt_policy>* poldslot, has_slots<mt_policy>* pnewslot) = 0;
 };

 template<class mt_policy = multi_threaded_local>
 class has_slots : public mt_policy
 {
 private:
  typedef std::set<_signal_base<mt_policy> *> sender_set;
  typedef typename sender_set::const_iterator const_iterator;

 public:
  has_slots()
  {
   ;
  }

  has_slots(const has_slots& hs)
        : mt_policy(hs)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = hs.m_senders.begin();
   const_iterator itEnd = hs.m_senders.end();

   while(it != itEnd)
   {
    (*it)->slot_duplicate(&hs, this);
    m_senders.insert(*it);
    ++it;
   }
  }

  void signal_connect(_signal_base<mt_policy>* sender)
  {
   lock_block<mt_policy> lock(this);
   m_senders.insert(sender);
  }

  void signal_disconnect(_signal_base<mt_policy>* sender)
  {
   lock_block<mt_policy> lock(this);
   m_senders.erase(sender);
  }

  virtual ~has_slots()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_senders.begin();
   const_iterator itEnd = m_senders.end();

   while(it != itEnd)
   {
    (*it)->slot_disconnect(this);
    ++it;
   }

   m_senders.erase(m_senders.begin(), m_senders.end());
  }

 private:
  sender_set m_senders;
 };

 template<class mt_policy>
 class _signal_base0 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base0<mt_policy> *> connections_list;

  _signal_base0()
  {
   ;
  }

  _signal_base0(const _signal_base0& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  ~_signal_base0()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class mt_policy>
 class _signal_base1 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base1<arg1_type, mt_policy> *> connections_list;

  _signal_base1()
  {
   ;
  }

  _signal_base1(const _signal_base1<arg1_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base1()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }


 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class mt_policy>
 class _signal_base2 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base2<arg1_type, arg2_type, mt_policy> *>
        connections_list;

  _signal_base2()
  {
   ;
  }

  _signal_base2(const _signal_base2<arg1_type, arg2_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base2()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _signal_base3 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base3<arg1_type, arg2_type, arg3_type, mt_policy> *>
        connections_list;

  _signal_base3()
  {
   ;
  }

  _signal_base3(const _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base3()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
 class _signal_base4 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base4<arg1_type, arg2_type, arg3_type,
        arg4_type, mt_policy> *> connections_list;

  _signal_base4()
  {
   ;
  }

  _signal_base4(const _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base4()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy>
 class _signal_base5 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base5<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, mt_policy> *> connections_list;

  _signal_base5()
  {
   ;
  }

  _signal_base5(const _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base5()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy>
 class _signal_base6 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base6<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, mt_policy> *> connections_list;

  _signal_base6()
  {
   ;
  }

  _signal_base6(const _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, arg6_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base6()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _signal_base7 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base7<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> *> connections_list;

  _signal_base7()
  {
   ;
  }

  _signal_base7(const _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, arg6_type, arg7_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base7()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
 class _signal_base8 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base8<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> *>
        connections_list;

  _signal_base8()
  {
   ;
  }

  _signal_base8(const _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base8()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };


 template<class dest_type, class mt_policy>
 class _connection0 : public _connection_base0<mt_policy>
 {
 public:
  _connection0()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection0(dest_type* pobject, void (dest_type::*pmemfun)())
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base0<mt_policy>* clone()
  {
   return new _connection0<dest_type, mt_policy>(*this);
  }

  virtual _connection_base0<mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection0<dest_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit()
  {
   (m_pobject->*m_pmemfun)();
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)();
 };

 template<class dest_type, class arg1_type, class mt_policy>
 class _connection1 : public _connection_base1<arg1_type, mt_policy>
 {
 public:
  _connection1()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection1(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base1<arg1_type, mt_policy>* clone()
  {
   return new _connection1<dest_type, arg1_type, mt_policy>(*this);
  }

  virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection1<dest_type, arg1_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1)
  {
   (m_pobject->*m_pmemfun)(a1);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class mt_policy>
 class _connection2 : public _connection_base2<arg1_type, arg2_type, mt_policy>
 {
 public:
  _connection2()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection2(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone()
  {
   return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>(*this);
  }

  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2)
  {
   (m_pobject->*m_pmemfun)(a1, a2);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _connection3 : public _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>
 {
 public:
  _connection3()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection3(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone()
  {
   return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>(*this);
  }

  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class mt_policy>
 class _connection4 : public _connection_base4<arg1_type, arg2_type,
    arg3_type, arg4_type, mt_policy>
 {
 public:
  _connection4()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection4(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone()
  {
   return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(*this);
  }

  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3,
                          arg4_type a4)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type,
                                      arg4_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class mt_policy>
 class _connection5 : public _connection_base5<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, mt_policy>
 {
 public:
  _connection5()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection5(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* clone()
  {
   return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, mt_policy>(*this);
  }

  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class mt_policy>
 class _connection6 : public _connection_base6<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, arg6_type, mt_policy>
 {
 public:
  _connection6()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection6(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* clone()
  {
   return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, mt_policy>(*this);
  }

  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5, arg6_type a6)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type, arg6_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _connection7 : public _connection_base7<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
 {
 public:
  _connection7()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection7(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type, arg6_type, arg7_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* clone()
  {
   return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, mt_policy>(*this);
  }

  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5, arg6_type a6, arg7_type a7)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type, arg6_type, arg7_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class arg7_type,
 class arg8_type, class mt_policy>
 class _connection8 : public _connection_base8<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
 {
 public:
  _connection8()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection8(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
                                                                    arg7_type, arg8_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone()
  {
   return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(*this);
  }

  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7, a8);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type, arg6_type, arg7_type, arg8_type);
 };

 template<class mt_policy = multi_threaded_local>
 class signal0 : public _signal_base0<mt_policy>
 {
 public:
        typedef std::list<_connection_base0<mt_policy> *> connections_list;
  signal0()
  {
   ;
  }

  signal0(const signal0<mt_policy>& s)
        : _signal_base0<mt_policy>(s)
  {
   ;
  }


  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)())
  {
   lock_block<mt_policy> lock(this);
   _connection0<desttype, mt_policy>* conn =
            new _connection0<desttype, mt_policy>(pclass, pmemfun);

   _signal_base0<mt_policy>::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = _signal_base0<mt_policy>::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = _signal_base0<mt_policy>::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit();

    it = itNext;
   }
  }

  void operator()()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = _signal_base0<mt_policy>::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = _signal_base0<mt_policy>::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit();

    it = itNext;
   }
  }

 };

 template<class arg1_type, class mt_policy = multi_threaded_local>
 class signal1 : public _signal_base1<arg1_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base1<arg1_type, mt_policy> *> connections_list;
        typedef _signal_base1<arg1_type, mt_policy> signal_base;
  signal1()
  {
   ;
  }

  signal1(const signal1<arg1_type, mt_policy>& s)
        : _signal_base1<arg1_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type))
  {
   lock_block<mt_policy> lock(this);
   _connection1<desttype, arg1_type, mt_policy>* conn =
            new _connection1<desttype, arg1_type, mt_policy>(pclass, pmemfun);
   signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1);

    it = itNext;
   }
  }

  void operator()(arg1_type a1)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class mt_policy = multi_threaded_local>
 class signal2 : public _signal_base2<arg1_type, arg2_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base2<arg1_type, arg2_type, mt_policy> *>
        connections_list;
        typedef _signal_base2<arg1_type, arg2_type, mt_policy> signal_base;
  signal2()
  {
   ;
  }

  signal2(const signal2<arg1_type, arg2_type, mt_policy>& s)
        : _signal_base2<arg1_type, arg2_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type))
  {
   lock_block<mt_policy> lock(this);
   _connection2<desttype, arg1_type, arg2_type, mt_policy>* conn = new
            _connection2<desttype, arg1_type, arg2_type, mt_policy>(pclass, pmemfun);
   signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy = multi_threaded_local>
 class signal3 : public _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base3<arg1_type, arg2_type, arg3_type, mt_policy> *>
        connections_list;
        typedef _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy> signal_base;
  signal3()
  {
   ;
  }

  ~signal3()
  {

  }

  signal3(const signal3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
        : _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type))
  {
   lock_block<mt_policy> lock(this);
   _connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>* conn =
            new _connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>(pclass,
                                                                                   pmemfun);
   signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy = multi_threaded_local>
 class signal4 : public _signal_base4<arg1_type, arg2_type, arg3_type,
    arg4_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base4<arg1_type, arg2_type, arg3_type,
        arg4_type, mt_policy> *> connections_list;
        typedef _signal_base4<arg1_type, arg2_type, arg3_type,
        arg4_type, mt_policy> signal_base;
  signal4()
  {
   ;
  }

  signal4(const signal4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
        : _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type))
  {
   lock_block<mt_policy> lock(this);
   _connection4<desttype, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>*
            conn = new _connection4<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy = multi_threaded_local>
 class signal5 : public _signal_base5<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base5<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, mt_policy> *> connections_list;
        typedef _signal_base5<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, mt_policy> signal_base;
  signal5()
  {
   ;
  }

  signal5(const signal5<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, mt_policy>& s)
        : _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type))
  {
   lock_block<mt_policy> lock(this);
   _connection5<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, mt_policy>* conn = new _connection5<desttype, arg1_type, arg2_type,
            arg3_type, arg4_type, arg5_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5);

    it = itNext;
   }
  }
 };


 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy = multi_threaded_local>
 class signal6 : public _signal_base6<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base6<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, mt_policy> *> connections_list;
        typedef _signal_base6<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, mt_policy> signal_base;
  signal6()
  {
   ;
  }

  signal6(const signal6<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, arg6_type, mt_policy>& s)
        : _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
  {
   lock_block<mt_policy> lock(this);
   _connection6<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, mt_policy>* conn =
            new _connection6<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, arg5_type, arg6_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5, arg6_type a6)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5, arg6_type a6)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy = multi_threaded_local>
 class signal7 : public _signal_base7<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base7<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> *> connections_list;
        typedef _signal_base7<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> signal_base;
  signal7()
  {
   ;
  }

  signal7(const signal7<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, arg6_type, arg7_type, mt_policy>& s)
        : _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
                                                                 arg7_type))
  {
   lock_block<mt_policy> lock(this);
   _connection7<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, mt_policy>* conn =
            new _connection7<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5, arg6_type a6, arg7_type a7)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5, arg6_type a6, arg7_type a7)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy = multi_threaded_local>
 class signal8 : public _signal_base8<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base8<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> *>
        connections_list;
        typedef _signal_base8<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> signal_base;
  signal8()
  {
   ;
  }

  signal8(const signal8<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
        : _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
                                                                 arg7_type, arg8_type))
  {
   lock_block<mt_policy> lock(this);
   _connection8<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* conn =
            new _connection8<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, arg5_type, arg6_type, arg7_type,
            arg8_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);

    it = itNext;
   }
  }
 };

};
# 57 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h"
# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/ObjectFactory.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/ObjectFactory.h"
namespace cocos2d
{
    namespace ui
    {
        class Widget;
    }
    namespace extension
    {
        class WidgetReaderProtocol;
    }
}


namespace cocos2d { namespace extension {

class ObjectFactory
{
public:
    typedef cocos2d::CCObject* (*Instance)(void);
    struct TInfo
    {
        TInfo(void);
        TInfo(const std::string& type, Instance ins = __null);
        TInfo(const TInfo &t);
        ~TInfo(void);
        TInfo& operator= (const TInfo &t);
        std::string _class;
        Instance _fun;
    };
    typedef std::map<std::string, TInfo> FactoryMap;
    ObjectFactory(void);
    virtual ~ObjectFactory(void);
    static ObjectFactory* getInstance();
    void destroyInstance();
    CCObject* createObject(std::string name);
 CCComponent* createComponent(std::string name);
    ui::Widget* createGUI(std::string name);
    WidgetReaderProtocol* createWidgetReaderProtocol(std::string name);
    void registerType(const TInfo &t);
    void removeAll();
private:
    static ObjectFactory *_sharedFactory;
    FactoryMap _typeMap;
};


}}
# 32 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerObj.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerObj.h"
namespace cocos2d { namespace extension {


class BaseTriggerCondition : public CCObject
{
protected:
    BaseTriggerCondition(void);
public:
 virtual ~BaseTriggerCondition(void);
    virtual bool init();
    virtual bool detect();
 virtual void serialize(const rapidjson::Value &val);
    virtual void removeAll();
};

class BaseTriggerAction : public CCObject
{
protected:
    BaseTriggerAction(void);
public:
 virtual ~BaseTriggerAction(void);
    virtual bool init();
    virtual void done();
 virtual void serialize(const rapidjson::Value &val);
    virtual void removeAll();
};


class TriggerObj : public CCObject
{
public:
    TriggerObj(void);
    virtual ~TriggerObj(void);
    virtual bool init();
    static TriggerObj* create(void);

    virtual bool detect();
    virtual void done();
    virtual void removeAll();
    virtual void serialize(const rapidjson::Value &val);
 unsigned int getId();
 void setEnable(bool bEnable);
 std::vector<int>& getEvents();

private:
    CCArray *_cons;
    CCArray *_acts;
 unsigned int _id;
 bool _bEnable;
 std::vector<int> _vInt;
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerMng.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerMng.h"
namespace cocos2d { namespace extension {

class TriggerObj;

class ArmatureMovementDispatcher : public CCObject
{
public:
 ArmatureMovementDispatcher(void);
 ~ArmatureMovementDispatcher(void);
public:
 void addAnimationEventCallBack(CCObject*pTarget, SEL_MovementEventCallFunc mecf);
 void removeAnnimationEventCallBack(CCObject*pTarget, SEL_MovementEventCallFunc mecf);
 void animationEvent(cocos2d::extension::CCArmature *armature, cocos2d::extension::MovementEventType movementType, const char *movementID);
 std::map<CCObject*, SEL_MovementEventCallFunc> *_mapEventAnimation;

};

class TriggerMng
{
public:
 TriggerMng(void);
 virtual ~TriggerMng(void);

public:
    static TriggerMng* getInstance();
    static const char* triggerMngVersion();
    void destroyInstance();

public:
 void parse(const rapidjson::Value &root);
 void removeAll(void);
 CCArray* get(unsigned int event) const;
 TriggerObj* getTriggerObj(unsigned int id) const;
    bool add(unsigned int event, TriggerObj *pObj);
    bool remove(unsigned int event);
 bool remove(unsigned int event, TriggerObj *pObj);
 bool removeTriggerObj(unsigned int id);
    bool isEmpty(void) const;
    void addArmatureMovementCallBack(CCArmature *pAr, CCObject *pTarget, SEL_MovementEventCallFunc mecf);
 void removeArmatureMovementCallBack(CCArmature *pAr, CCObject *pTarget, SEL_MovementEventCallFunc mecf);
 void removeArmatureAllMovementCallBack(CCArmature *pAr);
 void removeAllArmatureMovementCallBack();
private:
    void alloc(void);
private:
    CCDictionary *_eventTriggers;
    static TriggerMng *_sharedTriggerMng;
 CCDictionary *_triggerObjs;
 std::map<CCArmature*, ArmatureMovementDispatcher*> *_movementDispatches;
};

}}
# 34 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2

namespace cocos2d { namespace extension {
# 50 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h"
void sendEvent(unsigned int event);

}}
# 59 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComBase.h" 1
# 61 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAttribute.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAttribute.h"
namespace cocos2d { namespace extension {



class CCComAttribute : public cocos2d::CCComponent
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
protected:



    CCComAttribute(void);



    virtual ~CCComAttribute(void);

public:
   virtual bool init();
   static CCComAttribute* create(void);
   virtual bool serialize(void* r);

   void setInt(const char *key, int value);
   void setFloat(const char *key, float value);
   void setBool(const char *key, bool value);
   void setCString(const char *key, const char *value);

   int getInt(const char *key, int def = 0) const;
   float getFloat(const char *key, float def = 0.0f) const;
   bool getBool(const char *key, bool def = false) const;
   const char* getCString(const char *key, const char *def = __null) const;

   bool parse(const std::string &jsonPath);
private:
   cocos2d::CCDictionary *_dict;
   rapidjson::Document _doc;
};

}}
# 62 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAudio.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAudio.h"
namespace cocos2d { namespace extension {



class CCComAudio : public cocos2d::CCComponent
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
protected:
    CCComAudio(void);
    virtual ~CCComAudio(void);

public:
   virtual bool init();
   virtual void onEnter();
   virtual void onExit();
   virtual bool isEnabled() const;
   virtual void setEnabled(bool b);
   virtual bool serialize(void* r);

   static CCComAudio* create(void);

public:
   void end();
   void preloadBackgroundMusic(const char* pszFilePath);
   void playBackgroundMusic(const char* pszFilePath, bool bLoop);
   void playBackgroundMusic(const char* pszFilePath);
   void playBackgroundMusic();
   void stopBackgroundMusic(bool bReleaseData);
   void stopBackgroundMusic();
   void pauseBackgroundMusic();
   void resumeBackgroundMusic();
   void rewindBackgroundMusic();
   bool willPlayBackgroundMusic();
   bool isBackgroundMusicPlaying();
   float getBackgroundMusicVolume();
   void setBackgroundMusicVolume(float volume);
   float getEffectsVolume();
   void setEffectsVolume(float volume);
   unsigned int playEffect(const char* pszFilePath, bool bLoop);
   unsigned int playEffect(const char* pszFilePath);
   unsigned int playEffect();
   void pauseEffect(unsigned int nSoundId);
   void pauseAllEffects();
   void resumeEffect(unsigned int nSoundId);
   void resumeAllEffects();
   void stopEffect(unsigned int nSoundId);
   void stopAllEffects();
   void preloadEffect(const char* pszFilePath);
   void unloadEffect(const char* pszFilePath);
   void setFile(const char* pszFilePath);
   const char* getFile();
   void setLoop(bool bLoop);
   bool isLoop();
private:
   std::string m_strFilePath;
   bool m_bLoop;
};

}}
# 63 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComController.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Components/CCComController.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCInputDelegate.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/Components/CCInputDelegate.h"
namespace cocos2d { namespace extension {



class CCInputDelegate : public CCTouchDelegate, public CCAccelerometerDelegate, public CCKeypadDelegate
{
protected:
    CCInputDelegate(void);
    virtual ~CCInputDelegate(void);

public:
    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

    virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent);



    virtual void didAccelerate(CCAcceleration* pAccelerationValue);
public:
    virtual bool isTouchEnabled();
    virtual void setTouchEnabled(bool value);

    virtual bool isAccelerometerEnabled();
    virtual void setAccelerometerEnabled(bool value);

    virtual bool isKeypadEnabled();
    virtual void setKeypadEnabled(bool value);

    virtual void setTouchMode(ccTouchesMode mode);
    virtual int getTouchMode();

    virtual void setTouchPriority(int priority);
    virtual int getTouchPriority();

protected:
    bool m_bTouchEnabled;
    bool m_bAccelerometerEnabled;
    bool m_bKeypadEnabled;

private:
     int m_nTouchPriority;
     ccTouchesMode m_eTouchMode;
};

}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComController.h" 2

namespace cocos2d { namespace extension {



class CCComController : public cocos2d::CCComponent, public CCInputDelegate
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
public:



   CCComController(void);



   virtual ~CCComController(void);
   virtual bool init();
   virtual void onEnter();
   virtual void onExit();
   virtual void update(float delta);
   virtual bool isEnabled() const;
   virtual void setEnabled(bool b);

   static CCComController* create(void);
};

}}
# 64 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComRender.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComRender.h"
namespace cocos2d { namespace extension {




class CCComRender : public cocos2d::CCComponent
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
public:



    CCComRender(void);
    CCComRender(cocos2d::CCNode *node, const char *comName);



    virtual ~CCComRender(void);

public:
   virtual void onEnter();
   virtual void onExit();
   virtual bool serialize(void* r);
   virtual cocos2d::CCNode* getNode();
   virtual void setNode(cocos2d::CCNode *pNode);

   static CCComRender* create(cocos2d::CCNode *pNode, const char *comName);
   static CCComRender* create(void);
private:
   bool readJson(const char *pszFileName, rapidjson::Document &doc);
private:
   cocos2d::CCNode *m_pRender;
};

}}
# 65 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutDefine.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutDefine.h"
namespace cocos2d {

namespace ui {




class Margin
{
public:
    float left;
    float top;
    float right;
    float bottom;

public:
    Margin();
    Margin(float l, float t, float r, float b);
    Margin(const Margin& other);
    Margin& operator= (const Margin& other);
    void setMargin(float l, float t, float r, float b);
    bool equals(const Margin& target) const;
};

const Margin MarginZero = Margin();

typedef enum
{
    LINEAR_GRAVITY_NONE,
    LINEAR_GRAVITY_LEFT,
    LINEAR_GRAVITY_TOP,
    LINEAR_GRAVITY_RIGHT,
    LINEAR_GRAVITY_BOTTOM,
    LINEAR_GRAVITY_CENTER_VERTICAL,
    LINEAR_GRAVITY_CENTER_HORIZONTAL
}LinearGravity;

typedef enum
{
    RELATIVE_ALIGN_NONE,
    RELATIVE_ALIGN_PARENT_TOP_LEFT,
    RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL,
    RELATIVE_ALIGN_PARENT_TOP_RIGHT,
    RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL,
    RELATIVE_CENTER_IN_PARENT,
    RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL,
    RELATIVE_ALIGN_PARENT_LEFT_BOTTOM,
    RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL,
    RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM,

    RELATIVE_LOCATION_ABOVE_LEFTALIGN,
    RELATIVE_LOCATION_ABOVE_CENTER,
    RELATIVE_LOCATION_ABOVE_RIGHTALIGN,
    RELATIVE_LOCATION_LEFT_OF_TOPALIGN,
    RELATIVE_LOCATION_LEFT_OF_CENTER,
    RELATIVE_LOCATION_LEFT_OF_BOTTOMALIGN,
    RELATIVE_LOCATION_RIGHT_OF_TOPALIGN,
    RELATIVE_LOCATION_RIGHT_OF_CENTER,
    RELATIVE_LOCATION_RIGHT_OF_BOTTOMALIGN,
    RELATIVE_LOCATION_BELOW_LEFTALIGN,
    RELATIVE_LOCATION_BELOW_CENTER,
    RELATIVE_LOCATION_BELOW_RIGHTALIGN
}RelativeAlign;

}
}
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    LAYOUT_PARAMETER_NONE,
    LAYOUT_PARAMETER_LINEAR,
    LAYOUT_PARAMETER_RELATIVE
}LayoutParameterType;




class LayoutParameter : public CCObject
{
public:



    LayoutParameter() : _margin(Margin()){_layoutParameterType = LAYOUT_PARAMETER_NONE;};




    virtual ~LayoutParameter(){};





    static LayoutParameter* create();
# 70 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    void setMargin(const Margin& margin);
# 79 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    const Margin& getMargin() const;
# 88 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    LayoutParameterType getLayoutType() const;

    LayoutParameter* clone();
    virtual LayoutParameter* createCloneInstance();
    virtual void copyProperties(LayoutParameter* model);
protected:
    Margin _margin;
    LayoutParameterType _layoutParameterType;
};




class LinearLayoutParameter : public LayoutParameter
{
public:



    LinearLayoutParameter() : _linearGravity(LINEAR_GRAVITY_NONE){_layoutParameterType = LAYOUT_PARAMETER_LINEAR;};




    virtual ~LinearLayoutParameter(){};





    static LinearLayoutParameter* create();
# 127 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    void setGravity(LinearGravity gravity);
# 136 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    LinearGravity getGravity() const;
    virtual LayoutParameter* createCloneInstance();
    virtual void copyProperties(LayoutParameter* model);
protected:
    LinearGravity _linearGravity;
};





class RelativeLayoutParameter : public LayoutParameter
{
public:



    RelativeLayoutParameter() : _relativeAlign(RELATIVE_ALIGN_NONE),_relativeWidgetName(""),_relativeLayoutName(""),_put(false){_layoutParameterType = LAYOUT_PARAMETER_RELATIVE;};




    virtual ~RelativeLayoutParameter(){};





    static RelativeLayoutParameter* create();
# 173 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    void setAlign(RelativeAlign align);
# 182 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    RelativeAlign getAlign() const;






    void setRelativeToWidgetName(const char* name);






    const char* getRelativeToWidgetName() const;






    void setRelativeName(const char* name);






    const char* getRelativeName() const;

    virtual LayoutParameter* createCloneInstance();
    virtual void copyProperties(LayoutParameter* model);
protected:
    RelativeAlign _relativeAlign;
    std::string _relativeWidgetName;
    std::string _relativeLayoutName;
    bool _put;
    friend class Layout;
};

}

}
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../System/GUIDefine.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 2

namespace cocos2d {

namespace ui {

typedef enum
{
    BRIGHT_NONE = -1,
    BRIGHT_NORMAL,
    BRIGHT_HIGHLIGHT
}BrightStyle;

typedef enum
{
    WidgetTypeWidget,
    WidgetTypeContainer
}WidgetType;

typedef enum
{
    UI_TEX_TYPE_LOCAL,
    UI_TEX_TYPE_PLIST
}TextureResType;

typedef enum
{
    TOUCH_EVENT_BEGAN,
    TOUCH_EVENT_MOVED,
    TOUCH_EVENT_ENDED,
    TOUCH_EVENT_CANCELED
}TouchEventType;

typedef enum
{
    SIZE_ABSOLUTE,
    SIZE_PERCENT
}SizeType;

typedef enum
{
    POSITION_ABSOLUTE,
    POSITION_PERCENT
}PositionType;

typedef void (CCObject::*SEL_TouchEvent)(CCObject*,TouchEventType);





class Widget : public CCNode
{
public:



    Widget(void);




    virtual ~Widget();




    static Widget* create();
# 108 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void setEnabled(bool enabled);






    bool isEnabled() const;
# 124 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setBright(bool bright);






    bool isBright() const;
# 140 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void setTouchEnabled(bool enabled);
# 149 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setBrightStyle(BrightStyle style);






    bool isTouchEnabled() const;






    bool isFocused() const;
# 172 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setFocused(bool fucosed);






    float getLeftInParent();






    float getBottomInParent();






    float getRightInParent();






    float getTopInParent();
# 209 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void addChild(CCNode * child);
# 218 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void addChild(CCNode * child, int zOrder);
# 228 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);







    virtual CCNode * getChildByTag(int tag);

    virtual void sortAllChildren();
# 255 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual CCArray* getChildren();






    virtual unsigned int getChildrenCount() const;






    virtual void removeFromParent();







    virtual void removeFromParentAndCleanup(bool cleanup);

    virtual void removeChild(CCNode* child);







    virtual void removeChild(CCNode* child, bool cleanup);







    virtual void removeChildByTag(int tag, bool cleanup);





    virtual void removeAllChildren();







    virtual void removeAllChildrenWithCleanup(bool cleanup);
# 318 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual Widget* getChildByName(const char* name);

    virtual void addNode(CCNode* node);

    virtual void addNode(CCNode * node, int zOrder);

    virtual void addNode(CCNode* node, int zOrder, int tag);

    virtual CCNode * getNodeByTag(int tag);

    virtual CCArray* getNodes();

    virtual void removeNode(CCNode* node);

    virtual void removeNodeByTag(int tag);

    virtual void removeAllNodes();

    virtual void visit();




    void addTouchEventListener(CCObject* target,SEL_TouchEvent selector);
# 354 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setPosition(const CCPoint &pos);
# 364 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setPositionPercent(const CCPoint &percent);
# 373 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    const CCPoint& getPositionPercent();
# 382 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setPositionType(PositionType type);
# 391 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    PositionType getPositionType() const;






    virtual void setFlipX(bool flipX);
# 410 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual bool isFlipX(){return _flippedX;};






    virtual void setFlipY(bool flipY);
# 429 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual bool isFlipY(){return _flippedY;};

    virtual void setColor(const ccColor3B& color);

    virtual void setOpacity(GLubyte opacity);

    const ccColor3B& getColor(){return _color;};

    GLubyte getOpacity(){return _opacity;};




    void didNotSelectSelf();
# 451 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    bool clippingParentAreaContainPoint(const CCPoint &pt);




    virtual void checkChildInfo(int handleState,Widget* sender,const CCPoint &touchPoint);






    const CCPoint& getTouchStartPos();






    const CCPoint& getTouchMovePos();






    const CCPoint& getTouchEndPos();






    void setName(const char* name);
# 493 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    const char* getName() const;
# 502 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    WidgetType getWidgetType() const;






    virtual void setSize(const CCSize &size);






    virtual void setSizePercent(const CCPoint &percent);
# 525 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setSizeType(SizeType type);
# 534 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    SizeType getSizeType() const;






    const CCSize& getSize() const;

    virtual const CCSize& getLayoutSize() {return _size;};






    const CCPoint& getSizePercent() const;

    const CCSize& getCustomSize() const;
# 561 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual bool hitTest(const CCPoint &pt);

    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unused_event);
# 577 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setLayoutParameter(LayoutParameter* parameter);
# 588 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    LayoutParameter* getLayoutParameter(LayoutParameterType type);






    virtual void ignoreContentAdaptWithSize(bool ignore);






    bool isIgnoreContentAdaptWithSize() const;






    CCPoint getWorldPosition();
# 618 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual CCNode* getVirtualRenderer();






    virtual const CCSize& getContentSize() const;




    virtual std::string getDescription() const;

    Widget* clone();

    virtual void onEnter();
    virtual void onExit();

    void updateSizeAndPosition();

    void updateSizeAndPosition(const CCSize& parentSize);


    void setActionTag(int tag);
 int getActionTag();
protected:

    virtual void onSizeChanged();


    virtual bool init();


    virtual void initRenderer(){};


    virtual void onPressStateChangedToNormal();


    virtual void onPressStateChangedToPressed();


    virtual void onPressStateChangedToDisabled();
    void pushDownEvent();
    void moveEvent();
    void releaseUpEvent();
    void cancelUpEvent();
    void updateAnchorPoint();
    virtual void updateTextureColor(){};
    virtual void updateTextureOpacity(){};
    virtual void updateTextureRGBA(){};
    virtual void updateFlippedX(){};
    virtual void updateFlippedY(){};
    void updateColorToRenderer(CCNode* renderer);
    void updateOpacityToRenderer(CCNode* renderer);
    void updateRGBAToRenderer(CCNode* renderer);
    void copyProperties(Widget* model);
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    Widget* getWidgetParent();
protected:
    bool _enabled;
    bool _bright;
    bool _touchEnabled;
    bool _touchPassedEnabled;
    bool _focus;
    BrightStyle _brightStyle;
    CCPoint _touchStartPos;
    CCPoint _touchMovePos;
    CCPoint _touchEndPos;

    CCObject* _touchEventListener;
    SEL_TouchEvent _touchEventSelector;



    std::string _name;
    WidgetType _widgetType;
 int _actionTag;
    CCSize _size;
    CCSize _customSize;
    bool _ignoreSize;
    bool _affectByClipping;
    SizeType _sizeType;
    CCPoint _sizePercent;
    PositionType _positionType;
    CCPoint _positionPercent;
    bool _reorderWidgetChildDirty;
    bool _hitted;
    CCArray* _widgetChildren;
    CCDictionary* _layoutParameterDictionary;

    CCArray* _nodes;

    ccColor3B _color;
    GLubyte _opacity;

    bool _flippedX;
    bool _flippedY;

    friend class TouchGroup;
};
}

namespace gui = ui;

}
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    LAYOUT_COLOR_NONE,
    LAYOUT_COLOR_SOLID,
    LAYOUT_COLOR_GRADIENT
}LayoutBackGroundColorType;

typedef enum
{
    LAYOUT_ABSOLUTE,
    LAYOUT_LINEAR_VERTICAL,
    LAYOUT_LINEAR_HORIZONTAL,
    LAYOUT_RELATIVE
}LayoutType;

typedef enum {
    LAYOUT_CLIPPING_STENCIL,
    LAYOUT_CLIPPING_SCISSOR
}LayoutClippingType;





class Layout : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Layout();




    virtual ~Layout();




    static Layout* create();
# 87 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    void setBackGroundImage(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);







    void setBackGroundImageCapInsets(const CCRect& capInsets);

    const CCRect& getBackGroundImageCapInsets();






    void setBackGroundColorType(LayoutBackGroundColorType type);

    LayoutBackGroundColorType getBackGroundColorType();






    void setBackGroundImageScale9Enabled(bool enabled);

    bool isBackGroundImageScale9Enabled();






    void setBackGroundColor(const ccColor3B &color);

    const ccColor3B& getBackGroundColor();
# 133 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    void setBackGroundColor(const ccColor3B &startColor, const ccColor3B &endColor);

    const ccColor3B& getBackGroundStartColor();

    const ccColor3B& getBackGroundEndColor();






    void setBackGroundColorOpacity(GLubyte opacity);

    GLubyte getBackGroundColorOpacity();






    void setBackGroundColorVector(const CCPoint &vector);

    const CCPoint& getBackGroundColorVector();

    void setBackGroundImageColor(const ccColor3B& color);

    void setBackGroundImageOpacity(GLubyte opacity);

    const ccColor3B& getBackGroundImageColor();

    GLubyte getBackGroundImageOpacity();




    void removeBackGroundImage();






    const CCSize& getBackGroundImageTextureSize() const;
# 184 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void setClippingEnabled(bool enabled);

    void setClippingType(LayoutClippingType type);

    LayoutClippingType getClippingType();






    virtual bool isClippingEnabled();




    virtual std::string getDescription() const;
# 209 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void setLayoutType(LayoutType type);
# 218 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual LayoutType getLayoutType() const;

    virtual void addChild(CCNode * child);
# 229 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void addChild(CCNode * child, int zOrder);
# 239 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);

    virtual void removeChild(CCNode* child);

    virtual void removeChild(CCNode* widget, bool cleanup);

    virtual void removeAllChildren();

    virtual void removeAllChildrenWithCleanup(bool cleanup);

    virtual void visit();

    virtual void sortAllChildren();

    void requestDoLayout();

    virtual void onEnter();
    virtual void onExit();

    virtual bool hitTest(const CCPoint &pt);
protected:

    virtual bool init();


    virtual void onSizeChanged();


    void addBackGroundImage();

    void supplyTheLayoutParameterLackToChild(Widget* child);
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);

    void stencilClippingVisit();
    void scissorClippingVisit();

    void setStencilClippingSize(const CCSize& size);
    const CCRect& getClippingRect();
    virtual void doLayout();
    void updateBackGroundImageColor();
    void updateBackGroundImageOpacity();
    void updateBackGroundImageRGBA();
protected:
    bool _clippingEnabled;


    bool _backGroundScale9Enabled;
    CCNode* _backGroundImage;
    std::string _backGroundImageFileName;
    CCRect _backGroundImageCapInsets;
    LayoutBackGroundColorType _colorType;
    TextureResType _bgImageTexType;
    CCLayerColor* _colorRender;
    CCLayerGradient* _gradientRender;
    ccColor3B _cColor;
    ccColor3B _gStartColor;
    ccColor3B _gEndColor;
    CCPoint _alongVector;
    GLubyte _cOpacity;
    CCSize _backGroundImageTextureSize;
    LayoutType _layoutType;
    LayoutClippingType _clippingType;
    CCDrawNode* _clippingStencil;
    bool _handleScissor;
    bool _scissorRectDirty;
    CCRect _clippingRect;
    Layout* _clippingParent;
    bool _doLayoutDirty;
    bool _clippingRectDirty;
    ccColor3B _backGroundImageColor;
    GLubyte _backGroundImageOpacity;
};

}
}
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
namespace cocos2d {

namespace ui{





class Button : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Button();




    virtual ~Button();




    static Button* create();
# 69 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTextures(const char* normal,const char* selected,const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 78 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTextureNormal(const char* normal, TextureResType texType = UI_TEX_TYPE_LOCAL);
# 87 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTexturePressed(const char* selected, TextureResType texType = UI_TEX_TYPE_LOCAL);
# 96 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTextureDisabled(const char* disabled, TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setCapInsets(const CCRect &capInsets);






    void setCapInsetsNormalRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetNormalRenderer();






    void setCapInsetsPressedRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetPressedRenderer();






    void setCapInsetsDisabledRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetDisabledRenderer();


    virtual void setAnchorPoint(const CCPoint &pt);






    virtual void setScale9Enabled(bool able);

    bool isScale9Enabled();






    void setPressedActionEnabled(bool enabled);


    virtual void ignoreContentAdaptWithSize(bool ignore);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

    void setTitleText(const std::string& text);
    const char* getTitleText() const;
    void setTitleColor(const ccColor3B& color);
    const ccColor3B& getTitleColor() const;
    void setTitleFontSize(float size);
    float getTitleFontSize() const;
    void setTitleFontName(const char* fontName);
    const char* getTitleFontName() const;

protected:
    virtual bool init();
    virtual void initRenderer();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void normalTextureScaleChangedWithSize();
    void pressedTextureScaleChangedWithSize();
    void disabledTextureScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    CCNode* _buttonNormalRenderer;
    CCNode* _buttonClickedRenderer;
    CCNode* _buttonDisableRenderer;
    CCLabelTTF* _titleRenderer;
    std::string _normalFileName;
    std::string _clickedFileName;
    std::string _disabledFileName;
    bool _prevIgnoreSize;
    bool _scale9Enabled;
    CCRect _capInsetsNormal;
    CCRect _capInsetsPressed;
    CCRect _capInsetsDisabled;
    TextureResType _normalTexType;
    TextureResType _pressedTexType;
    TextureResType _disabledTexType;
    CCSize _normalTextureSize;
    CCSize _pressedTextureSize;
    CCSize _disabledTextureSize;
    bool _pressedActionEnabled;
    ccColor3B _titleColor;
    float _normalTextureScaleXInSize;
    float _normalTextureScaleYInSize;
    float _pressedTextureScaleXInSize;
    float _pressedTextureScaleYInSize;
    bool _normalTextureLoaded;
    bool _pressedTextureLoaded;
    bool _disabledTextureLoaded;
};

}

}
# 32 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    CHECKBOX_STATE_EVENT_SELECTED,
    CHECKBOX_STATE_EVENT_UNSELECTED
}CheckBoxEventType;

typedef void (CCObject::*SEL_SelectedStateEvent)(CCObject*,CheckBoxEventType);






class CheckBox : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    CheckBox();




    virtual ~CheckBox();




    static CheckBox* create();
# 80 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextures(const char* backGround,const char* backGroundSelected,const char* cross,const char* backGroundDisabled,const char* frontCrossDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 89 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureBackGround(const char* backGround,TextureResType type = UI_TEX_TYPE_LOCAL);
# 98 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureBackGroundSelected(const char* backGroundSelected,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 107 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureFrontCross(const char* cross,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 116 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureBackGroundDisabled(const char* backGroundDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 125 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureFrontCrossDisabled(const char* frontCrossDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setSelectedState(bool selected);






    bool getSelectedState();


    virtual void setAnchorPoint(const CCPoint &pt);


    void addEventListenerCheckBox(CCObject* target,SEL_SelectedStateEvent selector);


    virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

protected:
    virtual bool init();
    virtual void initRenderer();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    void selectedEvent();
    void unSelectedEvent();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void backGroundTextureScaleChangedWithSize();
    void backGroundSelectedTextureScaleChangedWithSize();
    void frontCrossTextureScaleChangedWithSize();
    void backGroundDisabledTextureScaleChangedWithSize();
    void frontCrossDisabledTextureScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    CCSprite* _backGroundBoxRenderer;
    CCSprite* _backGroundSelectedBoxRenderer;
    CCSprite* _frontCrossRenderer;
    CCSprite* _backGroundBoxDisabledRenderer;
    CCSprite* _frontCrossDisabledRenderer;
    bool _isSelected;

    CCObject* _checkBoxEventListener;
    SEL_SelectedStateEvent _checkBoxEventSelector;

    TextureResType _backGroundTexType;
    TextureResType _backGroundSelectedTexType;
    TextureResType _frontCrossTexType;
    TextureResType _backGroundDisabledTexType;
    TextureResType _frontCrossDisabledTexType;

    std::string _backGroundFileName;
    std::string _backGroundSelectedFileName;
    std::string _frontCrossFileName;
    std::string _backGroundDisabledFileName;
    std::string _frontCrossDisabledFileName;
};

}

}
# 33 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIImageView.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIImageView.h"
namespace cocos2d {

namespace ui {





class ImageView : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    ImageView();




    virtual ~ImageView();




    static ImageView* create();
# 65 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIImageView.h"
    void loadTexture(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);





    void setTextureRect(const CCRect& rect);






    void setScale9Enabled(bool able);

    bool isScale9Enabled();






    void setCapInsets(const CCRect &capInsets);

    const CCRect& getCapInsets();


    virtual void setAnchorPoint(const CCPoint &pt);


    virtual void ignoreContentAdaptWithSize(bool ignore);




    virtual std::string getDescription() const;

    virtual const CCSize& getContentSize() const;
    virtual CCNode* getVirtualRenderer();
protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void imageTextureScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    bool _scale9Enabled;
    bool _prevIgnoreSize;
    CCRect _capInsets;
    CCNode* _imageRenderer;
    std::string _textureFile;
    TextureResType _imageTexType;
    CCSize _imageTextureSize;
};

}

}
# 34 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabel.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabel.h"
namespace cocos2d {

namespace ui {





class Label : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Label();




    virtual ~Label();




    static Label* create();






    void setText(const std::string& text);






    const char* getStringValue();






    int getStringLength();






    void setFontSize(int size);

    int getFontSize();






    void setFontName(const std::string& name);

    const char* getFontName();





    void setTouchScaleChangeEnabled(bool enabled);






    bool isTouchScaleChangeEnabled();


    virtual void setAnchorPoint(const CCPoint &pt);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

    void setTextAreaSize(const CCSize &size);

    CCSize getTextAreaSize();

    void setTextHorizontalAlignment(CCTextAlignment alignment);

    CCTextAlignment getTextHorizontalAlignment();

    void setTextVerticalAlignment(CCVerticalTextAlignment alignment);

    CCVerticalTextAlignment getTextVerticalAlignment();
protected:
    virtual bool init();
    virtual void initRenderer();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void labelScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    bool _touchScaleChangeEnabled;
    float _normalScaleValueX;
    float _normalScaleValueY;
    std::string _fontName;
    int _fontSize;
    float _onSelectedScaleOffset;
    CCLabelTTF* _labelRenderer;
};

}

}
# 35 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelAtlas.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelAtlas.h"
namespace cocos2d {

namespace ui {





class UICCLabelAtlas : public CCLabelAtlas
{
public:



    UICCLabelAtlas();




    virtual ~UICCLabelAtlas();




    static UICCLabelAtlas* create();
    void setProperty(const std::string& string, const std::string& charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
    void setProperty(const std::string& string, CCTexture2D *texture, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
    virtual void updateDisplayedOpacity(GLubyte opacity);
    virtual void draw(void);
};




class LabelAtlas : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    LabelAtlas();




    virtual ~LabelAtlas();




    static LabelAtlas* create();


    void setProperty(const std::string& stringValue,const std::string& charMapFile, int itemWidth, int itemHeight, const std::string& startCharMap);


    void setStringValue(const std::string& value);


    const char* getStringValue() const;


    virtual void setAnchorPoint(const CCPoint &pt);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void labelAtlasScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    UICCLabelAtlas* _labelAtlasRenderer;
    std::string _stringValue;
    std::string _charMapFileName;
    int _itemWidth;
    int _itemHeight;
    std::string _startCharMap;
};

}
}
# 36 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    LoadingBarTypeLeft,
    LoadingBarTypeRight
}LoadingBarType;




class LoadingBar : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    LoadingBar();




    virtual ~LoadingBar();




    static LoadingBar* create();
# 71 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
    void setDirection(LoadingBarType dir);
# 80 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
    int getDirection();
# 89 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
    void loadTexture(const char* texture,TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setPercent(int percent);






    int getPercent();






    void setScale9Enabled(bool enabled);

    bool isScale9Enabled();






    void setCapInsets(const CCRect &capInsets);

    const CCRect& getCapInsets();


    virtual void ignoreContentAdaptWithSize(bool ignore);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;
protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void setScale9Scale();
    void barRendererScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    LoadingBarType _barType;
    int _percent;
    float _totalLength;
    CCNode* _barRenderer;
    TextureResType _renderBarTexType;
    CCSize _barRendererTextureSize;
    bool _scale9Enabled;
    bool _prevIgnoreSize;
    CCRect _capInsets;
    std::string _textureFile;
};

}
}
# 37 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollInterface.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollInterface.h"
namespace cocos2d {

namespace ui {

class UIScrollInterface
{
public:
    virtual ~UIScrollInterface() {}

protected:
    virtual void handlePressLogic(const CCPoint &touchPoint) = 0;
    virtual void handleMoveLogic(const CCPoint &touchPoint) = 0;
    virtual void handleReleaseLogic(const CCPoint &touchPoint) = 0;
    virtual void interceptTouchEvent(int handleState, Widget* sender, const CCPoint &touchPoint) = 0;
};

}
}
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h" 2

namespace cocos2d {

namespace ui {

class ScrollInnerContainer : public Layout
{
public:
    ScrollInnerContainer();
    virtual ~ScrollInnerContainer();
    static ScrollInnerContainer* create();
    virtual const CCSize& getLayoutSize();
protected:
};

enum SCROLLVIEW_DIR
{
    SCROLLVIEW_DIR_NONE,
    SCROLLVIEW_DIR_VERTICAL,
    SCROLLVIEW_DIR_HORIZONTAL,
    SCROLLVIEW_DIR_BOTH
};

typedef enum
{
    SCROLLVIEW_EVENT_SCROLL_TO_TOP,
    SCROLLVIEW_EVENT_SCROLL_TO_BOTTOM,
    SCROLLVIEW_EVENT_SCROLL_TO_LEFT,
    SCROLLVIEW_EVENT_SCROLL_TO_RIGHT,
    SCROLLVIEW_EVENT_SCROLLING,
    SCROLLVIEW_EVENT_BOUNCE_TOP,
    SCROLLVIEW_EVENT_BOUNCE_BOTTOM,
    SCROLLVIEW_EVENT_BOUNCE_LEFT,
    SCROLLVIEW_EVENT_BOUNCE_RIGHT
}ScrollviewEventType;

typedef void (CCObject::*SEL_ScrollViewEvent)(CCObject*, ScrollviewEventType);



class ScrollView : public Layout , public UIScrollInterface
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    ScrollView();




    virtual ~ScrollView();




    static ScrollView* create();
# 98 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void setDirection(SCROLLVIEW_DIR dir);
# 107 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    SCROLLVIEW_DIR getDirection();
# 116 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    Layout* getInnerContainer();




    void scrollToBottom(float time, bool attenuated);




    void scrollToTop(float time, bool attenuated);




    void scrollToLeft(float time, bool attenuated);




    void scrollToRight(float time, bool attenuated);




    void scrollToTopLeft(float time, bool attenuated);




    void scrollToTopRight(float time, bool attenuated);




    void scrollToBottomLeft(float time, bool attenuated);




    void scrollToBottomRight(float time, bool attenuated);




    void scrollToPercentVertical(float percent, float time, bool attenuated);




    void scrollToPercentHorizontal(float percent, float time, bool attenuated);




    void scrollToPercentBothDirection(const CCPoint& percent, float time, bool attenuated);




    void jumpToBottom();




    void jumpToTop();




    void jumpToLeft();




    void jumpToRight();




    void jumpToTopLeft();




    void jumpToTopRight();




    void jumpToBottomLeft();




    void jumpToBottomRight();




    void jumpToPercentVertical(float percent);




    void jumpToPercentHorizontal(float percent);




    void jumpToPercentBothDirection(const CCPoint& percent);
# 235 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    void setInnerContainerSize(const CCSize &size);
# 244 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
 const CCSize& getInnerContainerSize() const;




    void addEventListenerScrollView(CCObject* target, SEL_ScrollViewEvent selector);

    virtual void addChild(CCNode * child);
# 260 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void addChild(CCNode * child, int zOrder);
# 270 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);


    virtual void removeAllChildren();

    virtual void removeAllChildrenWithCleanup(bool cleanup);

    virtual void removeChild(CCNode* child);


 virtual void removeChild(CCNode* child, bool cleaup);


    virtual CCArray* getChildren();

    virtual unsigned int getChildrenCount() const;

    virtual CCNode * getChildByTag(int tag);

    virtual Widget* getChildByName(const char* name);

    virtual void addNode(CCNode* node);

    virtual void addNode(CCNode * node, int zOrder);

    virtual void addNode(CCNode* node, int zOrder, int tag);

    virtual CCNode * getNodeByTag(int tag);

    virtual void removeNodeByTag(int tag);

    virtual CCArray* getNodes();

    virtual void removeNode(CCNode* node);

    virtual void removeAllNodes();


    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unusedEvent);

    virtual void update(float dt);

    void setBounceEnabled(bool enabled);

    bool isBounceEnabled() const;

    void setInertiaScrollEnabled(bool enabled);

    bool isInertiaScrollEnabled() const;
# 330 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void setLayoutType(LayoutType type);
# 339 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual LayoutType getLayoutType() const;




    virtual std::string getDescription() const;

    virtual void onEnter();
protected:
    virtual bool init();
    virtual void initRenderer();
    void moveChildren(float offsetX, float offsetY);
    void autoScrollChildren(float dt);
    void bounceChildren(float dt);
    void checkBounceBoundary();
    bool checkNeedBounce();
    void startAutoScrollChildrenWithOriginalSpeed(const CCPoint& dir, float v, bool attenuated, float acceleration);
    void startAutoScrollChildrenWithDestination(const CCPoint& des, float time, bool attenuated);
    void jumpToDestination(const CCPoint& des);
    void stopAutoScrollChildren();
    void startBounceChildren(float v);
    void stopBounceChildren();
    bool checkCustomScrollDestination(float* touchOffsetX, float* touchOffsetY);
    virtual bool scrollChildren(float touchOffsetX, float touchOffsetY);
    bool bounceScrollChildren(float touchOffsetX, float touchOffsetY);
    void startRecordSlidAction();
    virtual void endRecordSlidAction();
    virtual void handlePressLogic(const CCPoint &touchPoint);
    virtual void handleMoveLogic(const CCPoint &touchPoint);
    virtual void handleReleaseLogic(const CCPoint &touchPoint);
    virtual void interceptTouchEvent(int handleState,Widget* sender,const CCPoint &touchPoint);
    virtual void checkChildInfo(int handleState,Widget* sender,const CCPoint &touchPoint);
    void recordSlidTime(float dt);
    void scrollToTopEvent();
    void scrollToBottomEvent();
    void scrollToLeftEvent();
    void scrollToRightEvent();
    void scrollingEvent();
    void bounceTopEvent();
    void bounceBottomEvent();
    void bounceLeftEvent();
    void bounceRightEvent();
    virtual void onSizeChanged();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    virtual void setClippingEnabled(bool able) {Layout::setClippingEnabled(able);};
    virtual void doLayout();
protected:
    ScrollInnerContainer* _innerContainer;

    SCROLLVIEW_DIR _direction;

    CCPoint _touchBeganPoint;
    CCPoint _touchMovedPoint;
    CCPoint _touchEndedPoint;
    CCPoint _touchMovingPoint;
    CCPoint _autoScrollDir;

    float _topBoundary;
    float _bottomBoundary;
    float _leftBoundary;
    float _rightBoundary;

    float _bounceTopBoundary;
    float _bounceBottomBoundary;
    float _bounceLeftBoundary;
    float _bounceRightBoundary;


    bool _autoScroll;
    float _autoScrollAddUpTime;

    float _autoScrollOriginalSpeed;
    float _autoScrollAcceleration;
    bool _isAutoScrollSpeedAttenuated;
    bool _needCheckAutoScrollDestination;
    CCPoint _autoScrollDestination;

    bool _bePressed;
    float _slidTime;
    CCPoint _moveChildPoint;
    float _childFocusCancelOffset;

    bool _leftBounceNeeded;
    bool _topBounceNeeded;
    bool _rightBounceNeeded;
    bool _bottomBounceNeeded;

    bool _bounceEnabled;
    bool _bouncing;
    CCPoint _bounceDir;
    float _bounceOriginalSpeed;
    bool _inertiaScrollEnabled;



    CCObject* _scrollViewEventListener;
    SEL_ScrollViewEvent _scrollViewEventSelector;
};

}
}
# 38 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    SLIDER_PERCENTCHANGED
}SliderEventType;

typedef void (CCObject::*SEL_SlidPercentChangedEvent)(CCObject*,SliderEventType);






class Slider : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Slider();




    virtual ~Slider();




    static Slider* create();
# 74 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadBarTexture(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setScale9Enabled(bool able);

    bool isScale9Enabled();






    void setCapInsets(const CCRect &capInsets);






    void setCapInsetsBarRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetBarRenderer();






    void setCapInsetProgressBarRebderer(const CCRect &capInsets);

    const CCRect& getCapInsetProgressBarRebderer();
# 121 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTextures(const char* normal,const char* pressed,const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 130 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTextureNormal(const char* normal,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 139 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTexturePressed(const char* pressed,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 148 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTextureDisabled(const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 157 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadProgressBarTexture(const char* fileName, TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setPercent(int percent);






    int getPercent();




    void addEventListenerSlider(CCObject* target,SEL_SlidPercentChangedEvent selector);

    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unused_event);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();


    virtual void ignoreContentAdaptWithSize(bool ignore);




    virtual std::string getDescription() const;

protected:
    virtual bool init();
    virtual void initRenderer();
    float getPercentWithBallPos(float location);
    void percentChangedEvent();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void barRendererScaleChangedWithSize();
    void progressBarRendererScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    CCNode* _barRenderer;
    CCNode* _progressBarRenderer;
    CCSize _progressBarTextureSize;

    CCSprite* _slidBallNormalRenderer;
    CCSprite* _slidBallPressedRenderer;
    CCSprite* _slidBallDisabledRenderer;
    CCNode* _slidBallRenderer;

    float _barLength;
    int _percent;

    bool _scale9Enabled;
    bool _prevIgnoreSize;
    std::string _textureFile;
    std::string _progressBarTextureFile;
    std::string _slidBallNormalTextureFile;
    std::string _slidBallPressedTextureFile;
    std::string _slidBallDisabledTextureFile;

    CCRect _capInsetsBarRenderer;
    CCRect _capInsetsProgressBarRenderer;

    CCObject* _sliderEventListener;
    SEL_SlidPercentChangedEvent _sliderEventSelector;
    TextureResType _barTexType;
    TextureResType _progressBarTexType;
    TextureResType _ballNTexType;
    TextureResType _ballPTexType;
    TextureResType _ballDTexType;
};

}
}
# 39 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UITextField.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UITextField.h"
namespace cocos2d {

namespace ui {





class UICCTextField: public CCTextFieldTTF, public CCTextFieldDelegate
{
public:
    UICCTextField();
    ~UICCTextField();

    virtual void onEnter();


    static UICCTextField* create(const char *placeholder, const char *fontName, float fontSize);


    virtual bool onTextFieldAttachWithIME(CCTextFieldTTF *pSender);
    virtual bool onTextFieldDetachWithIME(CCTextFieldTTF * pSender);
    virtual bool onTextFieldInsertText(CCTextFieldTTF * pSender, const char * text, int nLen);
    virtual bool onTextFieldDeleteBackward(CCTextFieldTTF * pSender, const char * delText, int nLen);

    void insertText(const char* text, int len);
    void deleteBackward();

    void openIME();
    void closeIME();

    void setMaxLengthEnabled(bool enable);
    bool isMaxLengthEnabled();
    void setMaxLength(int length);
    int getMaxLength();
    int getCharCount();
    void setPasswordEnabled(bool enable);
    bool isPasswordEnabled();
    void setPasswordStyleText(const char* styleText);
    void setPasswordText(const char* text);
    void setAttachWithIME(bool attach);
    bool getAttachWithIME();
    void setDetachWithIME(bool detach);
    bool getDetachWithIME();
    void setInsertText(bool insert);
    bool getInsertText();
    void setDeleteBackward(bool deleteBackward);
    bool getDeleteBackward();
protected:
    bool _maxLengthEnabled;
    int _maxLength;
    bool _passwordEnabled;
    std::string _passwordStyleText;
    bool _attachWithIME;
    bool _detachWithIME;
    bool _insertText;
    bool _deleteBackward;
};

typedef enum
{
    TEXTFIELD_EVENT_ATTACH_WITH_IME,
    TEXTFIELD_EVENT_DETACH_WITH_IME,
    TEXTFIELD_EVENT_INSERT_TEXT,
    TEXTFIELD_EVENT_DELETE_BACKWARD,
}TextFiledEventType;

typedef void (CCObject::*SEL_TextFieldEvent)(CCObject*, TextFiledEventType);






class TextField : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:
    TextField();
    virtual ~TextField();
    static TextField* create();
    void setTouchSize(const CCSize &size);
    CCSize getTouchSize();
    void setTouchAreaEnabled(bool enable);
    virtual bool hitTest(const CCPoint &pt);
    void setText(const std::string& text);
    void setPlaceHolder(const std::string& value);
    const char* getPlaceHolder();
    void setFontSize(int size);
    int getFontSize();
    void setFontName(const std::string& name);
    const char* getFontName();
    virtual void didNotSelectSelf();
    const char* getStringValue();
    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
    void setMaxLengthEnabled(bool enable);
    bool isMaxLengthEnabled();
    void setMaxLength(int length);
    int getMaxLength();
    void setPasswordEnabled(bool enable);
    bool isPasswordEnabled();
    void setPasswordStyleText(const char* styleText);
    const char* getPasswordStyleText();
    virtual void update(float dt);
    bool getAttachWithIME();
    void setAttachWithIME(bool attach);
    bool getDetachWithIME();
    void setDetachWithIME(bool detach);
    bool getInsertText();
    void setInsertText(bool insertText);
    bool getDeleteBackward();
    void setDeleteBackward(bool deleteBackward);
    void addEventListenerTextField(CCObject* target, SEL_TextFieldEvent selecor);

    virtual void setAnchorPoint(const CCPoint &pt);




    virtual std::string getDescription() const;

    virtual const CCSize& getContentSize() const;
    virtual CCNode* getVirtualRenderer();
    void attachWithIME();
    virtual void onEnter();

    void setTextAreaSize(const CCSize &size);
    void setTextHorizontalAlignment(CCTextAlignment alignment);
    void setTextVerticalAlignment(CCVerticalTextAlignment alignment);


protected:
    virtual bool init();
    virtual void initRenderer();

    void attachWithIMEEvent();
    void detachWithIMEEvent();
    void insertTextEvent();
    void deleteBackwardEvent();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void textfieldRendererScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    UICCTextField* _textFieldRenderer;

    float _touchWidth;
    float _touchHeight;
    bool _useTouchArea;

    CCObject* _textFieldEventListener;
    SEL_TextFieldEvent _textFieldEventSelector;

    std::string _passwordStyleText;
};

}

}
# 40 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
namespace cocos2d {

namespace ui{

typedef enum
{
    LISTVIEW_GRAVITY_LEFT,
    LISTVIEW_GRAVITY_RIGHT,
    LISTVIEW_GRAVITY_CENTER_HORIZONTAL,

    LISTVIEW_GRAVITY_TOP,
    LISTVIEW_GRAVITY_BOTTOM,
    LISTVIEW_GRAVITY_CENTER_VERTICAL,
}ListViewGravity;

typedef enum
{
    LISTVIEW_ONSELECTEDITEM_START,
    LISTVIEW_ONSELECTEDITEM_END
}ListViewEventType;

typedef void (CCObject::*SEL_ListViewEvent)(CCObject*,ListViewEventType);


class ListView : public ScrollView
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:




    ListView();




    virtual ~ListView();




    static ListView* create();
# 84 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    void setItemModel(Widget* model);




    void pushBackDefaultItem();




    void insertDefaultItem(int index);




    void pushBackCustomItem(Widget* item);




    void insertCustomItem(Widget* item, int index);




    void removeLastItem();






    void removeItem(int index);

    void removeAllItems();
# 127 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    Widget* getItem(unsigned int index);




    CCArray* getItems();
# 141 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    unsigned int getIndex(Widget* item) const;





    void setGravity(ListViewGravity gravity);






    void setItemsMargin(float margin);

    float getItemsMargin();

    virtual void sortAllChildren();

    int getCurSelectedIndex() const;

    void addEventListenerListView(CCObject* target, SEL_ListViewEvent selector);
# 171 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    virtual void setDirection(SCROLLVIEW_DIR dir);

    virtual std::string getDescription() const;

    void requestRefreshView();

    void refreshView();
protected:
    virtual void addChild(CCNode* child) {ScrollView::addChild(child);};
    virtual void addChild(CCNode * child, int zOrder) {ScrollView::addChild(child, zOrder);};
    virtual void addChild(CCNode* child, int zOrder, int tag) {ScrollView::addChild(child, zOrder, tag);};
    virtual void removeChild(CCNode* widget) {ScrollView::removeChild(widget);};
    virtual void removeChild(CCNode* widget, bool cleanup) {ScrollView::removeChild(widget, cleanup);};

    virtual void removeAllChildren() {ScrollView::removeAllChildren();};
    virtual void removeAllChildrenWithCleanup(bool cleanup) {ScrollView::removeAllChildrenWithCleanup(cleanup);};
    virtual CCArray* getChildren() {return ScrollView::getChildren();};
    virtual unsigned int getChildrenCount() const {return ScrollView::getChildrenCount();};
    virtual CCNode * getChildByTag(int tag) {return ScrollView::getChildByTag(tag);};
    virtual Widget* getChildByName(const char* name) {return ScrollView::getChildByName(name);};
    virtual bool init();
    void updateInnerContainerSize();
    void remedyLayoutParameter(Widget* item);
    virtual void onSizeChanged();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    void selectedItemEvent(int state);
    virtual void interceptTouchEvent(int handleState,Widget* sender,const CCPoint &touchPoint);
protected:

    Widget* _model;
    ListViewGravity _gravity;
    float _itemsMargin;
    CCObject* _listViewEventListener;
    SEL_ListViewEvent _listViewEventSelector;
    int _curSelectedIndex;
    bool _refreshViewDirty;
    CCArray* _items;
};

}
}
# 41 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelBMFont.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelBMFont.h"
namespace cocos2d {

namespace ui {





class LabelBMFont : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    LabelBMFont();




    virtual ~LabelBMFont();




    static LabelBMFont* create();


    void setFntFile(const char* fileName);


    void setText(const char* value);


    const char* getStringValue();
    virtual void setAnchorPoint(const CCPoint &pt);
    virtual const CCSize& getContentSize() const;
    virtual CCNode* getVirtualRenderer();



    virtual std::string getDescription() const;
protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void labelBMFontScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    cocos2d::CCLabelBMFont* _labelBMFontRenderer;
    bool _fntFileHasInit;
    std::string _fntFileName;
    std::string _stringValue;
};

}
}
# 42 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    PAGEVIEW_EVENT_TURNING,
}PageViewEventType;

typedef void (CCObject::*SEL_PageViewEvent)(CCObject*, PageViewEventType);


typedef enum {
    PAGEVIEW_TOUCHLEFT,
    PAGEVIEW_TOUCHRIGHT
}PVTouchDir;

class PageView : public Layout , public UIScrollInterface
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    PageView();




    virtual ~PageView();




    static PageView* create();
# 78 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h"
    void addWidgetToPage(Widget* widget, int pageIdx, bool forceCreate);






    void addPage(Layout* page);






    void insertPage(Layout* page, int idx);






    void removePage(Layout* page);






    void removePageAtIndex(int index);

    void removeAllPages();






    void scrollToPage(int idx);






    int getCurPageIndex() const;

    CCArray* getPages();

    Layout* getPage(int index);


    void addEventListenerPageView(CCObject *target, SEL_PageViewEvent selector);




    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unusedEvent);


    virtual void update(float dt);







    virtual void setLayoutType(LayoutType type){};
# 157 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h"
    virtual LayoutType getLayoutType() const {return LAYOUT_ABSOLUTE;};




    virtual std::string getDescription() const;

    virtual void onEnter();
protected:
    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode* child, int zOrder, int tag);
    virtual void removeChild(CCNode* widget);
    virtual void removeChild(CCNode* widget, bool cleanup);
    virtual void removeAllChildren();
    virtual void removeAllChildrenWithCleanup(bool cleanup);
    virtual CCArray* getChildren(){return Widget::getChildren();};
    virtual unsigned int getChildrenCount() const {return Widget::getChildrenCount();};
    virtual CCNode * getChildByTag(int tag) {return Widget::getChildByTag(tag);};
    virtual Widget* getChildByName(const char* name) {return Widget::getChildByName(name);};
    virtual bool init();
    Layout* createPage();
    float getPositionXByIndex(int idx);
    void updateBoundaryPages();
    virtual void handlePressLogic(const CCPoint &touchPoint);
    virtual void handleMoveLogic(const CCPoint &touchPoint);
    virtual void handleReleaseLogic(const CCPoint &touchPoint);
    virtual void interceptTouchEvent(int handleState, Widget* sender, const CCPoint &touchPoint);
    virtual void checkChildInfo(int handleState, Widget* sender, const CCPoint &touchPoint);
    virtual bool scrollPages(float touchOffset);
    void movePages(float offset);
    void pageTurningEvent();
    void updateChildrenSize();
    void updateChildrenPosition();
    virtual void onSizeChanged();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    virtual void setClippingEnabled(bool enabled) {Layout::setClippingEnabled(enabled);};
    virtual void doLayout() {if (!_doLayoutDirty){return;} _doLayoutDirty = false;};
protected:
    int _curPageIdx;
    CCArray* _pages;
    PVTouchDir _touchMoveDir;
    float _touchStartLocation;
    float _touchMoveStartLocation;
    CCPoint _movePagePoint;
    Widget* _leftChild;
    Widget* _rightChild;
    float _leftBoundary;
    float _rightBoundary;
    bool _isAutoScrolling;
    float _autoScrollDistance;
    float _autoScrollSpeed;
    int _autoScrollDir;
    float _childFocusCancelOffset;
    CCObject* _pageViewEventListener;
    SEL_PageViewEvent _pageViewEventSelector;

};

}
}
# 43 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h" 1
# 28 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
namespace cocos2d {

namespace ui {





class UIHelper
{
public:
# 48 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
    static Widget* seekWidgetByTag(Widget* root, int tag);
# 59 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
    static Widget* seekWidgetByName(Widget* root, const char* name);
# 72 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
    static Widget* seekWidgetByRelativeName(Widget* root, const char* name);


    static Widget* seekActionWidgetByActionTag(Widget* root, int tag);
};
}

}
# 44 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h"
# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/WidgetReader/WidgetReaderProtocol.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/WidgetReader/WidgetReaderProtocol.h"
namespace cocos2d
{
    namespace ui
    {
        class Widget;
    }
}

namespace cocos2d { namespace extension {

class WidgetReaderProtocol
{
public:
    virtual void setPropsFromJsonDictionary(ui::Widget* widget, const rapidjson::Value& options) = 0;
};

}}
# 32 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h" 2


namespace cocos2d { namespace extension {

typedef void (CCObject::*SEL_ParseEvent)(const std::string&, CCObject*, const rapidjson::Value&);







class GUIReader : public CCObject
{
public:



    GUIReader();



    ~GUIReader();



    static GUIReader* shareReader();



 static void purge();

    cocos2d::ui::Widget* widgetFromJsonFile(const char* fileName);
    int getVersionInteger(const char* str);
    void storeFileDesignSize(const char* fileName, const cocos2d::CCSize &size);
    const cocos2d::CCSize getFileDesignSize(const char* fileName) const;

    const std::string& getFilePath() const { return m_strFilePath; };

    void registerTypeAndCallBack(const std::string& classType,
                                 ObjectFactory::Instance ins,
                                 CCObject* object,
                                 SEL_ParseEvent callBack);
protected:
    std::string m_strFilePath;
    CCDictionary* _fileDesignSizes;

    typedef std::map<std::string, SEL_ParseEvent> ParseCallBackMap;
    ParseCallBackMap _mapParseSelector;
    typedef std::map<std::string, CCObject*> ParseObjectMap;
    ParseObjectMap _mapObject;

public:
    ParseCallBackMap getParseCallBackMap() { return _mapParseSelector; };
    ParseObjectMap getParseObjectMap() { return _mapObject; };
};

class WidgetPropertiesReader : public CCObject
{
public:
    virtual cocos2d::ui::Widget* createWidget(const rapidjson::Value& dic, const char* fullPath, const char* fileName)=0;
    virtual cocos2d::ui::Widget* widgetFromJsonDictionary(const rapidjson::Value& data) = 0;
    virtual void setPropsForAllWidgetFromJsonDictionary(WidgetReaderProtocol* reader, cocos2d::ui::Widget* widget, const rapidjson::Value& options) = 0;

    virtual void setPropsForAllCustomWidgetFromJsonDictionary(const std::string& classType,
                                                              cocos2d::ui::Widget* widget,
                                                              const rapidjson::Value& customOptions) = 0;

protected:
    std::string m_strFilePath;
};







class WidgetPropertiesReader0250 : public WidgetPropertiesReader
{


public:
    WidgetPropertiesReader0250(){};
    virtual ~WidgetPropertiesReader0250(){};

    virtual cocos2d::ui::Widget* createWidget(const rapidjson::Value& dic, const char* fullPath, const char* fileName);
    virtual cocos2d::ui::Widget* widgetFromJsonDictionary(const rapidjson::Value& dic);
    virtual void setPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setColorPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForButtonFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForCheckBoxFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForImageViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelAtlasFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelBMFontFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLoadingBarFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForSliderFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForTextFieldFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setPropsForLayoutFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForScrollViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setPropsForAllWidgetFromJsonDictionary(WidgetReaderProtocol* reader, cocos2d::ui::Widget* widget, const rapidjson::Value& options);

    virtual void setPropsForAllCustomWidgetFromJsonDictionary(const std::string& classType,
                                                              cocos2d::ui::Widget* widget,
                                                              const rapidjson::Value& customOptions);
};





class WidgetPropertiesReader0300 : public WidgetPropertiesReader
{


public:
    WidgetPropertiesReader0300(){};
    virtual ~WidgetPropertiesReader0300(){};

    virtual cocos2d::ui::Widget* createWidget(const rapidjson::Value& dic, const char* fullPath, const char* fileName);
    virtual cocos2d::ui::Widget* widgetFromJsonDictionary(const rapidjson::Value& dic);
    virtual void setPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setColorPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForButtonFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForCheckBoxFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForImageViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelAtlasFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelBMFontFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLoadingBarFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForSliderFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForTextFieldFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setPropsForLayoutFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForPageViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForScrollViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForListViewFromJsonDictionary(cocos2d::ui::Widget* widget, const rapidjson::Value& options);

    virtual void setPropsForAllWidgetFromJsonDictionary(WidgetReaderProtocol* reader, cocos2d::ui::Widget* widget, const rapidjson::Value& options);

    virtual void setPropsForAllCustomWidgetFromJsonDictionary(const std::string& classType,
                                                              cocos2d::ui::Widget* widget,
                                                              const rapidjson::Value& customOptions);
};

}}
# 45 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UITouchGroup.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UITouchGroup.h"
namespace cocos2d {

namespace ui {




class TouchGroup : public CCLayer
{

public:




    TouchGroup();





    virtual ~TouchGroup();




    static TouchGroup *create(void);


    virtual bool init();

    virtual void onEnter();
    virtual void onExit();
    virtual void onEnterTransitionDidFinish();

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);






    void addWidget(Widget* widget);
# 87 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UITouchGroup.h"
    void removeWidget(Widget* widget);






    Widget* getWidgetByTag(int tag);






    Widget* getWidgetByName(const char* name);




    virtual void clear();






    Widget* getRootWidget();
protected:
    bool checkEventWidget(CCTouch* touch, CCEvent *pEvent);
    bool checkTouchEvent(Widget* root, CCTouch* touch, CCEvent* pEvent);
protected:
    Widget* m_pRootWidget;
    CCPoint touchBeganedPoint;
    CCPoint touchMovedPoint;
    CCPoint touchEndedPoint;
    CCPoint touchCanceledPoint;
    CCArray* m_pSelectedWidgets;
};

}

}
# 46 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/Compatible/CompatibleClasses.h" 1
# 22 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/Compatible/CompatibleClasses.h"
namespace cocos2d {

namespace ui {

typedef cocos2d::ui::Layout UIPanel;
typedef cocos2d::ui::Layout UILayout;
typedef cocos2d::ui::Widget UIWidget;

typedef cocos2d::ui::LayoutParameter UILayoutParameter;
typedef cocos2d::ui::Margin UIMargin;

typedef cocos2d::ui::ListView UIListView;
typedef cocos2d::ui::PageView UIPageView;
typedef cocos2d::ui::ScrollView UIDragPanel;
typedef cocos2d::ui::ScrollView UIScrollView;
typedef cocos2d::ui::Button UIButton;
typedef cocos2d::ui::Button UITextButton;
typedef cocos2d::ui::CheckBox UICheckBox;
typedef cocos2d::ui::ImageView UIImageView;
typedef cocos2d::ui::Label UILabel;
typedef cocos2d::ui::LabelAtlas UILabelAtlas;
typedef cocos2d::ui::LabelBMFont UILabelBMFont;
typedef cocos2d::ui::LoadingBar UILoadingBar;
typedef cocos2d::ui::Slider UISlider;
typedef cocos2d::ui::TextField UITextField;
typedef cocos2d::ui::TouchGroup UILayer;

typedef cocos2d::ui::LinearGravity UILinearGravity;
typedef cocos2d::ui::RelativeAlign UIRelativeAlign;
typedef cocos2d::ui::LayoutParameter UILayoutParameter;
typedef cocos2d::ui::LinearLayoutParameter UILinearLayoutParameter;
typedef cocos2d::ui::RelativeLayoutParameter UIRelativeLayoutParameter;
}
}
# 47 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIRichText.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIRichText.h"
namespace cocos2d {

namespace ui {

typedef enum {
    RICH_TEXT,
    RICH_IMAGE,
    RICH_CUSTOM
}RichElementType;

class RichElement : public CCObject
{
public:
    RichElement(){};
    virtual ~RichElement(){};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity);
protected:
    RichElementType _type;
    int _tag;
    ccColor3B _color;
    GLubyte _opacity;
    friend class RichText;
};

class RichElementText : public RichElement
{
public:
    RichElementText(){_type = RICH_TEXT;};
    virtual ~RichElementText(){};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity, const char* text, const char* fontName, float fontSize);
    static RichElementText* create(int tag, const ccColor3B& color, GLubyte opacity, const char* text, const char* fontName, float fontSize);
protected:
    std::string _text;
    std::string _fontName;
    float _fontSize;
    friend class RichText;

};

class RichElementImage : public RichElement
{
public:
    RichElementImage(){_type = RICH_IMAGE;};
    virtual ~RichElementImage(){};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity, const char* filePath);
    static RichElementImage* create(int tag, const ccColor3B& color, GLubyte opacity, const char* filePath);
protected:
    std::string _filePath;
    CCRect _textureRect;
    int _textureType;
    friend class RichText;
};

class RichElementCustomNode : public RichElement
{
public:
    RichElementCustomNode(){_type = RICH_CUSTOM;};
    virtual ~RichElementCustomNode(){do { if(_customNode) { (_customNode)->release(); } } while(0);};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity, CCNode* customNode);
    static RichElementCustomNode* create(int tag, const ccColor3B& color, GLubyte opacity, CCNode* customNode);
protected:
    CCNode* _customNode;
    friend class RichText;
};

class RichText : public Widget
{
public:
    RichText();
    virtual ~RichText();
    static RichText* create();
    void insertElement(RichElement* element, int index);
    void pushBackElement(RichElement* element);
    void removeElement(int index);
    void removeElement(RichElement* element);
    virtual void visit();
    void setVerticalSpace(float space);
    virtual void setAnchorPoint(const CCPoint &pt);
    virtual const CCSize& getContentSize() const;
    void formatText();
    virtual void ignoreContentAdaptWithSize(bool ignore);
protected:
    virtual bool init();
    virtual void initRenderer();
    void pushToContainer(CCNode* renderer);
    void handleTextRenderer(const char* text, const char* fontName, float fontSize, const ccColor3B& color, GLubyte opacity);
    void handleImageRenderer(const char* fileParh, const ccColor3B& color, GLubyte opacity);
    void handleCustomRenderer(CCNode* renderer);
    void formarRenderers();
    void addNewLine();
protected:
    bool _formatTextDirty;
    CCArray* _richElements;
    std::vector<CCArray*> _elementRenders;
    float _leftSpaceWidth;
    float _verticalSpace;
    CCNode* _elementRenderersContainer;
};

}

}
# 48 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2



const char* CocosGUIVersion();
# 67 "Cacao/include/cocos2dext/cocos-ext.h" 2



# 1 "Cacao/include/cocos2dext/CocoStudio/Reader/SceneReader.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Reader/SceneReader.h"
# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Reader/SceneReader.h" 2


namespace cocos2d { namespace extension {


typedef void (CCObject::*SEL_CallFuncOD)(CCObject*, void*);






class SceneReader
{
public:
 SceneReader(void);
 virtual ~SceneReader(void);

public:
 static SceneReader* sharedSceneReader();
 static void purge();
 static const char* sceneReaderVersion();
 cocos2d::CCNode* createNodeWithSceneFile(const char *pszFileName);
 static void setTarget(CCObject *rec, SEL_CallFuncOD selector);
 cocos2d::CCNode* getNodeByTag(int nTag);
private:
    cocos2d::CCNode* createObject(const rapidjson::Value &root, cocos2d::CCNode* parent);
    void setPropertyFromJsonDict(const rapidjson::Value &root, cocos2d::CCNode *node);
    bool readJson(const char *pszFileName, rapidjson::Document &doc);
 cocos2d::CCNode* nodeByTag(cocos2d::CCNode *pParent, int nTag);
private:
 static SceneReader* _sharedReader;
 static CCObject* _pListener;
 static SEL_CallFuncOD _pfnSelector;
 cocos2d::CCNode *_pNode;
};


}}
# 71 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionObject.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionObject.h"
namespace cocos2d { namespace extension {

class ActionNode;




class ActionObject:public CCObject
{
public:




 ActionObject();




 virtual ~ActionObject();






 void setName(const char* name);






 const char* getName();






 void setLoop(bool bLoop);






 bool getLoop();






 void setUnitTime(float fTime);






 float getUnitTime();






 void setCurrentTime(float fTime);






 float getCurrentTime();






 float getTotalTime();





 bool isPlaying();




 void play();






 void play(CCCallFunc* func);




 void pause();




 void stop();






 void addActionNode(ActionNode* node);






 void removeActionNode(ActionNode* node);


 void updateToFrameByTime(float fTime);


 void initWithDictionary(const rapidjson::Value& dic,CCObject* root);

 void simulationActionUpdate(float dt);

protected:
 CCArray* m_ActionNodeList;
 std::string m_name;
 bool m_loop;
 bool m_bPause;
 bool m_bPlaying;
 float m_fUnitTime;
 float m_CurrentTime;
 CCScheduler *m_pScheduler;
 CCCallFunc *m_CallBack;
 float m_fTotalTime;
};

}}
# 31 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h" 2

namespace cocos2d { namespace extension {




class ActionManager:public CCObject
{
public:





 ActionManager();





 virtual ~ActionManager();




 static ActionManager* shareManager();




 static void purge();
# 72 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
 ActionObject* getActionByName(const char* jsonName,const char* actionName);
# 81 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
 ActionObject* playActionByName(const char* jsonName,const char* actionName);
# 92 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
 ActionObject* playActionByName(const char* jsonName,const char* actionName, CCCallFunc* func);


 void initWithDictionary(const char* jsonName,const rapidjson::Value &dic,CCObject* root);




 void releaseActions();

protected:
 CCDictionary* m_pActionDic;
};

}}
# 73 "Cacao/include/cocos2dext/cocos-ext.h" 2








# 1 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 1
# 29 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h"
# 1 "Cacao/include/cocos2dext/spine/spine.h" 1
# 29 "Cacao/include/cocos2dext/spine/spine.h"
# 1 "Cacao/include/cocos2dext/spine/Animation.h" 1
# 29 "Cacao/include/cocos2dext/spine/Animation.h"
namespace cocos2d { namespace extension {

typedef struct Timeline Timeline;
struct Skeleton;

typedef struct {
 const char* const name;
 float duration;

 int timelineCount;
 Timeline** timelines;
} Animation;

Animation* Animation_create (const char* name, int timelineCount);
void Animation_dispose (Animation* self);

void Animation_apply (const Animation* self, struct Skeleton* skeleton, float time, int loop);
void Animation_mix (const Animation* self, struct Skeleton* skeleton, float time, int loop, float alpha);



struct Timeline {
 const void* const vtable;
};

void Timeline_dispose (Timeline* self);
void Timeline_apply (const Timeline* self, struct Skeleton* skeleton, float time, float alpha);



typedef struct {
 Timeline super;
 float* curves;
} CurveTimeline;

void CurveTimeline_setLinear (CurveTimeline* self, int frameIndex);
void CurveTimeline_setStepped (CurveTimeline* self, int frameIndex);




void CurveTimeline_setCurve (CurveTimeline* self, int frameIndex, float cx1, float cy1, float cx2, float cy2);
float CurveTimeline_getCurvePercent (const CurveTimeline* self, int frameIndex, float percent);



typedef struct BaseTimeline {
 CurveTimeline super;
 int const framesLength;
 float* const frames;
 int boneIndex;
} RotateTimeline;

RotateTimeline* RotateTimeline_create (int frameCount);

void RotateTimeline_setFrame (RotateTimeline* self, int frameIndex, float time, float angle);



typedef struct BaseTimeline TranslateTimeline;

TranslateTimeline* TranslateTimeline_create (int frameCount);

void TranslateTimeline_setFrame (TranslateTimeline* self, int frameIndex, float time, float x, float y);



typedef struct BaseTimeline ScaleTimeline;

ScaleTimeline* ScaleTimeline_create (int frameCount);

void ScaleTimeline_setFrame (ScaleTimeline* self, int frameIndex, float time, float x, float y);



typedef struct {
 CurveTimeline super;
 int const framesLength;
 float* const frames;
 int slotIndex;
} ColorTimeline;

ColorTimeline* ColorTimeline_create (int frameCount);

void ColorTimeline_setFrame (ColorTimeline* self, int frameIndex, float time, float r, float g, float b, float a);



typedef struct {
 Timeline super;
 int const framesLength;
 float* const frames;
 int slotIndex;
 const char** const attachmentNames;
} AttachmentTimeline;

AttachmentTimeline* AttachmentTimeline_create (int frameCount);


void AttachmentTimeline_setFrame (AttachmentTimeline* self, int frameIndex, float time, const char* attachmentName);

}}
# 30 "Cacao/include/cocos2dext/spine/spine.h" 2
# 1 "Cacao/include/cocos2dext/spine/AnimationState.h" 1
# 29 "Cacao/include/cocos2dext/spine/AnimationState.h"
# 1 "Cacao/include/cocos2dext/spine/AnimationStateData.h" 1
# 30 "Cacao/include/cocos2dext/spine/AnimationStateData.h"
# 1 "Cacao/include/cocos2dext/spine/SkeletonData.h" 1
# 29 "Cacao/include/cocos2dext/spine/SkeletonData.h"
# 1 "Cacao/include/cocos2dext/spine/BoneData.h" 1
# 29 "Cacao/include/cocos2dext/spine/BoneData.h"
namespace cocos2d { namespace extension {

typedef struct BoneData BoneData;
struct BoneData {
 const char* const name;
 BoneData* const parent;
 float length;
 float x, y;
 float rotation;
 float scaleX, scaleY;
};

BoneData* BoneData_create (const char* name, BoneData* parent);
void BoneData_dispose (BoneData* self);

}}
# 30 "Cacao/include/cocos2dext/spine/SkeletonData.h" 2
# 1 "Cacao/include/cocos2dext/spine/SlotData.h" 1
# 31 "Cacao/include/cocos2dext/spine/SlotData.h"
namespace cocos2d { namespace extension {

typedef struct {
 const char* const name;
 const BoneData* const boneData;
 const char* const attachmentName;
 float r, g, b, a;
} SlotData;

SlotData* SlotData_create (const char* name, BoneData* boneData);
void SlotData_dispose (SlotData* self);


void SlotData_setAttachmentName (SlotData* self, const char* attachmentName);

}}
# 31 "Cacao/include/cocos2dext/spine/SkeletonData.h" 2
# 1 "Cacao/include/cocos2dext/spine/Skin.h" 1
# 29 "Cacao/include/cocos2dext/spine/Skin.h"
# 1 "Cacao/include/cocos2dext/spine/Attachment.h" 1
# 29 "Cacao/include/cocos2dext/spine/Attachment.h"
namespace cocos2d { namespace extension {

struct Slot;

typedef enum {
 ATTACHMENT_REGION, ATTACHMENT_REGION_SEQUENCE
} AttachmentType;

typedef struct Attachment Attachment;
struct Attachment {
 const char* const name;
 AttachmentType type;

 const void* const vtable;
};

void Attachment_dispose (Attachment* self);

}}
# 30 "Cacao/include/cocos2dext/spine/Skin.h" 2

namespace cocos2d { namespace extension {

struct Skeleton;

typedef struct {
 const char* const name;
} Skin;

Skin* Skin_create (const char* name);
void Skin_dispose (Skin* self);


void Skin_addAttachment (Skin* self, int slotIndex, const char* name, Attachment* attachment);

Attachment* Skin_getAttachment (const Skin* self, int slotIndex, const char* name);


const char* Skin_getAttachmentName (const Skin* self, int slotIndex, int attachmentIndex);


void Skin_attachAll (const Skin* self, struct Skeleton* skeleton, const Skin* oldSkin);

}}
# 32 "Cacao/include/cocos2dext/spine/SkeletonData.h" 2


namespace cocos2d { namespace extension {

typedef struct {
 int boneCount;
 BoneData** bones;

 int slotCount;
 SlotData** slots;

 int skinCount;
 Skin** skins;
 Skin* defaultSkin;

 int animationCount;
 Animation** animations;
} SkeletonData;

SkeletonData* SkeletonData_create ();
void SkeletonData_dispose (SkeletonData* self);

BoneData* SkeletonData_findBone (const SkeletonData* self, const char* boneName);
int SkeletonData_findBoneIndex (const SkeletonData* self, const char* boneName);

SlotData* SkeletonData_findSlot (const SkeletonData* self, const char* slotName);
int SkeletonData_findSlotIndex (const SkeletonData* self, const char* slotName);

Skin* SkeletonData_findSkin (const SkeletonData* self, const char* skinName);

Animation* SkeletonData_findAnimation (const SkeletonData* self, const char* animationName);

}}
# 31 "Cacao/include/cocos2dext/spine/AnimationStateData.h" 2

namespace cocos2d { namespace extension {

typedef struct {
 SkeletonData* const skeletonData;
 const void* const entries;
} AnimationStateData;

AnimationStateData* AnimationStateData_create (SkeletonData* skeletonData);
void AnimationStateData_dispose (AnimationStateData* self);

void AnimationStateData_setMixByName (AnimationStateData* self, const char* fromName, const char* toName, float duration);
void AnimationStateData_setMix (AnimationStateData* self, Animation* from, Animation* to, float duration);

float AnimationStateData_getMix (AnimationStateData* self, Animation* from, Animation* to);

}}
# 30 "Cacao/include/cocos2dext/spine/AnimationState.h" 2

namespace cocos2d { namespace extension {

typedef struct {
 AnimationStateData* const data;
 Animation* const animation;
 float time;
 int loop;
} AnimationState;


AnimationState* AnimationState_create (AnimationStateData* data);
void AnimationState_dispose (AnimationState* self);

void AnimationState_update (AnimationState* self, float delta);

void AnimationState_apply (AnimationState* self, struct Skeleton* skeleton);


void AnimationState_setAnimationByName (AnimationState* self, const char* animationName, int loop);

void AnimationState_setAnimation (AnimationState* self, Animation* animation, int loop);



void AnimationState_addAnimationByName (AnimationState* self, const char* animationName, int loop, float delay);


void AnimationState_addAnimation (AnimationState* self, Animation* animation, int loop, float delay);

void AnimationState_clearAnimation (AnimationState* self);

int AnimationState_isComplete (AnimationState* self);

}}
# 31 "Cacao/include/cocos2dext/spine/spine.h" 2

# 1 "Cacao/include/cocos2dext/spine/Atlas.h" 1
# 29 "Cacao/include/cocos2dext/spine/Atlas.h"
namespace cocos2d { namespace extension {

typedef enum {
 ATLAS_ALPHA, ATLAS_INTENSITY, ATLAS_LUMINANCE_ALPHA, ATLAS_RGB565, ATLAS_RGBA4444, ATLAS_RGB888, ATLAS_RGBA8888
} AtlasFormat;

typedef enum {
 ATLAS_NEAREST,
 ATLAS_LINEAR,
 ATLAS_MIPMAP,
 ATLAS_MIPMAP_NEAREST_NEAREST,
 ATLAS_MIPMAP_LINEAR_NEAREST,
 ATLAS_MIPMAP_NEAREST_LINEAR,
 ATLAS_MIPMAP_LINEAR_LINEAR
} AtlasFilter;

typedef enum {
 ATLAS_MIRROREDREPEAT, ATLAS_CLAMPTOEDGE, ATLAS_REPEAT
} AtlasWrap;

typedef struct AtlasPage AtlasPage;
struct AtlasPage {
 const char* name;
 AtlasFormat format;
 AtlasFilter minFilter, magFilter;
 AtlasWrap uWrap, vWrap;

 void* rendererObject;
 int width, height;

 AtlasPage* next;
};

AtlasPage* AtlasPage_create (const char* name);
void AtlasPage_dispose (AtlasPage* self);



typedef struct AtlasRegion AtlasRegion;
struct AtlasRegion {
 const char* name;
 int x, y, width, height;
 float u, v, u2, v2;
 int offsetX, offsetY;
 int originalWidth, originalHeight;
 int index;
 int rotate;
 int flip;
 int* splits;
 int* pads;

 AtlasPage* page;

 AtlasRegion* next;
};

AtlasRegion* AtlasRegion_create ();
void AtlasRegion_dispose (AtlasRegion* self);



typedef struct {
 AtlasPage* pages;
 AtlasRegion* regions;
} Atlas;


Atlas* Atlas_readAtlas (const char* data, int length, const char* dir);

Atlas* Atlas_readAtlasFile (const char* path);
void Atlas_dispose (Atlas* atlas);


AtlasRegion* Atlas_findRegion (const Atlas* self, const char* name);

}}
# 33 "Cacao/include/cocos2dext/spine/spine.h" 2
# 1 "Cacao/include/cocos2dext/spine/AtlasAttachmentLoader.h" 1
# 29 "Cacao/include/cocos2dext/spine/AtlasAttachmentLoader.h"
# 1 "Cacao/include/cocos2dext/spine/AttachmentLoader.h" 1
# 32 "Cacao/include/cocos2dext/spine/AttachmentLoader.h"
namespace cocos2d { namespace extension {

typedef struct AttachmentLoader AttachmentLoader;
struct AttachmentLoader {
 const char* error1;
 const char* error2;

 const void* const vtable;

 AttachmentLoader () : error1(0), error2(0), vtable(0) {}

};

void AttachmentLoader_dispose (AttachmentLoader* self);


Attachment* AttachmentLoader_newAttachment (AttachmentLoader* self, Skin* skin, AttachmentType type, const char* name);

}}
# 30 "Cacao/include/cocos2dext/spine/AtlasAttachmentLoader.h" 2


namespace cocos2d { namespace extension {

typedef struct {
 AttachmentLoader super;
 Atlas* atlas;
} AtlasAttachmentLoader;

AtlasAttachmentLoader* AtlasAttachmentLoader_create (Atlas* atlas);

}}
# 34 "Cacao/include/cocos2dext/spine/spine.h" 2


# 1 "Cacao/include/cocos2dext/spine/Bone.h" 1
# 31 "Cacao/include/cocos2dext/spine/Bone.h"
namespace cocos2d { namespace extension {

typedef struct Bone Bone;
struct Bone {
 BoneData* const data;
 Bone* const parent;
 float x, y;
 float rotation;
 float scaleX, scaleY;

 float const m00, m01, worldX;
 float const m10, m11, worldY;
 float const worldRotation;
 float const worldScaleX, worldScaleY;
};

void Bone_setYDown (int yDown);


Bone* Bone_create (BoneData* data, Bone* parent);
void Bone_dispose (Bone* self);

void Bone_setToSetupPose (Bone* self);

void Bone_updateWorldTransform (Bone* self, int flipX, int flipY);

}}
# 37 "Cacao/include/cocos2dext/spine/spine.h" 2

# 1 "Cacao/include/cocos2dext/spine/RegionAttachment.h" 1
# 31 "Cacao/include/cocos2dext/spine/RegionAttachment.h"
# 1 "Cacao/include/cocos2dext/spine/Slot.h" 1
# 33 "Cacao/include/cocos2dext/spine/Slot.h"
namespace cocos2d { namespace extension {

struct Skeleton;

typedef struct Slot {
 SlotData* const data;
 struct Skeleton* const skeleton;
 Bone* const bone;
 float r, g, b, a;
 Attachment* const attachment;
} Slot;

Slot* Slot_create (SlotData* data, struct Skeleton* skeleton, Bone* bone);
void Slot_dispose (Slot* self);


void Slot_setAttachment (Slot* self, Attachment* attachment);

void Slot_setAttachmentTime (Slot* self, float time);
float Slot_getAttachmentTime (const Slot* self);

void Slot_setToSetupPose (Slot* self);

}}
# 32 "Cacao/include/cocos2dext/spine/RegionAttachment.h" 2

namespace cocos2d { namespace extension {

typedef enum {
 VERTEX_X1 = 0, VERTEX_Y1, VERTEX_X2, VERTEX_Y2, VERTEX_X3, VERTEX_Y3, VERTEX_X4, VERTEX_Y4
} VertexIndex;

typedef struct RegionAttachment RegionAttachment;
struct RegionAttachment {
 Attachment super;
 float x, y, scaleX, scaleY, rotation, width, height;

 void* rendererObject;
 int regionOffsetX, regionOffsetY;
 int regionWidth, regionHeight;
 int regionOriginalWidth, regionOriginalHeight;

 float offset[8];
 float uvs[8];
};

RegionAttachment* RegionAttachment_create (const char* name);
void RegionAttachment_setUVs (RegionAttachment* self, float u, float v, float u2, float v2, int rotate);
void RegionAttachment_updateOffset (RegionAttachment* self);
void RegionAttachment_computeVertices (RegionAttachment* self, float x, float y, Bone* bone, float* vertices);

}}
# 39 "Cacao/include/cocos2dext/spine/spine.h" 2
# 1 "Cacao/include/cocos2dext/spine/Skeleton.h" 1
# 33 "Cacao/include/cocos2dext/spine/Skeleton.h"
namespace cocos2d { namespace extension {

typedef struct Skeleton Skeleton;
struct Skeleton {
 SkeletonData* const data;

 int boneCount;
 Bone** bones;
 Bone* const root;

 int slotCount;
 Slot** slots;
 Slot** drawOrder;

 Skin* const skin;
 float r, g, b, a;
 float time;
 int flipX, flipY;
 float x, y;
};

Skeleton* Skeleton_create (SkeletonData* data);
void Skeleton_dispose (Skeleton* self);

void Skeleton_updateWorldTransform (const Skeleton* self);

void Skeleton_setToSetupPose (const Skeleton* self);
void Skeleton_setBonesToSetupPose (const Skeleton* self);
void Skeleton_setSlotsToSetupPose (const Skeleton* self);


Bone* Skeleton_findBone (const Skeleton* self, const char* boneName);

int Skeleton_findBoneIndex (const Skeleton* self, const char* boneName);


Slot* Skeleton_findSlot (const Skeleton* self, const char* slotName);

int Skeleton_findSlotIndex (const Skeleton* self, const char* slotName);




void Skeleton_setSkin (Skeleton* self, Skin* skin);


int Skeleton_setSkinByName (Skeleton* self, const char* skinName);


Attachment* Skeleton_getAttachmentForSlotName (const Skeleton* self, const char* slotName, const char* attachmentName);

Attachment* Skeleton_getAttachmentForSlotIndex (const Skeleton* self, int slotIndex, const char* attachmentName);

int Skeleton_setAttachment (Skeleton* self, const char* slotName, const char* attachmentName);

void Skeleton_update (Skeleton* self, float deltaTime);

}}
# 40 "Cacao/include/cocos2dext/spine/spine.h" 2

# 1 "Cacao/include/cocos2dext/spine/SkeletonJson.h" 1
# 35 "Cacao/include/cocos2dext/spine/SkeletonJson.h"
namespace cocos2d { namespace extension {

typedef struct {
 float scale;
 AttachmentLoader* attachmentLoader;
 const char* const error;
} SkeletonJson;

SkeletonJson* SkeletonJson_createWithLoader (AttachmentLoader* attachmentLoader);
SkeletonJson* SkeletonJson_create (Atlas* atlas);
void SkeletonJson_dispose (SkeletonJson* self);

SkeletonData* SkeletonJson_readSkeletonData (SkeletonJson* self, const char* json);
SkeletonData* SkeletonJson_readSkeletonDataFile (SkeletonJson* self, const char* path);

}}
# 42 "Cacao/include/cocos2dext/spine/spine.h" 2
# 30 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 2

# 1 "Cacao/include/cocos2dext/spine/CCSkeleton.h" 1
# 32 "Cacao/include/cocos2dext/spine/CCSkeleton.h"
namespace cocos2d { namespace extension {




class CCSkeleton: public cocos2d::CCNodeRGBA, public cocos2d::CCBlendProtocol {
public:
 Skeleton* skeleton;
 Bone* rootBone;
 float timeScale;
 bool debugSlots;
 bool debugBones;
 bool premultipliedAlpha;

 static CCSkeleton* createWithData (SkeletonData* skeletonData, bool ownsSkeletonData = false);
 static CCSkeleton* createWithFile (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 static CCSkeleton* createWithFile (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 CCSkeleton (SkeletonData* skeletonData, bool ownsSkeletonData = false);
 CCSkeleton (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 CCSkeleton (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 virtual ~CCSkeleton ();

 virtual void update (float deltaTime);
 virtual void draw ();
 virtual cocos2d::CCRect boundingBox ();


 void updateWorldTransform ();

 void setToSetupPose ();
 void setBonesToSetupPose ();
 void setSlotsToSetupPose ();


 Bone* findBone (const char* boneName) const;

 Slot* findSlot (const char* slotName) const;




 bool setSkin (const char* skinName);


 Attachment* getAttachment (const char* slotName, const char* attachmentName) const;

 bool setAttachment (const char* slotName, const char* attachmentName);


 protected: cocos2d::ccBlendFunc blendFunc;public: virtual cocos2d::ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(cocos2d::ccBlendFunc var);;
 virtual void setOpacityModifyRGB (bool value);
 virtual bool isOpacityModifyRGB ();

protected:
 CCSkeleton ();
 void setSkeletonData (SkeletonData* skeletonData, bool ownsSkeletonData);
 cocos2d::CCTextureAtlas* getTextureAtlas (RegionAttachment* regionAttachment) const;

private:
 bool ownsSkeletonData;
 Atlas* atlas;
 void initialize ();
};

}}
# 32 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 2
# 1 "Cacao/include/cocos2dext/spine/CCSkeletonAnimation.h" 1
# 33 "Cacao/include/cocos2dext/spine/CCSkeletonAnimation.h"
namespace cocos2d { namespace extension {




class CCSkeletonAnimation: public CCSkeleton {
public:
 std::vector<AnimationState*> states;

 static CCSkeletonAnimation* createWithData (SkeletonData* skeletonData);
 static CCSkeletonAnimation* createWithFile (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 static CCSkeletonAnimation* createWithFile (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 CCSkeletonAnimation (SkeletonData* skeletonData);
 CCSkeletonAnimation (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 CCSkeletonAnimation (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 virtual ~CCSkeletonAnimation ();

 virtual void update (float deltaTime);

 void addAnimationState (AnimationStateData* stateData = 0);
 void setAnimationStateData (AnimationStateData* stateData, int stateIndex = 0);
 void setMix (const char* fromAnimation, const char* toAnimation, float duration, int stateIndex = 0);
 void setAnimation (const char* name, bool loop, int stateIndex = 0);
 void addAnimation (const char* name, bool loop, float delay = 0, int stateIndex = 0);
 void clearAnimation (int stateIndex = 0);

protected:
 CCSkeletonAnimation ();

private:
 typedef CCSkeleton super;
 std::vector<AnimationStateData*> stateDatas;

 void initialize ();
};

}}
# 33 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 2

namespace cocos2d { namespace extension {

void RegionAttachment_updateQuad (RegionAttachment* self, Slot* slot, cocos2d::ccV3F_C4B_T2F_Quad* quad, bool premultiplied = false);

}}
# 82 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 12 "Cacao/include/cc_defs.hpp" 2






void setupTypeinfos();

typedef void(*queuefunc)(std::string);

typedef struct GameModes {
    bool cube;
    bool ship;
    bool ufo;
    bool ball;
    bool wave;
    bool robot;
    bool spider;
} GameModes;

typedef struct LevelDifficulty {
    int32_t denominator;
    int32_t numerator;
} LevelDifficulty;
# 51 "Cacao/include/cc_defs.hpp"
class GDObj {
public:
    void* valOffset(long offset);
    void setValOffset(long offset, void* setter);
};

class GJGameLevel : public GDObj {
public:
    inline std::string& _name() { if (this) { return *((std::string*)((long)this + 0x138)); } else { return *(std::string*)(-1); } };
    inline int& _levelId() { if (this) { return *((int*)((long)this + 0x130)); } else { return *(int*)(-1); } };
    inline int& _bestNormal() { if (this) { return *((int*)((long)this + 0x214)); } else { return *(int*)(-1); } };
    inline int& _bestPractice() { if (this) { return *((int*)((long)this + 0x238)); } else { return *(int*)(-1); } };
    inline std::string& _author() { if (this) { return *((std::string*)((long)this + 0x150)); } else { return *(std::string*)(-1); } };
    inline LevelDifficulty _difficulty() { return *(LevelDifficulty*)((long)this+0x1b0); };
};

class LevelSettingsObject : public GDObj {
public:
    inline GJGameLevel*& _level() { if (this) { return *((GJGameLevel**)((long)this + 0x150)); } else { return *(GJGameLevel**)(-1); } };
};

class GameLevelManager : public GDObj {
public:
    static GameLevelManager* sharedState();
    GJGameLevel* createNewLevel();
    inline cocos2d::CCDictionary*& _timerDict() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x1e8)); } else { return *(cocos2d::CCDictionary**)(-1); } };
};

class AppDelegate : public GDObj {
public:
    inline cocos2d::CCScene*& _runningScene() { if (this) { return *((cocos2d::CCScene**)((long)this + 0x28)); } else { return *(cocos2d::CCScene**)(-1); } };
    static AppDelegate* get();
};

class GameSoundManager : public GDObj {
public:
    static GameSoundManager* sharedManager();
    void stopBackgroundMusic();
    virtual ~GameSoundManager();
};

class GameObject : public cocos2d::CCSprite, public GDObj{
public:
    GameObject();
    void init(char const* frame);
    void setPosition(cocos2d::CCPoint const& pt);
    void destroyObject();
    int getGroupID(int index);
    void playShineEffect();
    inline int& _type() { if (this) { return *((int*)((long)this + 0x370)); } else { return *(int*)(-1); } };
    inline int& _id() { if (this) { return *((int*)((long)this + 0x3c4)); } else { return *(int*)(-1); } };
    inline bool& _touchTriggered() { if (this) { return *((bool*)((long)this + 0x378)); } else { return *(bool*)(-1); } };
    inline int& _uuid() { if (this) { return *((int*)((long)this + 0x36c)); } else { return *(int*)(-1); } };
};

class SpawnTriggerAction : public cocos2d::CCNode {
 public:
    bool timerEnded;
    float delay;
    float timer;
    int group;
    int uuid;
};

class EffectGameObject : public GameObject {
public:
    inline bool& _touchHoldMode() { if (this) { return *((bool*)((long)this + 0x579)); } else { return *(bool*)(-1); } };
};

class LabelGameObject : public GameObject {
 public:
  static LabelGameObject* create(char const* frame);
};

class PlayerObject : public GameObject {
public:
    static PlayerObject* create(int icn, int icon, cocos2d::CCLayer*);
    void addAllParticles();
    void setColor(cocos2d::_ccColor3B const&);
    void setSecondColor(cocos2d::_ccColor3B const&);
    void flipGravity(bool, bool);
    inline double& _yAccel() { if (this) { return *((double*)((long)this + 0x760)); } else { return *(double*)(-1); } };
    inline float& _xPos() { if (this) { return *((float*)((long)this + 0x7c8)); } else { return *(float*)(-1); } };
    inline bool& _isShip() { if (this) { return *((bool*)((long)this + 0x770)); } else { return *(bool*)(-1); } };
    inline bool& _isUpsideDown() { if (this) { return *((bool*)((long)this + 0x776)); } else { return *(bool*)(-1); } };
    inline float& _vSize() { if (this) { return *((float*)((long)this + 0x77c)); } else { return *(float*)(-1); } };
    inline bool& _isHolding() { if (this) { return *((bool*)((long)this + 0x745)); } else { return *(bool*)(-1); } };
    inline bool& _hasJustHeld() { if (this) { return *((bool*)((long)this + 0x746)); } else { return *(bool*)(-1); } };
};

class GJBaseGameLayer : public cocos2d::CCLayer, public GDObj {
public:
    void spawnGroup(int group);
    inline cocos2d::CCArray*& _objects() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x3a0)); } else { return *(cocos2d::CCArray**)(-1); } };
    inline PlayerObject*& _player1() { if (this) { return *((PlayerObject**)((long)this + 0x380)); } else { return *(PlayerObject**)(-1); } };
    inline PlayerObject*& _player2() { if (this) { return *((PlayerObject**)((long)this + 0x388)); } else { return *(PlayerObject**)(-1); } };
    inline LevelSettingsObject*& _levelSettings() { if (this) { return *((LevelSettingsObject**)((long)this + 0x390)); } else { return *(LevelSettingsObject**)(-1); } };
    inline cocos2d::CCDictionary*& _unknownDict() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x398)); } else { return *(cocos2d::CCDictionary**)(-1); } };
};

class LevelEditorLayer : public GJBaseGameLayer {
public:
    void createObjectsFromString(std::string st, bool idk);
    void removeAllObjects();
    void undoLastAction();
    void redoLastAction();
    inline cocos2d::CCArray*& _objects() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x3a0)); } else { return *(cocos2d::CCArray**)(-1); } };
};

class EditButtonBar : public cocos2d::CCNode, public GDObj {
 public:
    void loadFromItems(cocos2d::CCArray*, int, int, bool);
    inline cocos2d::CCArray*& _objectSlots() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x130)); } else { return *(cocos2d::CCArray**)(-1); } };
};
class EditorUI : public cocos2d::CCLayer, public GDObj {
public:
    void pasteObjects(std::string str);
    void undoLastAction();
    void redoLastAction();
    CCMenuItemSpriteExtra* getCreateBtn(int obid, int four);
    cocos2d::CCArray* getSelectedObjects();
    void selectObjects(cocos2d::CCArray* objs, bool keep);
    inline LevelEditorLayer*& _editorLayer() { if (this) { return *((LevelEditorLayer**)((long)this + 0x408)); } else { return *(LevelEditorLayer**)(-1); } };
    inline cocos2d::CCArray*& _editBars() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x358)); } else { return *(cocos2d::CCArray**)(-1); } };
};

class PlayLayer : public GJBaseGameLayer {
public:
    static PlayLayer* create();
    inline float& _length() { if (this) { return *((float*)((long)this + 0x5f8)); } else { return *(float*)(-1); } };
    inline int& _attempt() { if (this) { return *((int*)((long)this + 0x754)); } else { return *(int*)(-1); } };
    inline bool& _practiceMode() { if (this) { return *((bool*)((long)this + 0x739)); } else { return *(bool*)(-1); } };
    inline float& _time() { if (this) { return *((float*)((long)this + 0x760)); } else { return *(float*)(-1); } };
    inline GameModes _gameModes() { return *(GameModes*)((long)this+0x76f); };
};

class ObjectToolbox : public GDObj {
public:
    static ObjectToolbox* sharedState();
    inline cocos2d::CCDictionary*& _strKeyObjects() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x120)); } else { return *(cocos2d::CCDictionary**)(-1); } };
    inline cocos2d::CCDictionary*& _intKeyObjects() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x128)); } else { return *(cocos2d::CCDictionary**)(-1); } };
};

class ButtonSprite : public cocos2d::CCSprite, public GDObj {
public:
    static ButtonSprite* create(char const* text, int width, int relativeWidth, float scale, bool relative);
};

class FLAlertLayer : public cocos2d::CCLayerColor, public GDObj {
public:
    FLAlertLayer();
    static FLAlertLayer* create(void* fdsg, char const* x, const std::string &thing, char const* l, char const* u, float f);

    static FLAlertLayer* create(char const* title, const std::string &desc, char const* btn) {
        return FLAlertLayer::create(__null, title, desc, btn, __null, 300.0);
    }
    virtual ~FLAlertLayer();
    virtual void onEnter(void);
    virtual bool ccTouchBegan(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void ccTouchMoved(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void ccTouchEnded(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void ccTouchCancelled(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void registerWithTouchDispatcher(int);
    virtual void keyBackClicked(void);
    virtual void keyDown(cocos2d::enumKeyCodes);
    int show(void);
    inline cocos2d::CCLayer*& _mainLayer() { if (this) { return *((cocos2d::CCLayer**)((long)this + 0x220)); } else { return *(cocos2d::CCLayer**)(-1); } };
    inline cocos2d::CCMenu*& _mainMenu() { if (this) { return *((cocos2d::CCMenu**)((long)this + 0x1f8)); } else { return *(cocos2d::CCMenu**)(-1); } };
};


class TextArea : public ButtonSprite {
public:
    static TextArea* create(std::string a, char const*, float textSize, float maxWidth, cocos2d::CCPoint position, float returnSize, bool idk);
};


class MenuLayer : public cocos2d::CCLayer, public GDObj {
public:
    void onQuit(cocos2d::CCObject*);
    void keyBackClicked();
};
class MoreVideoOptionsLayer : public FLAlertLayer {
public:
    static MoreVideoOptionsLayer* create();
    bool init();

};

class GJSearchObject : public GDObj {
public:
    static GJSearchObject* create(int, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int);
};

class LevelBrowserLayer : public GDObj {
public:
    static cocos2d::CCScene* scene(GJSearchObject* search);
};

class EditorPauseLayer : public GDObj {
public:
    static EditorPauseLayer* create(LevelEditorLayer* editor);
    void saveLevel();
    virtual ~EditorPauseLayer();
};

class PauseLayer : public FLAlertLayer {

};

class GJAccountManager : public GDObj {
public:
    static GJAccountManager* sharedState();

    inline char const*& _password() { if (this) { return *((char const**)((long)this + 0x128)); } else { return *(char const**)(-1); } };
    inline char const*& _username() { if (this) { return *((char const**)((long)this + 0x130)); } else { return *(char const**)(-1); } };
};

class GameManager : public GDObj {
public:
    static GameManager* sharedState();
    bool getGameVariable(char const* var);
    void setGameVariable(char const* var, bool val);
    void fadeInMusic(char const* ye);
    void reloadAllStep5();
    void doQuickSave();
    void reloadAll(bool a, bool b, bool c);
    void accountStatusChanged();
    void load();

    void setSecondColorIdx(int idx);
    void setFirstColorIdx(int idx);
    cocos2d::_ccColor3B const& colorForIdx(int idx);
    std::string& manFile();
    virtual ~GameManager();

    inline PlayLayer*& _playLayer() { if (this) { return *((PlayLayer**)((long)this + 0x180)); } else { return *(PlayLayer**)(-1); } };
    inline LevelEditorLayer*& _editorLayer() { if (this) { return *((LevelEditorLayer**)((long)this + 0x188)); } else { return *(LevelEditorLayer**)(-1); } };
    inline int& _scene() { if (this) { return *((int*)((long)this + 0x1f4)); } else { return *(int*)(-1); } };
};

class InfoLayer : public cocos2d::CCLayer, public GDObj {
public:
    void loadPage(int type, bool yes);
    void onRefreshComments(cocos2d::CCObject*);
    void onClose(cocos2d::CCObject*);
    inline cocos2d::CCLayer*& _mainLayer() { if (this) { return *((cocos2d::CCLayer**)((long)this + 0x220)); } else { return *(cocos2d::CCLayer**)(-1); } };
    inline cocos2d::CCMenu*& _rightMenu() { if (this) { return *((cocos2d::CCMenu**)((long)this + 0x1f8)); } else { return *(cocos2d::CCMenu**)(-1); } };
};

class CCMenuItemToggler : public cocos2d::CCNodeRGBA, public GDObj {
public:
    static CCMenuItemToggler* create(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, void (cocos2d::CCObject::*)(cocos2d::CCObject*));
    void setSizeMult(float);
};

class CCTextInputNode : public cocos2d::CCNode, public cocos2d::CCIMEDelegate, public GDObj {
public:
    static CCTextInputNode* create(float x, float y, char const* placeholder, char const* font, int, char const*);
    void setAllowedChars(std::string allowed);
    void setMaxLabelScale(float max);
    void setMaxLabelWidth(float max);
    std::string getString();
    char const* getString_s();
};

class GJEffectManager : public cocos2d::CCNode, public GDObj {
 public:
    inline GJBaseGameLayer*& _gameLayer() { if (this) { return *((GJBaseGameLayer**)((long)this + 0x120)); } else { return *(GJBaseGameLayer**)(-1); } };
    inline cocos2d::CCArray*& _spawnActions() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x1c18)); } else { return *(cocos2d::CCArray**)(-1); } };
};

class SetupSpawnPopup : public FLAlertLayer {
 public:
    inline EffectGameObject*& _object() { if (this) { return *((EffectGameObject**)((long)this + 0x258)); } else { return *(EffectGameObject**)(-1); } };
    void createToggleButton(std::string name, void (cocos2d::CCObject::*)(cocos2d::CCObject*), bool enabled, cocos2d::CCMenu* menu, cocos2d::CCPoint location, cocos2d::CCArray* idk);
};
# 6 "Cacao/include/Cacao.hpp" 2


namespace Cacao {
    typedef void (cocos2d::CCObject::* CC_SEL)(cocos2d::CCObject*);

    cocos2d::CCPoint relativePosition(double x, double y);
    cocos2d::CCPoint addedPosition(double x, double y);
    cocos2d::CCSprite* spriteFromPng(unsigned char* img, int img_len);

    CCMenuItemToggler* createToggler(cocos2d::CCObject* parent, CC_SEL callback);
    void addGDObject(char const* name, int id);

    class FLDialogHelper;

    class FLDialogDelegate {
    protected:
        virtual void onSubmit(FLDialogHelper* dl, const std::string& text);
        virtual void onCancel(FLDialogHelper* dl);
        virtual void onShow(FLDialogHelper* dl);
        friend class FLDialogHelper;
    };

    class FLDialogHelper : public cocos2d::CCNode {
     public:
        static FLDialogHelper* create(FLDialogDelegate* del, char const* title, char const* submit, char const* cancel, char const* placeholder);

        static FLDialogHelper* create(FLDialogDelegate* del, char const* title, char const* submit, char const* cancel);
        static FLDialogHelper* create(FLDialogDelegate* del, char const* title, char const* submit);
        static FLDialogHelper* create(FLDialogDelegate* del, char const* title);
        static FLDialogHelper* create(FLDialogDelegate* del);
        static FLDialogHelper* create();
        void close();
        void show();

        bool initWithStuff(FLDialogDelegate* delegate, char const* title, char const* submit, char const* cancel, char const* placeholder);
     protected:
        FLAlertLayer* alertLayer;
        cocos2d::CCLayer* mainLayer;
        CCTextInputNode* textNode;
        FLDialogDelegate* del;
     private:
        void onSubmit(cocos2d::CCObject*);
        void onCancel(cocos2d::CCObject*);
    };
}
# 3 "Cacao/include/Cacao.cpp" 2

using namespace cocos2d;

namespace Cacao {
    cocos2d::CCPoint relativePosition(double x, double y) {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        float xp = winSize.width * (x/100.);
        float yp = winSize.height * (y/100.);
        CCPoint ccp;
        ccp.x = xp;
        ccp.y = yp;
        return ccp;
    }
    cocos2d::CCPoint addedPosition(double x, double y) {
        auto winSize = cocos2d::CCDirector::sharedDirector()->getWinSize();
        float xp = winSize.width/2 + x;
        float yp = winSize.height/2 + y;
        CCPoint ccp;
        ccp.x = xp;
        ccp.y = yp;
        return ccp;
    }
    cocos2d::CCSprite* spriteFromPng(unsigned char* img, int img_len) {
        auto image = new cocos2d::CCImage();
        image->initWithImageData((void*)img, img_len, cocos2d::CCImage::kFmtPng,1,1,1);

        auto text = new cocos2d::CCTexture2D();
        text->initWithImage(image);

        cocos2d::CCRect r(0, 0, image->getWidth(), image->getHeight());

        std::cout << image->getWidth() << "\n";
        std::cout << image->getHeight() << "\n";

        auto sprite = cocos2d::CCSprite::create();
        sprite->initWithTexture(text, r);

        sprite->setTexture(text);

        return sprite;
    }

    void addGDObject(char const* name, int id) {
        auto toolbox = ObjectToolbox::sharedState();
        CCDictionary* keyInt = toolbox->_intKeyObjects();
        CCDictionary* keyStr = toolbox->_strKeyObjects();

        auto strid = CCString::createWithFormat("%i", id);
        auto strname = CCString::createWithFormat("%s", name);

        keyStr->setObject(strid, std::string(name));
        keyInt->setObject(strname, id);
    }

    CCMenuItemToggler* createToggler(cocos2d::CCObject* parent, CC_SEL callback) {
        auto on = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");
        auto off = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
        return CCMenuItemToggler::create(off, on, parent, callback);
    }

    void FLDialogDelegate::onSubmit(FLDialogHelper* dl, const std::string& text) {dl->close();}
    void FLDialogDelegate::onCancel(FLDialogHelper* dl) {dl->close();}
    void FLDialogDelegate::onShow(FLDialogHelper* dl) {}

    FLDialogHelper* FLDialogHelper::create(FLDialogDelegate* del, char const* title, char const* submit, char const* cancel, char const* placeholder) {
        FLDialogHelper* pRet = new FLDialogHelper();
        if (pRet->initWithStuff(del, title, submit, cancel, placeholder)) {
            return pRet;
        }
        delete pRet;
        return __null;
    }

    FLDialogHelper* FLDialogHelper::create(FLDialogDelegate* del, char const* title, char const* submit, char const* cancel) {
        return FLDialogHelper::create(del, title, submit, cancel, "Insert text");
    }
    FLDialogHelper* FLDialogHelper::create(FLDialogDelegate* del, char const* title, char const* submit) {
        return FLDialogHelper::create(del, title, submit, "Cancel");
    }
    FLDialogHelper* FLDialogHelper::create(FLDialogDelegate* del, char const* title) {
        return FLDialogHelper::create(del, title, "Submit");
    }
    FLDialogHelper* FLDialogHelper::create(FLDialogDelegate* del) {
        return FLDialogHelper::create(del, "Cacao Prompt");
    }
    FLDialogHelper* FLDialogHelper::create() {
        return FLDialogHelper::create(__null);
    }

    void FLDialogHelper::close() {
        alertLayer->keyBackClicked();
    }
    void FLDialogHelper::onSubmit(CCObject*) {
        std::string text(textNode->getString_s());
        del->onSubmit(this, text);
    }

    void FLDialogHelper::onCancel(CCObject*) {
        del->onCancel(this);
    }

    bool FLDialogHelper::initWithStuff(FLDialogDelegate* delegate, char const* title, char const* submit, char const* cancel, char const* placeholder) {
        if (delegate) {
            del = delegate;
        } else {
            del = new FLDialogDelegate();
        }


        alertLayer = FLAlertLayer::create("ok","ok","ok");
        mainLayer = alertLayer->_mainLayer();

        CCArray* ch = alertLayer->_mainLayer()->getChildren();

        for (int i=0; i<ch->count(); i++) {



            auto ob = ch->objectAtIndex(i);
            if ((getBase()+0x682FC0) == *((long*)ob)) {
                CCArray* ch2 = ((CCNode*)ob)->getChildren();
                for (int i=0; i<ch2->count(); i++) {
                    ((CCMenuItem*)ch2->objectAtIndex(i))->setVisible(false);
                }
            } else {
                ((CCNode*)ob)->setVisible(false);
            }
        }

        CCSize wSize = CCDirector::sharedDirector()->getWinSize();

            CCRect squareRect(0,0,80,80);
            float squareHeight = 135.f;
            float squareY = 80.f;
            CCPoint squarePosition = {wSize.width/2.f, wSize.height/2.f + squareY};
            CCPoint titlePosition = {squarePosition.x, (float)(squarePosition.y + squareHeight/2. - 16)};
            CCPoint menuPosition = {squarePosition.x, squarePosition.y - 60};

            auto label = CCLabelBMFont::create(title, "bigFont.fnt");
            label->setPosition(titlePosition);
            label->setScale(0.6);
            mainLayer->addChild(label);

            float textWidth = 360.0;
            float textHeight = 50.0;

            auto input = CCTextInputNode::create(textWidth, textHeight, placeholder, "Thonburi", 12, __null);
            input->setPosition(squarePosition);
            mainLayer->addChild(input);
            textNode = input;

            CCPoint colOffset = {-100, -8};
            auto lay = CCLayerColor::create(ccc4(230,230,230,150), 200, 16);
            lay->setPosition(squarePosition + colOffset);
            mainLayer->addChild(lay);

            auto canc = ButtonSprite::create(cancel, 90, 0, 1, true);
            auto menuCancel = CCMenuItemSpriteExtra::create(canc, canc, this, (SEL_MenuHandler)(&FLDialogHelper::onCancel));
            menuCancel->setScale(0.8);

            auto subm = ButtonSprite::create(submit, 90, 0, 1, true);
            auto menuSubmit = CCMenuItemSpriteExtra::create(subm, subm, this, (SEL_MenuHandler)(&FLDialogHelper::onSubmit));
            CCPoint offset(50, 0);
            menuSubmit->setScale(0.8);

            for (int i=0; i<ch->count(); i++) {


                auto ob = ch->objectAtIndex(i);
                if ((getBase()+0x682FC0) == *((long*)ob)) {
                    CCMenu* m = (CCMenu*)ob;
                    menuSubmit->setPosition(m->convertToNodeSpace(menuPosition + offset));
                    menuCancel->setPosition(m->convertToNodeSpace(menuPosition - offset));

                    m->addChild(menuSubmit);
                    m->addChild(menuCancel);
                    break;
                }
            }

        return true;
    }
    void FLDialogHelper::show() {
        del->onShow(this);
        alertLayer->show();
    }
}
# 1 "speedchange.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 390 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "speedchange.cpp" 2
# 1 "Cacao/include/Cacao.hpp" 1




# 1 "Cacao/include/cc_defs.hpp" 1





# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 1 3
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 1 3
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 1 3
# 27 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 1 3
# 32 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 1 3
# 417 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_symbol_aliasing.h" 1 3
# 418 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 2 3
# 494 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_posix_availability.h" 1 3
# 495 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 2 3
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_types.h" 1 3
# 32 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_types.h" 1 3
# 37 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_types.h" 3
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_types.h" 3
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;





typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_types.h" 2 3
# 34 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 2 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 3
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[1168]; };
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_types.h" 3
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
# 28 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 2 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_types.h" 3
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/unistd.h" 1 3
# 138 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/unistd.h" 3
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/Availability.h" 1 3
# 141 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/Availability.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/AvailabilityInternal.h" 1 3
# 142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/Availability.h" 2 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3



typedef __darwin_gid_t gid_t;




typedef __darwin_intptr_t intptr_t;




typedef __darwin_off_t off_t;




typedef __darwin_pid_t pid_t;






typedef __darwin_size_t size_t;




typedef __darwin_ssize_t ssize_t;




typedef __darwin_uid_t uid_t;




typedef __darwin_useconds_t useconds_t;
# 468 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
extern "C" {
void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int, const void *, size_t) __asm("_" "write" );
}
# 545 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
extern "C" {
size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;
}
# 570 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
 extern "C" {




void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);



char *ctermid(char *);


void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((__const__)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" );

ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" );





void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void);


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}
# 657 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
extern "C" {
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}








# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/appleapiopts.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 88 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};







struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 183 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[_n/(sizeof(__int32_t) * 8)] & (1<<(_n % (sizeof(__int32_t) * 8))));
}
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3








typedef __darwin_time_t time_t;




typedef __darwin_suseconds_t suseconds_t;




typedef __darwin_sigset_t sigset_t;
# 134 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 3
extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )




  __asm("_" "pselect" "$1050")




  ;



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_select.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_select.h" 3
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )




  __asm("_" "select" "$1050")




  ;
# 153 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3

}
# 673 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 2 3



typedef __darwin_dev_t dev_t;




typedef __darwin_mode_t mode_t;




typedef __darwin_uuid_t uuid_t;


extern "C" {
void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
int gethostuuid(uuid_t, const struct timespec *) __attribute__((visibility("default")));
mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" );



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
# 772 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/unistd.h" 3
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((visibility("default")));

extern int optreset;

}
# 62 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 2 3


extern "C" {
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/os_defines.h" 3
extern void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1(void);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1(void);
extern void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1(void);


}
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpu_defines.h" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 2 3
# 153 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 3
namespace std {
# 165 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++config.h" 3
}
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 1 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/clocale" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/clocale" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_locale.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_locale.h" 3
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};





extern "C" {
struct lconv *localeconv(void);
}
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 2 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/locale.h" 3
extern "C" {
char *setlocale(int, const char *);
}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/clocale" 2 3





namespace std {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstddef" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstddef" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 1 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 3
typedef __darwin_ptrdiff_t ptrdiff_t;
# 100 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 3
typedef __darwin_wint_t wint_t;
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstddef" 2 3

namespace std {

  using ::ptrdiff_t;
  using ::size_t;

}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 1 3
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" );
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
}
# 113 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
char *strtok_r(char *, const char *, char **);
}
# 125 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);
}
# 139 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((visibility("default")));
char *strndup(const char *, size_t) __attribute__((visibility("default")));
size_t strnlen(const char *, size_t) __attribute__((visibility("default")));
char *strsignal(int sig);
}
# 158 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 3
extern "C" {
void *memmem(const void *, size_t, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern4(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern8(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern16(void *, const void *, size_t) __attribute__((visibility("default")));

char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);


void swab(const void * , void * , ssize_t);
}







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/strings.h" 1 3
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/strings.h" 3
extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((visibility("default")));
int fls(int) __attribute__((visibility("default")));
int flsl(long) __attribute__((visibility("default")));
}


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 1 3
# 95 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/strings.h" 2 3
# 181 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/string.h" 2 3
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 2 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstring" 3
namespace std {

  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }

}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 1 3
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
typedef __darwin_va_list va_list;
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
typedef __darwin_off_t fpos_t;
# 96 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 130 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 238 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen" );

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
# 296 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
# 306 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
}
# 318 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen" );

}
# 340 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







static inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 377 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


char *tempnam(const char *, const char *) __asm("_" "tempnam" );
}
# 417 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}



extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 445 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdio.h" 3
extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((visibility("default")));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((visibility("default")));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((visibility("default")));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((visibility("default")));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char **, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 2 3
# 98 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3
namespace std {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 155 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3
namespace __gnu_cxx {
# 170 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdarg" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdarg" 3


# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.0/include/stdarg.h" 1 3 4
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdarg" 2 3






namespace std {

  using ::va_list;

}
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++locale.h" 2 3



namespace std {

  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, __null);
    char* __sav = __null;
    if (std::strcmp(__old, "C"))
      {
 __sav = new char[std::strlen(__old) + 1];
 std::strcpy(__sav, __old);
 std::setlocale(4, "C");
      }

    va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = std::vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }

}
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++io.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++io.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 1 3
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 114 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 1 3
# 57 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread_impl.h" 1 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sched.h" 1 3
# 30 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sched.h" 3
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_structs.h" 1 3
# 24 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 25 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_structs.h" 2 3
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 2 3







typedef __darwin_clock_t clock_t;
# 90 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 3
struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 113 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/time.h" 3
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" );

}
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 2 3



typedef __darwin_pthread_attr_t pthread_attr_t;




typedef __darwin_pthread_cond_t pthread_cond_t;




typedef __darwin_pthread_condattr_t pthread_condattr_t;




typedef __darwin_pthread_key_t pthread_key_t;




typedef __darwin_pthread_mutex_t pthread_mutex_t;




typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;




typedef __darwin_pthread_once_t pthread_once_t;




typedef __darwin_pthread_rwlock_t pthread_rwlock_t;




typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;




typedef __darwin_pthread_t pthread_t;






typedef __darwin_mach_port_t mach_port_t;
# 149 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 3
extern "C" {
# 250 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/pthread.h" 3
int pthread_atfork(void (*)(void), void (*)(void),
                      void (*)(void));
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(const pthread_attr_t *,
          int *);
int pthread_attr_getguardsize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_getinheritsched(const pthread_attr_t * ,
           int * );
int pthread_attr_getschedparam(const pthread_attr_t * ,
                                     struct sched_param * );
int pthread_attr_getschedpolicy(const pthread_attr_t * ,
          int * );
int pthread_attr_getscope(const pthread_attr_t * , int * );
int pthread_attr_getstack(const pthread_attr_t * ,
                                      void ** , size_t * );
int pthread_attr_getstackaddr(const pthread_attr_t * ,
                                      void ** );
int pthread_attr_getstacksize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *,
          int );
int pthread_attr_setguardsize(pthread_attr_t *, size_t );
int pthread_attr_setinheritsched(pthread_attr_t *,
           int );
int pthread_attr_setschedparam(pthread_attr_t * ,
                                     const struct sched_param * );
int pthread_attr_setschedpolicy(pthread_attr_t *,
          int );
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_setstack(pthread_attr_t *,
                                      void *, size_t );
int pthread_attr_setstackaddr(pthread_attr_t *,
                                      void *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t );
int pthread_cancel(pthread_t ) __asm("_" "pthread_cancel" );

int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t * ,
                            const pthread_condattr_t * ) __asm("_" "pthread_cond_init" );
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t * ,
     pthread_mutex_t * ,
     const struct timespec * ) __asm("_" "pthread_cond_timedwait" );
int pthread_cond_wait(pthread_cond_t * ,
       pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_getpshared(const pthread_condattr_t * ,
   int * );
int pthread_condattr_setpshared(pthread_condattr_t *,
   int );
int pthread_create(pthread_t * ,
                         const pthread_attr_t * ,
                         void *(*)(void *),
                         void * );
int pthread_detach(pthread_t );
int pthread_equal(pthread_t ,
   pthread_t );
void pthread_exit(void *) __attribute__((__noreturn__));
int pthread_getconcurrency(void);
int pthread_getschedparam(pthread_t , int * , struct sched_param * );
void *pthread_getspecific(pthread_key_t );
int pthread_join(pthread_t , void **) __asm("_" "pthread_join" );
int pthread_key_create(pthread_key_t *, void (*)(void *));
int pthread_key_delete(pthread_key_t );
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t * , int * );
int pthread_mutex_init(pthread_mutex_t * , const pthread_mutexattr_t * );
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_setprioceiling(pthread_mutex_t * , int, int * );
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_gettype(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int );
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );
int pthread_rwlock_init(pthread_rwlock_t * , const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init" );
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
   int * );
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,
   int );
pthread_t pthread_self(void);

int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate" );
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype" );
int pthread_setconcurrency(int);
int pthread_setschedparam(pthread_t ,
    int ,
                                const struct sched_param *);
int pthread_setspecific(pthread_key_t ,
         const void *);
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );



int pthread_is_threaded_np(void);

int pthread_threadid_np(pthread_t,__uint64_t*) __attribute__((visibility("default")));

int pthread_rwlock_longrdlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_yieldwrlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_downgrade_np(pthread_rwlock_t *);
int pthread_rwlock_upgrade_np(pthread_rwlock_t *);
int pthread_rwlock_tryupgrade_np(pthread_rwlock_t *);
int pthread_rwlock_held_np(pthread_rwlock_t *);
int pthread_rwlock_rdheld_np(pthread_rwlock_t *);
int pthread_rwlock_wrheld_np(pthread_rwlock_t *);


int pthread_getname_np(pthread_t,char*,size_t) __attribute__((visibility("default")));
int pthread_setname_np(const char*) __attribute__((visibility("default")));

int pthread_main_np(void);


mach_port_t pthread_mach_thread_np(pthread_t);
size_t pthread_get_stacksize_np(pthread_t);
void * pthread_get_stackaddr_np(pthread_t);


int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);


int pthread_cond_timedwait_relative_np(pthread_cond_t *,
     pthread_mutex_t *,
     const struct timespec *);


int pthread_create_suspended_np(pthread_t *,
                         const pthread_attr_t *,
                         void *(*)(void *),
                         void *);
int pthread_kill(pthread_t, int);

pthread_t pthread_from_mach_thread_np(mach_port_t) __attribute__((visibility("default")));

int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
void pthread_yield_np(void);

}
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 2 3


typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
# 214 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 571 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}


static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t attr;
      int r;

      r = pthread_mutexattr_init (&attr);
      if (!r)
 r = pthread_mutexattr_settype (&attr, 2);
      if (!r)
 r = pthread_mutex_init (mutex, &attr);
      if (!r)
 r = pthread_mutexattr_destroy (&attr);
      return r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
# 115 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++io.h" 2 3

namespace std {

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/runetype.h" 1 3
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/runetype.h" 3
typedef __darwin_ct_rune_t ct_rune_t;




typedef __darwin_rune_t rune_t;
# 81 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/runetype.h" 3
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 2 3
# 145 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

static inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 164 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


static inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

static inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 204 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/ctype.h" 3
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


static inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






static inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

static inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

static inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

static inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


static inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

static inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

static inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

static inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

static inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

static inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

static inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


static inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

static inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

static inline int
tolower(int _c)
{
        return (__tolower(_c));
}

static inline int
toupper(int _c)
{
        return (__toupper(_c));
}


static inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

static inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

static inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

static inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

static inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

static inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

static inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 2 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cctype" 3
namespace std {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stringfwd.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stringfwd.h" 3



namespace std {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;


}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ctime" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ctime" 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ctime" 3
namespace std {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 1 3
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
typedef __darwin_mbstate_t mbstate_t;
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 1 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 3
typedef __darwin_wctype_t wctype_t;
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 3
static inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

static inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

static inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

static inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

static inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

static inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

static inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

static inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

static inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

static inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

static inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

static inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

static inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

static inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 176 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/_wctype.h" 3
extern "C" {
wctype_t
 wctype(const char *);
}
# 117 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 2 3



extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...) ;
int fwscanf(FILE * , const wchar_t * , ...) ;
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * ,
     ...) ;
int swscanf(const wchar_t * , const wchar_t * , ...) ;
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list) ;
int vwprintf(const wchar_t * , __darwin_va_list) ;
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...) ;
int wscanf(const wchar_t * , ...) ;
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list) ;
int vwscanf(const wchar_t * , __darwin_va_list) ;
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** ) ;

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 219 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wchar.h" 3
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((visibility("default")));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((visibility("default")));
wchar_t *wcsdup(const wchar_t *) __attribute__((visibility("default")));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((visibility("default")));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((visibility("default")));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((visibility("default")));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((visibility("default")));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 2 3
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::mbstate_t;

}
# 144 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }

}







namespace __gnu_cxx {






  using ::wcstold;
# 262 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 1 3
# 20 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 3
typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int64_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long uint64_t;



typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 3
typedef unsigned long uintptr_t;







typedef long int intmax_t;
# 106 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdint.h" 3
typedef long unsigned int uintmax_t;
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 2 3


namespace std {
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;

  template<typename _StateT>
    class fpos;
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

}
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/functexcept.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/functexcept.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception_defines.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/functexcept.h" 2 3

namespace std {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

}
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 2 3

namespace std {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 135 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 112 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx {
# 127 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/exception" 3
  void __verbose_terminate_handler ();

}

}

#pragma GCC visibility pop
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/climits" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/climits" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/limits.h" 1 3





# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/limits.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/limits.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_limits.h" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/limits.h" 2 3
# 7 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/limits.h" 2 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/syslimits.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/limits.h" 2 3
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/climits" 2 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 1 3
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;
# 95 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
typedef __darwin_id_t id_t;
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 1 3
# 81 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/signal.h" 1 3
# 32 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 3
typedef int sig_atomic_t;
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 1 3
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/signal.h" 2 3
# 33 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/signal.h" 2 3
# 82 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 2 3
# 148 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 57 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_structs.h" 1 3
# 29 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 1 3
# 38 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
# 402 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 454 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
# 751 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 2 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 86 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 127 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/_structs.h" 2 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 2 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
# 128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};
# 218 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
typedef struct __darwin_sigaltstack stack_t;
# 227 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3
typedef struct __darwin_ucontext ucontext_t;
# 149 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 2 3
# 175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 348 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
typedef void (*sig_t)(int);
# 365 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 384 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 406 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/signal.h" 3
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 117 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 1 3
# 77 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 2 3
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
typedef __uint64_t rlim_t;
# 151 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 162 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 222 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 244 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/resource.h" 3
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((visibility("default")));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((visibility("default")));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
# 118 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3
# 193 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/endian.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/endian.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/endian.h" 1 3
# 99 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/endian.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_endian.h" 1 3
# 124 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_endian.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((_data << 8) | (_data >> 8));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 2 3
# 125 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_endian.h" 2 3
# 100 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/endian.h" 2 3
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/endian.h" 2 3
# 194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 254 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/wait.h" 3
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/alloca.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/alloca.h" 3
extern "C" {
void *alloca(size_t);
}
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3
# 97 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 134 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
extern int __mb_cur_max;
# 144 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
extern "C" {
void abort(void) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((visibility("default")));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **) ;

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system" );
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" );
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/types.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/types.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/types.h" 1 3
# 80 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/types.h" 3
typedef unsigned char u_int8_t;




typedef unsigned short u_int16_t;




typedef unsigned int u_int32_t;




typedef unsigned long long u_int64_t;


typedef int64_t register_t;
# 114 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/types.h" 3
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/types.h" 2 3
# 256 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3
# 267 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stdlib.h" 3
u_int32_t
  arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((visibility("default")));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((visibility("default")));

int atexit_b(void (^)(void)) __attribute__((visibility("default")));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((visibility("default")));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((deprecated,visibility("default")));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((visibility("default")));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((visibility("default")));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 2 3
# 104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
namespace std {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 161 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
namespace __gnu_cxx {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_pair.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_pair.h" 3
namespace std {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }

}
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
namespace __gnu_cxx {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std {

namespace __detail
{


  typedef char __one;
  typedef char __two[2];

  template<typename _Tp>
  __one __test_type(int _Tp::*);
  template<typename _Tp>
  __two& __test_type(...);
}


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };


  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   __value = (sizeof(__detail::__test_type<_Tp>(0))
       != sizeof(__detail::__one))
 };
    };




  template<typename _Tp>
    struct __is_empty
    {
    private:
      template<typename>
        struct __first { };
      template<typename _Up>
        struct __second
        : public _Up { };

    public:
      enum
 {
   __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)
 };
    };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


}
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/type_traits.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/type_traits.h" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/utility" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/utility" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 1 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
namespace std {

  namespace rel_ops
  {
# 90 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 103 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 129 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/utility" 2 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/type_traits.h" 2 3


namespace __gnu_cxx {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;

}
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3

namespace std {
# 80 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/concept_check.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/concept_check.h" 3
# 70 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 2 3

namespace std {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 113 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 171 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 76 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 1 3
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
namespace std {
# 93 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
# 384 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 410 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 444 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 459 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 484 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 518 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 537 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 579 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 614 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx {
# 633 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 730 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 77 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/debug/debug.h" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}

namespace __gnu_cxx
{
  namespace __debug { };
}

namespace __gnu_debug
{
  using namespace std::__debug;
  using namespace __gnu_cxx::__debug;
}
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

namespace std {
# 91 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = *__a;
          *__a = *__b;
          *__b = __tmp;
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 141 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
# 160 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
 __are_same<_ValueType1 &, _ReferenceType1>::__value &&
 __are_same<_ValueType2 &, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 180 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 202 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 224 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 244 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }







  template<bool, typename>
    struct __copy
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy<_BoolType, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };

  template<>
    struct __copy<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<typename _II, typename _OI>
    inline _OI
    __copy_aux(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
    }


  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT*, _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT*, const _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
        _CharT*);

  template<bool, bool>
    struct __copy_normal
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_normal<true, false>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first.base(), __last.base(), __result); }
    };

  template<>
    struct __copy_normal<false, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
    };

  template<>
    struct __copy_normal<true, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first.base(), __last.base(),
         __result.base())); }
    };
# 387 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {




                                                     ;

       const bool __in = __is_normal_iterator<_InputIterator>::__value;
       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
       return std::__copy_normal<__in, __out>::__copy_n(__first, __last,
       __result);
    }


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                 ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  ostreambuf_iterator<_CharT>);

  template<bool, typename>
    struct __copy_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy_backward<_BoolType, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };

  template<>
    struct __copy_backward<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueType1>::__value
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_backward<__simple, _Category>::__copy_b(__first,
         __last,
         __result);
    }

  template<bool, bool>
    struct __copy_backward_normal
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_backward_normal<true, false>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first.base(), __last.base(),
       __result); }
    };

  template<>
    struct __copy_backward_normal<false, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first, __last,
            __result.base())); }
    };

  template<>
    struct __copy_backward_normal<true, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
            __result.base())); }
    };
# 524 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
      return std::__copy_backward_normal<__bi1, __bi2>::__copy_b_n(__first,
           __last,
           __result);
    }

  template<bool>
    struct __fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   for (; __first != __last; ++__first)
     *__first = __value;
 }
    };

  template<>
    struct __fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __first != __last; ++__first)
     *__first = __tmp;
 }
    };
# 581 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      const bool __scalar = __is_scalar<_Tp>::__value;
      std::__fill<__scalar>::fill(__first, __last, __value);
    }


  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
                                                   ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
                                                   ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
                                                   ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<bool>
    struct __fill_n
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   for (; __n > 0; --__n, ++__first)
     *__first = __value;
   return __first;
 }
    };

  template<>
    struct __fill_n<true>
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __n > 0; --__n, ++__first)
     *__first = __tmp;
   return __first;
 }
    };
# 657 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {



      const bool __scalar = __is_scalar<_Tp>::__value;
      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
    }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(signed char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 704 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 739 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 769 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
# 801 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
# 833 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {
# 847 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 873 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {



                                                       ;
                                                       ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
                                                     ;
                                                     ;

    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
                                                     ;
                                                     ;


    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);






  }

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 2 3


namespace __gnu_cxx {
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3
  template <class _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(std::memmove(__s1, __s2,
            __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std {
# 225 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>(((__darwin_wint_t)-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/localefwd.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/localefwd.h" 3






namespace std {


  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/atomic_word.h" 1 3
# 37 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 2 3

namespace __gnu_cxx {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 1 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/allocator.h" 1 3
# 53 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/allocator.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++allocator.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++allocator.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 1 3
# 37 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/new" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/new" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 95 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 38 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 2 3


namespace __gnu_cxx {

  using std::size_t;
  using std::ptrdiff_t;
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/c++allocator.h" 2 3
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/allocator.h" 2 3



namespace std {

  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = std::__is_empty<_Alloc>::__value>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };

}
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
namespace std {







  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }







  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {


      ::new(static_cast<void*>(__p)) _T1();
    }






  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    {
      for (; __first != __last; ++__first)
 std::_Destroy(&*__first);
    }
# 134 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
# 146 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename std::__is_scalar<_Value_type>::__type
                _Has_trivial_destructor;

      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
# 166 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>)
    {
      _Destroy(__first, __last);
    }

}
# 56 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
namespace std {


  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
# 106 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 168 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { std::fill_n(__first, __n, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }
# 213 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      _Allocator __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      allocator<_Tp>)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        allocator<_Tp2>)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 318 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last,
         _Allocator __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }

}
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_raw_storage_iter.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_raw_storage_iter.h" 3
namespace std {





  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };

}
# 59 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
# 150 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
namespace std {






  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 192 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;





    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };





  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -9223372036854775807L - 1; }
      static long max() throw()
      { return 9223372036854775807L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 9223372036854775807L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 2 3

namespace std {
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 108 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    inline pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
# 120 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
# 132 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 173 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 199 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 211 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 222 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 239 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 269 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      element_type&
      operator*() const throw()
      {
                                   ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
                                   ;
 return _M_ptr;
      }
# 299 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 313 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 328 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 349 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
  };

}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream_insert.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream_insert.h" 3



namespace std {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
namespace std {
# 101 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template <class _Arg1, class _Arg2, class _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 133 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template <class _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template <class _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template <class _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template <class _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template <class _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 195 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template <class _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template <class _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template <class _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template <class _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template <class _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 256 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template <class _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template <class _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 311 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) {}

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template <class _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template <class _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
        bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x)
      : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template <class _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 391 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    };


  template <class _Operation, class _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template <class _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    };


  template <class _Operation, class _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
# 480 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Arg, class _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() {}

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template <class _Arg, class _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template <class _Arg1, class _Arg2, class _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() {}

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template <class _Arg1, class _Arg2, class _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template <class _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template <class _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template <class _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 582 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_function.h" 3
  template <class _Ret, class _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };


  template <class _Ret, class _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };


  template <class _Ret, class _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template <class _Ret, class _Tp, class _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) {}

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template <class _Ret, class _Tp, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) {}

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template <class _Ret, class _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template <class _Ret, class _Tp, class _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3




namespace std {
# 110 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 147 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 172 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {
   this->_M_set_sharable();
   this->_M_length = __n;
   traits_type::assign(this->_M_refdata()[__n], _S_terminal);


 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __x, size_type __y)
      {
         if (__x > __y)
            return 1;
         if (__x < __y)
            return -1;
         return 0;
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 463 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 518 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 629 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 642 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 671 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 699 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }
# 716 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

                                       ;

                                         ;
 _M_leak();
 return _M_data()[__pos];
      }
# 737 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 756 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }






      basic_string&
      append(const basic_string& __str);
# 816 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }
# 848 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 859 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 898 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 914 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 926 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }
# 942 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 954 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 971 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 986 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1002 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1024 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1047 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1065 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1088 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1105 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1129 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1145 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1165 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {

                            ;
        const size_type __pos = __first - _M_ibegin();
 _M_mutate(__pos, __last - __first, size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1192 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1214 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1238 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1257 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1298 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1316 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1337 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1358 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1380 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }

      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __true_type)
 { return _S_construct(static_cast<size_type>(__beg),
         static_cast<value_type>(__end), __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1511 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1521 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1531 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1563 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1576 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1590 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1607 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1620 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1635 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1648 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1665 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1678 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1693 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1706 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1725 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1739 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1754 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1767 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1786 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1800 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1815 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1829 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1846 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1859 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1875 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1888 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1905 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1920 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 1938 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 1968 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 1992 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2010 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2033 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2058 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2079 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2150 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }
# 2224 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2261 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2298 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2335 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2372 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2389 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2407 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2430 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2447 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/algorithm" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/algorithm" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
namespace std {




  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 139 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;


      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
# 251 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;
                                              ;

      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
# 317 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                           ;

      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
# 342 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 382 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 420 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;


      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--));
    }
# 446 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--), __comp);
    }

}
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tempbuf.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tempbuf.h" 3
namespace std {
# 76 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tempbuf.h" 3
  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

      void
      _M_initialize_buffer(const _Tp&, __true_type) { }

      void
      _M_initialize_buffer(const _Tp& __val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, __val); }

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {

      typedef typename std::__is_scalar<_Tp>::__type _Trivial;

      try
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 2 3




namespace std {
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {


      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 119 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {


      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
# 151 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }






  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }






  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  const _CharT&);
# 316 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 338 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 360 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 391 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 422 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 446 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 485 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 556 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 628 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }
# 662 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 720 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 747 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !__binary_pred(*__first, __val))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
 }
      return __last;
    }
# 787 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!__binary_pred(*__lookAhead, __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 848 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 884 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
# 900 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                       ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 922 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 957 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 989 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 1020 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 1053 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 1089 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 1123 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
# 1149 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 1176 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1212 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1251 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
# 1286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
# 1312 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
# 1337 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1362 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1384 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(*__first, *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
# 1415 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1446 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1487 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 1527 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 1560 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1599 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1633 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }
# 1655 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1682 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1708 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
# 1736 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }






  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }






  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   swap(*__first, *--__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }






  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }

    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }

   *__p = __tmp;
   ++__first;
 }
    }
# 1915 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1948 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }
# 1974 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 2001 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }

      return __first;
    }






  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 2095 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }







  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 2206 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }







  enum { _S_threshold = 16 };






  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }






  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
# 2535 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 2573 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 2612 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2632 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2677 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2701 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }






  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }






  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
# 2814 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 2849 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 2882 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2932 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2979 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 3029 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }






  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3227 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3247 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 3288 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3309 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }






  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
# 3711 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





                                                  ;
                                                 ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3765 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






                                                               ;
                                                              ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
# 3874 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 3915 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 4030 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 4068 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 4107 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 4168 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;







                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 4226 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                            ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 4258 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





                                                                         ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 4297 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4345 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4363 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4394 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4415 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4460 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4483 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4526 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4545 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4582 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4603 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4639 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4658 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4699 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4720 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4756 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4777 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4821 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4845 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4879 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 4906 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 4958 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 4993 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5049 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5160 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5219 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 5255 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 5285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 5435 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 5480 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }

}
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/algorithm" 2 3
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.tcc" 1 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.tcc" 3

namespace std {

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__is_null_pointer(__beg) && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 559 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 59 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/string" 2 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 2 3


namespace std {
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 104 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 123 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale() throw();
# 132 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 157 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 170 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 182 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 196 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 211 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 230 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 258 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 274 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 309 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 342 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 373 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    inline void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

 inline void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch (...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 433 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }




   inline void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);




   inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = std::strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 2 3

namespace std {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 201 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 328 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 359 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;





    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 392 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 418 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 435 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 447 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:






    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    inline fmtflags
    flags() const { return _M_flags; }
# 557 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 573 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 590 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 617 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline streamsize
    precision() const { return _M_precision; }






    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    inline streamsize
    width() const { return _M_width; }






    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 666 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 678 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 689 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline locale
    getloc() const { return _M_ios_locale; }
# 699 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }
# 717 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 733 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 754 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 771 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3








namespace std {






  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 123 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
# 146 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_aux(istreambuf_iterator<_CharT2>,
     istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 195 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;






      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 223 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 240 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 294 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 312 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 334 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 353 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 367 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 392 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 419 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 445 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 459 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 477 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 493 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 504 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 524 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 550 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 571 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 586 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 597 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 609 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 622 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int
      sync() { return 0; }
# 644 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 660 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 682 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 695 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 719 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 737 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 762 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 791 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 3
    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf.tcc" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf.tcc" 3

namespace std {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 821 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/streambuf" 2 3
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf_iterator.h" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/streambuf_iterator.h" 3




namespace std {



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_aux(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
     _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      {
 const bool __thiseof = _M_at_eof();
 const bool __beof = __b._M_at_eof();
 return (__thiseof && __beof || (!__thiseof && !__beof));
      }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT* __first, _CharT* __last,
        ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT* __first, const _CharT* __last,
        ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT> __first,
        istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

}
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 1 3
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 1 3
# 39 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 3
typedef __darwin_wctrans_t wctrans_t;
# 62 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 3
static inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


static inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

static inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

static inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

static inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

static inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

static inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

static inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 130 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/wctype.h" 3
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 54 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 2 3
# 80 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cwctype" 3
namespace std {

  using ::wint_t;

  using ::wctype_t;
  using ::wctrans_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_base.h" 1 3
# 38 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_base.h" 3
namespace std {


  struct ctype_base
  {

    typedef const int* __to_type;

    typedef unsigned long mask;


    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask xdigit = 0x00010000L;
    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask graph = 0x00000100L | 0x00000400L | 0x00002000L;
    static const mask cntrl = 0x00000200L;
    static const mask punct = 0x00002000L;
    static const mask alnum = 0x00000100L | 0x00000400L;
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_base.h" 3
  };

}
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3





namespace std {
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, const streamsize __newlen,
      const streamsize __oldlen, const bool __num);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline



 ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 148 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 166 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 183 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 199 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 215 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 229 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 244 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 258 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 273 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 290 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 309 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 328 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 350 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 375 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 394 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 413 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 432 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 450 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 467 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 483 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 500 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 519 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 562 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 586 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 609 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 678 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 715 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 728 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 741 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 756 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 770 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 784 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 799 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 816 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 832 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 849 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 869 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 896 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 927 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 960 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }

    protected:


      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();







      virtual
      ~ctype();
# 1007 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1024 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1040 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1057 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1077 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1100 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1126 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1152 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:

      void _M_widen_init() const
      {
 char __tmp[sizeof(_M_widen)];
 for (size_t __i = 0; __i < sizeof(_M_widen); ++__i)
   __tmp[__i] = __i;
 do_widen(__tmp, __tmp + sizeof(__tmp), _M_widen);

 _M_widen_ok = 1;

 if (memcmp(__tmp, _M_widen, sizeof(_M_widen)))
   _M_widen_ok = 2;
      }




      void _M_narrow_init() const
      {
 char __tmp[sizeof(_M_narrow)];
 for (size_t __i = 0; __i < sizeof(_M_narrow); ++__i)
   __tmp[__i] = __i;
 do_narrow(__tmp, __tmp + sizeof(__tmp), 0, _M_narrow);

 _M_narrow_ok = 1;
 if (memcmp(__tmp, _M_narrow, sizeof(_M_narrow)))
   _M_narrow_ok = 2;
 else
   {


     char __c;
     do_narrow(__tmp, __tmp + 1, 1, &__c);
     if (__c == 1)
       _M_narrow_ok = 2;
   }
      }
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 1216 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1249 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1260 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;


      virtual
      ~ctype();
# 1284 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1303 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1321 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1339 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1356 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1373 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1389 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1406 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1426 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1448 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1471 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1497 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype();
    };

  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_inline.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_inline.h" 3
namespace std {




bool
  ctype<char>::
  is(mask __m, char __c) const
  {
    if (_M_table)
      return _M_table[static_cast<unsigned char>(__c)] & __m;
    else
      return __istype(__c, __m);
  }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    if (_M_table)
      while (__low < __high)
 *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    else
      for (;__low < __high; ++__vec, ++__low)
 {

   *__vec = __maskrune (*__low, upper | lower | alpha | digit | xdigit
          | space | print | graph | cntrl | punct | alnum);
# 86 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ctype_inline.h" 3
 }
    return __high;
  }




const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
 ++__low;
    else
      while (__low < __high && !this->is(__m, *__low))
 ++__low;
    return __low;
  }




const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
 ++__low;
    else
      while (__low < __high && this->is(__m, *__low) != 0)
 ++__low;
    return __low;
  }


  inline bool
  ctype<wchar_t>::
  do_is(mask __m, wchar_t __c) const
  {
    return __istype (__c, __m);
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const
  {
    for (; __lo < __hi; ++__vec, ++__lo)
      *__vec = __maskrune (*__lo, upper | lower | alpha | digit | xdigit
      | space | print | graph | cntrl | punct | alnum);
    return __hi;
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_is(mask __m, const wchar_t* __lo, const wchar_t* __hi) const
  {
    while (__lo < __hi && ! __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }

  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
  {
    while (__lo < __hi && __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }


}
# 1537 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 1 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3

namespace std {


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 119 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 158 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 199 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 240 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };

}
# 1540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3

namespace std {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1664 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1701 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1715 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1729 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1742 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1773 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1786 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1799 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1816 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1828 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1841 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1854 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1867 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1934 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1955 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1981 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2017 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2076 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2118 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string& __xtrc) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT& __v) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2189 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
       unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2248 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2265 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2304 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2346 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2409 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2434 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2482 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2539 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 2566 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 2580 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 2597 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 2616 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 2630 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 2659 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 2675 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 2688 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };
# 2748 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 2906 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const;


}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/time_members.h" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/time_members.h" 3
namespace std {

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      const size_t __len = std::strlen(__s) + 1;
      char* __tmp = new char[__len];
      std::memcpy(__tmp, __s, __len);
      _M_name_timepunct = __tmp;

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }

}
# 3044 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3

namespace std {
# 3059 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 3081 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 3098 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 3122 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 3147 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 3175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 3204 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 3230 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 3250 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual dateorder
      do_date_order() const;
# 3268 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3287 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 3306 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 3325 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 3344 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;



      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 3400 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 3421 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 3440 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 3460 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 3487 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 3525 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }







  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 3646 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 3658 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 3673 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 3687 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 3700 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 3729 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 3742 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 3759 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 3776 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 3792 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 3827 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 3849 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 3861 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 3874 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 3887 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 3900 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 3913 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 3927 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 3941 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 3955 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;
# 4047 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 4069 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 4099 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 4129 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 4152 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 4164 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 4175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 4196 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 4217 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 4237 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 4259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 4293 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 4316 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 4327 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;






  struct messages_base
  {
    typedef int catalog;
  };
# 4366 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 4394 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      messages(size_t __refs = 0);
# 4408 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 4421 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 4439 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 4457 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 4468 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 4488 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 4507 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 4564 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/messages_members.h" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/messages_members.h" 3
namespace std {


  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }

}
# 4603 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.h" 2 3

namespace std {







  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 2 3

namespace std {
# 55 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 122 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 133 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 186 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 207 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 242 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
      _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 280 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 292 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 332 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 346 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 375 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 395 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 415 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const;
# 433 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 3
      char_type
      widen(char __c) const;

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
      _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.tcc" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.tcc" 3

namespace std {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    { return __check_facet(_M_ctype).narrow(__c, __dfault); }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    { return __check_facet(_M_ctype).widen(__c); }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 160 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 466 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/basic_ios.h" 2 3
# 51 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ios" 2 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 2 3


namespace std {
# 58 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 85 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 111 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 168 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 286 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 314 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 327 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      flush();
# 338 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      pos_type
      tellp();
# 349 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 361 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      explicit
      basic_ostream() { }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 383 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 402 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 412 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      ~sentry()
      {

 if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 430 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 451 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 493 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 543 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream.tcc" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream.tcc" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/locale" 1 3
# 42 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/locale" 3




# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 1 3
# 40 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 1 3
# 41 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 60 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name; }
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }

    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
# 127 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/typeinfo" 3
  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 2 3



namespace std {

  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 87 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }
# 109 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _Facet>
    inline const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__np.grouping()[0]) > 0);

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(__mp.grouping()[0]) > 0);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;

      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;

      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;

      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }
# 272 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  static bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err |= ios_base::failbit;
        }


      if (__testeof)
        __err |= ios_base::eofbit;
      return __beg;
    }





  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     if (numeric_limits<_ValueT>::is_signed)
       __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 const __unsigned_type __max = __negative ?
   -numeric_limits<_ValueT>::min() : numeric_limits<_ValueT>::max();
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testfail = true;
       else
  {
    __result *= __base;
    __testfail |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testfail = true;
    else
      {
        __result *= __base;
        __testfail |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err |= ios_base::failbit;
   }

 if (!__testfail && (__sep_pos || __found_zero
       || __found_grouping.size()))
   __v = __negative ? -__result : __result;
 else
   __err |= ios_base::failbit;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = __l;
   else
            __err |= ios_base::failbit;
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   size_t __n;
   bool __testeof = __beg == __end;
          for (__n = 0; !__testeof; ++__n)
            {
       const char_type __c = *__beg;

       if (__testf)
  if (__n < __lc->_M_falsename_size)
    __testf = __c == __lc->_M_falsename[__n];
  else
    break;

       if (__testt)
  if (__n < __lc->_M_truename_size)
    __testt = __c == __lc->_M_truename[__n];
  else
    break;

       if (!__testf && !__testt)
  break;

       if (++__beg == __end)
  __testeof = true;
            }
   if (__testf && __n == __lc->_M_falsename_size)
     __v = 0;
   else if (__testt && __n == __lc->_M_truename_size)
     __v = 1;
   else
     __err |= ios_base::failbit;

          if (__testeof)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    { return _M_extract_int(__beg, __end, __io, __err, __v); }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }
# 864 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags(__fmt & ~ios_base::basefield | ios_base::hex);

      unsigned long __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      if (!(__err & ios_base::failbit))
 __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
        __w, __len, true);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = (__v > 0 || !__dec) ? __v : -__v;
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v > 0)
       {
  if (__flags & ios_base::showpos
      && numeric_limits<_ValueT>::is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else if (__v)
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (__flags & ios_base::showbase && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 1093 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits = numeric_limits<_ValueT>::digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1152 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       _CharT* __cs
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __w));
       _M_pad(__fill, __w, __io, __cs, __name, __len);
       __name = __cs;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_insert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1291 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase
      | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<unsigned long>(__v));
      __io.flags(__flags);
      return __s;
    }

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || __mandatory_sign
         && (static_cast<part>(__p.field[3])
      == money_base::sign))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __lc->_M_frac_digits > 0
  && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 1547 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 1752 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }







      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }






  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __tmperr);
    break;
  case 'Y':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }


  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val = *__lo + ((__val << 7) |
         (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
# 2503 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       const streamsize __newlen,
       const streamsize __oldlen, const bool __num)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, const_cast<_CharT*>(__olds), __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal && __num)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   const bool __testsign = (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0]);
   const bool __testhex = (__ctype.widen('0') == __olds[0]
      && __oldlen > 1
      && (__ctype.widen('x') == __olds[1]
          || __ctype.widen('X') == __olds[1]));
   if (__testhex)
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
   else if (__testsign)
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, const_cast<_CharT*>(__olds + __mod),
      __oldlen - __mod);
    }

  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp)
  {
    const size_t __n = __grouping_tmp.size() - 1;
    const size_t __min = std::min(__n, size_t(__grouping_size - 1));
    size_t __i = __n;
    bool __test = true;




    for (size_t __j = 0; __j < __min && __test; --__i, ++__j)
      __test = __grouping_tmp[__i] == __grouping[__j];
    for (; __i && __test; --__i)
      __test = __grouping_tmp[__i] == __grouping[__min];



    if (static_cast<signed char>(__grouping[__min]) > 0)
      __test &= __grouping_tmp[0] <= __grouping[__min];
    return __test;
  }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);



}
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/locale" 2 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/ostream.tcc" 2 3

namespace std {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch (...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   _CharT* __ws = 0;
   try
     {
       __ws = new _CharT[__clen];
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
     }
   catch(...)
     {
       delete [] __ws;
       __out._M_setstate(ios_base::badbit);
       return __out;
     }

   try
     {
       __ostream_insert(__out, __ws, __clen);
       delete [] __ws;
     }
   catch(...)
     {
       delete [] __ws;
       throw;
     }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 573 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/ostream" 2 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3




namespace std {
# 57 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

    protected:







      streamsize _M_gcount;

    public:
# 103 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb): _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 130 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 177 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 249 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 291 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      int_type
      get();
# 305 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(char_type& __c);
# 332 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 343 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 366 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 376 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 405 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 416 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 440 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 457 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      int_type
      peek();
# 475 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 494 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 510 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      putback(char_type __c);
# 525 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      unget();
# 543 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      int
      sync();
# 557 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      pos_type
      tellg();
# 572 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      seekg(pos_type);
# 588 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      explicit
      basic_istream(): _M_gcount(streamsize(0)) { }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 645 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 677 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 687 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
      operator bool() const
      { return _M_ok; }

    private:
      bool _M_ok;
    };
# 707 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 748 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 775 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(), __ostream_type()
      { this->init(__sb); }




      virtual
      ~basic_iostream() { }

    protected:
      explicit
      basic_iostream() : __istream_type(), __ostream_type()
      { }
    };
# 838 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/istream.tcc" 1 3
# 45 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/istream.tcc" 3




namespace std {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && (__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (numeric_limits<short>::min() <= __l
       && __l <= numeric_limits<short>::max())
     __n = __l;
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (numeric_limits<int>::min() <= __l
       && __l <= numeric_limits<int>::max())
     __n = __l;
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 429 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == numeric_limits<streamsize>::max()
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount = numeric_limits<streamsize>::min();
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = numeric_limits<streamsize>::max();

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount < numeric_limits<streamsize>::max())
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = numeric_limits<streamsize>::max();

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       __in.width(0);
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __sb->sbumpc();
  }
       else
  __err |= ios_base::failbit;
     }
   catch(...)
     {



       __in._M_setstate(ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 846 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/istream" 2 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 2 3

namespace std {
# 63 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 7 "Cacao/include/cc_defs.hpp" 2

# 1 "Cacao/include/GDML/GDML.hpp" 1







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 3






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
namespace std {






  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 _Tp* _M_start;
 _Tp* _M_finish;
 _Tp* _M_end_of_storage;
 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
   if (__n)
   {
     this->_M_impl._M_start = this->_M_allocate(__n);
     this->_M_impl._M_finish = this->_M_impl._M_start;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   }
      }

      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      _Tp*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 161 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a)
      { }
# 212 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_start + __n;
      }
# 231 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 254 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 282 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 295 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 311 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }



      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 418 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }





      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 461 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 476 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 491 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 516 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 534 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 580 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 599 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 620 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 638 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 654 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 672 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 697 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 718 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 730 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:






      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }





      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }






      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      void
      _M_insert_aux(iterator __position, const value_type& __x);





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 940 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 957 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_bvector.h" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_bvector.h" 3
namespace std {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<class _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base(const allocator_type& __a) : _M_impl(__a) { }

      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std {
# 455 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    explicit
    vector(const allocator_type& __a = allocator_type())
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    template<class _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }





    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<class _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }

    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }

    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= size_type(-1) / int(_S_word_bit) ?
       __asize * int(_S_word_bit) : size_type(-1));
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector<bool, _Alloc>& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<class _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }

    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }


    template<class _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(__n);
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<class _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<class _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<class _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }

    template<class _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign((size_t) __n, (bool) __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<class _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<class _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }


    template<class _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<class _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len = size() + std::max(size(), __n);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    template<class _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<class _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len = size() + std::max(size(), __n);
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

    void
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len = size() ? 2 * size()
                                  : static_cast<size_type>(_S_word_bit);
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 72 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/vector.tcc" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/vector.tcc" 3
namespace std {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n, this->_M_impl._M_start,
            this->_M_impl._M_finish);
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
        _M_insert_aux(__position, __x);
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      *(this->_M_impl._M_finish - 1));
   ++this->_M_impl._M_finish;
   _Tp __x_copy = __x;
   std::copy_backward(__position.base(),
        this->_M_impl._M_finish - 2,
        this->_M_impl._M_finish - 1);
   *__position = __x_copy;
 }
      else
 {
   const size_type __old_size = size();
   if (__old_size == this->max_size())
     __throw_length_error(("vector::_M_insert_aux"));




   size_type __len = __old_size != 0 ? 2 * __old_size : 1;
   if (__len < __old_size)
     __len = this->max_size();

   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {
       __new_finish =
  std::__uninitialized_copy_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       this->_M_impl.construct(__new_finish, __x);
       ++__new_finish;
       __new_finish =
  std::__uninitialized_copy_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
   catch(...)
     {
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n,
         __old_finish);
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_copy_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __old_size = size();
       if (this->max_size() - __old_size < __n)
  __throw_length_error(("vector::_M_fill_insert"));


       size_type __len = __old_size + std::max(__old_size, __n);
       if (__len < __old_size)
  __len = this->max_size();

       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish =
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    std::__uninitialized_fill_n_a(__new_finish, __n, __x,
      _M_get_Tp_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_copy_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp, _Alloc>::
    _M_range_insert(iterator __pos, _InputIterator __first,
      _InputIterator __last, std::input_iterator_tag)
    {
      for (; __first != __last; ++__first)
 {
   __pos = insert(__pos, *__first);
   ++__pos;
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_copy_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n,
           __old_finish);
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_copy_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __old_size = size();
  if (this->max_size() - __old_size < __n)
    __throw_length_error(("vector::_M_range_insert"));


  size_type __len = __old_size + std::max(__old_size, __n);
  if (__len < __old_size)
    __len = this->max_size();

  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_copy_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last, __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }

}
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/vector" 2 3
# 9 "Cacao/include/GDML/GDML.hpp" 2

using namespace std;





typedef void(*func_t)();

#pragma GCC visibility push(default)

class BaseContainer {
protected:
    long address;
    size_t byteCount;
    char* originalBytes;
    char* moddedBytes;

public:
    virtual ~BaseContainer();
    void enable();
    void disable();
    friend class ModContainer;
};

class MemoryContainer : public BaseContainer{
public:
    MemoryContainer(long address, size_t byteCount, char* bytes);
    ~MemoryContainer();
};

class HookContainer : public BaseContainer {
public:
    HookContainer(long address, func_t function);
    func_t getOriginal();
    ~HookContainer();
private:
    func_t original;


};

class ModContainer
{
public:
    static vector<ModContainer*> containers;
    template <typename S>
    static ModContainer* containerByName(S name);
    ModContainer(char const* name);
    ~ModContainer();
    void enable();
    void disable();
    void registerWrite(long address, size_t byteCount, char* bytes);

    template <typename F>
    F registerHook(long address, F function) {
        HookContainer* hook = new HookContainer(address, (func_t)function);
        mods.push_back(hook);
        return (F)hook->getOriginal();
    }

    func_t getOriginal(long address);
    char const* getName();
private:
    vector<BaseContainer*> mods;
    char const* containerName;
};

struct OriginalNotFoundException : public exception
{
  const char * what () const throw ()
  {
    return "Cannot find the original address of this function";
  }
};

struct ModNotFoundException : public exception
{
  const char * what () const throw ()
  {
    return "Cannot find the mod container given the name";
  }
};

long getBase();

void inject(void) __attribute__((constructor));
#pragma GCC visibility pop
# 9 "Cacao/include/cc_defs.hpp" 2
# 1 "Cacao/include/cocos2dx/custom/Sprites/CCMenuItemSpriteExtra/CCMenuItemSpriteExtra.h" 1

# 1 "Cacao/include/cocos2dx/cocos2d.h" 1
# 38 "Cacao/include/cocos2dx/cocos2d.h"
# 1 "Cacao/include/cocos2dx/include/ccConfig.h" 1
# 30 "Cacao/include/cocos2dx/include/ccConfig.h"
# 1 "Cacao/include/cocos2dx/platform/CCPlatformConfig.h" 1
# 31 "Cacao/include/cocos2dx/include/ccConfig.h" 2
# 39 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/actions/CCAction.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCAction.h"
# 1 "Cacao/include/cocos2dx/cocoa/CCObject.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCObject.h"
# 1 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h"
# 1 "Cacao/include/cocos2dx/platform/CCPlatformMacros.h" 1
# 32 "Cacao/include/cocos2dx/platform/CCPlatformMacros.h"
# 1 "Cacao/include/cocos2dx/platform/mac/CCPlatformDefine.h" 1



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 1 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 3
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));



}
# 5 "Cacao/include/cocos2dx/platform/mac/CCPlatformDefine.h" 2
# 33 "Cacao/include/cocos2dx/platform/CCPlatformMacros.h" 2
# 29 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h" 2


namespace cocos2d {

class CCObject;
class CCBool;
class CCInteger;
class CCFloat;
class CCDouble;
class CCString;
class CCArray;
class CCDictionary;
class CCSet;
# 64 "Cacao/include/cocos2dx/cocoa/CCDataVisitor.h"
class CCDataVisitor
{
public:
    virtual ~CCDataVisitor() {}


    virtual void visitObject(const CCObject *p) = 0;

    virtual void visit(const CCBool *p);
    virtual void visit(const CCInteger *p);
    virtual void visit(const CCFloat *p);
    virtual void visit(const CCDouble *p);
    virtual void visit(const CCString *p);
    virtual void visit(const CCArray *p);
    virtual void visit(const CCDictionary *p);
    virtual void visit(const CCSet *p);
};





class CCPrettyPrinter : public CCDataVisitor
{
public:
    CCPrettyPrinter(int indentLevel = 0);

    virtual void clear();
    virtual std::string getResult();

    virtual void visitObject(const CCObject *p);
    virtual void visit(const CCBool * p);
    virtual void visit(const CCInteger *p);
    virtual void visit(const CCFloat *p);
    virtual void visit(const CCDouble *p);
    virtual void visit(const CCString *p);
    virtual void visit(const CCArray *p);
    virtual void visit(const CCDictionary *p);
    virtual void visit(const CCSet *p);
private:
    void setIndentLevel(int indentLevel);
    int _indentLevel;
    std::string _indentStr;
    std::string _result;
};




}
# 29 "Cacao/include/cocos2dx/cocoa/CCObject.h" 2




class DS_Dictionary;
namespace cocos2d {






class CCZone;
class CCObject;
class CCNode;
class CCEvent;
enum CCObjectType {
};




class CCCopying
{
public:
    virtual CCObject* copyWithZone(CCZone* pZone);
};




class CCObject : public CCCopying
{
public:

    unsigned int m_uID;

    int m_nLuaID;
protected:
    unsigned int m_uTag;

    unsigned int m_uReference;

    CCObjectType m_CCObjectType;


    unsigned int m_uAutoReleaseCount;

    unsigned int m_uPadding;
public:
    CCObject(void);



    virtual ~CCObject(void);

    void release(void);
    void retain(void);
    CCObject* autorelease(void);
    CCObject* copy(void);
    bool isSingleReference(void) const;
    unsigned int retainCount(void) const;
    virtual bool isEqual(const CCObject* pObject);

    virtual void acceptVisitor(CCDataVisitor &visitor);
    virtual void update(float dt) {(void)dt;};
    virtual void encodeWithCoder(DS_Dictionary*);
    virtual bool canEncode();
    virtual int getTag() const;
    virtual void setTag(int);

    friend class CCAutoreleasePool;
};


typedef void (CCObject::*SEL_SCHEDULE)(float);
typedef void (CCObject::*SEL_CallFunc)();
typedef void (CCObject::*SEL_CallFuncN)(CCNode*);
typedef void (CCObject::*SEL_CallFuncND)(CCNode*, void*);
typedef void (CCObject::*SEL_CallFuncO)(CCObject*);
typedef void (CCObject::*SEL_MenuHandler)(CCObject*);
typedef void (CCObject::*SEL_EventHandler)(CCEvent*);
typedef int (CCObject::*SEL_Compare)(CCObject*);
# 125 "Cacao/include/cocos2dx/cocoa/CCObject.h"
}
# 31 "Cacao/include/cocos2dx/actions/CCAction.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCGeometry.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCGeometry.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/math.h" 1 3
# 28 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/math.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 1 3
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern "C" {
# 49 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
 typedef float float_t;
 typedef double double_t;
# 108 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern int __math_errhandling ( void );
# 128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern int __fpclassifyf(float );
extern int __fpclassifyd(double );
extern int __fpclassify (long double);
# 163 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
 static __inline__ int __inline_isfinitef (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinited (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinite (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isinff (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinfd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinf (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnanf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnand (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnan (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormalf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormald (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormal (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbit (long double) __attribute__ ((always_inline));

 static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
 static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
 static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
 static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
 static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
 static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
 static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
 static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
 static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
 static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
 static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
 static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); }
 static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= 1.17549435e-38F; }
 static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= 2.2250738585072014e-308; }
 static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= 3.36210314311209350626e-4932L; }
# 253 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern double acos( double );
extern float acosf( float );

extern double asin( double );
extern float asinf( float );

extern double atan( double );
extern float atanf( float );

extern double atan2( double, double );
extern float atan2f( float, float );

extern double cos( double );
extern float cosf( float );

extern double sin( double );
extern float sinf( float );

extern double tan( double );
extern float tanf( float );

extern double acosh( double );
extern float acoshf( float );

extern double asinh( double );
extern float asinhf( float );

extern double atanh( double );
extern float atanhf( float );

extern double cosh( double );
extern float coshf( float );

extern double sinh( double );
extern float sinhf( float );

extern double tanh( double );
extern float tanhf( float );

extern double exp ( double );
extern float expf ( float );

extern double exp2 ( double );
extern float exp2f ( float );

extern double expm1 ( double );
extern float expm1f ( float );

extern double log ( double );
extern float logf ( float );

extern double log10 ( double );
extern float log10f ( float );

extern double log2 ( double );
extern float log2f ( float );

extern double log1p ( double );
extern float log1pf ( float );

extern double logb ( double );
extern float logbf ( float );

extern double modf ( double, double * );
extern float modff ( float, float * );

extern double ldexp ( double, int );
extern float ldexpf ( float, int );

extern double frexp ( double, int * );
extern float frexpf ( float, int * );

extern int ilogb ( double );
extern int ilogbf ( float );

extern double scalbn ( double, int );
extern float scalbnf ( float, int );

extern double scalbln ( double, long int );
extern float scalblnf ( float, long int );

extern double fabs( double );
extern float fabsf( float );

extern double cbrt( double );
extern float cbrtf( float );

extern double hypot ( double, double );
extern float hypotf ( float, float );

extern double pow ( double, double );
extern float powf ( float, float );

extern double sqrt( double );
extern float sqrtf( float );

extern double erf( double );
extern float erff( float );

extern double erfc( double );
extern float erfcf( float );






extern double lgamma( double );
extern float lgammaf( float );

extern double tgamma( double );
extern float tgammaf( float );

extern double ceil ( double );
extern float ceilf ( float );

extern double floor ( double );
extern float floorf ( float );

extern double nearbyint ( double );
extern float nearbyintf ( float );

extern double rint ( double );
extern float rintf ( float );

extern long int lrint ( double );
extern long int lrintf ( float );

extern double round ( double );
extern float roundf ( float );

extern long int lround ( double );
extern long int lroundf ( float );



    extern long long int llrint ( double );
    extern long long int llrintf ( float );
    extern long long int llround ( double );
    extern long long int llroundf ( float );


extern double trunc ( double );
extern float truncf ( float );

extern double fmod ( double, double );
extern float fmodf ( float, float );

extern double remainder ( double, double );
extern float remainderf ( float, float );

extern double remquo ( double, double, int * );
extern float remquof ( float, float, int * );

extern double copysign ( double, double );
extern float copysignf ( float, float );

extern double nan( const char * );
extern float nanf( const char * );

extern double nextafter ( double, double );
extern float nextafterf ( float, float );

extern double fdim ( double, double );
extern float fdimf ( float, float );

extern double fmax ( double, double );
extern float fmaxf ( float, float );

extern double fmin ( double, double );
extern float fminf ( float, float );

extern double fma ( double, double, double );
extern float fmaf ( float, float, float );

extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double exp2l(long double);
extern long double expm1l(long double);
extern long double logl(long double);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);
extern long double logbl(long double);
extern long double modfl(long double, long double *);
extern long double ldexpl(long double, int);
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double scalbnl(long double, int);
extern long double scalblnl(long double, long int);
extern long double fabsl(long double);
extern long double cbrtl(long double);
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double erfl(long double);
extern long double erfcl(long double);






extern long double lgammal(long double);

extern long double tgammal(long double);
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
extern long double rintl(long double);
extern long int lrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);



    extern long long int llrintl(long double);
    extern long long int llroundl(long double);


extern long double truncl(long double);
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);
# 507 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern double __inf( void );
extern float __inff( void );
extern long double __infl( void );
extern float __nan( void );


extern double j0 ( double );

extern double j1 ( double );

extern double jn ( int, double );

extern double y0 ( double );

extern double y1 ( double );

extern double yn ( int, double );

extern double scalb ( double, double );
# 543 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern int signgam;
# 558 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
extern long int rinttol ( double );


extern long int roundtol ( double );
# 643 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3
}
# 29 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/math.h" 2 3
# 31 "Cacao/include/cocos2dx/cocoa/CCGeometry.h" 2

namespace cocos2d {







class CCSize;




class CCPoint
{
public:
    float x;
    float y;

public:
    CCPoint();
    CCPoint(float x, float y);



    CCPoint(const CCPoint& other);



    CCPoint(const CCSize& size);



    CCPoint& operator= (const CCPoint& other);



    CCPoint& operator= (const CCSize& size);



    CCPoint operator+(const CCPoint& right) const;



    CCPoint operator-(const CCPoint& right) const;



    CCPoint operator-() const;



    CCPoint operator*(float a) const;



    CCPoint operator/(float a) const;



    void setPoint(float x, float y);
    bool equals(const CCPoint& target) const;





    bool fuzzyEquals(const CCPoint& target, float variance) const;






    inline float getLength() const {
        return sqrtf(x*x + y*y);
    };






    inline float getLengthSq() const {
        return dot(*this);
    };





    inline float getDistanceSq(const CCPoint& other) const {
        return (*this - other).getLengthSq();
    };





    inline float getDistance(const CCPoint& other) const {
        return (*this - other).getLength();
    };




    inline float getAngle() const {
        return atan2f(y, x);
    };




    float getAngle(const CCPoint& other) const;





    inline float dot(const CCPoint& other) const {
        return x*other.x + y*other.y;
    };





    inline float cross(const CCPoint& other) const {
        return x*other.y - y*other.x;
    };





    inline CCPoint getPerp() const {
        return CCPoint(-y, x);
    };





    inline CCPoint getRPerp() const {
        return CCPoint(y, -x);
    };





    inline CCPoint project(const CCPoint& other) const {
        return other * (dot(other)/other.dot(other));
    };






    inline CCPoint rotate(const CCPoint& other) const {
        return CCPoint(x*other.x - y*other.y, x*other.y + y*other.x);
    };






    inline CCPoint unrotate(const CCPoint& other) const {
        return CCPoint(x*other.x + y*other.y, y*other.x - x*other.y);
    };






    inline CCPoint normalize() const {
        float length = getLength();
        if(length == 0.) return CCPoint(1.f, 0);
        return *this / getLength();
    };
# 224 "Cacao/include/cocos2dx/cocoa/CCGeometry.h"
    inline CCPoint lerp(const CCPoint& other, float alpha) const {
        return *this * (1.f - alpha) + other * alpha;
    };







    CCPoint rotateByAngle(const CCPoint& pivot, float angle) const;

    static inline CCPoint forAngle(const float a)
    {
     return CCPoint(cosf(a), sinf(a));
    }
};




class CCSize
{
public:
    float width;
    float height;

public:
    CCSize();
    CCSize(float width, float height);



    CCSize(const CCSize& other);



    CCSize(const CCPoint& point);



    CCSize& operator= (const CCSize& other);



    CCSize& operator= (const CCPoint& point);



    CCSize operator+(const CCSize& right) const;



    CCSize operator-(const CCSize& right) const;



    CCSize operator*(float a) const;



    CCSize operator/(float a) const;



    void setSize(float width, float height);



    bool equals(const CCSize& target) const;
};




class CCRect
{
public:
    CCPoint origin;
    CCSize size;

public:
    CCRect();
    CCRect(float x, float y, float width, float height);



    CCRect(const CCRect& other);



    CCRect& operator= (const CCRect& other);
    void setRect(float x, float y, float width, float height);
    float getMinX() const;
    float getMidX() const;
    float getMaxX() const;
    float getMinY() const;
    float getMidY() const;
    float getMaxY() const;
    bool equals(const CCRect& rect) const;
    bool containsPoint(const CCPoint& point) const;
    bool intersectsRect(const CCRect& rect) const;
};







const CCPoint CCPointZero = CCPoint((float)(0), (float)(0));


const CCSize CCSizeZero = CCSize((float)(0), (float)(0));


const CCRect CCRectZero = CCRect((float)(0), (float)(0), (float)(0), (float)(0));




}
# 32 "Cacao/include/cocos2dx/actions/CCAction.h" 2


namespace cocos2d {

enum {

    kCCActionTagInvalid = -1,
};
# 49 "Cacao/include/cocos2dx/actions/CCAction.h"
class CCAction : public CCObject
{
public:



    CCAction(void);




    virtual ~CCAction(void);




    const char* description();




    virtual CCObject* copyWithZone(CCZone *pZone);


    virtual bool isDone(void);


    virtual void startWithTarget(CCNode *pTarget);





    virtual void stop(void);


    virtual void step(float dt);
# 95 "Cacao/include/cocos2dx/actions/CCAction.h"
    virtual void update(float time);

    inline CCNode* getTarget(void) { return m_pTarget; }

    inline void setTarget(CCNode *pTarget) { m_pTarget = pTarget; }

    inline CCNode* getOriginalTarget(void) { return m_pOriginalTarget; }





    inline void setOriginalTarget(CCNode *pOriginalTarget) { m_pOriginalTarget = pOriginalTarget; }

    inline int getTag(void) { return m_nTag; }
    inline void setTag(int nTag) { m_nTag = nTag; }

public:

    static CCAction* create();
protected:
    CCNode *m_pOriginalTarget;





    CCNode *m_pTarget;

    int m_nTag;
};
# 136 "Cacao/include/cocos2dx/actions/CCAction.h"
class CCFiniteTimeAction : public CCAction
{
public:



    CCFiniteTimeAction()
        : m_fDuration(0)
    {}




    virtual ~CCFiniteTimeAction(){}

    inline float getDuration(void) { return m_fDuration; }

    inline void setDuration(float duration) { m_fDuration = duration; }


    virtual CCFiniteTimeAction* reverse(void);
protected:

    float m_fDuration;
};

class CCActionInterval;
class CCRepeatForever;







class CCSpeed : public CCAction
{
public:



    CCSpeed()
        : m_fSpeed(0.0)
        , m_pInnerAction(__null)
    {}




    virtual ~CCSpeed(void);

    inline float getSpeed(void) { return m_fSpeed; }

    inline void setSpeed(float fSpeed) { m_fSpeed = fSpeed; }


    bool initWithAction(CCActionInterval *pAction, float fSpeed);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode* pTarget);
    virtual void stop();
    virtual void step(float dt);
    virtual bool isDone(void);
    virtual CCActionInterval* reverse(void);

    void setInnerAction(CCActionInterval *pAction);

    inline CCActionInterval* getInnerAction()
    {
        return m_pInnerAction;
    }

public:

    static CCSpeed* create(CCActionInterval* pAction, float fSpeed);
protected:
    float m_fSpeed;
    CCActionInterval *m_pInnerAction;
};
# 228 "Cacao/include/cocos2dx/actions/CCAction.h"
class CCFollow : public CCAction
{
public:



    CCFollow()
        : m_pobFollowedNode(__null)
        , m_bBoundarySet(false)
        , m_bBoundaryFullyCovered(false)
        , m_fLeftBoundary(0.0)
        , m_fRightBoundary(0.0)
        , m_fTopBoundary(0.0)
        , m_fBottomBoundary(0.0)
    {}




    virtual ~CCFollow(void);

    inline bool isBoundarySet(void) { return m_bBoundarySet; }

    inline void setBoudarySet(bool bValue) { m_bBoundarySet = bValue; }


    bool initWithTarget(CCNode *pFollowedNode, const CCRect& rect = CCRectZero);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void step(float dt);
    virtual bool isDone(void);
    virtual void stop(void);

public:



    static CCFollow* create(CCNode *pFollowedNode, const CCRect& rect = CCRectZero);
protected:

    CCNode *m_pobFollowedNode;


    bool m_bBoundarySet;


    bool m_bBoundaryFullyCovered;


    CCPoint m_obHalfScreenSize;
    CCPoint m_obFullScreenSize;


    float m_fLeftBoundary;
    float m_fRightBoundary;
    float m_fTopBoundary;
    float m_fBottomBoundary;
};




}
# 42 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionInterval.h"
# 1 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 1
# 31 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
# 1 "Cacao/include/cocos2dx/include/ccMacros.h" 1
# 34 "Cacao/include/cocos2dx/include/ccMacros.h"
# 1 "Cacao/include/cocos2dx/platform/CCCommon.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCCommon.h"
namespace cocos2d {







static const int kMaxLogLen = 16*1024;




void CCLog(const char * pszFormat, ...) __attribute__((__format__(printf, 1, 2)));




void CCLuaLog(const char * pszFormat);




void CCMessageBox(const char * pszMsg, const char * pszTitle);




typedef enum LanguageType
{
    kLanguageEnglish = 0,
    kLanguageChinese,
    kLanguageFrench,
    kLanguageItalian,
    kLanguageGerman,
    kLanguageSpanish,
    kLanguageRussian,
    kLanguageKorean,
    kLanguageJapanese,
    kLanguageHungarian,
    kLanguagePortuguese,
    kLanguageArabic
} ccLanguageType;




}
# 35 "Cacao/include/cocos2dx/include/ccMacros.h" 2
# 1 "Cacao/include/cocos2dx/platform/mac/CCStdC.h" 1
# 29 "Cacao/include/cocos2dx/platform/mac/CCStdC.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/11.0.0/include/float.h" 1 3 4
# 30 "Cacao/include/cocos2dx/platform/mac/CCStdC.h" 2






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 1 3
# 78 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3
# 79 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 2 3
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 144 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/sys/time.h" 3
struct clockinfo {
 int hz;
 int tick;
 int tickadj;
 int stathz;
 int profhz;
};







extern "C" {


int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *) __attribute__((visibility("default")));
int settimeofday(const struct timeval *, const struct timezone *);


int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * , void * );



int setitimer(int, const struct itimerval * ,
  struct itimerval * );
int utimes(const char *, const struct timeval *);

}
# 37 "Cacao/include/cocos2dx/platform/mac/CCStdC.h" 2
# 36 "Cacao/include/cocos2dx/include/ccMacros.h" 2
# 248 "Cacao/include/cocos2dx/include/ccMacros.h"
extern unsigned int g_uNumberOfDraws;
# 32 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCAffineTransform.h" 1
# 31 "Cacao/include/cocos2dx/cocoa/CCAffineTransform.h"
namespace cocos2d {

struct CCAffineTransform {
  float a, b, c, d;
  float tx, ty;
};

       CCAffineTransform __CCAffineTransformMake(float a, float b, float c, float d, float tx, float ty);


       CCPoint __CCPointApplyAffineTransform(const CCPoint& point, const CCAffineTransform& t);


       CCSize __CCSizeApplyAffineTransform(const CCSize& size, const CCAffineTransform& t);


       CCAffineTransform CCAffineTransformMakeIdentity();
       CCRect CCRectApplyAffineTransform(const CCRect& rect, const CCAffineTransform& anAffineTransform);

       CCAffineTransform CCAffineTransformTranslate(const CCAffineTransform& t, float tx, float ty);
       CCAffineTransform CCAffineTransformRotate(const CCAffineTransform& aTransform, float anAngle);
       CCAffineTransform CCAffineTransformScale(const CCAffineTransform& t, float sx, float sy);
       CCAffineTransform CCAffineTransformConcat(const CCAffineTransform& t1, const CCAffineTransform& t2);
       bool CCAffineTransformEqualToTransform(const CCAffineTransform& t1, const CCAffineTransform& t2);
       CCAffineTransform CCAffineTransformInvert(const CCAffineTransform& t);

extern const CCAffineTransform CCAffineTransformIdentity;

}
# 33 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCArray.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCArray.h"
# 1 "Cacao/include/cocos2dx/support/data_support/ccCArray.h" 1
# 52 "Cacao/include/cocos2dx/support/data_support/ccCArray.h"
namespace cocos2d {
# 61 "Cacao/include/cocos2dx/support/data_support/ccCArray.h"
typedef struct _ccArray {
 unsigned int num, max;
 CCObject** arr;
} ccArray;


ccArray* ccArrayNew(unsigned int capacity);


void ccArrayFree(ccArray*& arr);


void ccArrayDoubleCapacity(ccArray *arr);


void ccArrayEnsureExtraCapacity(ccArray *arr, unsigned int extra);


void ccArrayShrink(ccArray *arr);


unsigned int ccArrayGetIndexOfObject(ccArray *arr, CCObject* object);


bool ccArrayContainsObject(ccArray *arr, CCObject* object);


void ccArrayAppendObject(ccArray *arr, CCObject* object);


void ccArrayAppendObjectWithResize(ccArray *arr, CCObject* object);



void ccArrayAppendArray(ccArray *arr, ccArray *plusArr);


void ccArrayAppendArrayWithResize(ccArray *arr, ccArray *plusArr);


void ccArrayInsertObjectAtIndex(ccArray *arr, CCObject* object, unsigned int index);


void ccArraySwapObjectsAtIndexes(ccArray *arr, unsigned int index1, unsigned int index2);


void ccArrayRemoveAllObjects(ccArray *arr);



void ccArrayRemoveObjectAtIndex(ccArray *arr, unsigned int index, bool bReleaseObj = true);




void ccArrayFastRemoveObjectAtIndex(ccArray *arr, unsigned int index);

void ccArrayFastRemoveObject(ccArray *arr, CCObject* object);



void ccArrayRemoveObject(ccArray *arr, CCObject* object, bool bReleaseObj = true);



void ccArrayRemoveArray(ccArray *arr, ccArray *minusArr);



void ccArrayFullRemoveArray(ccArray *arr, ccArray *minusArr);




typedef struct _ccCArray {
    unsigned int num, max;
    void** arr;
} ccCArray;


ccCArray* ccCArrayNew(unsigned int capacity);


void ccCArrayFree(ccCArray *arr);


void ccCArrayDoubleCapacity(ccCArray *arr);


void ccCArrayEnsureExtraCapacity(ccCArray *arr, unsigned int extra);


unsigned int ccCArrayGetIndexOfValue(ccCArray *arr, void* value);


bool ccCArrayContainsValue(ccCArray *arr, void* value);


void ccCArrayInsertValueAtIndex( ccCArray *arr, void* value, unsigned int index);


void ccCArrayAppendValue(ccCArray *arr, void* value);


void ccCArrayAppendValueWithResize(ccCArray *arr, void* value);



void ccCArrayAppendArray(ccCArray *arr, ccCArray *plusArr);


void ccCArrayAppendArrayWithResize(ccCArray *arr, ccCArray *plusArr);


void ccCArrayRemoveAllValues(ccCArray *arr);





void ccCArrayRemoveValueAtIndex(ccCArray *arr, unsigned int index);






void ccCArrayFastRemoveValueAtIndex(ccCArray *arr, unsigned int index);




void ccCArrayRemoveValue(ccCArray *arr, void* value);




void ccCArrayRemoveArray(ccCArray *arr, ccCArray *minusArr);




void ccCArrayFullRemoveArray(ccCArray *arr, ccCArray *minusArr);

}
# 29 "Cacao/include/cocos2dx/cocoa/CCArray.h" 2
# 110 "Cacao/include/cocos2dx/cocoa/CCArray.h"
namespace cocos2d {



class CCArray : public CCObject
{
public:



    ~CCArray();


    static CCArray* create();



    static CCArray* create(CCObject* pObject, ...);

    static CCArray* createWithObject(CCObject* pObject);

    static CCArray* createWithCapacity(unsigned int capacity);

    static CCArray* createWithArray(CCArray* otherArray);





    static CCArray* createWithContentsOfFile(const char* pFileName);






    static CCArray* createWithContentsOfFileThreadSafe(const char* pFileName);




    bool init();



    bool initWithObject(CCObject* pObject);



    bool initWithObjects(CCObject* pObject, ...);



    bool initWithCapacity(unsigned int capacity);



    bool initWithArray(CCArray* otherArray);




    unsigned int count() const;

    unsigned int capacity() const;

    unsigned int indexOfObject(CCObject* object) const;

    CCObject* objectAtIndex(unsigned int index);

    CCObject* lastObject();

    CCObject* randomObject();

    bool containsObject(CCObject* object) const;

    bool isEqualToArray(CCArray* pOtherArray);



    void addObject(CCObject* object);

    void addObjectsFromArray(CCArray* otherArray);

    void insertObject(CCObject* object, unsigned int index);




    void removeLastObject(bool bReleaseObj = true);

    void removeObject(CCObject* object, bool bReleaseObj = true);

    void removeObjectAtIndex(unsigned int index, bool bReleaseObj = true);

    void removeObjectsInArray(CCArray* otherArray);

    void removeAllObjects();

    void fastRemoveObject(CCObject* object);

    void fastRemoveObjectAtIndex(unsigned int index);




    void exchangeObject(CCObject* object1, CCObject* object2);

    void exchangeObjectAtIndex(unsigned int index1, unsigned int index2);


    void replaceObjectAtIndex(unsigned int uIndex, CCObject* pObject, bool bReleaseObject = true);


    void reverseObjects();

    void reduceMemoryFootprint();





    virtual CCObject* copyWithZone(CCZone* pZone);


    virtual void acceptVisitor(CCDataVisitor &visitor);

public:
    ccArray* data;



    CCArray();



    CCArray(unsigned int capacity);
};




}
# 34 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/platform/mac/CCGL.h" 1
# 28 "Cacao/include/cocos2dx/platform/mac/CCGL.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3








extern "C" {
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

typedef long GLintptr;
typedef long GLsizeiptr;




typedef char GLchar;






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 1 3







# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/inttypes.h" 1 3
# 257 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/inttypes.h" 3
extern "C" {


  extern intmax_t imaxabs(intmax_t j);


  typedef struct {
        intmax_t quot;
        intmax_t rem;
  } imaxdiv_t;

  extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);


  extern intmax_t strtoimax(const char * nptr, char ** endptr, int base);
  extern uintmax_t strtoumax(const char * nptr, char ** endptr, int base);
# 282 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/inttypes.h" 3
  extern intmax_t wcstoimax(const wchar_t * nptr, wchar_t ** endptr, int base);
  extern uintmax_t wcstoumax(const wchar_t * nptr, wchar_t ** endptr, int base);






}
# 9 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 2 3


extern "C" {
# 313 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
typedef unsigned short GLhalfARB;



typedef unsigned short GLhalf;



typedef char GLcharARB;
typedef void *GLhandleARB;



typedef long GLintptrARB;
typedef long GLsizeiptrARB;




typedef int64_t GLint64;
typedef uint64_t GLuint64;
typedef struct __GLsync *GLsync;



typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;
# 3135 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glActiveTextureARB(GLenum texture);
extern void glClientActiveTextureARB(GLenum texture);
extern void glMultiTexCoord1dARB(GLenum target, GLdouble s);
extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord1fARB(GLenum target, GLfloat s);
extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord1iARB(GLenum target, GLint s);
extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord1sARB(GLenum target, GLshort s);
extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v);
# 3179 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glLoadTransposeMatrixfARB(const GLfloat *m);
extern void glLoadTransposeMatrixdARB(const GLdouble *m);
extern void glMultTransposeMatrixfARB(const GLfloat *m);
extern void glMultTransposeMatrixdARB(const GLdouble *m);







extern void glSampleCoverageARB(GLclampf value, GLboolean invert);
# 3204 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data);
# 3227 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWeightbvARB(GLint size, const GLbyte *weights);
extern void glWeightsvARB(GLint size, const GLshort *weights);
extern void glWeightivARB(GLint size, const GLint *weights);
extern void glWeightfvARB(GLint size, const GLfloat *weights);
extern void glWeightdvARB(GLint size, const GLdouble *weights);
extern void glWeightubvARB(GLint size, const GLubyte *weights);
extern void glWeightusvARB(GLint size, const GLushort *weights);
extern void glWeightuivARB(GLint size, const GLuint *weights);
extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexBlendARB(GLint count);
# 3259 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWindowPos2dARB(GLdouble x, GLdouble y);
extern void glWindowPos2dvARB(const GLdouble *p);
extern void glWindowPos2fARB(GLfloat x, GLfloat y);
extern void glWindowPos2fvARB(const GLfloat *p);
extern void glWindowPos2iARB(GLint x, GLint y);
extern void glWindowPos2ivARB(const GLint *p);
extern void glWindowPos2sARB(GLshort x, GLshort y);
extern void glWindowPos2svARB(const GLshort *p);
extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dvARB(const GLdouble *p);
extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fvARB(const GLfloat *p);
extern void glWindowPos3iARB(GLint x, GLint y, GLint z);
extern void glWindowPos3ivARB(const GLint *p);
extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z);
extern void glWindowPos3svARB(const GLshort *p);
# 3289 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenQueriesARB(GLsizei n, GLuint *ids);
extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids);
extern GLboolean glIsQueryARB(GLuint id);
extern void glBeginQueryARB(GLenum target, GLuint id);
extern void glEndQueryARB(GLenum target);
extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params);
# 3305 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameterfARB(GLenum pname, GLfloat param);
extern void glPointParameterfvARB(GLenum pname, const GLfloat *params);
# 3341 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindProgramARB(GLenum target, GLuint program);
extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs);
extern void glGenProgramsARB(GLsizei n, GLuint *programs);
extern GLboolean glIsProgramARB(GLuint program);

extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);

extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params);

extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);


extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params);

extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string);
extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string);

extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params);
# 3424 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttrib1dARB(GLuint index, GLdouble x);
extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib1fARB(GLuint index, GLfloat x);
extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib1sARB(GLuint index, GLshort x);
extern void glVertexAttrib1svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4NivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v);
extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib4ivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v);
extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);

extern void glDisableVertexAttribArrayARB(GLuint index);
extern void glEnableVertexAttribArrayARB(GLuint index);

extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer);
extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params);
# 3515 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDeleteObjectARB(GLhandleARB obj);
extern GLhandleARB glGetHandleARB(GLenum pname);
extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);
extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType);
extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length);
extern void glCompileShaderARB(GLhandleARB shaderObj);
extern GLhandleARB glCreateProgramObjectARB(void);
extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);
extern void glLinkProgramARB(GLhandleARB programObj);
extern void glUseProgramObjectARB(GLhandleARB programObj);
extern void glValidateProgramARB(GLhandleARB programObj);
extern void glUniform1fARB(GLint location, GLfloat v0);
extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1iARB(GLint location, GLint v0);
extern void glUniform2iARB(GLint location, GLint v0, GLint v1);
extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params);
extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params);
extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name);
extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params);
extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params);
extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
# 3563 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name);
extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name);
# 3583 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferARB(GLenum target, GLuint buffer);
extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers);
extern void glGenBuffersARB(GLsizei n, GLuint *buffers);
extern GLboolean glIsBufferARB(GLuint buffer);
extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
extern GLvoid *glMapBufferARB(GLenum target, GLenum access);
extern GLboolean glUnmapBufferARB(GLenum target);
extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params);







extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs);







extern void glClampColorARB(GLenum target, GLenum clamp);
# 3618 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);







extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor);
# 3638 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex);
extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount, const GLint *base_vertex);
# 3655 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLsync glFenceSync(GLenum condition, GLbitfield flags);
extern GLboolean glIsSync(GLsync sync);
extern void glDeleteSync(GLsync sync);
extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glGetInteger64v(GLenum pname, GLint64 *params);
extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);







extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
# 3821 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBlendEquationEXT(GLenum mode);
# 3891 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 3941 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bvEXT(const GLbyte *v);
extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dvEXT(const GLdouble *v);
extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fvEXT(const GLfloat *v);
extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue);
extern void glSecondaryColor3ivEXT(const GLint *v);
extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3svEXT(const GLshort *v);
extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubvEXT(const GLubyte *v);
extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uivEXT(const GLuint *v);
extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usvEXT(const GLushort *v);
extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 3974 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount);
# 3987 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFogCoordfEXT(GLfloat coord);
extern void glFogCoordfvEXT(const GLfloat *coord);
extern void glFogCoorddEXT(GLdouble coord);
extern void glFogCoorddvEXT(const GLdouble *coord);
extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer);
# 4049 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 4203 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glActiveStencilFaceEXT(GLenum face);







extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);







extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);
# 4243 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer);
extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebufferEXT(GLuint framebuffer);
extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatusEXT(GLenum target);
extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmapEXT(GLenum target);







extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);







extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 4285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);







extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 4322 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLboolean glIsRenderbuffer(GLuint renderbuffer);
extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebuffer(GLuint framebuffer);
extern void glBindFramebuffer(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatus(GLenum target);
extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmap(GLenum target);
extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 4355 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);
extern void glBeginTransformFeedbackEXT(GLenum primitiveMode);
extern void glEndTransformFeedbackEXT(void);
extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode);
extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
# 4370 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values);
extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values);
# 4381 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);
extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location);
extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location);
# 4396 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glClearColorIiEXT( GLint r, GLint g, GLint b, GLint a );
extern void glClearColorIuiEXT( GLuint r, GLuint g, GLuint b, GLuint a );
extern void glTexParameterIivEXT( GLenum target, GLenum pname, GLint *params );
extern void glTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params );
extern void glGetTexParameterIivEXT( GLenum target, GLenum pname, GLint *params);
extern void glGetTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params);
# 4442 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttribI1iEXT(GLuint index, GLint x);
extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern void glVertexAttribI1uiEXT(GLuint index, GLuint x);
extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v);
extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v);
extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v);
extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v);
extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params);
extern void glUniform1uiEXT(GLint location, GLuint v0);
extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);
extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params);
extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name);
extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name);
# 4486 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern void glEnableIndexedEXT(GLenum target, GLuint index);
extern void glDisableIndexedEXT(GLenum target, GLuint index);
extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index);







extern void glProvokingVertexEXT(GLenum mode);







extern void glProvokingVertex(GLenum mode);
# 4514 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params);
extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params);
# 4524 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer);
extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params);
# 4535 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param);
# 4548 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindVertexArrayAPPLE(GLuint id);
extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids);
extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids);
extern GLboolean glIsVertexArrayAPPLE(GLuint id);
# 4566 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenFencesAPPLE(GLsizei n, GLuint *fences);
extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences);
extern void glSetFenceAPPLE(GLuint fence);
extern GLboolean glIsFenceAPPLE(GLuint fence);
extern GLboolean glTestFenceAPPLE(GLuint fence);
extern void glFinishFenceAPPLE(GLuint fence);
extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name);
extern void glFinishObjectAPPLE(GLenum object, GLuint name);
# 4585 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer);
extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);
extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
# 4599 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFlushRenderAPPLE(void);
extern void glFinishRenderAPPLE(void);
extern void glSwapAPPLE(void);
# 4615 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname);
extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname);
extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);
extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
# 4630 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);
extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);
# 4641 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params);
# 4652 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexPointSizefAPPLE(GLfloat size);
# 4662 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPNTrianglesiATI(GLenum pname, GLint param);
extern void glPNTrianglesfATI(GLenum pname, GLfloat param);







extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha);
# 4680 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
# 4690 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPNTrianglesiATIX(GLenum pname, GLint param);
extern void glPNTrianglesfATIX(GLenum pname, GLfloat param);
# 4963 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameteriNV(GLenum pname, GLint param);
extern void glPointParameterivNV(GLenum pname, const GLint *params);
# 5407 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBeginConditionalRenderNV(GLuint id, GLenum mode);
extern void glEndConditionalRenderNV(void);



}
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 2 3
# 2405 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glBlendEquation (GLenum mode);
extern void glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
extern void glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params);
extern void glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glConvolutionParameteri (GLenum target, GLenum pname, GLint params);
extern void glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
extern void glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, GLvoid **params);
extern void glGetPolygonStipple (GLubyte *mask);
extern void glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern const GLubyte *glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMinmax (GLenum target, GLenum internalformat, GLboolean sink);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLint mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLint mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLint mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glResetHistogram (GLenum target);
extern void glResetMinmax (GLenum target);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

extern void glSampleCoverage (GLclampf value, GLboolean invert);

extern void glLoadTransposeMatrixf (const GLfloat *m);
extern void glLoadTransposeMatrixd (const GLdouble *m);
extern void glMultTransposeMatrixf (const GLfloat *m);
extern void glMultTransposeMatrixd (const GLdouble *m);

extern void glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImage (GLenum target, GLint lod, GLvoid *img);

extern void glActiveTexture (GLenum texture);
extern void glClientActiveTexture (GLenum texture);
extern void glMultiTexCoord1d (GLenum target, GLdouble s);
extern void glMultiTexCoord1dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord1f (GLenum target, GLfloat s);
extern void glMultiTexCoord1fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord1i (GLenum target, GLint s);
extern void glMultiTexCoord1iv (GLenum target, const GLint *v);
extern void glMultiTexCoord1s (GLenum target, GLshort s);
extern void glMultiTexCoord1sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord2i (GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2iv (GLenum target, const GLint *v);
extern void glMultiTexCoord2s (GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3iv (GLenum target, const GLint *v);
extern void glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord4i (GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4iv (GLenum target, const GLint *v);
extern void glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4sv (GLenum target, const GLshort *v);

extern void glFogCoordf (GLfloat coord);
extern void glFogCoordfv (const GLfloat *coord);
extern void glFogCoordd (GLdouble coord);
extern void glFogCoorddv (const GLdouble *coord);
extern void glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bv (const GLbyte *v);
extern void glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dv (const GLdouble *v);
extern void glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fv (const GLfloat *v);
extern void glSecondaryColor3i (GLint red, GLint green, GLint blue);
extern void glSecondaryColor3iv (const GLint *v);
extern void glSecondaryColor3s (GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3sv (const GLshort *v);
extern void glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubv (const GLubyte *v);
extern void glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uiv (const GLuint *v);
extern void glSecondaryColor3us (GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usv (const GLushort *v);
extern void glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glPointParameterf (GLenum pname, GLfloat param);
extern void glPointParameterfv (GLenum pname, const GLfloat *params);
extern void glPointParameteri (GLenum pname, GLint param);
extern void glPointParameteriv (GLenum pname, const GLint *params);

extern void glBlendFuncSeparate (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

extern void glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount);

extern void glWindowPos2d (GLdouble x, GLdouble y);
extern void glWindowPos2dv (const GLdouble *v);
extern void glWindowPos2f (GLfloat x, GLfloat y);
extern void glWindowPos2fv (const GLfloat *v);
extern void glWindowPos2i (GLint x, GLint y);
extern void glWindowPos2iv (const GLint *v);
extern void glWindowPos2s (GLshort x, GLshort y);
extern void glWindowPos2sv (const GLshort *v);
extern void glWindowPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dv (const GLdouble *v);
extern void glWindowPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fv (const GLfloat *v);
extern void glWindowPos3i (GLint x, GLint y, GLint z);
extern void glWindowPos3iv (const GLint *v);
extern void glWindowPos3s (GLshort x, GLshort y, GLshort z);
extern void glWindowPos3sv (const GLshort *v);

extern void glGenQueries (GLsizei n, GLuint *ids);
extern void glDeleteQueries (GLsizei n, const GLuint *ids);
extern GLboolean glIsQuery (GLuint id);
extern void glBeginQuery (GLenum target, GLuint id);
extern void glEndQuery (GLenum target);
extern void glGetQueryiv (GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectiv (GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);

extern void glBindBuffer (GLenum target, GLuint buffer);
extern void glDeleteBuffers (GLsizei n, const GLuint *buffers);
extern void glGenBuffers (GLsizei n, GLuint *buffers);
extern GLboolean glIsBuffer (GLuint buffer);
extern void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
extern void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
extern void glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
extern GLvoid *glMapBuffer (GLenum target, GLenum access);
extern GLboolean glUnmapBuffer (GLenum target);
extern void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointerv (GLenum target, GLenum pname, GLvoid **params);

extern void glDrawBuffers (GLsizei n, const GLenum *bufs);
extern void glVertexAttrib1d (GLuint index, GLdouble x);
extern void glVertexAttrib1dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib1f (GLuint index, GLfloat x);
extern void glVertexAttrib1fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib1s (GLuint index, GLshort x);
extern void glVertexAttrib1sv (GLuint index, const GLshort *v);
extern void glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib2s (GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2sv (GLuint index, const GLshort *v);
extern void glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nbv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4Niv (GLuint index, const GLint *v);
extern void glVertexAttrib4Nsv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4Nubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4Nuiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4Nusv (GLuint index, const GLushort *v);
extern void glVertexAttrib4bv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib4iv (GLuint index, const GLint *v);
extern void glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4ubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4uiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4usv (GLuint index, const GLushort *v);
extern void glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
extern void glEnableVertexAttribArray (GLuint index);
extern void glDisableVertexAttribArray (GLuint index);
extern void glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid **pointer);
extern void glDeleteShader (GLuint shader);
extern void glDetachShader (GLuint program, GLuint shader);
extern GLuint glCreateShader (GLenum type);
extern void glShaderSource (GLuint shader, GLsizei count, const GLchar **string, const GLint *length);
extern void glCompileShader (GLuint shader);
extern GLuint glCreateProgram (void);
extern void glAttachShader (GLuint program, GLuint shader);
extern void glLinkProgram (GLuint program);
extern void glUseProgram (GLuint program);
extern void glDeleteProgram (GLuint program);
extern void glValidateProgram (GLuint program);
extern void glUniform1f (GLint location, GLfloat v0);
extern void glUniform2f (GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1i (GLint location, GLint v0);
extern void glUniform2i (GLint location, GLint v0, GLint v1);
extern void glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform2iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform3iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform4iv (GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern GLboolean glIsShader (GLuint shader);
extern GLboolean glIsProgram (GLuint program);
extern void glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
extern void glGetProgramiv (GLuint program, GLenum pname, GLint *params);
extern void glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern void glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern void glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern GLint glGetUniformLocation (GLuint program, const GLchar *name);
extern void glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern void glGetUniformfv (GLuint program, GLint location, GLfloat *params);
extern void glGetUniformiv (GLuint program, GLint location, GLint *params);
extern void glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern void glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
extern void glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern GLint glGetAttribLocation (GLuint program, const GLchar *name);
extern void glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
extern void glStencilOpSeparate (GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
extern void glStencilMaskSeparate (GLenum face, GLuint mask);

extern void glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);





}
# 29 "Cacao/include/cocos2dx/platform/mac/CCGL.h" 2
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 1 3
# 11 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern "C" {
# 218 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
class GLUnurbs;
class GLUquadric;
class GLUtesselator;

typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;
# 239 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern void gluBeginCurve (GLUnurbs* nurb);
extern void gluBeginPolygon (GLUtesselator* tess);
extern void gluBeginSurface (GLUnurbs* nurb);
extern void gluBeginTrim (GLUnurbs* nurb);
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString);
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks);
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb);
extern void gluDeleteQuadric (GLUquadric* quad);
extern void gluDeleteTess (GLUtesselator* tess);
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops);
extern void gluEndCurve (GLUnurbs* nurb);
extern void gluEndPolygon (GLUtesselator* tess);
extern void gluEndSurface (GLUnurbs* nurb);
extern void gluEndTrim (GLUnurbs* nurb);
extern const GLubyte * gluErrorString (GLenum error);
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data);
extern const GLubyte * gluGetString (GLenum name);
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data);
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view);
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ);
extern GLUnurbs* gluNewNurbsRenderer (void);
extern GLUquadric* gluNewQuadric (void);
extern GLUtesselator* gluNewTess (void);
extern void gluNextContour (GLUtesselator* tess, GLenum type);
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)());
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type);
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value);
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type);
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top);
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep);
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport);
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ);
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type);
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, GLvoid (*CallBackFunc)());
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw);
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal);
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation);
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture);
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut);
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks);
extern void gluTessBeginContour (GLUtesselator* tess);
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data);
extern void gluTessCallback (GLUtesselator* tess, GLenum which, GLvoid (*CallBackFunc)());
extern void gluTessEndContour (GLUtesselator* tess);
extern void gluTessEndPolygon (GLUtesselator* tess);
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ);
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data);
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data);
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ);
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW);


}
# 30 "Cacao/include/cocos2dx/platform/mac/CCGL.h" 2
# 35 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h" 1
# 33 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
namespace cocos2d {






class CCGLProgram;


enum {
    kCCVertexAttribFlag_None = 0,

    kCCVertexAttribFlag_Position = 1 << 0,
    kCCVertexAttribFlag_Color = 1 << 1,
    kCCVertexAttribFlag_TexCoords = 1 << 2,

    kCCVertexAttribFlag_PosColorTex = ( kCCVertexAttribFlag_Position | kCCVertexAttribFlag_Color | kCCVertexAttribFlag_TexCoords ),
};


typedef enum {
# 63 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
      CC_GL_ALL = 0,

} ccGLServerState;
# 74 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
void ccGLInvalidateStateCache(void);





void ccGLUseProgram(GLuint program);





void ccGLDeleteProgram(GLuint program);





void ccGLBlendFunc(GLenum sfactor, GLenum dfactor);





void ccGLBlendResetToCache(void);




void ccSetProjectionMatrixDirty(void);
# 116 "Cacao/include/cocos2dx/shaders/ccGLStateCache.h"
void ccGLEnableVertexAttribs(unsigned int flags);





void ccGLBindTexture2D(GLuint textureId);






void ccGLBindTexture2DN(GLuint textureUnit, GLuint textureId);





void ccGLDeleteTexture(GLuint textureId);





void ccGLDeleteTextureN(GLuint textureUnit, GLuint textureId);





void ccGLBindVAO(GLuint vaoId);





void ccGLEnable( ccGLServerState flags );




}
# 36 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/shaders/CCGLProgram.h" 1
# 36 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
namespace cocos2d {






enum {
    kCCVertexAttrib_Position,
    kCCVertexAttrib_Color,
    kCCVertexAttrib_TexCoords,

    kCCVertexAttrib_MAX,
};

enum {
 kCCUniformPMatrix,
 kCCUniformMVMatrix,
 kCCUniformMVPMatrix,
 kCCUniformTime,
 kCCUniformSinTime,
 kCCUniformCosTime,
 kCCUniformRandom01,
 kCCUniformSampler,

 kCCUniform_MAX,
};
# 90 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
struct _hashUniformEntry;

typedef void (*GLInfoFunction)(GLuint program, GLenum pname, GLint* params);
typedef void (*GLLogFunction) (GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog);







class CCGLProgram : public CCObject
{
public:




    CCGLProgram();




    virtual ~CCGLProgram();




    bool initWithVertexShaderByteArray(const GLchar* vShaderByteArray, const GLchar* fShaderByteArray);
# 128 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
    bool initWithVertexShaderFilename(const char* vShaderFilename, const char* fShaderFilename);



    void addAttribute(const char* attributeName, GLuint index);



    bool link();



    void use();
# 150 "Cacao/include/cocos2dx/shaders/CCGLProgram.h"
    void updateUniforms();




    GLint getUniformLocationForName(const char* name);





    void setUniformLocationWith1i(GLint location, GLint i1);




    void setUniformLocationWith2i(GLint location, GLint i1, GLint i2);




    void setUniformLocationWith3i(GLint location, GLint i1, GLint i2, GLint i3);




    void setUniformLocationWith4i(GLint location, GLint i1, GLint i2, GLint i3, GLint i4);




    void setUniformLocationWith2iv(GLint location, GLint* ints, unsigned int numberOfArrays);




    void setUniformLocationWith3iv(GLint location, GLint* ints, unsigned int numberOfArrays);





    void setUniformLocationWith4iv(GLint location, GLint* ints, unsigned int numberOfArrays);





    void setUniformLocationWith1f(GLint location, GLfloat f1);





    void setUniformLocationWith2f(GLint location, GLfloat f1, GLfloat f2);





    void setUniformLocationWith3f(GLint location, GLfloat f1, GLfloat f2, GLfloat f3);





    void setUniformLocationWith4f(GLint location, GLfloat f1, GLfloat f2, GLfloat f3, GLfloat f4);





    void setUniformLocationWith2fv(GLint location, GLfloat* floats, unsigned int numberOfArrays);





    void setUniformLocationWith3fv(GLint location, GLfloat* floats, unsigned int numberOfArrays);





    void setUniformLocationWith4fv(GLint location, GLfloat* floats, unsigned int numberOfArrays);





    void setUniformLocationWithMatrix4fv(GLint location, GLfloat* matrixArray, unsigned int numberOfMatrices);




    void setUniformsForBuiltins();





    const char* vertexShaderLog();




    const char* fragmentShaderLog();




    const char* programLog();





    void reset();



    inline const GLuint getProgram() { return m_uProgram; }

private:
    bool updateUniformLocation(GLint location, GLvoid* data, unsigned int bytes);
    const char* description();
    bool compileShader(GLuint * shader, GLenum type, const GLchar* source);
    const char* logForOpenGLObject(GLuint object, GLInfoFunction infoFunc, GLLogFunction logFunc);

private:
    GLuint m_uProgram;
    GLuint m_uVertShader;
    GLuint m_uFragShader;
    GLint m_uUniforms[kCCUniform_MAX];
    struct _hashUniformEntry* m_pHashForUniforms;
    bool m_bUsesTime;
    bool m_hasShaderCompiler;




};




}
# 37 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 1
# 29 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h"
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec2.h" 1
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec2.h"
struct kmMat3;





#pragma pack(push)
#pragma pack(1)
typedef struct kmVec2 {
    float x;
    float y;
} kmVec2;

#pragma pack(pop)


extern "C" {

       kmVec2* kmVec2Fill(kmVec2* pOut, float x, float y);
       float kmVec2Length(const kmVec2* pIn);
       float kmVec2LengthSq(const kmVec2* pIn);
       kmVec2* kmVec2Normalize(kmVec2* pOut, const kmVec2* pIn);
       kmVec2* kmVec2Add(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2);
       float kmVec2Dot(const kmVec2* pV1, const kmVec2* pV2);
       kmVec2* kmVec2Subtract(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2);
       kmVec2* kmVec2Transform(kmVec2* pOut, const kmVec2* pV1, const struct kmMat3* pM);
       kmVec2* kmVec2TransformCoord(kmVec2* pOut, const kmVec2* pV, const struct kmMat3* pM);
       kmVec2* kmVec2Scale(kmVec2* pOut, const kmVec2* pIn, const float s);
       int kmVec2AreEqual(const kmVec2* p1, const kmVec2* p2);


}
# 30 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec3.h" 1
# 30 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec3.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 1 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 3
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));



}
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/vec3.h" 2





struct kmMat4;

typedef struct kmVec3 {
    float x;
    float y;
    float z;
} kmVec3;


extern "C" {


       kmVec3* kmVec3Fill(kmVec3* pOut, float x, float y, float z);
       float kmVec3Length(const kmVec3* pIn);
       float kmVec3LengthSq(const kmVec3* pIn);
       kmVec3* kmVec3Normalize(kmVec3* pOut, const kmVec3* pIn);
       kmVec3* kmVec3Cross(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
       float kmVec3Dot(const kmVec3* pV1, const kmVec3* pV2);
       kmVec3* kmVec3Add(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
       kmVec3* kmVec3Subtract(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2);
       kmVec3* kmVec3Transform(kmVec3* pOut, const kmVec3* pV1, const struct kmMat4* pM);
       kmVec3* kmVec3TransformNormal(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
       kmVec3* kmVec3TransformCoord(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
       kmVec3* kmVec3Scale(kmVec3* pOut, const kmVec3* pIn, const float s);
       int kmVec3AreEqual(const kmVec3* p1, const kmVec3* p2);
       kmVec3* kmVec3InverseTransform(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);
       kmVec3* kmVec3InverseTransformNormal(kmVec3* pOut, const kmVec3* pVect, const struct kmMat4* pM);
       kmVec3* kmVec3Assign(kmVec3* pOut, const kmVec3* pIn);
       kmVec3* kmVec3Zero(kmVec3* pOut);


}
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat3.h" 1
# 31 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat3.h"
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/utility.h" 1
# 60 "Cacao/include/cocos2dx/kazmath/include/kazmath/utility.h"
extern "C" {


       float kmSQR(float s);
       float kmDegreesToRadians(float degrees);
       float kmRadiansToDegrees(float radians);

       float kmMin(float lhs, float rhs);
       float kmMax(float lhs, float rhs);
       unsigned char kmAlmostEqual(float lhs, float rhs);


}
# 32 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat3.h" 2

struct kmVec3;
struct kmQuaternion;

typedef struct kmMat3{
    float mat[9];
} kmMat3;


extern "C" {


       kmMat3* const kmMat3Fill(kmMat3* pOut, const float* pMat);
       kmMat3* const kmMat3Adjugate(kmMat3* pOut, const kmMat3* pIn);
       kmMat3* const kmMat3Identity(kmMat3* pOut);
       kmMat3* const kmMat3Inverse(kmMat3* pOut, const float pDeterminate, const kmMat3* pM);
       const int kmMat3IsIdentity(const kmMat3* pIn);
       kmMat3* const kmMat3Transpose(kmMat3* pOut, const kmMat3* pIn);
       const float kmMat3Determinant(const kmMat3* pIn);
       kmMat3* const kmMat3Multiply(kmMat3* pOut, const kmMat3* pM1, const kmMat3* pM2);
       kmMat3* const kmMat3ScalarMultiply(kmMat3* pOut, const kmMat3* pM, const float pFactor);

       kmMat3* const kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians);
       struct kmVec3* const kmMat3RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat3* pIn);

       kmMat3* const kmMat3Assign(kmMat3* pOut, const kmMat3* pIn);
       const int kmMat3AreEqual(const kmMat3* pM1, const kmMat3* pM2);

       kmMat3* const kmMat3RotationX(kmMat3* pOut, const float radians);
       kmMat3* const kmMat3RotationY(kmMat3* pOut, const float radians);
       kmMat3* const kmMat3RotationZ(kmMat3* pOut, const float radians);

       kmMat3* const kmMat3Rotation(kmMat3* pOut, const float radians);
       kmMat3* const kmMat3Scaling(kmMat3* pOut, const float x, const float y);
       kmMat3* const kmMat3Translation(kmMat3* pOut, const float x, const float y);

       kmMat3* const kmMat3RotationQuaternion(kmMat3* pOut, const struct kmQuaternion* pIn);
       kmMat3* const kmMat3RotationAxisAngle(kmMat3* pOut, const struct kmVec3* axis, float radians);
       struct kmVec3* const kmMat3RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat3* pIn);


}
# 32 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat4.h" 1
# 32 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat4.h"
struct kmVec3;
struct kmMat3;
struct kmQuaternion;
struct kmPlane;
# 47 "Cacao/include/cocos2dx/kazmath/include/kazmath/mat4.h"
extern "C" {


typedef struct kmMat4 {
    float mat[16];
} kmMat4;

       kmMat4* const kmMat4Fill(kmMat4* pOut, const float* pMat);


       kmMat4* const kmMat4Identity(kmMat4* pOut);

       kmMat4* const kmMat4Inverse(kmMat4* pOut, const kmMat4* pM);


       const int kmMat4IsIdentity(const kmMat4* pIn);

       kmMat4* const kmMat4Transpose(kmMat4* pOut, const kmMat4* pIn);
       kmMat4* const kmMat4Multiply(kmMat4* pOut, const kmMat4* pM1, const kmMat4* pM2);

       kmMat4* const kmMat4Assign(kmMat4* pOut, const kmMat4* pIn);
       const int kmMat4AreEqual(const kmMat4* pM1, const kmMat4* pM2);

       kmMat4* const kmMat4RotationX(kmMat4* pOut, const float radians);
       kmMat4* const kmMat4RotationY(kmMat4* pOut, const float radians);
       kmMat4* const kmMat4RotationZ(kmMat4* pOut, const float radians);
       kmMat4* const kmMat4RotationPitchYawRoll(kmMat4* pOut, const float pitch, const float yaw, const float roll);
       kmMat4* const kmMat4RotationQuaternion(kmMat4* pOut, const struct kmQuaternion* pQ);
       kmMat4* const kmMat4RotationTranslation(kmMat4* pOut, const struct kmMat3* rotation, const struct kmVec3* translation);
       kmMat4* const kmMat4Scaling(kmMat4* pOut, const float x, const float y, const float z);
       kmMat4* const kmMat4Translation(kmMat4* pOut, const float x, const float y, const float z);

       struct kmVec3* const kmMat4GetUpVec3(struct kmVec3* pOut, const kmMat4* pIn);
       struct kmVec3* const kmMat4GetRightVec3(struct kmVec3* pOut, const kmMat4* pIn);
       struct kmVec3* const kmMat4GetForwardVec3(struct kmVec3* pOut, const kmMat4* pIn);

       kmMat4* const kmMat4PerspectiveProjection(kmMat4* pOut, float fovY, float aspect, float zNear, float zFar);
       kmMat4* const kmMat4OrthographicProjection(kmMat4* pOut, float left, float right, float bottom, float top, float nearVal, float farVal);
       kmMat4* const kmMat4LookAt(kmMat4* pOut, const struct kmVec3* pEye, const struct kmVec3* pCenter, const struct kmVec3* pUp);

       kmMat4* const kmMat4RotationAxisAngle(kmMat4* pOut, const struct kmVec3* axis, float radians);
       struct kmMat3* const kmMat4ExtractRotation(struct kmMat3* pOut, const kmMat4* pIn);
       struct kmPlane* const kmMat4ExtractPlane(struct kmPlane* pOut, const kmMat4* pIn, const unsigned int plane);
       struct kmVec3* const kmMat4RotationToAxisAngle(struct kmVec3* pAxis, float* radians, const kmMat4* pIn);

}
# 33 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2

# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/quaternion.h" 1
# 30 "Cacao/include/cocos2dx/kazmath/include/kazmath/quaternion.h"
extern "C" {





struct kmMat4;
struct kmMat3;
struct kmVec3;

typedef struct kmQuaternion {
    float x;
    float y;
    float z;
    float w;
} kmQuaternion;

       kmQuaternion* const kmQuaternionConjugate(kmQuaternion* pOut, const kmQuaternion* pIn);

       const float kmQuaternionDot(const kmQuaternion* q1, const kmQuaternion* q2);

       kmQuaternion* kmQuaternionExp(kmQuaternion* pOut, const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionIdentity(kmQuaternion* pOut);



       kmQuaternion* kmQuaternionInverse(kmQuaternion* pOut,
                                            const kmQuaternion* pIn);



       int kmQuaternionIsIdentity(const kmQuaternion* pIn);



       float kmQuaternionLength(const kmQuaternion* pIn);



       float kmQuaternionLengthSq(const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionLn(kmQuaternion* pOut, const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionMultiply(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2);



       kmQuaternion* kmQuaternionNormalize(kmQuaternion* pOut, const kmQuaternion* pIn);



       kmQuaternion* kmQuaternionRotationAxis(kmQuaternion* pOut, const struct kmVec3* pV, float angle);



       kmQuaternion* kmQuaternionRotationMatrix(kmQuaternion* pOut, const struct kmMat3* pIn);



       kmQuaternion* kmQuaternionRotationYawPitchRoll(kmQuaternion* pOut, float yaw, float pitch, float roll);

       kmQuaternion* kmQuaternionSlerp(kmQuaternion* pOut, const kmQuaternion* q1, const kmQuaternion* q2, float t);


       void kmQuaternionToAxisAngle(const kmQuaternion* pIn, struct kmVec3* pVector, float* pAngle);


       kmQuaternion* kmQuaternionScale(kmQuaternion* pOut, const kmQuaternion* pIn, float s);
       kmQuaternion* kmQuaternionAssign(kmQuaternion* pOut, const kmQuaternion* pIn);
       kmQuaternion* kmQuaternionAdd(kmQuaternion* pOut, const kmQuaternion* pQ1, const kmQuaternion* pQ2);
       kmQuaternion* kmQuaternionRotationBetweenVec3(kmQuaternion* pOut, const struct kmVec3* vec1, const struct kmVec3* vec2, const struct kmVec3* fallback);
       struct kmVec3* kmQuaternionMultiplyVec3(struct kmVec3* pOut, const kmQuaternion* q, const struct kmVec3* v);


}
# 35 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/plane.h" 1
# 39 "Cacao/include/cocos2dx/kazmath/include/kazmath/plane.h"
struct kmVec3;
struct kmVec4;
struct kmMat4;

typedef struct kmPlane {
    float a, b, c, d;
} kmPlane;


extern "C" {


typedef enum POINT_CLASSIFICATION {
    POINT_INFRONT_OF_PLANE = 0,
    POINT_BEHIND_PLANE,
    POINT_ON_PLANE,
} POINT_CLASSIFICATION;

       const float kmPlaneDot(const kmPlane* pP, const struct kmVec4* pV);
       const float kmPlaneDotCoord(const kmPlane* pP, const struct kmVec3* pV);
       const float kmPlaneDotNormal(const kmPlane* pP, const struct kmVec3* pV);
       kmPlane* const kmPlaneFromPointNormal(kmPlane* pOut, const struct kmVec3* pPoint, const struct kmVec3* pNormal);
       kmPlane* const kmPlaneFromPoints(kmPlane* pOut, const struct kmVec3* p1, const struct kmVec3* p2, const struct kmVec3* p3);
       kmVec3* const kmPlaneIntersectLine(struct kmVec3* pOut, const kmPlane* pP, const struct kmVec3* pV1, const struct kmVec3* pV2);
       kmPlane* const kmPlaneNormalize(kmPlane* pOut, const kmPlane* pP);
       kmPlane* const kmPlaneScale(kmPlane* pOut, const kmPlane* pP, float s);
       const POINT_CLASSIFICATION kmPlaneClassifyPoint(const kmPlane* pIn, const kmVec3* pP);


}
# 36 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/aabb.h" 1
# 34 "Cacao/include/cocos2dx/kazmath/include/kazmath/aabb.h"
extern "C" {






typedef struct kmAABB {
    kmVec3 min;
    kmVec3 max;
} kmAABB;

       const int kmAABBContainsPoint(const kmVec3* pPoint, const kmAABB* pBox);
       kmAABB* const kmAABBAssign(kmAABB* pOut, const kmAABB* pIn);
       kmAABB* const kmAABBScale(kmAABB* pOut, const kmAABB* pIn, float s);


}
# 37 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/ray2.h" 1
# 34 "Cacao/include/cocos2dx/kazmath/include/kazmath/ray2.h"
extern "C" {


typedef struct kmRay2 {
    kmVec2 start;
    kmVec2 dir;
} kmRay2;

       void kmRay2Fill(kmRay2* ray, float px, float py, float vx, float vy);
       unsigned char kmRay2IntersectLineSegment(const kmRay2* ray, const kmVec2* p1, const kmVec2* p2, kmVec2* intersection);
       unsigned char kmRay2IntersectTriangle(const kmRay2* ray, const kmVec2* p1, const kmVec2* p2, const kmVec2* p3, kmVec2* intersection, kmVec2* normal_out);
       unsigned char kmRay2IntersectCircle(const kmRay2* ray, const kmVec2 centre, const float radius, kmVec2* intersection);


}
# 38 "Cacao/include/cocos2dx/kazmath/include/kazmath/kazmath.h" 2
# 38 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 1
# 29 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
# 1 "Cacao/include/cocos2dx/platform/mac/CCAccelerometer.h" 1
# 28 "Cacao/include/cocos2dx/platform/mac/CCAccelerometer.h"
# 1 "Cacao/include/cocos2dx/platform/CCAccelerometerDelegate.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCAccelerometerDelegate.h"
namespace cocos2d {



class CCAcceleration
{
public:
    double x;
    double y;
    double z;

    double timestamp;
};
# 51 "Cacao/include/cocos2dx/platform/CCAccelerometerDelegate.h"
class CCAccelerometerDelegate
{
public:
    virtual void didAccelerate(CCAcceleration* pAccelerationValue) {(void)pAccelerationValue;}
};

}
# 29 "Cacao/include/cocos2dx/platform/mac/CCAccelerometer.h" 2

namespace cocos2d {

class CCAccelerometer
{
public:
    CCAccelerometer() {}
    ~CCAccelerometer() {}

    void setDelegate(CCAccelerometerDelegate* pDelegate) { (void)pDelegate; }
    void setAccelerometerInterval(float interval) {(void)interval;};
};

}
# 30 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2
# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouch.h" 1
# 31 "Cacao/include/cocos2dx/touch_dispatcher/CCTouch.h"
namespace cocos2d {






class CCTouch : public CCObject
{
public:



    CCTouch()
        : m_nId(0),
        m_startPointCaptured(false)
    {}


    CCPoint getLocation() const;

    CCPoint getPreviousLocation() const;

    CCPoint getStartLocation() const;

    CCPoint getDelta() const;

    CCPoint getLocationInView() const;

    CCPoint getPreviousLocationInView() const;

    CCPoint getStartLocationInView() const;

    void setTouchInfo(int id, float x, float y)
    {
        m_nId = id;
        m_prevPoint = m_point;
        m_point.x = x;
        m_point.y = y;
        if (!m_startPointCaptured)
        {
            m_startPoint = m_point;
            m_startPointCaptured = true;
        }
    }



    int getID() const
    {
        return m_nId;
    }

private:
    int m_nId;
    bool m_startPointCaptured;
    CCPoint m_startPoint;
    CCPoint m_point;
    CCPoint m_prevPoint;
};

class CCEvent : public CCObject
{
};




}
# 31 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCSet.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCSet.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tree.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tree.h" 3







namespace std {
# 93 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,
                       _Rb_tree_node_base*& __root);

  void
  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,
                        _Rb_tree_node_base*& __root);

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val> _Rb_tree_node;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node* _Link_type;
      typedef const _Rb_tree_node* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Rb_tree_node*
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Rb_tree_node* __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }

      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = std::__is_pod<_Key_compare>::__value>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };



      template<typename _Key_compare>
        struct _Rb_tree_impl<_Key_compare, true> : public _Node_allocator
 {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl(const _Node_allocator& __a = _Node_allocator(),
   const _Key_compare& __comp = _Key_compare())
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      const_iterator
      _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __y,
  const value_type& __v);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

    public:

      _Rb_tree()
      { }

      _Rb_tree(const _Compare& __comp)
      : _M_impl(allocator_type(), __comp)
      { }

      _Rb_tree(const _Compare& __comp, const allocator_type& __a)
      : _M_impl(__a, __comp)
      { }

      _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
      : _M_impl(__x._M_get_Node_allocator(), __x._M_impl._M_key_compare)
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }

      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
      operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return get_allocator().max_size(); }

      void
      swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t);


      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);



      iterator
      _M_insert_equal_lower(const value_type& __x);

      iterator
      _M_insert_unique(iterator __position, const value_type& __x);

      const_iterator
      _M_insert_unique(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal(iterator __position, const value_type& __x);

      const_iterator
      _M_insert_equal(const_iterator __position, const value_type& __x);

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      void
      erase(const_iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const_iterator __first, const_iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __x);

      const_iterator
      find(const key_type& __x) const;

      size_type
      count(const key_type& __x) const;

      iterator
      lower_bound(const key_type& __x);

      const_iterator
      lower_bound(const key_type& __x) const;

      iterator
      upper_bound(const key_type& __x);

      const_iterator
      upper_bound(const key_type& __x) const;

      pair<iterator,iterator>
      equal_range(const key_type& __x);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return const_iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 if (__j == begin())
   return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
 else
   --__j;
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else
 return __position;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return const_iterator(_M_insert_unique(__v).first);
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return const_iterator(_M_insert_unique(__v).first);
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return const_iterator(_M_insert_unique(__v).first);
 }
      else
 return __position;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {

   iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert(0, _M_rightmost(), __v);
   else
     return const_iterator(_M_insert_equal(__v));
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert(0, __before._M_node, __v);
       else
  return _M_insert(__position._M_node,
     __position._M_node, __v);
     }
   else
     return const_iterator(_M_insert_equal(__v));
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert(0, __position._M_node, __v);
       else
  return _M_insert(__after._M_node, __after._M_node, __v);
     }
   else
     return const_iterator(_M_insert_equal_lower(__v));
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      iterator __j = iterator(__y);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

     while (__x != 0)
       {
  if (!_M_impl._M_key_compare(_S_key(__x), __k))
    __y = __x, __x = _S_left(__x);
  else
    __x = _S_right(__x);
       }
     const_iterator __j = const_iterator(__y);
     return (__j == end()
      || _M_impl._M_key_compare(__k,
           _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    lower_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    upper_bound(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();

      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key, _Val, _KoV,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    { return pair<const_iterator, const_iterator>(lower_bound(__k),
        upper_bound(__k)); }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }

}
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
namespace std {
# 91 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
  template<class _Key, class _Compare = std::less<_Key>,
    class _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;




      set()
      : _M_t(_Compare(), allocator_type()) {}







      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) {}
# 163 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      template<class _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
        : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_unique(__first, __last); }
# 179 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      template<class _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 193 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      set(const set<_Key,_Compare,_Alloc>& __x)
      : _M_t(__x._M_t) { }
# 203 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      set<_Key,_Compare,_Alloc>&
      operator=(const set<_Key, _Compare, _Alloc>& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }




      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }





      iterator
      begin() const
      { return _M_t.begin(); }





      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }


      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 285 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      void
      swap(set<_Key,_Compare,_Alloc>& __x)
      { _M_t.swap(__x._M_t); }
# 303 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      std::pair<iterator,bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 330 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique(__position, __x); }
# 342 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      template<class _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 356 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 371 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 386 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 410 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 428 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 449 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 465 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 490 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<class _K1, class _C1, class _A1>
        friend bool
        operator== (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<class _K1, class _C1, class _A1>
        friend bool
        operator< (const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 519 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 536 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_set.h" 3
  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<class _Key, class _Compare, class _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<class _Key, class _Compare, class _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
namespace std {
# 88 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
  template <class _Key, class _Compare = std::less<_Key>,
     class _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      multiset()
      : _M_t(_Compare(), allocator_type()) { }

      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 153 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      template <class _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_equal(__first, __last); }
# 169 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      template <class _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 183 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      multiset(const multiset<_Key,_Compare,_Alloc>& __x)
      : _M_t(__x._M_t) { }
# 193 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      multiset<_Key,_Compare,_Alloc>&
      operator=(const multiset<_Key,_Compare,_Alloc>& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }




      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }


      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 277 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      void
      swap(multiset<_Key, _Compare, _Alloc>& __x)
      { _M_t.swap(__x._M_t); }
# 293 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 317 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal(__position, __x); }
# 329 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      template <class _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 344 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 359 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 374 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 395 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 413 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 434 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 450 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 475 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <class _K1, class _C1, class _A1>
        friend bool
        operator== (const multiset<_K1, _C1, _A1>&,
      const multiset<_K1, _C1, _A1>&);

      template <class _K1, class _C1, class _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 505 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 522 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multiset.h" 3
  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template <class _Key, class _Compare, class _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template <class _Key, class _Compare, class _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/set" 2 3
# 29 "Cacao/include/cocos2dx/cocoa/CCSet.h" 2


namespace cocos2d {






typedef std::set<CCObject *>::iterator CCSetIterator;

class CCSet : public CCObject
{
public:




    CCSet(void);



    CCSet(const CCSet &rSetObject);




    virtual ~CCSet(void);





    static CCSet * create();




    CCSet* copy();




    CCSet* mutableCopy();



    int count();



    void addObject(CCObject *pObject);



    void removeObject(CCObject *pObject);



    void removeAllObjects();



    bool containsObject(CCObject *pObject);





    CCSetIterator begin();





    CCSetIterator end();



    CCObject* anyObject();




    virtual void acceptVisitor(CCDataVisitor &visitor);

private:
    std::set<CCObject *> *m_pSet;
};




}
# 32 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
namespace std {
# 91 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t(_Compare(), allocator_type()) { }





      explicit
      map(const _Compare& __comp, const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 175 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 187 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_unique(__first, __last); }
# 203 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      template <typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp, const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 225 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }


      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }





      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 341 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 363 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 398 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 425 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique(__position, __x); }
# 437 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 452 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 467 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 482 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 497 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 540 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 555 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 567 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 582 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 597 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 636 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 655 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const map<_K1, _T1, _C1, _A1>&,
      const map<_K1, _T1, _C1, _A1>&);

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);
    };
# 680 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 697 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 2 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 1 3
# 66 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
namespace std {
# 89 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t(_Compare(), allocator_type()) { }





      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 173 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 185 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t(_Compare(), allocator_type())
        { _M_t._M_insert_equal(__first, __last); }
# 201 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 224 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }


      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }



      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 338 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 362 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal(__position, __x); }
# 374 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      template <typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 389 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 404 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 419 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 434 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 477 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 492 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 516 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 531 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 568 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 585 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator== (const multimap<_K1, _T1, _C1, _A1>&,
      const multimap<_K1, _T1, _C1, _A1>&);

      template <typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator< (const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);
  };
# 610 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 627 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

}
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/map" 2 3
# 34 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 3






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 1 3
# 67 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
namespace std {







  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
    };
# 111 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };
# 188 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }







  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 298 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }


      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 406 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
# 449 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      _Node*
      _M_create_node(const value_type& __x)
      {
 _Node* __p = this->_M_get_node();
 try
   {
     _M_get_Tp_allocator().construct(&__p->_M_data, __x);
   }
 catch(...)
   {
     _M_put_node(__p);
     throw;
   }
 return __p;
      }

    public:





      explicit
      list(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 482 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
# 495 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 508 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 533 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 546 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 562 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }






      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 677 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 732 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
# 748 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 762 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
# 777 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 792 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 807 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
# 827 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
# 851 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 872 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 889 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 925 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x)
      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 945 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 971 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      splice(iterator __position, list& __x, iterator __first, iterator __last)
      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 994 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1008 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1022 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      unique();
# 1037 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1050 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      void
      merge(list& __x);
# 1065 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&, _StrictWeakOrdering);






      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:



      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_fill_initialize(static_cast<size_type>(__n),
        static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   push_back(__x);
      }





      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node, __last._M_node); }


      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->hook(__position._M_node);
      }


      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        _M_get_Tp_allocator().destroy(&__n->_M_data);
        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (_M_get_Node_allocator() != __x._M_get_Node_allocator())
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1194 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1223 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/list.tcc" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/list.tcc" 3
namespace std {

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);
   _M_get_Tp_allocator().destroy(&__tmp->_M_data);
   _M_put_node(__tmp);
 }
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     _M_erase(__first);
   __first = __next;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    merge(list& __x)
    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }

}
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/list" 2 3
# 36 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h" 2

typedef struct lua_State lua_State;

namespace cocos2d {

class CCTimer;
class CCLayer;
class CCMenuItem;
class CCNotificationCenter;
class CCCallFunc;
class CCAcceleration;

enum ccScriptType {
    kScriptTypeNone = 0,
    kScriptTypeLua,
    kScriptTypeJavascript
};




class CCScriptHandlerEntry : public CCObject
{
public:
    static CCScriptHandlerEntry* create(int nHandler);
    ~CCScriptHandlerEntry(void);

    int getHandler(void) {
        return m_nHandler;
    }

    int getEntryId(void) {
        return m_nEntryId;
    }

protected:
    CCScriptHandlerEntry(int nHandler)
    : m_nHandler(nHandler)
    {
        static int newEntryId = 0;
        newEntryId++;
        m_nEntryId = newEntryId;
    }

    int m_nHandler;
    int m_nEntryId;
};
# 91 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
class CCSchedulerScriptHandlerEntry : public CCScriptHandlerEntry
{
public:

    static CCSchedulerScriptHandlerEntry* create(int nHandler, float fInterval, bool bPaused);
    ~CCSchedulerScriptHandlerEntry(void);

    cocos2d::CCTimer* getTimer(void) {
        return m_pTimer;
    }

    bool isPaused(void) {
        return m_bPaused;
    }

    void markedForDeletion(void) {
        m_bMarkedForDeletion = true;
    }

    bool isMarkedForDeletion(void) {
        return m_bMarkedForDeletion;
    }

private:
    CCSchedulerScriptHandlerEntry(int nHandler)
    : CCScriptHandlerEntry(nHandler)
    , m_pTimer(__null)
    , m_bPaused(false)
    , m_bMarkedForDeletion(false)
    {
    }
    bool init(float fInterval, bool bPaused);

    cocos2d::CCTimer* m_pTimer;
    bool m_bPaused;
    bool m_bMarkedForDeletion;
};






class CCTouchScriptHandlerEntry : public CCScriptHandlerEntry
{
public:
    static CCTouchScriptHandlerEntry* create(int nHandler, bool bIsMultiTouches, int nPriority, bool bSwallowsTouches);
    ~CCTouchScriptHandlerEntry(void);

    bool isMultiTouches(void) {
        return m_bIsMultiTouches;
    }

    int getPriority(void) {
        return m_nPriority;
    }

    bool getSwallowsTouches(void) {
        return m_bSwallowsTouches;
    }

private:
    CCTouchScriptHandlerEntry(int nHandler)
    : CCScriptHandlerEntry(nHandler)
    , m_bIsMultiTouches(false)
    , m_nPriority(0)
    , m_bSwallowsTouches(false)
    {
    }
    bool init(bool bIsMultiTouches, int nPriority, bool bSwallowsTouches);

    bool m_bIsMultiTouches;
    int m_nPriority;
    bool m_bSwallowsTouches;
};
# 175 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
class CCScriptEngineProtocol
{
public:
    virtual ~CCScriptEngineProtocol() {};


    virtual ccScriptType getScriptType() { return kScriptTypeNone; };


    virtual void removeScriptObjectByCCObject(CCObject* pObj) = 0;


    virtual void removeScriptHandler(int nHandler) {};


    virtual int reallocateScriptHandler(int nHandler) { return -1;}







    virtual int executeString(const char* codes) = 0;





    virtual int executeScriptFile(const char* filename) = 0;







    virtual int executeGlobalFunction(const char* functionName) = 0;







    virtual int executeNodeEvent(CCNode* pNode, int nAction) = 0;

    virtual int executeMenuItemEvent(CCMenuItem* pMenuItem) = 0;

    virtual int executeNotificationEvent(CCNotificationCenter* pNotificationCenter, const char* pszName) = 0;


    virtual int executeCallFuncActionEvent(CCCallFunc* pAction, CCObject* pTarget = __null) = 0;

    virtual int executeSchedule(int nHandler, float dt, CCNode* pNode = __null) = 0;


    virtual int executeLayerTouchesEvent(CCLayer* pLayer, int eventType, CCSet *pTouches) = 0;
    virtual int executeLayerTouchEvent(CCLayer* pLayer, int eventType, CCTouch *pTouch) = 0;


    virtual int executeLayerKeypadEvent(CCLayer* pLayer, int eventType) = 0;


    virtual int executeAccelerometerEvent(CCLayer* pLayer, CCAcceleration* pAccelerationValue) = 0;


    virtual int executeEvent(int nHandler, const char* pEventName, CCObject* pEventSource = __null, const char* pEventSourceClassName = __null) = 0;


    virtual int executeEventWithArgs(int nHandler, CCArray* pArgs) { return 0; }




    virtual bool handleAssert(const char *msg) = 0;




    enum ConfigType
    {
        NONE,
        COCOSTUDIO,
    };
    virtual bool parseConfig(ConfigType type, const std::string& str) = 0;
};
# 270 "Cacao/include/cocos2dx/script_support/CCScriptSupport.h"
class CCScriptEngineManager
{
public:
    ~CCScriptEngineManager(void);

    CCScriptEngineProtocol* getScriptEngine(void) {
        return m_pScriptEngine;
    }
    void setScriptEngine(CCScriptEngineProtocol *pScriptEngine);
    void removeScriptEngine(void);

    static CCScriptEngineManager* sharedManager(void);
    static void purgeSharedManager(void);

private:
    CCScriptEngineManager(void)
    : m_pScriptEngine(__null)
    {
    }

    CCScriptEngineProtocol *m_pScriptEngine;
};




}
# 39 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2
# 1 "Cacao/include/cocos2dx/include/CCProtocols.h" 1
# 29 "Cacao/include/cocos2dx/include/CCProtocols.h"
# 1 "Cacao/include/cocos2dx/include/ccTypes.h" 1
# 35 "Cacao/include/cocos2dx/include/ccTypes.h"
namespace cocos2d {




typedef struct _ccColor3B
{
    GLubyte r;
    GLubyte g;
    GLubyte b;
} ccColor3B;


static inline ccColor3B
ccc3(const GLubyte r, const GLubyte g, const GLubyte b)
{
    ccColor3B c = {r, g, b};
    return c;
}



static inline bool ccc3BEqual(const ccColor3B &col1, const ccColor3B &col2)
{
    return col1.r == col2.r && col1.g == col2.g && col1.b == col2.b;
}



static const ccColor3B ccWHITE={255,255,255};

static const ccColor3B ccYELLOW={255,255,0};

static const ccColor3B ccBLUE={0,0,255};

static const ccColor3B ccGREEN={0,255,0};

static const ccColor3B ccRED={255,0,0};

static const ccColor3B ccMAGENTA={255,0,255};

static const ccColor3B ccBLACK={0,0,0};

static const ccColor3B ccORANGE={255,127,0};

static const ccColor3B ccGRAY={166,166,166};




typedef struct _ccColor4B
{
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
} ccColor4B;

static inline ccColor4B
ccc4(const GLubyte r, const GLubyte g, const GLubyte b, const GLubyte o)
{
    ccColor4B c = {r, g, b, o};
    return c;
}





typedef struct _ccColor4F {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
} ccColor4F;





static inline ccColor4F ccc4FFromccc3B(ccColor3B c)
{
    ccColor4F c4 = {c.r/255.f, c.g/255.f, c.b/255.f, 1.f};
    return c4;
}


static inline ccColor4F
ccc4f(const GLfloat r, const GLfloat g, const GLfloat b, const GLfloat a)
{
    ccColor4F c4 = {r, g, b, a};
    return c4;
}




static inline ccColor4F ccc4FFromccc4B(ccColor4B c)
{
    ccColor4F c4 = {c.r/255.f, c.g/255.f, c.b/255.f, c.a/255.f};
    return c4;
}

static inline ccColor4B ccc4BFromccc4F(ccColor4F c)
{
    ccColor4B ret = {(GLubyte)(c.r*255), (GLubyte)(c.g*255), (GLubyte)(c.b*255), (GLubyte)(c.a*255)};
 return ret;
}




static inline bool ccc4FEqual(ccColor4F a, ccColor4F b)
{
    return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
}




typedef struct _ccVertex2F
{
    GLfloat x;
    GLfloat y;
} ccVertex2F;

static inline ccVertex2F vertex2(const float x, const float y)
{
    ccVertex2F c = {x, y};
    return c;
}





typedef struct _ccVertex3F
{
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ccVertex3F;

static inline ccVertex3F vertex3(const float x, const float y, const float z)
{
    ccVertex3F c = {x, y, z};
    return c;
}




typedef struct _ccTex2F {
     GLfloat u;
     GLfloat v;
} ccTex2F;

static inline ccTex2F tex2(const float u, const float v)
{
    ccTex2F t = {u , v};
    return t;
}



typedef struct _ccPointSprite
{
    ccVertex2F pos;
    ccColor4B color;
    GLfloat size;
} ccPointSprite;


typedef struct _ccQuad2 {
    ccVertex2F tl;
    ccVertex2F tr;
    ccVertex2F bl;
    ccVertex2F br;
} ccQuad2;



typedef struct _ccQuad3 {
    ccVertex3F bl;
    ccVertex3F br;
    ccVertex3F tl;
    ccVertex3F tr;
} ccQuad3;


typedef struct _ccV2F_C4B_T2F
{

    ccVertex2F vertices;

    ccColor4B colors;

    ccTex2F texCoords;
} ccV2F_C4B_T2F;


typedef struct _ccV2F_C4F_T2F
{

    ccVertex2F vertices;

    ccColor4F colors;

    ccTex2F texCoords;
} ccV2F_C4F_T2F;


typedef struct _ccV3F_C4B_T2F
{

    ccVertex3F vertices;



    ccColor4B colors;



    ccTex2F texCoords;
} ccV3F_C4B_T2F;


typedef struct _ccV2F_C4B_T2F_Triangle
{

 ccV2F_C4B_T2F a;

 ccV2F_C4B_T2F b;

 ccV2F_C4B_T2F c;
} ccV2F_C4B_T2F_Triangle;


typedef struct _ccV2F_C4B_T2F_Quad
{

    ccV2F_C4B_T2F bl;

    ccV2F_C4B_T2F br;

    ccV2F_C4B_T2F tl;

    ccV2F_C4B_T2F tr;
} ccV2F_C4B_T2F_Quad;


typedef struct _ccV3F_C4B_T2F_Quad
{

    ccV3F_C4B_T2F tl;

    ccV3F_C4B_T2F bl;

    ccV3F_C4B_T2F tr;

    ccV3F_C4B_T2F br;
} ccV3F_C4B_T2F_Quad;


typedef struct _ccV2F_C4F_T2F_Quad
{

    ccV2F_C4F_T2F bl;

    ccV2F_C4F_T2F br;

    ccV2F_C4F_T2F tl;

    ccV2F_C4F_T2F tr;
} ccV2F_C4F_T2F_Quad;


typedef struct _ccBlendFunc
{

    GLenum src;

    GLenum dst;
} ccBlendFunc;

static const ccBlendFunc kCCBlendFuncDisable = {1, 0};



typedef enum
{
    kCCVerticalTextAlignmentTop,
    kCCVerticalTextAlignmentCenter,
    kCCVerticalTextAlignmentBottom,
} CCVerticalTextAlignment;



typedef enum
{
    kCCTextAlignmentLeft,
    kCCTextAlignmentCenter,
    kCCTextAlignmentRight,
} CCTextAlignment;




typedef struct _ccT2F_Quad
{

    ccTex2F bl;

    ccTex2F br;

    ccTex2F tl;

    ccTex2F tr;
} ccT2F_Quad;


typedef struct
{
    ccT2F_Quad texCoords;
    float delay;
    CCSize size;
} ccAnimationFrameData;
# 370 "Cacao/include/cocos2dx/include/ccTypes.h"
typedef struct _ccFontShadow
{
public:


    _ccFontShadow(): m_shadowEnabled(false) {}


    bool m_shadowEnabled;

 CCSize m_shadowOffset;

 float m_shadowBlur;

 float m_shadowOpacity;

} ccFontShadow;


typedef struct _ccFontStroke
{
public:


    _ccFontStroke(): m_strokeEnabled(false) {}


    bool m_strokeEnabled;

 ccColor3B m_strokeColor;

    float m_strokeSize;

} ccFontStroke;






typedef struct _ccFontDefinition
{
public:

    _ccFontDefinition(): m_alignment(kCCTextAlignmentCenter),
    m_vertAlignment(kCCVerticalTextAlignmentTop),
    m_fontFillColor(ccWHITE)
    { m_dimensions = CCSize((float)(0), (float)(0)); }


    std::string m_fontName;

    int m_fontSize;

    CCTextAlignment m_alignment;

    CCVerticalTextAlignment m_vertAlignment;

    CCSize m_dimensions;

    ccColor3B m_fontFillColor;

    ccFontShadow m_shadow;

    ccFontStroke m_stroke;

} ccFontDefinition;


}
# 30 "Cacao/include/cocos2dx/include/CCProtocols.h" 2
# 1 "Cacao/include/cocos2dx/textures/CCTexture2D.h" 1
# 37 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
namespace cocos2d {

class CCImage;
# 51 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
typedef enum {


    kCCTexture2DPixelFormat_RGBA8888,

    kCCTexture2DPixelFormat_RGB888,

    kCCTexture2DPixelFormat_RGB565,

    kCCTexture2DPixelFormat_A8,

    kCCTexture2DPixelFormat_I8,

    kCCTexture2DPixelFormat_AI88,

    kCCTexture2DPixelFormat_RGBA4444,

    kCCTexture2DPixelFormat_RGB5A1,

    kCCTexture2DPixelFormat_PVRTC4,

    kCCTexture2DPixelFormat_PVRTC2,



    kCCTexture2DPixelFormat_Default = kCCTexture2DPixelFormat_RGBA8888,


    kTexture2DPixelFormat_RGBA8888 = kCCTexture2DPixelFormat_RGBA8888,
    kTexture2DPixelFormat_RGB888 = kCCTexture2DPixelFormat_RGB888,
    kTexture2DPixelFormat_RGB565 = kCCTexture2DPixelFormat_RGB565,
    kTexture2DPixelFormat_A8 = kCCTexture2DPixelFormat_A8,
    kTexture2DPixelFormat_RGBA4444 = kCCTexture2DPixelFormat_RGBA4444,
    kTexture2DPixelFormat_RGB5A1 = kCCTexture2DPixelFormat_RGB5A1,
    kTexture2DPixelFormat_Default = kCCTexture2DPixelFormat_Default

} CCTexture2DPixelFormat;

class CCGLProgram;




typedef struct _ccTexParams {
    GLuint minFilter;
    GLuint magFilter;
    GLuint wrapS;
    GLuint wrapT;
} ccTexParams;
# 109 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
class CCTexture2D : public CCObject



{
public:



    CCTexture2D();




    virtual ~CCTexture2D();




    const char* description(void);




    void releaseData(void *data);



    void* keepData(void *data, unsigned int length);





    bool initWithData(const void* data, CCTexture2DPixelFormat pixelFormat, unsigned int pixelsWide, unsigned int pixelsHigh, const CCSize& contentSize);






    void drawAtPoint(const CCPoint& point);

    void drawInRect(const CCRect& rect);







    bool initWithImage(CCImage * uiImage);


    bool initWithString(const char *text, const char *fontName, float fontSize, const CCSize& dimensions, CCTextAlignment hAlignment, CCVerticalTextAlignment vAlignment);

    bool initWithString(const char *text, const char *fontName, float fontSize);

    bool initWithString(const char *text, ccFontDefinition *textDefinition);


    bool initWithPVRFile(const char* file);


    bool initWithETCFile(const char* file);
# 186 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    void setTexParameters(ccTexParams* texParams);
# 196 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    void setAntiAliasTexParameters();
# 206 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    void setAliasTexParameters();






    void generateMipmap();




    const char* stringForFormat();




    unsigned int bitsPerPixelForFormat();




    unsigned int bitsPerPixelForFormat(CCTexture2DPixelFormat format);
# 247 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    static void setDefaultAlphaPixelFormat(CCTexture2DPixelFormat format);





    static CCTexture2DPixelFormat defaultAlphaPixelFormat();
# 263 "Cacao/include/cocos2dx/textures/CCTexture2D.h"
    static void PVRImagesHavePremultipliedAlpha(bool haveAlphaPremultiplied);


    const CCSize& getContentSizeInPixels();

    bool hasPremultipliedAlpha();
    bool hasMipmaps();


    void releaseGLTexture(void);
private:
    bool initPremultipliedATextureWithImage(CCImage * image, unsigned int pixelsWide, unsigned int pixelsHigh);


    bool m_bPVRHaveAlphaPremultiplied;


    protected: CCTexture2DPixelFormat m_ePixelFormat;public: virtual CCTexture2DPixelFormat getPixelFormat(void);

    protected: unsigned int m_uPixelsWide;public: virtual unsigned int getPixelsWide(void);

    protected: unsigned int m_uPixelsHigh;public: virtual unsigned int getPixelsHigh(void);


    protected: GLuint m_uName;public: virtual GLuint getName(void);


    protected: GLfloat m_fMaxS;public: virtual GLfloat getMaxS(void);public: virtual void setMaxS(GLfloat var);

    protected: GLfloat m_fMaxT;public: virtual GLfloat getMaxT(void);public: virtual void setMaxT(GLfloat var);

    protected: CCSize m_tContentSize;public: virtual CCSize getContentSize(void);


    bool m_bHasPremultipliedAlpha;

    bool m_bHasMipmaps;


    protected: CCGLProgram* m_pShaderProgram;public: virtual CCGLProgram* getShaderProgram(void);public: virtual void setShaderProgram(CCGLProgram* var);;
};




}
# 31 "Cacao/include/cocos2dx/include/CCProtocols.h" 2


namespace cocos2d {





class CCRGBAProtocol
{
public:





    virtual void setColor(const ccColor3B& color) = 0;






    virtual const ccColor3B& getColor(void) = 0;






    virtual const ccColor3B& getDisplayedColor(void) = 0;






    virtual GLubyte getDisplayedOpacity(void) = 0;
# 77 "Cacao/include/cocos2dx/include/CCProtocols.h"
    virtual GLubyte getOpacity(void) = 0;






    virtual void setOpacity(GLubyte opacity) = 0;
# 96 "Cacao/include/cocos2dx/include/CCProtocols.h"
    virtual void setOpacityModifyRGB(bool bValue) = 0;







    virtual bool isOpacityModifyRGB(void) = 0;




    virtual bool isCascadeColorEnabled(void) = 0;
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled) = 0;




    virtual void updateDisplayedColor(const ccColor3B& color) = 0;




    virtual bool isCascadeOpacityEnabled(void) = 0;
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled) = 0;




    virtual void updateDisplayedOpacity(GLubyte opacity) = 0;
};
# 136 "Cacao/include/cocos2dx/include/CCProtocols.h"
class CCBlendProtocol
{
public:







    virtual void setBlendFunc(ccBlendFunc blendFunc) = 0;






    virtual ccBlendFunc getBlendFunc(void) = 0;
};
# 166 "Cacao/include/cocos2dx/include/CCProtocols.h"
class CCTextureProtocol : public CCBlendProtocol
{
public:






    virtual CCTexture2D* getTexture(void) = 0;







    virtual void setTexture(CCTexture2D *texture) = 0;
};






class CCLabelProtocol
{
public:





    virtual void setString(const char *label) = 0;






    virtual const char* getString(void) = 0;
};






class CCDirectorDelegate
{
public:



    virtual void updateProjection(void) = 0;
};

}
# 40 "Cacao/include/cocos2dx/base_nodes/CCNode.h" 2

namespace cocos2d {

class CCCamera;
class CCGridBase;
class CCPoint;
class CCTouch;
class CCAction;
class CCRGBAProtocol;
class CCLabelProtocol;
class CCScheduler;
class CCActionManager;
class CCComponent;
class CCDictionary;
class CCComponentContainer;






enum {
    kCCNodeTagInvalid = -1,
};

enum {
    kCCNodeOnEnter,
    kCCNodeOnExit,
    kCCNodeOnEnterTransitionDidFinish,
    kCCNodeOnExitTransitionDidStart,
    kCCNodeOnCleanup
};
# 128 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
class CCNode : public CCObject
{
public:







    CCNode(void);






    virtual ~CCNode(void);





    virtual bool init();




    static CCNode * create(void);






    const char* description(void);
# 182 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setZOrder(int zOrder);
# 191 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void _setZOrder(int z);







    virtual int getZOrder();
# 214 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setVertexZ(float vertexZ);







    virtual float getVertexZ();
# 232 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScaleX(float fScaleX);







    virtual float getScaleX();
# 250 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScaleY(float fScaleY);







    virtual float getScaleY();
# 268 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScale(float scale);
# 277 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual float getScale();
# 288 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScale(float fScaleX,float fScaleY);
# 305 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setPosition(const CCPoint &position);







    virtual const CCPoint& getPosition();
# 331 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setPosition(float x, float y);





    virtual void getPosition(float* x, float* y);




    virtual void setPositionX(float x);
    virtual float getPositionX(void);
    virtual void setPositionY(float y);
    virtual float getPositionY(void);
# 357 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setSkewX(float fSkewX);







    virtual float getSkewX();
# 377 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setSkewY(float fSkewY);







    virtual float getSkewY();
# 399 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setAnchorPoint(const CCPoint& anchorPoint);







    virtual const CCPoint& getAnchorPoint();
# 416 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual const CCPoint& getAnchorPointInPoints();
# 427 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setContentSize(const CCSize& contentSize);







    virtual const CCSize& getContentSize() const;


    virtual CCSize getScaledContentSize();
# 447 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setVisible(bool visible);







    virtual bool isVisible();
# 466 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setRotation(float fRotation);







    virtual float getRotation();
# 485 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setRotationX(float fRotaionX);







    virtual float getRotationX();
# 504 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setRotationY(float fRotationY);







    virtual float getRotationY();
# 525 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setOrderOfArrival(unsigned int uOrderOfArrival);







    virtual unsigned int getOrderOfArrival();
# 542 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setGLServerState(ccGLServerState glServerState);






    virtual ccGLServerState getGLServerState();
# 561 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void ignoreAnchorPointForPosition(bool ignore);







    virtual bool isIgnoreAnchorPointForPosition();
# 584 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void addChild(CCNode * child);
# 593 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void addChild(CCNode * child, int zOrder);
# 603 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);







    virtual CCNode * getChildByTag(int tag);
# 628 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCArray* getChildren();






    virtual unsigned int getChildrenCount(void) const;






    virtual void setParent(CCNode* parent);







    virtual CCNode* getParent();
# 660 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void removeFromParent();






    virtual void removeFromParentAndCleanup(bool cleanup);


    virtual void removeMeAndCleanup();







    virtual void removeChild(CCNode* child);






    virtual void removeChild(CCNode* child, bool cleanup);







    virtual void removeChildByTag(int tag);






    virtual void removeChildByTag(int tag, bool cleanup);





    virtual void removeAllChildren();






    virtual void removeAllChildrenWithCleanup(bool cleanup);







    virtual void reorderChild(CCNode * child, int zOrder);






    virtual void sortAllChildren();
# 743 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCGridBase* getGrid();





    virtual void setGrid(CCGridBase *pGrid);
# 811 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void* getUserData();
# 822 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setUserData(void *pUserData);
# 832 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCObject* getUserObject();
# 843 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setUserObject(CCObject *pUserObject);
# 855 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCGLProgram* getShaderProgram();
# 867 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setShaderProgram(CCGLProgram *pShaderProgram);
# 882 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual CCCamera* getCamera();
# 891 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual bool isRunning();
# 918 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void registerScriptHandler(int handler);





    virtual void unregisterScriptHandler(void);







    inline int getScriptHandler() { return m_nScriptHandler; };





    void scheduleUpdateWithPriorityLua(int nHandler, int priority);
# 954 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void onEnter();







    virtual void onEnterTransitionDidFinish();
# 972 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void onExit();







    virtual void onExitTransitionDidStart();







    virtual void cleanup(void);
# 1000 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void draw(void);




    virtual void visit(void);
# 1018 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCRect boundingBox(void);
# 1030 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setActionManager(CCActionManager* actionManager);





    virtual CCActionManager* getActionManager();
# 1046 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCAction* runAction(CCAction* action);




    void stopAllActions(void);






    void stopAction(CCAction* action);






    void stopActionByTag(int tag);
# 1074 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCAction* getActionByTag(int tag);
# 1086 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    unsigned int numberOfRunningActions(void);
# 1101 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    virtual void setScheduler(CCScheduler* scheduler);







    virtual CCScheduler* getScheduler();
# 1119 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    bool isScheduled(SEL_SCHEDULE selector);
# 1129 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void scheduleUpdate(void);
# 1139 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void scheduleUpdateWithPriority(int priority);





    void unscheduleUpdate(void);
# 1163 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void schedule(SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay);
# 1173 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void schedule(SEL_SCHEDULE selector, float interval);
# 1183 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void scheduleOnce(SEL_SCHEDULE selector, float delay);
# 1192 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void schedule(SEL_SCHEDULE selector);
# 1201 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void unschedule(SEL_SCHEDULE selector);





    void unscheduleAllSelectors(void);







    void resumeSchedulerAndActions(void);






    void pauseSchedulerAndActions(void);




    virtual void update(float delta);
# 1237 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void transform(void);





    void transformAncestors(void);







    virtual void updateTransform(void);







    virtual const CCAffineTransform nodeToParentTransform(void);





    virtual const CCAffineTransform parentToNodeTransform(void);




    virtual CCAffineTransform nodeToWorldTransform(void);




    virtual CCAffineTransform worldToNodeTransform(void);
# 1286 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCPoint convertToNodeSpace(const CCPoint& worldPoint);




    CCPoint convertToWorldSpace(const CCPoint& nodePoint);





    CCPoint convertToNodeSpaceAR(const CCPoint& worldPoint);





    CCPoint convertToWorldSpaceAR(const CCPoint& nodePoint);




    CCPoint convertTouchToNodeSpace(CCTouch * touch);




    CCPoint convertTouchToNodeSpaceAR(CCTouch * touch);
# 1363 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    void setAdditionalTransform(const CCAffineTransform& additionalTransform);
# 1372 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
    CCComponent* getComponent(const char *pName) const;




    virtual bool addComponent(CCComponent *pComponent);




    virtual bool removeComponent(const char *pName);




    virtual bool removeComponent(CCComponent *pComponent);




    virtual void removeAllComponents();



    virtual void updateTweenAction(float, char const*);
private:

    void childrenAlloc(void);


    void insertChild(CCNode* child, int z);


    void detachChild(CCNode *child, bool doCleanup);





    CCPoint convertToWindowSpace(const CCPoint& nodePoint);

protected:
    float m_fRotationX;
    float m_fRotationY;

    float m_fScaleX;
    float m_fScaleY;

    float m_fVertexZ;

    CCPoint m_obPosition;

    float m_fSkewX;
    float m_fSkewY;

    CCPoint m_obAnchorPointInPoints;
    CCPoint m_obAnchorPoint;

    CCSize m_obContentSize;


    CCAffineTransform m_sAdditionalTransform;
    CCAffineTransform m_sTransform;
    CCAffineTransform m_sInverse;

    CCCamera *m_pCamera;

    CCGridBase *m_pGrid;

    int m_nZOrder;

    CCArray *m_pChildren;
    CCNode *m_pParent;



    void *m_pUserData;
    CCObject *m_pUserObject;

    CCGLProgram *m_pShaderProgram;

    ccGLServerState m_eGLServerState;

    unsigned int m_uOrderOfArrival;

    CCScheduler *m_pScheduler;

    CCActionManager *m_pActionManager;

    bool m_bRunning;

    bool m_bTransformDirty;
    bool m_bInverseDirty;
    bool m_bAdditionalTransformDirty;
    bool m_bVisible;

    bool m_bIgnoreAnchorPointForPosition;


    bool m_bReorderChildDirty;

    int m_nScriptHandler;
    int m_nUpdateScriptHandler;
    ccScriptType m_eScriptType;

    CCComponentContainer *m_pComponentContainer;

};
# 1494 "Cacao/include/cocos2dx/base_nodes/CCNode.h"
class CCNodeRGBA : public CCNode, public CCRGBAProtocol
{
public:



    CCNodeRGBA();




    virtual ~CCNodeRGBA();

    virtual bool init();





    static CCNodeRGBA * create(void);

    virtual GLubyte getOpacity();
    virtual GLubyte getDisplayedOpacity();
    virtual void setOpacity(GLubyte opacity);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual bool isCascadeOpacityEnabled();
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);

    virtual const ccColor3B& getColor(void);
    virtual const ccColor3B& getDisplayedColor();
    virtual void setColor(const ccColor3B& color);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual bool isCascadeColorEnabled();
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled);

    virtual void setOpacityModifyRGB(bool bValue) {(void)bValue;};
    virtual bool isOpacityModifyRGB() { return false; };

protected:
 GLubyte _displayedOpacity;
    GLubyte _realOpacity;
 ccColor3B _displayedColor;
    ccColor3B _realColor;
 bool _cascadeColorEnabled;
    bool _cascadeOpacityEnabled;
};




}
# 31 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 2


# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrame.h" 1
# 35 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrame.h"
namespace cocos2d {

class CCTexture2D;
class CCZone;
# 55 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrame.h"
class CCSpriteFrame : public CCObject
{
public:


    inline const CCRect& getRectInPixels(void) { return m_obRectInPixels; }
    void setRectInPixels(const CCRect& rectInPixels);

    inline bool isRotated(void) { return m_bRotated; }
    inline void setRotated(bool bRotated) { m_bRotated = bRotated; }


    inline const CCRect& getRect(void) { return m_obRect; }

    void setRect(const CCRect& rect);


    const CCPoint& getOffsetInPixels(void);

    void setOffsetInPixels(const CCPoint& offsetInPixels);


    inline const CCSize& getOriginalSizeInPixels(void) { return m_obOriginalSizeInPixels; }

    inline void setOriginalSizeInPixels(const CCSize& sizeInPixels) { m_obOriginalSizeInPixels = sizeInPixels; }


    inline const CCSize& getOriginalSize(void) { return m_obOriginalSize; }

    inline void setOriginalSize(const CCSize& sizeInPixels) { m_obOriginalSize = sizeInPixels; }


    CCTexture2D* getTexture(void);

    void setTexture(CCTexture2D* pobTexture);

    const CCPoint& getOffset(void);
    void setOffset(const CCPoint& offsets);

public:




    ~CCSpriteFrame(void);




    virtual CCObject* copyWithZone(CCZone *pZone);




    static CCSpriteFrame* create(const char* filename, const CCRect& rect);




    static CCSpriteFrame* create(const char* filename, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);




    static CCSpriteFrame* createWithTexture(CCTexture2D* pobTexture, const CCRect& rect);




    static CCSpriteFrame* createWithTexture(CCTexture2D* pobTexture, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);

public:



    bool initWithTexture(CCTexture2D* pobTexture, const CCRect& rect);




    bool initWithTextureFilename(const char* filename, const CCRect& rect);




    bool initWithTexture(CCTexture2D* pobTexture, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);






    bool initWithTextureFilename(const char* filename, const CCRect& rect, bool rotated, const CCPoint& offset, const CCSize& originalSize);


protected:
    CCPoint m_obOffset;
    CCSize m_obOriginalSize;
    CCRect m_obRectInPixels;
    bool m_bRotated;
    CCRect m_obRect;
    CCPoint m_obOffsetInPixels;
    CCSize m_obOriginalSizeInPixels;
    CCTexture2D *m_pobTexture;
    std::string m_strTextureFilename;
};




}
# 34 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 2
# 1 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h" 1
# 32 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
# 1 "Cacao/include/cocos2dx/cocoa/CCDictionary.h" 1
# 28 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
# 1 "Cacao/include/cocos2dx/support/data_support/uthash.h" 1
# 28 "Cacao/include/cocos2dx/support/data_support/uthash.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/stddef.h" 1 3
# 29 "Cacao/include/cocos2dx/support/data_support/uthash.h" 2
# 872 "Cacao/include/cocos2dx/support/data_support/uthash.h"
typedef struct UT_hash_bucket {
   struct UT_hash_handle *hh_head;
   unsigned count;
# 888 "Cacao/include/cocos2dx/support/data_support/uthash.h"
   unsigned expand_mult;

} UT_hash_bucket;





typedef struct UT_hash_table {
   UT_hash_bucket *buckets;
   unsigned num_buckets, log2_num_buckets;
   unsigned num_items;
   struct UT_hash_handle *tail;
   ptrdiff_t hho;



   unsigned ideal_chain_maxlen;




   unsigned nonideal_items;







   unsigned ineff_expands, noexpand;

   uint32_t signature;






} UT_hash_table;

typedef struct UT_hash_handle {
   struct UT_hash_table *tbl;
   void *prev;
   void *next;
   struct UT_hash_handle *hh_prev;
   struct UT_hash_handle *hh_next;
   void *key;
   unsigned keylen;
   unsigned hashv;
} UT_hash_handle;
# 29 "Cacao/include/cocos2dx/cocoa/CCDictionary.h" 2


# 1 "Cacao/include/cocos2dx/cocoa/CCString.h" 1
# 33 "Cacao/include/cocos2dx/cocoa/CCString.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/functional" 1 3
# 52 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/functional" 3
# 34 "Cacao/include/cocos2dx/cocoa/CCString.h" 2


namespace cocos2d {







class CCString : public CCObject
{
public:



    CCString();



    CCString(const char* str);



    CCString(const std::string& str);



    CCString(const CCString& str);



    virtual ~CCString();




    CCString& operator= (const CCString& other);




    bool initWithFormat(const char* format, ...) __attribute__((__format__(printf, 2, 3)));


    int intValue() const;


    unsigned int uintValue() const;


    float floatValue() const;


    double doubleValue() const;


    bool boolValue() const;


    const char* getCString() const;


    unsigned int length() const;


    int compare(const char *) const;





    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual bool isEqual(const CCObject* pObject);





    static CCString* create(const std::string& str);







    static CCString* createWithFormat(const char* format, ...) __attribute__((__format__(printf, 1, 2)));





    static CCString* createWithData(const unsigned char* pData, unsigned long nLen);





    static CCString* createWithContentsOfFile(const char* pszFileName);



    virtual void acceptVisitor(CCDataVisitor &visitor);

private:


    bool initWithFormatAndValist(const char* format, va_list ap);

public:
    std::string m_sString;
};

struct CCStringCompare : public std::binary_function<CCString *, CCString *, bool> {
    public:
        bool operator() (CCString * a, CCString * b) const {
            return strcmp(a->getCString(), b->getCString()) < 0;
        }
};







}
# 32 "Cacao/include/cocos2dx/cocoa/CCDictionary.h" 2

namespace cocos2d {

class CCDictionary;
# 63 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
class CCDictElement
{
private:






    CCDictElement(const char* pszKey, CCObject* pObject);







    CCDictElement(intptr_t iKey, CCObject* pObject);

public:



    ~CCDictElement();
# 97 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    inline const char* getStrKey() const
    {
        ((void)(m_szKey[0] != '\0'));
        return m_szKey;
    }
# 110 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    inline intptr_t getIntKey() const
    {
        ((void)(m_szKey[0] == '\0'));
        return m_iKey;
    }






    inline CCObject* getObject() const { return m_pObject; }

private:




    char m_szKey[256];
    intptr_t m_iKey;
    CCObject* m_pObject;
public:
    UT_hash_handle hh;
    friend class CCDictionary;
};
# 174 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
class CCDictionary : public CCObject
{
public:




    CCDictionary();





    ~CCDictionary();






    unsigned int count();






    CCArray* allKeys();






    CCArray* allKeysForObject(CCObject* object);
# 228 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    CCObject* objectForKey(const std::string& key);
# 238 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    CCObject* objectForKey(intptr_t key);
# 248 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    const CCString* valueForKey(const std::string& key);
# 258 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    const CCString* valueForKey(intptr_t key);
# 271 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void setObject(CCObject* pObject, const std::string& key);
# 283 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void setObject(CCObject* pObject, intptr_t key);
# 292 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectForKey(const std::string& key);
# 301 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectForKey(intptr_t key);
# 310 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectsForKeys(CCArray* pKeyArray);
# 320 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    void removeObjectForElememt(CCDictElement* pElement);







    void removeAllObjects();
# 338 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    virtual CCObject* copyWithZone(CCZone* pZone);
# 348 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    CCObject* randomObject();






    static CCDictionary* create();
# 364 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    static CCDictionary* createWithDictionary(CCDictionary* srcDict);







    static CCDictionary* createWithContentsOfFile(const char *pFileName);







    bool writeToFile(const char *fullPath);
# 394 "Cacao/include/cocos2dx/cocoa/CCDictionary.h"
    static CCDictionary* createWithContentsOfFileThreadSafe(const char *pFileName);




    virtual void acceptVisitor(CCDataVisitor &visitor);

private:



    void setObjectUnSafe(CCObject* pObject, const std::string& key);
    void setObjectUnSafe(CCObject* pObject, const intptr_t key);

public:





    CCDictElement* m_pElements;
private:


    enum CCDictType
    {
        kCCDictUnknown = 0,
        kCCDictStr,
        kCCDictInt
    };




    CCDictType m_eDictType;
};




}
# 33 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h" 2




namespace cocos2d {

class CCTexture2D;
class CCSpriteFrame;
# 55 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
class CCAnimationFrame : public CCObject
{
public:



    CCAnimationFrame();




    virtual ~CCAnimationFrame();




    virtual CCObject* copyWithZone(CCZone* pZone);

    bool initWithSpriteFrame(CCSpriteFrame* spriteFrame, float delayUnits, CCDictionary* userInfo);
# 86 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
    CCSpriteFrame* getSpriteFrame(void)const;
    void setSpriteFrame(CCSpriteFrame*);

    float getDelayUnits(void)const;
    void setDelayUnits(float);

    CCDictionary* getUserInfo(void)const;
    void setUserInfo(CCDictionary*);
};
# 107 "Cacao/include/cocos2dx/sprite_nodes/CCAnimation.h"
class CCAnimation : public CCObject
{
public:



    CCAnimation();




    ~CCAnimation(void);
public:



    static CCAnimation* create(void);






    static CCAnimation* createWithSpriteFrames(CCArray* arrayOfSpriteFrameNames, float delay = 0.0f);




    static CCAnimation* create(CCArray *arrayOfAnimationFrameNames, float delayPerUnit, unsigned int loops);
    static CCAnimation* create(CCArray *arrayOfAnimationFrameNames, float delayPerUnit) {
        return CCAnimation::create(arrayOfAnimationFrameNames, delayPerUnit, 1);
    }




    void addSpriteFrame(CCSpriteFrame *pFrame);






    void addSpriteFrameWithFileName(const char *pszFileName);





    void addSpriteFrameWithTexture(CCTexture2D* pobTexture, const CCRect& rect);



    bool init();





    bool initWithSpriteFrames(CCArray *pFrames, float delay = 0.0f);





    bool initWithAnimationFrames(CCArray* arrayOfAnimationFrames, float delayPerUnit, unsigned int loops);




    virtual CCObject* copyWithZone(CCZone* pZone);


    protected: float m_fTotalDelayUnits;public: float getTotalDelayUnits(void) const { return m_fTotalDelayUnits; }


    protected: float m_fDelayPerUnit;public: float getDelayPerUnit(void) const { return m_fDelayPerUnit; }public: void setDelayPerUnit(float var){ m_fDelayPerUnit = var; }


    protected: float m_fDuration;public: virtual float getDuration(void);


    private: CCArray* m_pFrames; public: CCArray* getFrames(void) const { return m_pFrames; } public: void setFrames(CCArray* var);


    protected: bool m_bRestoreOriginalFrame;public: bool getRestoreOriginalFrame(void) const { return m_bRestoreOriginalFrame; }public: void setRestoreOriginalFrame(bool var){ m_bRestoreOriginalFrame = var; }


    protected: unsigned int m_uLoops;public: unsigned int getLoops(void) const { return m_uLoops; }public: void setLoops(unsigned int var){ m_uLoops = var; }
};




}
# 35 "Cacao/include/cocos2dx/actions/CCActionInterval.h" 2


namespace cocos2d {
# 61 "Cacao/include/cocos2dx/actions/CCActionInterval.h"
class CCActionInterval : public CCFiniteTimeAction
{
public:

    inline float getElapsed(void) { return m_elapsed; }


    bool initWithDuration(float d);


    virtual bool isDone(void);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void step(float dt);
    virtual void startWithTarget(CCNode *pTarget);

    virtual CCActionInterval* reverse(void);

public:


    static CCActionInterval* create(float d);

public:

    void setAmplitudeRate(float amp);
    float getAmplitudeRate(void);

protected:
    float m_elapsed;
    bool m_bFirstTick;
};



class CCSequence : public CCActionInterval
{
public:




    ~CCSequence(void);




    bool initWithTwoActions(CCFiniteTimeAction *pActionOne, CCFiniteTimeAction *pActionTwo);




    virtual CCObject* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void stop(void);



    virtual void update(float t);
    virtual CCActionInterval* reverse(void);

public:




    static CCSequence* create(CCFiniteTimeAction *pAction1, ...);



    static CCSequence* create(CCArray *arrayOfActions);




    static CCSequence* createWithVariableList(CCFiniteTimeAction *pAction1, va_list args);



    static CCSequence* createWithTwoActions(CCFiniteTimeAction *pActionOne, CCFiniteTimeAction *pActionTwo);

protected:
    CCFiniteTimeAction *m_pActions[2];
    float m_split;
    int m_last;
};




class CCRepeat : public CCActionInterval
{
public:




    ~CCRepeat(void);


    bool initWithAction(CCFiniteTimeAction *pAction, unsigned int times);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float dt);
    virtual bool isDone(void);
    virtual CCActionInterval* reverse(void);

    inline void setInnerAction(CCFiniteTimeAction *pAction)
    {
        if (m_pInnerAction != pAction)
        {
            do { if(pAction) { (pAction)->retain(); } } while(0);
            do { if(m_pInnerAction) { (m_pInnerAction)->release(); } } while(0);
            m_pInnerAction = pAction;
        }
    }

    inline CCFiniteTimeAction* getInnerAction()
    {
        return m_pInnerAction;
    }

public:


    static CCRepeat* create(CCFiniteTimeAction *pAction, unsigned int times);
protected:
    unsigned int m_uTimes;
    unsigned int m_uTotal;
    float m_fNextDt;
    bool m_bActionInstant;

    CCFiniteTimeAction *m_pInnerAction;
};





class CCRepeatForever : public CCActionInterval
{
public:



    CCRepeatForever()
        : m_pInnerAction(__null)
    {}




    virtual ~CCRepeatForever();


    bool initWithAction(CCActionInterval *pAction);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode* pTarget);
    virtual void step(float dt);
    virtual bool isDone(void);
    virtual CCActionInterval* reverse(void);

    inline void setInnerAction(CCActionInterval *pAction)
    {
        if (m_pInnerAction != pAction)
        {
            do { if(m_pInnerAction) { (m_pInnerAction)->release(); } } while(0);
            m_pInnerAction = pAction;
            do { if(m_pInnerAction) { (m_pInnerAction)->retain(); } } while(0);
        }
    }

    inline CCActionInterval* getInnerAction()
    {
        return m_pInnerAction;
    }

public:


    static CCRepeatForever* create(CCActionInterval *pAction);
protected:

    CCActionInterval *m_pInnerAction;
};



class CCSpawn : public CCActionInterval
{
public:




    ~CCSpawn(void);




    bool initWithTwoActions(CCFiniteTimeAction *pAction1, CCFiniteTimeAction *pAction2);




    virtual CCObject* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void stop(void);



    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:




    static CCSpawn* create(CCFiniteTimeAction *pAction1, ...);





    static CCSpawn* createWithVariableList(CCFiniteTimeAction *pAction1, va_list args);




    static CCSpawn* create(CCArray *arrayOfActions);




    static CCSpawn* createWithTwoActions(CCFiniteTimeAction *pAction1, CCFiniteTimeAction *pAction2);

protected:
    CCFiniteTimeAction *m_pOne;
    CCFiniteTimeAction *m_pTwo;
};





class CCRotateTo : public CCActionInterval
{
public:

    static CCRotateTo* create(float fDuration, float fDeltaAngle);

    bool initWithDuration(float fDuration, float fDeltaAngle);


    static CCRotateTo* create(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
    virtual bool initWithDuration(float fDuration, float fDeltaAngleX, float fDeltaAngleY);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

protected:
    float m_fDstAngleX;
    float m_fStartAngleX;
    float m_fDiffAngleX;

    float m_fDstAngleY;
    float m_fStartAngleY;
    float m_fDiffAngleY;
};



class CCRotateBy : public CCActionInterval
{
public:

    static CCRotateBy* create(float fDuration, float fDeltaAngle);

    bool initWithDuration(float fDuration, float fDeltaAngle);

    static CCRotateBy* create(float fDuration, float fDeltaAngleX, float fDeltaAngleY);
    bool initWithDuration(float fDuration, float fDeltaAngleX, float fDeltaAngleY);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

protected:
    float m_fAngleX;
    float m_fStartAngleX;
    float m_fAngleY;
    float m_fStartAngleY;
};







class CCMoveBy : public CCActionInterval
{
public:

    bool initWithDuration(float duration, const CCPoint& deltaPosition);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);
    virtual void update(float time);

public:

    static CCMoveBy* create(float duration, const CCPoint& deltaPosition);
protected:
    CCPoint m_positionDelta;
    CCPoint m_startPosition;
    CCPoint m_previousPosition;
};






class CCMoveTo : public CCMoveBy
{
public:

    bool initWithDuration(float duration, const CCPoint& position);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCMoveTo* create(float duration, const CCPoint& position);
protected:
    CCPoint m_endPosition;
};




class CCSkewTo : public CCActionInterval
{
public:



    CCSkewTo();
    virtual bool initWithDuration(float t, float sx, float sy);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCSkewTo* create(float t, float sx, float sy);
protected:
    float m_fSkewX;
    float m_fSkewY;
    float m_fStartSkewX;
    float m_fStartSkewY;
    float m_fEndSkewX;
    float m_fEndSkewY;
    float m_fDeltaX;
    float m_fDeltaY;
};




class CCSkewBy : public CCSkewTo
{
public:
    virtual bool initWithDuration(float t, float sx, float sy);
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);

public:


    static CCSkewBy* create(float t, float deltaSkewX, float deltaSkewY);
};



class CCJumpBy : public CCActionInterval
{
public:

    bool initWithDuration(float duration, const CCPoint& position, float height, unsigned int jumps);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCJumpBy* create(float duration, const CCPoint& position, float height, unsigned int jumps);
protected:
    CCPoint m_startPosition;
    CCPoint m_delta;
    float m_height;
    unsigned int m_nJumps;
    CCPoint m_previousPos;
};



class CCJumpTo : public CCJumpBy
{
public:
    virtual void startWithTarget(CCNode *pTarget);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCJumpTo* create(float duration, const CCPoint& position, float height, int jumps);
};



typedef struct _ccBezierConfig {

    CCPoint endPosition;

    CCPoint controlPoint_1;

    CCPoint controlPoint_2;
} ccBezierConfig;



class CCBezierBy : public CCActionInterval
{
public:



    bool initWithDuration(float t, const ccBezierConfig& c);




    virtual CCObject* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:






    static CCBezierBy* create(float t, const ccBezierConfig& c);
protected:
    ccBezierConfig m_sConfig;
    CCPoint m_startPosition;
    CCPoint m_previousPosition;
};




class CCBezierTo : public CCBezierBy
{
public:



    virtual void startWithTarget(CCNode *pTarget);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:







    static CCBezierTo* create(float t, const ccBezierConfig& c);



    bool initWithDuration(float t, const ccBezierConfig &c);

protected:
    ccBezierConfig m_sToConfig;
};




class CCScaleTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, float s);


    bool initWithDuration(float duration, float sx, float sy);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCScaleTo* create(float duration, float s);


    static CCScaleTo* create(float duration, float sx, float sy);
protected:
    float m_fScaleX;
    float m_fScaleY;
    float m_fStartScaleX;
    float m_fStartScaleY;
    float m_fEndScaleX;
    float m_fEndScaleY;
    float m_fDeltaX;
    float m_fDeltaY;
};



class CCScaleBy : public CCScaleTo
{
public:
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCScaleBy* create(float duration, float s);


    static CCScaleBy* create(float duration, float sx, float sy);
};



class CCBlink : public CCActionInterval
{
public:

    bool initWithDuration(float duration, unsigned int uBlinks);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:


    static CCBlink* create(float duration, unsigned int uBlinks);

    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop();

protected:
    unsigned int m_nTimes;
    bool m_bOriginalState;
};




class CCFadeIn : public CCActionInterval
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCFadeIn* create(float d);
};




class CCFadeOut : public CCActionInterval
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCFadeOut* create(float d);
};




class CCFadeTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, GLubyte opacity);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:

    static CCFadeTo* create(float duration, GLubyte opacity);
protected:
    GLubyte m_toOpacity;
    GLubyte m_fromOpacity;
};





class CCTintTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, GLubyte red, GLubyte green, GLubyte blue);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:

    static CCTintTo* create(float duration, GLubyte red, GLubyte green, GLubyte blue);
protected:
    ccColor3B m_to;
    ccColor3B m_from;
};




class CCTintBy : public CCActionInterval
{
public:

    bool initWithDuration(float duration, GLshort deltaRed, GLshort deltaGreen, GLshort deltaBlue);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCTintBy* create(float duration, GLshort deltaRed, GLshort deltaGreen, GLshort deltaBlue);
protected:
    GLshort m_deltaR;
    GLshort m_deltaG;
    GLshort m_deltaB;

    GLshort m_fromR;
    GLshort m_fromG;
    GLshort m_fromB;
};



class CCDelayTime : public CCActionInterval
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCDelayTime* create(float d);
};
# 849 "Cacao/include/cocos2dx/actions/CCActionInterval.h"
class CCReverseTime : public CCActionInterval
{
public:



    ~CCReverseTime(void);




    CCReverseTime();


    bool initWithAction(CCFiniteTimeAction *pAction);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCReverseTime* create(CCFiniteTimeAction *pAction);
protected:
    CCFiniteTimeAction *m_pOther;
};

class CCTexture2D;

class CCAnimate : public CCActionInterval
{
public:



    CCAnimate();




    ~CCAnimate();


    bool initWithAnimation(CCAnimation *pAnimation);





    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float t);
    virtual CCActionInterval* reverse(void);

public:

    static CCAnimate* create(CCAnimation *pAnimation);
    private: CCAnimation* m_pAnimation; public: virtual CCAnimation* getAnimation(void) const { return m_pAnimation; } public: virtual void setAnimation(CCAnimation* var) { if (m_pAnimation != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pAnimation) { (m_pAnimation)->release(); } } while(0); m_pAnimation = var; } }
protected:
    std::vector<float>* m_pSplitTimes;
    int m_nNextFrame;
    CCSpriteFrame* m_pOrigFrame;
       unsigned int m_uExecutedLoops;
};




class CCTargetedAction : public CCActionInterval
{
public:



    CCTargetedAction();




    virtual ~CCTargetedAction();


    static CCTargetedAction* create(CCNode* pTarget, CCFiniteTimeAction* pAction);


    bool initWithTarget(CCNode* pTarget, CCFiniteTimeAction* pAction);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float time);


    private: CCNode* m_pForcedTarget; public: virtual CCNode* getForcedTarget(void) const { return m_pForcedTarget; } public: virtual void setForcedTarget(CCNode* var) { if (m_pForcedTarget != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pForcedTarget) { (m_pForcedTarget)->release(); } } while(0); m_pForcedTarget = var; } };
private:
    CCFiniteTimeAction* m_pAction;
};




}
# 43 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionCamera.h" 1
# 31 "Cacao/include/cocos2dx/actions/CCActionCamera.h"
namespace cocos2d {

class CCCamera;
# 44 "Cacao/include/cocos2dx/actions/CCActionCamera.h"
class CCActionCamera : public CCActionInterval
{
public:



    CCActionCamera()
        :m_fCenterXOrig(0)
        ,m_fCenterYOrig(0)
        ,m_fCenterZOrig(0)
        ,m_fEyeXOrig(0)
        ,m_fEyeYOrig(0)
        ,m_fEyeZOrig(0)
        ,m_fUpXOrig(0)
        ,m_fUpYOrig(0)
        ,m_fUpZOrig(0)
    {}




    virtual ~CCActionCamera(){}

    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval * reverse();
protected:
    float m_fCenterXOrig;
    float m_fCenterYOrig;
    float m_fCenterZOrig;

    float m_fEyeXOrig;
    float m_fEyeYOrig;
    float m_fEyeZOrig;

    float m_fUpXOrig;
    float m_fUpYOrig;
    float m_fUpZOrig;
};






class CCOrbitCamera : public CCActionCamera
{
public:



    CCOrbitCamera()
        : m_fRadius(0.0)
        , m_fDeltaRadius(0.0)
        , m_fAngleZ(0.0)
        , m_fDeltaAngleZ(0.0)
        , m_fAngleX(0.0)
        , m_fDeltaAngleX(0.0)
        , m_fRadZ(0.0)
        , m_fRadDeltaZ(0.0)
        , m_fRadX(0.0)
        , m_fRadDeltaX(0.0)
    {}




    ~CCOrbitCamera(){}


    static CCOrbitCamera* create(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX);


    bool initWithDuration(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX);

    void sphericalRadius(float *r, float *zenith, float *azimuth);





    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

protected:
    float m_fRadius;
    float m_fDeltaRadius;
    float m_fAngleZ;
    float m_fDeltaAngleZ;
    float m_fAngleX;
    float m_fDeltaAngleX;

    float m_fRadZ;
    float m_fRadDeltaZ;
    float m_fRadX;
    float m_fRadDeltaX;
};




}
# 44 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionManager.h" 1
# 35 "Cacao/include/cocos2dx/actions/CCActionManager.h"
namespace cocos2d {

class CCSet;

struct _hashElement;
# 57 "Cacao/include/cocos2dx/actions/CCActionManager.h"
class CCActionManager : public CCObject
{
public:



    CCActionManager(void);




    ~CCActionManager(void);
# 77 "Cacao/include/cocos2dx/actions/CCActionManager.h"
    void addAction(CCAction *pAction, CCNode *pTarget, bool paused);



    void removeAllActions(void);




    void removeAllActionsFromTarget(CCObject *pTarget);



    void removeAction(CCAction *pAction);


    void removeActionByTag(unsigned int tag, CCObject *pTarget);




    CCAction* getActionByTag(unsigned int tag, CCObject *pTarget);






    unsigned int numberOfRunningActionsInTarget(CCObject *pTarget);



    void pauseTarget(CCObject *pTarget);



    void resumeTarget(CCObject *pTarget);



    CCSet* pauseAllRunningActions();



    void resumeTargets(CCSet *targetsToResume);

protected:


    void removeActionAtIndex(unsigned int uIndex, struct _hashElement *pElement);
    void deleteHashElement(struct _hashElement *pElement);
    void actionAllocWithHashElement(struct _hashElement *pElement);
    void update(float dt);

protected:
    struct _hashElement *m_pTargets;
    struct _hashElement *m_pCurrentTarget;
    bool m_bCurrentTargetSalvaged;
};




}
# 45 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionEase.h" 1
# 31 "Cacao/include/cocos2dx/actions/CCActionEase.h"
namespace cocos2d {

class CCObject;
class CCZone;
# 45 "Cacao/include/cocos2dx/actions/CCActionEase.h"
class CCActionEase : public CCActionInterval
{
public:




    virtual ~CCActionEase(void);


    bool initWithAction(CCActionInterval *pAction);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void stop(void);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);
    virtual CCActionInterval* getInnerAction();

public:


    static CCActionEase* create(CCActionInterval *pAction);

protected:

    CCActionInterval *m_pInner;
};





class CCEaseRateAction : public CCActionEase
{
public:




    virtual ~CCEaseRateAction(void);


    inline void setRate(float rate) { m_fRate = rate; }

    inline float getRate(void) { return m_fRate; }


    bool initWithAction(CCActionInterval *pAction, float fRate);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse(void);

public:


    static CCEaseRateAction* create(CCActionInterval* pAction, float fRate);

protected:
    float m_fRate;
};





class CCEaseIn : public CCEaseRateAction
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);
public:


    static CCEaseIn* create(CCActionInterval* pAction, float fRate);
};





class CCEaseOut : public CCEaseRateAction
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse();




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseOut* create(CCActionInterval* pAction, float fRate);
};





class CCEaseInOut : public CCEaseRateAction
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse(void);

public:


    static CCEaseInOut* create(CCActionInterval* pAction, float fRate);
};





class CCEaseExponentialIn : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCEaseExponentialIn* create(CCActionInterval* pAction);
};





class CCEaseExponentialOut : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCEaseExponentialOut* create(CCActionInterval* pAction);
};





class CCEaseExponentialInOut : public CCActionEase
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseExponentialInOut* create(CCActionInterval* pAction);
};





class CCEaseSineIn : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCEaseSineIn* create(CCActionInterval* pAction);
};





class CCEaseSineOut : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseSineOut* create(CCActionInterval* pAction);
};





class CCEaseSineInOut : public CCActionEase
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseSineInOut* create(CCActionInterval* pAction);
};






class CCEaseElastic : public CCActionEase
{
public:

    inline float getPeriod(void) { return m_fPeriod; }

    inline void setPeriod(float fPeriod) { m_fPeriod = fPeriod; }


    bool initWithAction(CCActionInterval *pAction, float fPeriod = 0.3f);

    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElastic* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElastic* create(CCActionInterval *pAction);
protected:
    float m_fPeriod;
};







class CCEaseElasticIn : public CCEaseElastic
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElasticIn* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElasticIn* create(CCActionInterval *pAction);
};







class CCEaseElasticOut : public CCEaseElastic
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElasticOut* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElasticOut* create(CCActionInterval *pAction);
};







class CCEaseElasticInOut : public CCEaseElastic
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseElasticInOut* create(CCActionInterval *pAction, float fPeriod);
    static CCEaseElasticInOut* create(CCActionInterval *pAction);
};






class CCEaseBounce : public CCActionEase
{
public:
    float bounceTime(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseBounce* create(CCActionInterval* pAction);
};







class CCEaseBounceIn : public CCEaseBounce
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBounceIn* create(CCActionInterval* pAction);
};







class CCEaseBounceOut : public CCEaseBounce
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBounceOut* create(CCActionInterval* pAction);
};







class CCEaseBounceInOut : public CCEaseBounce
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseBounceInOut* create(CCActionInterval* pAction);
};







class CCEaseBackIn : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBackIn* create(CCActionInterval* pAction);
};







class CCEaseBackOut : public CCActionEase
{
public:
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:


    static CCEaseBackOut* create(CCActionInterval* pAction);
};







class CCEaseBackInOut : public CCActionEase
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual CCActionInterval* reverse();

public:


    static CCEaseBackInOut* create(CCActionInterval* pAction);
};




}
# 46 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h" 1
# 28 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h"
# 1 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h" 1
# 28 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h"
# 1 "Cacao/include/cocos2dx/actions/CCActionGrid.h" 1
# 29 "Cacao/include/cocos2dx/actions/CCActionGrid.h"
# 1 "Cacao/include/cocos2dx/actions/CCActionInstant.h" 1
# 31 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
# 1 "Cacao/include/cocos2dx/include/ccTypeInfo.h" 1
# 34 "Cacao/include/cocos2dx/include/ccTypeInfo.h"
namespace cocos2d {

class TypeInfo
{
public:
 virtual long getClassTypeInfo() = 0;
};

static inline unsigned int getHashCodeByString(const char *key)
{
 unsigned int len = strlen(key);
 const char *end=key+len;
 unsigned int hash;

 for (hash = 0; key < end; key++)
 {
  hash *= 16777619;
  hash ^= (unsigned int) (unsigned char) toupper(*key);
 }
 return (hash);
}
}
# 32 "Cacao/include/cocos2dx/actions/CCActionInstant.h" 2


namespace cocos2d {
# 45 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
class CCActionInstant : public CCFiniteTimeAction
{
public:



    CCActionInstant();




    virtual ~CCActionInstant(){}





    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual bool isDone(void);
    virtual void step(float dt);
    virtual void update(float time);

    virtual CCFiniteTimeAction * reverse(void);
};



class CCShow : public CCActionInstant
{
public:




    CCShow(){}




    virtual ~CCShow(){}

    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);




    virtual CCObject* copyWithZone(CCZone *pZone);
public:


    static CCShow * create();
};






class CCHide : public CCActionInstant
{
public:




    CCHide(){}




    virtual ~CCHide(){}




    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);




    virtual CCObject* copyWithZone(CCZone *pZone);
public:


    static CCHide * create();
};



class CCToggleVisibility : public CCActionInstant
{
public:



    CCToggleVisibility(){}




    virtual ~CCToggleVisibility(){}

    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone *pZone);
public:


    static CCToggleVisibility * create();
};






class CCRemoveSelf : public CCActionInstant
{
public:
 CCRemoveSelf(){}
 virtual ~CCRemoveSelf(){}

 virtual void update(float time);
 virtual CCFiniteTimeAction * reverse(void);
 virtual CCObject* copyWithZone(CCZone *pZone);
public:

 static CCRemoveSelf * create(bool isNeedCleanUp = true);

 bool init(bool isNeedCleanUp);
protected:
 bool m_bIsNeedCleanUp;
};






class CCFlipX : public CCActionInstant
{
public:



    CCFlipX()
        :m_bFlipX(false)
    {}




    virtual ~CCFlipX(){}


    static CCFlipX * create(bool x);


    bool initWithFlipX(bool x);

    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);



    virtual CCObject* copyWithZone(CCZone *pZone);

protected:
    bool m_bFlipX;
};






class CCFlipY : public CCActionInstant
{
public:



    CCFlipY()
        :m_bFlipY(false)
    {}




    virtual ~CCFlipY(){}


    static CCFlipY * create(bool y);


    bool initWithFlipY(bool y);

    virtual void update(float time);
    virtual CCFiniteTimeAction * reverse(void);



    virtual CCObject* copyWithZone(CCZone *pZone);

protected:
    bool m_bFlipY;
};



class CCPlace : public CCActionInstant
{
public:



    CCPlace(){}




    virtual ~CCPlace(){}


    static CCPlace * create(const CCPoint& pos);

    bool initWithPosition(const CCPoint& pos);

    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone *pZone);
protected:
    CCPoint m_tPosition;
};



class CCCallFunc : public CCActionInstant
{
public:



    CCCallFunc()
        : m_pSelectorTarget(__null)
  , m_nScriptHandler(0)
        , m_pCallFunc(__null)
    {
    }




    virtual ~CCCallFunc();






    static CCCallFunc * create(CCObject* pSelectorTarget, SEL_CallFunc selector);




 static CCCallFunc * create(int nHandler);






    virtual bool initWithTarget(CCObject* pSelectorTarget);



    virtual void execute();



    virtual void update(float time);




    CCObject * copyWithZone(CCZone *pZone);



    inline CCObject* getTargetCallback()
    {
        return m_pSelectorTarget;
    }



    inline void setTargetCallback(CCObject* pSel)
    {
        if (pSel != m_pSelectorTarget)
        {
            do { if(pSel) { (pSel)->retain(); } } while(0);
            do { if(m_pSelectorTarget) { (m_pSelectorTarget)->release(); } } while(0);
            m_pSelectorTarget = pSel;
        }
    }



    inline int getScriptHandler() { return m_nScriptHandler; };
protected:

    CCObject* m_pSelectorTarget;

 int m_nScriptHandler;

    union
    {
        SEL_CallFunc m_pCallFunc;
        SEL_CallFuncN m_pCallFuncN;
        SEL_CallFuncND m_pCallFuncND;
        SEL_CallFuncO m_pCallFuncO;
    };
};






class CCCallFuncN : public CCCallFunc, public TypeInfo
{
public:




    CCCallFuncN(){}




    virtual ~CCCallFuncN(){}



    virtual long getClassTypeInfo() {
  static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCCallFunc).name());
  return id;
    }






    static CCCallFuncN * create(CCObject* pSelectorTarget, SEL_CallFuncN selector);


 static CCCallFuncN * create(int nHandler);






    virtual bool initWithTarget(CCObject* pSelectorTarget, SEL_CallFuncN selector);




    virtual CCObject* copyWithZone(CCZone *pZone);



    virtual void execute();
};
# 437 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
class CCCallFuncND : public CCCallFuncN
{
public:
    virtual long getClassTypeInfo() {
        static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCCallFunc).name());
  return id;
    }


    static CCCallFuncND * create(CCObject* pSelectorTarget, SEL_CallFuncND selector, void* d);


    virtual bool initWithTarget(CCObject* pSelectorTarget, SEL_CallFuncND selector, void* d);





    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void execute();

protected:
    void *m_pData;
};
# 471 "Cacao/include/cocos2dx/actions/CCActionInstant.h"
class CCCallFuncO : public CCCallFunc, public TypeInfo
{
public:
    CCCallFuncO();
    virtual ~CCCallFuncO();

    virtual long getClassTypeInfo() {
     static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCCallFunc).name());
  return id;
    }





    static CCCallFuncO * create(CCObject* pSelectorTarget, SEL_CallFuncO selector, CCObject* pObject);





    virtual bool initWithTarget(CCObject* pSelectorTarget, SEL_CallFuncO selector, CCObject* pObject);





    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void execute();

    inline CCObject* getObject()
    {
        return m_pObject;
    }

    inline void setObject(CCObject* pObj)
    {
        if (pObj != m_pObject)
        {
            do { if(m_pObject) { (m_pObject)->release(); } } while(0);
            m_pObject = pObj;
            do { if(m_pObject) { (m_pObject)->retain(); } } while(0);
        }
    }

protected:

    CCObject* m_pObject;
};




}
# 30 "Cacao/include/cocos2dx/actions/CCActionGrid.h" 2

namespace cocos2d {

class CCGridBase;







class CCGridAction : public CCActionInterval
{
public:




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse(void);


    virtual bool initWithDuration(float duration, const CCSize& gridSize);


    virtual CCGridBase* getGrid(void);

public:






    static CCGridAction* create(float duration, const CCSize& gridSize);
protected:
    CCSize m_sGridSize;
};





class CCGrid3DAction : public CCGridAction
{
public:

    virtual CCGridBase* getGrid(void);

    ccVertex3F vertex(const CCPoint& position);

    ccVertex3F originalVertex(const CCPoint& position);

    void setVertex(const CCPoint& position, const ccVertex3F& vertex);

public:




    static CCGrid3DAction* create(float duration, const CCSize& gridSize);
};


class CCTiledGrid3DAction : public CCGridAction
{
public:

    ccQuad3 tile(const CCPoint& position);

    ccQuad3 originalTile(const CCPoint& position);

    void setTile(const CCPoint& position, const ccQuad3& coords);


    virtual CCGridBase* getGrid(void);

public:




    static CCTiledGrid3DAction* create(float duration, const CCSize& gridSize);
};


class CCAccelDeccelAmplitude : public CCActionInterval
{
public:




    virtual ~CCAccelDeccelAmplitude(void);

    bool initWithAction(CCAction *pAction, float duration);

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);


    inline float getRate(void) { return m_fRate; }

    inline void setRate(float fRate) { m_fRate = fRate; }

public:

    static CCAccelDeccelAmplitude* create(CCAction *pAction, float duration);

protected:
    float m_fRate;
    CCActionInterval *m_pOther;
};


class CCAccelAmplitude : public CCActionInterval
{
public:




    ~CCAccelAmplitude(void);

    bool initWithAction(CCAction *pAction, float duration);


    inline float getRate(void) { return m_fRate; }

    inline void setRate(float fRate) { m_fRate = fRate; }

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCAccelAmplitude* create(CCAction *pAction, float duration);
protected:
    float m_fRate;
    CCActionInterval *m_pOther;
};


class CCDeccelAmplitude : public CCActionInterval
{
public:




    ~CCDeccelAmplitude(void);

    bool initWithAction(CCAction *pAction, float duration);


    inline float getRate(void) { return m_fRate; }

    inline void setRate(float fRate) { m_fRate = fRate; }

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);
    virtual CCActionInterval* reverse(void);

public:

    static CCDeccelAmplitude* create(CCAction *pAction, float duration);

protected:
    float m_fRate;
    CCActionInterval *m_pOther;
};






class CCStopGrid : public CCActionInstant
{
public:
    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCStopGrid* create(void);
};


class CCReuseGrid : public CCActionInstant
{
public:

    bool initWithTimes(int times);

    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCReuseGrid* create(int times);
protected:
    int m_nTimes;
};




}
# 29 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h" 2

namespace cocos2d {
# 40 "Cacao/include/cocos2dx/actions/CCActionGrid3D.h"
class CCWaves3D : public CCGrid3DAction
{
public:
    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCWaves3D* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCFlipX3D : public CCGrid3DAction
{
public:

    virtual bool initWithDuration(float duration);
    virtual bool initWithSize(const CCSize& gridSize, float duration);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCFlipX3D* create(float duration);
};


class CCFlipY3D : public CCFlipX3D
{
public:
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCFlipY3D* create(float duration);
};


class CCLens3D : public CCGrid3DAction
{
public:

    inline float getLensEffect(void) { return m_fLensEffect; }

    inline void setLensEffect(float fLensEffect) { m_fLensEffect = fLensEffect; }

    inline void setConcave(bool bConcave) { m_bConcave = bConcave; }

    inline const CCPoint& getPosition(void) { return m_position; }
    void setPosition(const CCPoint& position);


    bool initWithDuration(float duration, const CCSize& gridSize, const CCPoint& position, float radius);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCLens3D* create(float duration, const CCSize& gridSize, const CCPoint& position, float radius);
protected:

    CCPoint m_position;
    float m_fRadius;

    float m_fLensEffect;

    bool m_bConcave;

    bool m_bDirty;
};


class CCRipple3D : public CCGrid3DAction
{
public:

    inline const CCPoint& getPosition(void) { return m_position; }

    void setPosition(const CCPoint& position);

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, const CCPoint& position, float radius, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCRipple3D* create(float duration, const CCSize& gridSize, const CCPoint& position, float radius, unsigned int waves, float amplitude);
protected:

    CCPoint m_position;
    float m_fRadius;
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCShaky3D : public CCGrid3DAction
{
public:

    bool initWithDuration(float duration, const CCSize& gridSize, int range, bool shakeZ);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCShaky3D* create(float duration, const CCSize& gridSize, int range, bool shakeZ);
protected:
    int m_nRandrange;
    bool m_bShakeZ;
};


class CCLiquid : public CCGrid3DAction
{
public:
    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCLiquid* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCWaves : public CCGrid3DAction
{
public:
    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCWaves* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
    bool m_bVertical;
    bool m_bHorizontal;
};


class CCTwirl : public CCGrid3DAction
{
public:

    inline const CCPoint& getPosition(void) { return m_position; }

    void setPosition(const CCPoint& position);

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }

    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, CCPoint position, unsigned int twirls, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCTwirl* create(float duration, const CCSize& gridSize, CCPoint position, unsigned int twirls, float amplitude);
protected:

    CCPoint m_position;
    unsigned int m_nTwirls;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};




}
# 29 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h" 2

namespace cocos2d {
# 46 "Cacao/include/cocos2dx/actions/CCActionPageTurn3D.h"
class CCPageTurn3D : public CCGrid3DAction
{
public:
    virtual void update(float time);

public:


    static CCPageTurn3D* create(float duration, const CCSize& gridSize);
};




}
# 47 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/actions/CCActionProgressTimer.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionProgressTimer.h"
namespace cocos2d {
# 41 "Cacao/include/cocos2dx/actions/CCActionProgressTimer.h"
class CCProgressTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, float fPercent);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:

    static CCProgressTo* create(float duration, float fPercent);
protected:
    float m_fTo;
    float m_fFrom;
};





class CCProgressFromTo : public CCActionInterval
{
public:

    bool initWithDuration(float duration, float fFromPercentage, float fToPercentage);




    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual CCActionInterval* reverse(void);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCProgressFromTo* create(float duration, float fFromPercentage, float fToPercentage);
protected:
    float m_fTo;
    float m_fFrom;
};




}
# 49 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/actions/CCActionTiledGrid.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionTiledGrid.h"
namespace cocos2d {







class CCShakyTiles3D : public CCTiledGrid3DAction
{
public:

    virtual bool initWithDuration(float duration, const CCSize& gridSize, int nRange, bool bShakeZ);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCShakyTiles3D* create(float duration, const CCSize& gridSize, int nRange, bool bShakeZ);

protected:
    int m_nRandrange;
    bool m_bShakeZ;
};


class CCShatteredTiles3D : public CCTiledGrid3DAction
{
public:

    virtual bool initWithDuration(float duration, const CCSize& gridSize, int nRange, bool bShatterZ);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCShatteredTiles3D* create(float duration, const CCSize& gridSize, int nRange, bool bShatterZ);
protected:
    int m_nRandrange;
    bool m_bOnce;
    bool m_bShatterZ;
};

struct Tile;



class CCShuffleTiles : public CCTiledGrid3DAction
{
public:




    ~CCShuffleTiles(void);

    virtual bool initWithDuration(float duration, const CCSize& gridSize, unsigned int seed);
    void shuffle(unsigned int *pArray, unsigned int nLen);
    CCSize getDelta(const CCSize& pos);
    void placeTile(const CCPoint& pos, Tile *t);

    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);




    virtual CCObject* copyWithZone(CCZone* pZone);

public:

    static CCShuffleTiles* create(float duration, const CCSize& gridSize, unsigned int seed);
protected:
    unsigned int m_nSeed;
    unsigned int m_nTilesCount;
    unsigned int* m_pTilesOrder;
    Tile* m_pTiles;
};




class CCFadeOutTRTiles : public CCTiledGrid3DAction
{
public:
    virtual float testFunc(const CCSize& pos, float time);
    void turnOnTile(const CCPoint& pos);
    void turnOffTile(const CCPoint& pos);
    virtual void transformTile(const CCPoint& pos, float distance);
    virtual void update(float time);

public:


    static CCFadeOutTRTiles* create(float duration, const CCSize& gridSize);
};




class CCFadeOutBLTiles : public CCFadeOutTRTiles
{
public:
    virtual float testFunc(const CCSize& pos, float time);

public:


    static CCFadeOutBLTiles* create(float duration, const CCSize& gridSize);
};




class CCFadeOutUpTiles : public CCFadeOutTRTiles
{
public:
    virtual float testFunc(const CCSize& pos, float time);
    virtual void transformTile(const CCPoint& pos, float distance);

public:

    static CCFadeOutUpTiles* create(float duration, const CCSize& gridSize);

};




class CCFadeOutDownTiles : public CCFadeOutUpTiles
{
public:
    virtual float testFunc(const CCSize& pos, float time);

public:


    static CCFadeOutDownTiles* create(float duration, const CCSize& gridSize);
};




class CCTurnOffTiles : public CCTiledGrid3DAction
{
public:




    ~CCTurnOffTiles(void);

    virtual bool initWithDuration(float duration, const CCSize& gridSize, unsigned int seed);
    void shuffle(unsigned int *pArray, unsigned int nLen);
    void turnOnTile(const CCPoint& pos);
    void turnOffTile(const CCPoint& pos);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void startWithTarget(CCNode *pTarget);
    virtual void update(float time);

public:


    static CCTurnOffTiles* create(float duration, const CCSize& gridSize);

    static CCTurnOffTiles* create(float duration, const CCSize& gridSize, unsigned int seed);

protected:
    unsigned int m_nSeed;
    unsigned int m_nTilesCount;
    unsigned int* m_pTilesOrder;
};


class CCWavesTiles3D : public CCTiledGrid3DAction
{
public:

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }


    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    virtual bool initWithDuration(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:

    static CCWavesTiles3D* create(float duration, const CCSize& gridSize, unsigned int waves, float amplitude);
protected:
    unsigned int m_nWaves;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};




class CCJumpTiles3D : public CCTiledGrid3DAction
{
public:

    inline float getAmplitude(void) { return m_fAmplitude; }
    inline void setAmplitude(float fAmplitude) { m_fAmplitude = fAmplitude; }


    inline float getAmplitudeRate(void) { return m_fAmplitudeRate; }
    inline void setAmplitudeRate(float fAmplitudeRate) { m_fAmplitudeRate = fAmplitudeRate; }


    bool initWithDuration(float duration, const CCSize& gridSize, unsigned int numberOfJumps, float amplitude);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);

public:


    static CCJumpTiles3D* create(float duration, const CCSize& gridSize, unsigned int numberOfJumps, float amplitude);
protected:
    unsigned int m_nJumps;
    float m_fAmplitude;
    float m_fAmplitudeRate;
};


class CCSplitRows : public CCTiledGrid3DAction
{
public :

    virtual bool initWithDuration(float duration, unsigned int nRows);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);
    virtual void startWithTarget(CCNode *pTarget);

public:


    static CCSplitRows* create(float duration, unsigned int nRows);
protected:
    unsigned int m_nRows;
    CCSize m_winSize;
};


class CCSplitCols : public CCTiledGrid3DAction
{
public:

    virtual bool initWithDuration(float duration, unsigned int nCols);




    virtual CCObject* copyWithZone(CCZone* pZone);
    virtual void update(float time);
    virtual void startWithTarget(CCNode *pTarget);

public:

    static CCSplitCols* create(float duration, unsigned int nCols);
protected:
    unsigned int m_nCols;
    CCSize m_winSize;
};




}
# 51 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/actions/CCActionTween.h" 1
# 30 "Cacao/include/cocos2dx/actions/CCActionTween.h"
namespace cocos2d {






class CCActionTweenDelegate
{
public:




    virtual ~CCActionTweenDelegate() {}
    virtual void updateTweenAction(float value, const char* key) = 0;
};
# 66 "Cacao/include/cocos2dx/actions/CCActionTween.h"
class CCActionTween : public CCActionInterval
{
public:

    static CCActionTween* create(float aDuration, const char* key, float from, float to);

    bool initWithDuration(float aDuration, const char* key, float from, float to);

    void startWithTarget(CCNode *pTarget);
    void update(float dt);
    CCActionInterval* reverse();

    std::string m_strKey;
    float m_fFrom, m_fTo;
    float m_fDelta;
};




}
# 53 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/actions/CCActionCatmullRom.h" 1
# 46 "Cacao/include/cocos2dx/actions/CCActionCatmullRom.h"
namespace cocos2d {;
# 58 "Cacao/include/cocos2dx/actions/CCActionCatmullRom.h"
class CCPointArray : public CCObject
{
public:




    static CCPointArray* create(unsigned int capacity);



    virtual ~CCPointArray();



    CCPointArray();


    bool initWithCapacity(unsigned int capacity);


    void addControlPoint(CCPoint controlPoint);


    void insertControlPoint(CCPoint &controlPoint, unsigned int index);


    void replaceControlPoint(CCPoint &controlPoint, unsigned int index);


    CCPoint getControlPointAtIndex(unsigned int index);


    void removeControlPointAtIndex(unsigned int index);


    unsigned int count();


    CCPointArray* reverse();


    void reverseInline();




    virtual CCObject* copyWithZone(CCZone *zone);

    const std::vector<CCPoint*>* getControlPoints();

    void setControlPoints(std::vector<CCPoint*> *controlPoints);
private:

    std::vector<CCPoint*> *m_pControlPoints;
};





class CCCardinalSplineTo : public CCActionInterval
{
public:







    static CCCardinalSplineTo* create(float duration, CCPointArray* points, float tension);




    virtual ~CCCardinalSplineTo();




    CCCardinalSplineTo();




    bool initWithDuration(float duration, CCPointArray* points, float tension);






    virtual CCCardinalSplineTo* copyWithZone(CCZone* pZone);



    virtual void startWithTarget(CCNode *pTarget);



    virtual void update(float time);
    virtual CCActionInterval* reverse();



    virtual void updatePosition(CCPoint &newPos);

    inline CCPointArray* getPoints() { return m_pPoints; }



    inline void setPoints(CCPointArray* points)
    {
        do { if(points) { (points)->retain(); } } while(0);
        do { if(m_pPoints) { (m_pPoints)->release(); } } while(0);
        m_pPoints = points;
    }

protected:

    CCPointArray *m_pPoints;
    float m_fDeltaT;
    float m_fTension;
    CCPoint m_previousPosition;
    CCPoint m_accumulatedDiff;
};





class CCCardinalSplineBy : public CCCardinalSplineTo
{
public:







    static CCCardinalSplineBy* create(float duration, CCPointArray* points, float tension);




    CCCardinalSplineBy();



    virtual void startWithTarget(CCNode *pTarget);
    virtual CCActionInterval* reverse();



    virtual void updatePosition(CCPoint &newPos);
protected:
    CCPoint m_startPosition;
};






class CCCatmullRomTo : public CCCardinalSplineTo
{
public:







    static CCCatmullRomTo* create(float dt, CCPointArray* points);





    bool initWithDuration(float dt, CCPointArray* points);
};






class CCCatmullRomBy : public CCCardinalSplineBy
{
public:







    static CCCatmullRomBy* create(float dt, CCPointArray* points);





    bool initWithDuration(float dt, CCPointArray* points);
};


extern CCPoint ccCardinalSplineAt(CCPoint &p0, CCPoint &p1, CCPoint &p2, CCPoint &p3, float tension, float t);




};
# 54 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/base_nodes/CCAtlasNode.h" 1
# 34 "Cacao/include/cocos2dx/base_nodes/CCAtlasNode.h"
namespace cocos2d {






class CCTextureAtlas;
# 51 "Cacao/include/cocos2dx/base_nodes/CCAtlasNode.h"
class CCAtlasNode : public CCNodeRGBA, public CCTextureProtocol
{
protected:


    unsigned int m_uItemsPerRow;

    unsigned int m_uItemsPerColumn;


    unsigned int m_uItemWidth;

    unsigned int m_uItemHeight;

    ccColor3B m_tColorUnmodified;

    protected: CCTextureAtlas* m_pTextureAtlas;public: virtual CCTextureAtlas* getTextureAtlas(void);public: virtual void setTextureAtlas(CCTextureAtlas* var);;


    bool m_bIsOpacityModifyRGB;

    protected: ccBlendFunc m_tBlendFunc;public: virtual ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(ccBlendFunc var);;


    protected: unsigned int m_uQuadsToDraw;public: virtual unsigned int getQuadsToDraw(void);public: virtual void setQuadsToDraw(unsigned int var);;

    GLint m_nUniformColor;

    bool m_bIgnoreContentScaleFactor;

public:



    CCAtlasNode();




    virtual ~CCAtlasNode();


 static CCAtlasNode * create(const char* tile,unsigned int tileWidth, unsigned int tileHeight,
  unsigned int itemsToRender);


    bool initWithTileFile(const char* tile, unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);


    bool initWithTexture(CCTexture2D* texture, unsigned int tileWidth, unsigned int tileHeight, unsigned int itemsToRender);




    virtual void updateAtlasValues();

    virtual void draw(void);




    virtual CCTexture2D* getTexture(void);


    virtual void setTexture(CCTexture2D *texture);

    virtual bool isOpacityModifyRGB();
    virtual void setOpacityModifyRGB(bool isOpacityModifyRGB);
    virtual const ccColor3B& getColor(void);
    virtual void setColor(const ccColor3B& color);
    virtual void setOpacity(GLubyte opacity);

private :
    void calculateMaxItems();
    void updateBlendFunc();
    void updateOpacityModifyRGB();

    friend class CCDirector;
    void setIgnoreContentScaleFactor(bool bIgnoreContentScaleFactor);
};




}
# 58 "Cacao/include/cocos2dx/cocos2d.h" 2








# 1 "Cacao/include/cocos2dx/cocoa/CCAutoreleasePool.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCAutoreleasePool.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCAutoreleasePool.h"
class CCAutoreleasePool : public CCObject
{
    CCArray* m_pManagedObjectArray;
public:
    CCAutoreleasePool(void);
    ~CCAutoreleasePool(void);

    void addObject(CCObject *pObject);
    void removeObject(CCObject *pObject);

    void clear();
};





class CCPoolManager
{
    CCArray* m_pReleasePoolStack;
    CCAutoreleasePool* m_pCurReleasePool;

    CCAutoreleasePool* getCurReleasePool();
public:
    CCPoolManager();
    ~CCPoolManager();
    void finalize();
    void push();
    void pop();

    void removeObject(CCObject* pObject);
    void addObject(CCObject* pObject);

    static CCPoolManager* sharedPoolManager();
    static void purgePoolManager();

    friend class CCAutoreleasePool;
};




}
# 67 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCInteger.h" 1





namespace cocos2d {







class CCInteger : public CCObject
{
public:
    CCInteger(int v)
        : m_nValue(v) {}
    int getValue() const {return m_nValue;}

    static CCInteger* create(int v)
    {
        CCInteger* pRet = new CCInteger(v);
        pRet->autorelease();
        return pRet;
    }




    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    int m_nValue;
};




}
# 68 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCFloat.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCFloat.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCFloat.h"
class CCFloat : public CCObject
{
public:
    CCFloat(float v)
        : m_fValue(v) {}
    float getValue() const {return m_fValue;}

    static CCFloat* create(float v)
    {
        CCFloat* pRet = new CCFloat(v);
        if (pRet)
        {
            pRet->autorelease();
        }
        return pRet;
    }


    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    float m_fValue;
};




}
# 69 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCDouble.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCDouble.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCDouble.h"
class CCDouble : public CCObject
{
public:
    CCDouble(double v)
        : m_dValue(v) {}
    double getValue() const {return m_dValue;}

    static CCDouble* create(double v)
    {
        CCDouble* pRet = new CCDouble(v);
        if (pRet)
        {
            pRet->autorelease();
        }
        return pRet;
    }


    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    double m_dValue;
};




}
# 70 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCBool.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCBool.h"
namespace cocos2d {
# 39 "Cacao/include/cocos2dx/cocoa/CCBool.h"
class CCBool : public CCObject
{
public:
    CCBool(bool v)
        : m_bValue(v) {}
    bool getValue() const {return m_bValue;}

    static CCBool* create(bool v)
    {
        CCBool* pRet = new CCBool(v);
        if (pRet)
        {
            pRet->autorelease();
        }
        return pRet;
    }


    virtual void acceptVisitor(CCDataVisitor &visitor) { visitor.visit(this); }

private:
    bool m_bValue;
};




}
# 71 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/cocoa/CCNS.h" 1
# 30 "Cacao/include/cocos2dx/cocoa/CCNS.h"
namespace cocos2d {
# 47 "Cacao/include/cocos2dx/cocoa/CCNS.h"
CCRect CCRectFromString(const char* pszContent);
# 59 "Cacao/include/cocos2dx/cocoa/CCNS.h"
CCPoint CCPointFromString(const char* pszContent);
# 71 "Cacao/include/cocos2dx/cocoa/CCNS.h"
CCSize CCSizeFromString(const char* pszContent);




}
# 73 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/cocoa/CCZone.h" 1
# 31 "Cacao/include/cocos2dx/cocoa/CCZone.h"
namespace cocos2d {






class CCObject;




class CCZone
{
public:
    CCZone(CCObject *pObject = __null);

public:
    CCObject *m_pCopyObject;
};




}
# 74 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/draw_nodes/CCDrawingPrimitives.h" 1
# 69 "Cacao/include/cocos2dx/draw_nodes/CCDrawingPrimitives.h"
namespace cocos2d {






class CCPointArray;


void ccDrawInit();


void ccDrawFree();


void ccDrawPoint( const CCPoint& point );




void ccDrawPoints( const CCPoint *points, unsigned int numberOfPoints );


void ccDrawLine( const CCPoint& origin, const CCPoint& destination );


void ccDrawRect( CCPoint origin, CCPoint destination );




void ccDrawSolidRect( CCPoint origin, CCPoint destination, ccColor4F color );




void ccDrawPoly( const CCPoint *vertices, unsigned int numOfVertices, bool closePolygon );



void ccDrawSolidPoly( const CCPoint *poli, unsigned int numberOfPoints, ccColor4F color );


void ccDrawCircle( const CCPoint& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float scaleX, float scaleY);
void ccDrawCircle( const CCPoint& center, float radius, float angle, unsigned int segments, bool drawLineToCenter);





void ccDrawQuadBezier(const CCPoint& origin, const CCPoint& control, const CCPoint& destination, unsigned int segments);





void ccDrawCubicBezier(const CCPoint& origin, const CCPoint& control1, const CCPoint& control2, const CCPoint& destination, unsigned int segments);





void ccDrawCatmullRom( CCPointArray *arrayOfControlPoints, unsigned int segments );





void ccDrawCardinalSpline( CCPointArray *config, float tension, unsigned int segments );




void ccDrawColor4B( GLubyte r, GLubyte g, GLubyte b, GLubyte a );




void ccDrawColor4F( GLfloat r, GLfloat g, GLfloat b, GLfloat a );




void ccPointSize( GLfloat pointSize );




}
# 77 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/draw_nodes/CCDrawNode.h" 1
# 36 "Cacao/include/cocos2dx/draw_nodes/CCDrawNode.h"
namespace cocos2d {
# 45 "Cacao/include/cocos2dx/draw_nodes/CCDrawNode.h"
class CCDrawNode : public CCNode
{
protected:
    GLuint m_uVao;
    GLuint m_uVbo;

    unsigned int m_uBufferCapacity;
    GLsizei m_nBufferCount;
    ccV2F_C4B_T2F *m_pBuffer;

    ccBlendFunc m_sBlendFunc;

    bool m_bDirty;

public:
    static CCDrawNode* create();
    virtual ~CCDrawNode();

    virtual bool init();
    virtual void draw();


    void drawDot(const CCPoint &pos, float radius, const ccColor4F &color);


    void drawSegment(const CCPoint &from, const CCPoint &to, float radius, const ccColor4F &color);







    void drawPolygon(CCPoint *verts, unsigned int count, const ccColor4F &fillColor, float borderWidth, const ccColor4F &borderColor);


    void clear();



    ccBlendFunc getBlendFunc() const;






    void setBlendFunc(const ccBlendFunc &blendFunc);

    CCDrawNode();




    void listenBackToForeground(CCObject *obj);
private:
    void ensureCapacity(unsigned int count);
    void render();
};

}
# 78 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/effects/CCGrabber.h" 1
# 28 "Cacao/include/cocos2dx/effects/CCGrabber.h"
# 1 "Cacao/include/cocos2dx/CCConfiguration.h" 1
# 36 "Cacao/include/cocos2dx/CCConfiguration.h"
namespace cocos2d {

typedef enum _ccConfigurationType {
    ConfigurationError,
    ConfigurationString,
    ConfigurationInt,
    ConfigurationDouble,
    ConfigurationBoolean
} ccConfigurationType;
# 55 "Cacao/include/cocos2dx/CCConfiguration.h"
class CCConfiguration : public CCObject
{
public:

    static CCConfiguration *sharedConfiguration(void);


    static void purgeConfiguration(void);

public:




 virtual ~CCConfiguration(void);


 int getMaxTextureSize(void) const;


 int getMaxModelviewStackDepth(void) const;




 int getMaxTextureUnits(void) const;






 bool supportsNPOT(void) const;


 bool supportsPVRTC(void) const;




 bool supportsBGRA8888(void) const;




 bool supportsDiscardFramebuffer(void) const;




 bool supportsShareableVAO(void) const;


    bool checkForGLExtension(const std::string &searchName) const;

    bool init(void);



 const char* getCString( const char *key, const char *default_value=__null ) const;



 bool getBool( const char *key, bool default_value=false ) const;



 double getNumber( const char *key, double default_value=0.0 ) const;


 CCObject * getObject( const char *key ) const;


 void setObject( const char *key, CCObject *value );


 void dumpInfo(void) const;


 void gatherGPUInfo( void );


 void loadConfigFile( const char *filename );

private:
    CCConfiguration(void);
    static CCConfiguration *s_gSharedConfiguration;
 static std::string s_sConfigfile;

protected:
    GLint m_nMaxTextureSize;
    GLint m_nMaxModelviewStackDepth;
    bool m_bSupportsPVRTC;
    bool m_bSupportsNPOT;
    bool m_bSupportsBGRA8888;
    bool m_bSupportsDiscardFramebuffer;
    bool m_bSupportsShareableVAO;
    GLint m_nMaxSamplesAllowed;
    GLint m_nMaxTextureUnits;
    char * m_pGlExtensions;

 CCDictionary *m_pValueDict;
};




}
# 29 "Cacao/include/cocos2dx/effects/CCGrabber.h" 2



namespace cocos2d {

class CCTexture2D;
# 45 "Cacao/include/cocos2dx/effects/CCGrabber.h"
class CCGrabber : public CCObject
{
public:
    CCGrabber(void);
    ~CCGrabber(void);

    void grab(CCTexture2D *pTexture);
    void beforeRender(CCTexture2D *pTexture);
    void afterRender(CCTexture2D *pTexture);

protected:
    GLuint m_FBO;
    GLint m_oldFBO;
    GLfloat m_oldClearColor[4];
};




}
# 81 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/effects/CCGrid.h" 1
# 30 "Cacao/include/cocos2dx/effects/CCGrid.h"
# 1 "Cacao/include/cocos2dx/CCCamera.h" 1
# 35 "Cacao/include/cocos2dx/CCCamera.h"
namespace cocos2d {
# 64 "Cacao/include/cocos2dx/CCCamera.h"
class CCCamera : public CCObject
{
protected:
    float m_fEyeX;
    float m_fEyeY;
    float m_fEyeZ;

    float m_fCenterX;
    float m_fCenterY;
    float m_fCenterZ;

    float m_fUpX;
    float m_fUpY;
    float m_fUpZ;

    bool m_bDirty;
    kmMat4 m_lookupMatrix;
public:



    CCCamera(void);




    ~CCCamera(void);

    void init(void);



    const char* description(void);


    inline void setDirty(bool bValue) { m_bDirty = bValue; }

    inline bool isDirty(void) { return m_bDirty; }


    void restore(void);

    void locate(void);



    void setEyeXYZ(float fEyeX, float fEyeY, float fEyeZ);



    void setCenterXYZ(float fCenterX, float fCenterY, float fCenterZ);



    void setUpXYZ(float fUpX, float fUpY, float fUpZ);




    void getEyeXYZ(float *pEyeX, float *pEyeY, float *pEyeZ);



    void getCenterXYZ(float *pCenterX, float *pCenterY, float *pCenterZ);



    void getUpXYZ(float *pUpX, float *pUpY, float *pUpZ);
public:

    static float getZEye();

private:
    CCCamera(const CCCamera&); void operator=(const CCCamera&);
};




}
# 31 "Cacao/include/cocos2dx/effects/CCGrid.h" 2


# 1 "Cacao/include/cocos2dx/CCDirector.h" 1
# 37 "Cacao/include/cocos2dx/CCDirector.h"
# 1 "Cacao/include/cocos2dx/label_nodes/CCLabelAtlas.h" 1
# 31 "Cacao/include/cocos2dx/label_nodes/CCLabelAtlas.h"
namespace cocos2d {
# 51 "Cacao/include/cocos2dx/label_nodes/CCLabelAtlas.h"
class CCLabelAtlas : public CCAtlasNode, public CCLabelProtocol
{
public:




    CCLabelAtlas()
        :m_sString("")
    {}




    virtual ~CCLabelAtlas()
    {
        m_sString.clear();
    }


    static CCLabelAtlas * create(const char *string, const char *charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);





    static CCLabelAtlas* create(const char *string, const char *fntFile);


    bool initWithString(const char *string, const char *charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);




    bool initWithString(const char *string, const char *fntFile);


    bool initWithString(const char* string, CCTexture2D* texture, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);


    virtual void updateAtlasValues();
    virtual void setString(const char *label);
    virtual const char* getString(void);





protected:

    std::string m_sString;

    unsigned int m_uMapStartChar;
};






}
# 38 "Cacao/include/cocos2dx/CCDirector.h" 2



namespace cocos2d {
# 51 "Cacao/include/cocos2dx/CCDirector.h"
    typedef enum {

    kCCDirectorProjection2D,


    kCCDirectorProjection3D,


    kCCDirectorProjectionCustom,


    kCCDirectorProjectionDefault = kCCDirectorProjection3D,
} ccDirectorProjection;

    typedef enum {
        LOW=1,
        MEDIUM,
        HIGH
    }TextureQuality;

    typedef enum{
        FadeTransition,
        MoveInTransition
    }PopTransition;





class CCLabelAtlas;
class CCScene;
class CCEGLView;
class CCDirectorDelegate;
class CCNode;
class CCScheduler;
class CCActionManager;
class CCTouchDispatcher;
class CCKeypadDispatcher;
class CCKeyboardDispatcher;
class CCMouseDispatcher;
class CCSceneDelegate;
class CCAccelerometer;
# 115 "Cacao/include/cocos2dx/CCDirector.h"
class CCDirector : public CCObject, public TypeInfo
{
public:



    CCDirector(void);




    virtual ~CCDirector(void);
    virtual bool init(void);




    virtual long getClassTypeInfo() {
        static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCDirector).name());
        return id;
    }




    inline CCScene* getRunningScene(void) { return m_pRunningScene; }


    inline double getAnimationInterval(void) { return m_dAnimationInterval; }

    virtual void setAnimationInterval(double dValue) = 0;


    inline bool isDisplayStats(void) { return m_bDisplayStats; }

    inline void setDisplayStats(bool bDisplayStats) { m_bDisplayStats = bDisplayStats; }


    inline float getSecondsPerFrame() { return m_fSecondsPerFrame; }




    inline CCEGLView* getOpenGLView(void) { return m_pobOpenGLView; }
    void setOpenGLView(CCEGLView* pobOpenGLView);

    inline bool isNextDeltaTimeZero(void) { return m_bNextDeltaTimeZero; }
    void setNextDeltaTimeZero(bool bNextDeltaTimeZero);


    inline bool isPaused(void) { return m_bPaused; }


    inline unsigned int getTotalFrames(void) { return m_uTotalFrames; }





    inline ccDirectorProjection getProjection(void) { return m_eProjection; }
    void setProjection(ccDirectorProjection kProjection);

    void reshapeProjection(const CCSize& newWindowSize);


    void setViewport();
# 190 "Cacao/include/cocos2dx/CCDirector.h"
    inline bool isSendCleanupToScene(void) { return m_bSendCleanupToScene; }






    CCNode* getNotificationNode();
    void setNotificationNode(CCNode* node);




    CCDirectorDelegate* getDelegate() const;
    void setDelegate(CCDirectorDelegate* pDelegate);





    CCSize getWinSize(void);



    CCSize getWinSizeInPixels(void);





    CCSize getVisibleSize();



    CCPoint getVisibleOrigin();




    CCPoint convertToGL(const CCPoint& obPoint);




    CCPoint convertToUI(const CCPoint& obPoint);


    float getZEye(void);
# 247 "Cacao/include/cocos2dx/CCDirector.h"
    void runWithScene(CCScene* pScene);
# 256 "Cacao/include/cocos2dx/CCDirector.h"
    bool pushScene(CCScene* pScene);






    void popScene(void);





    void popToRootScene(void);






    void popToSceneStackLevel(int level);





    bool replaceScene(CCScene* pScene);




    void end(void);





    void pause(void);





    void resume(void);




    virtual void stopAnimation(void) = 0;





    virtual void startAnimation(void) = 0;




    void drawScene(void);







    void purgeCachedData(void);


    void setDefaultValues(void);




    void setGLDefaultValues(void);


    void setAlphaBlending(bool bOn);


    void setDepthTest(bool bOn);

    virtual void mainLoop(void) = 0;






    void setContentScaleFactor(float scaleFactor);
    float getContentScaleFactor(void);
private:
    float m_fScreenScaleFactor;
    float m_fScreenScaleFactorMax;
    float m_fScreenScaleFactorW;
    float m_fScreenScaleFactorH;
    float m_fScreenTop;
    float m_fScreenBottom;
    float m_fScreenLeft;
    float m_fScreenRight;
    uint32_t m_uSceneReference;

public:



    protected: CCScheduler* m_pScheduler;public: virtual CCScheduler* getScheduler(void);public: virtual void setScheduler(CCScheduler* var);;




    protected: CCActionManager* m_pActionManager;public: virtual CCActionManager* getActionManager(void);public: virtual void setActionManager(CCActionManager* var);;




    protected: CCTouchDispatcher* m_pTouchDispatcher;public: virtual CCTouchDispatcher* getTouchDispatcher(void);public: virtual void setTouchDispatcher(CCTouchDispatcher* var);;




    protected: CCKeypadDispatcher* m_pKeypadDispatcher;public: virtual CCKeypadDispatcher* getKeypadDispatcher(void);public: virtual void setKeypadDispatcher(CCKeypadDispatcher* var);;


    protected: CCKeyboardDispatcher* m_pKeyboardDispatcher;public: virtual CCKeyboardDispatcher* getKeyboardDispatcher(void);public: virtual void setKeyboardDispatcher(CCKeyboardDispatcher* var);;


    protected: CCMouseDispatcher* m_pMouseDispatcher;public: virtual CCMouseDispatcher* getMouseDispatcher(void);public: virtual void setMouseDispatcher(CCMouseDispatcher* var);;







    protected: CCAccelerometer* m_pAccelerometer;public: virtual CCAccelerometer* getAccelerometer(void);public: virtual void setAccelerometer(CCAccelerometer* var);;
protected:
    float m_fDeltaTime;
public:

    virtual float getDeltaTime(void);
    void setDeltaTime(float);



    protected: float m_fActualDeltaTime;public: float getActualDeltaTime(void);public: void setActualDeltaTime(float var);;

    protected: bool m_bIsTransitioning;public: virtual bool getIsTransitioning(void) const { return m_bIsTransitioning; }


public:



    static CCDirector* sharedDirector(void);

protected:

    void purgeDirector();
    bool m_bPurgeDirecotorInNextLoop;

    void setNextScene(void);

    void showStats();
    void createStatsLabel();
    void calculateMPF();
    void getFPSImageData(unsigned char** datapointer, unsigned int* length);


    void calculateDeltaTime();
protected:
    uint32_t m_uPadding00[2];

    CCEGLView* m_pobOpenGLView;

    uint32_t m_uPadding01;

    double m_dAnimationInterval;
    double m_dOldAnimationInterval;


    bool m_bLandscape;


    bool m_bDisplayStats;
    float m_fAccumDt;
    float m_fFrameRate;

    CCLabelAtlas* m_pFPSLabel;
    CCLabelAtlas* m_pSPFLabel;
    CCLabelAtlas* m_pDrawsLabel;


    bool m_bPaused;


    unsigned int m_uTotalFrames;
    unsigned int m_uFrames;
    float m_fSecondsPerFrame;


    CCScene* m_pRunningScene;



    CCScene* m_pNextScene;


    bool m_bSendCleanupToScene;


    CCArray* m_pobScenesStack;


    struct cc_timeval* m_pLastUpdate;


    bool m_bNextDeltaTimeZero;


    ccDirectorProjection m_eProjection;


    CCSize m_obWinSizeInPoints;


    float m_fContentScaleFactor;


    char* m_pszFPS;


    CCNode* m_pNotificationNode;


    CCDirectorDelegate* m_pProjectionDelegate;



    protected: CCSceneDelegate* m_pSceneDelegate;public: virtual CCSceneDelegate* getSceneDelegate(void) const;public: virtual void setSceneDelegate(CCSceneDelegate* var);;
protected:
    CCSize m_sUnknown04;
    CCSize m_sUnknown05;

    TextureQuality m_eTextureQuality;
    bool m_bWillSwitchToScene;



    friend class CCEGLViewProtocol;
public:

    bool getDontCallWillSwitch(void) const;



    TextureQuality getLoadedTextureQuality(void) const;

    CCScene* getNextScene(void);

    CCScene* getSceneReference(void) const;
    float getScreenBottom(void);
    float getScreenLeft(void);
    float getScreenRight(void);
    float getScreenScaleFactor(void);
    float getScreenScaleFactorH(void);
    float getScreenScaleFactorMax(void);
    float getScreenScaleFactorW(void);
    float getScreenTop(void);
    bool getSmoothFix(void) const;
    bool getSmoothFixCheck(void) const;
    int getSmoothFixCounter(void) const;
    int levelForSceneInStack(CCScene*);
    void popSceneWithTransition(float, PopTransition);
    int sceneCount(void);


    void setForceSmoothFix(bool);



    void setSceneReference(CCScene*);
    void setSmoothFix(bool);
    void setSmoothFixCheck(bool);
    void setupScreenScale(CCSize, CCSize, TextureQuality);
    void updateContentScale(TextureQuality);
    void updateScreenScale(CCSize);
    void willSwitchToScene(CCScene*);
};
# 558 "Cacao/include/cocos2dx/CCDirector.h"
class CCDisplayLinkDirector : public CCDirector
{
public:
    CCDisplayLinkDirector(void)
        : m_bInvalid(false)
    {}

    virtual void mainLoop(void);
    virtual void setAnimationInterval(double dValue);
    virtual void startAnimation(void);
    virtual void stopAnimation();

protected:
    bool m_bInvalid;
};




}
# 34 "Cacao/include/cocos2dx/effects/CCGrid.h" 2





namespace cocos2d {

class CCTexture2D;
class CCGrabber;
class CCGLProgram;
# 52 "Cacao/include/cocos2dx/effects/CCGrid.h"
class CCGridBase : public CCObject
{
public:




    virtual ~CCGridBase(void);




    inline bool isActive(void) { return m_bActive; }



    void setActive(bool bActive);




    inline int getReuseGrid(void) { return m_nReuseGrid; }



    inline void setReuseGrid(int nReuseGrid) { m_nReuseGrid = nReuseGrid; }




    inline const CCSize& getGridSize(void) { return m_sGridSize; }



    inline void setGridSize(const CCSize& gridSize) { m_sGridSize = gridSize; }




    inline const CCPoint& getStep(void) { return m_obStep; }



    inline void setStep(const CCPoint& step) { m_obStep = step; }




    inline bool isTextureFlipped(void) { return m_bIsTextureFlipped; }



    void setTextureFlipped(bool bFlipped);



    bool initWithSize(const CCSize& gridSize, CCTexture2D *pTexture, bool bFlipped);



    bool initWithSize(const CCSize& gridSize);



    void beforeDraw(void);



    void afterDraw(CCNode *pTarget);



    virtual void blit(void);



    virtual void reuse(void);



    virtual void calculateVertexPoints(void);

public:




    static CCGridBase* create(const CCSize& gridSize, CCTexture2D *texture, bool flipped);



    static CCGridBase* create(const CCSize& gridSize);



    void set2DProjection(void);

protected:
    bool m_bActive;
    int m_nReuseGrid;
    CCSize m_sGridSize;
    CCTexture2D *m_pTexture;
    CCPoint m_obStep;
    CCGrabber *m_pGrabber;
    bool m_bIsTextureFlipped;
    CCGLProgram* m_pShaderProgram;
    ccDirectorProjection m_directorProjection;
};






class CCGrid3D : public CCGridBase



{
public:
    CCGrid3D();
    ~CCGrid3D(void);


    ccVertex3F vertex(const CCPoint& pos);

    ccVertex3F originalVertex(const CCPoint& pos);

    void setVertex(const CCPoint& pos, const ccVertex3F& vertex);

    virtual void blit(void);
    virtual void reuse(void);
    virtual void calculateVertexPoints(void);

public:

    static CCGrid3D* create(const CCSize& gridSize, CCTexture2D *pTexture, bool bFlipped);

    static CCGrid3D* create(const CCSize& gridSize);

protected:
    GLvoid *m_pTexCoordinates;
    GLvoid *m_pVertices;
    GLvoid *m_pOriginalVertices;
    GLushort *m_pIndices;
};







class CCTiledGrid3D : public CCGridBase



{
public:
    CCTiledGrid3D();
    ~CCTiledGrid3D(void);


    ccQuad3 tile(const CCPoint& pos);

    ccQuad3 originalTile(const CCPoint& pos);

    void setTile(const CCPoint& pos, const ccQuad3& coords);

    virtual void blit(void);
    virtual void reuse(void);
    virtual void calculateVertexPoints(void);

public:


    static CCTiledGrid3D* create(const CCSize& gridSize, CCTexture2D *pTexture, bool bFlipped);

    static CCTiledGrid3D* create(const CCSize& gridSize);

protected:
    GLvoid *m_pTexCoordinates;
    GLvoid *m_pVertices;
    GLvoid *m_pOriginalVertices;
    GLushort *m_pIndices;
};




}
# 82 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/include/CCEventType.h" 1
# 85 "Cacao/include/cocos2dx/cocos2d.h" 2







# 1 "Cacao/include/cocos2dx/kazmath/include/kazmath/GL/matrix.h" 1
# 35 "Cacao/include/cocos2dx/kazmath/include/kazmath/GL/matrix.h"
typedef unsigned int kmGLEnum;





extern "C" {


void kmGLFreeAll(void);
void kmGLPushMatrix(void);
void kmGLPopMatrix(void);
void kmGLMatrixMode(kmGLEnum mode);
void kmGLLoadIdentity(void);
void kmGLLoadMatrix(const kmMat4* pIn);
void kmGLMultMatrix(const kmMat4* pIn);
void kmGLTranslatef(float x, float y, float z);
void kmGLRotatef(float angle, float x, float y, float z);
void kmGLScalef(float x, float y, float z);
void kmGLGetMatrix(kmGLEnum mode, kmMat4* pOut);


}
# 93 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h" 1
# 31 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h"
namespace cocos2d {
# 40 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h"
class CCKeypadDelegate
{
public:

    virtual void keyBackClicked() {}


    virtual void keyMenuClicked() {};
};
# 57 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDelegate.h"
class CCKeypadHandler : public CCObject
{
public:
    virtual ~CCKeypadHandler(void);


    CCKeypadDelegate* getDelegate();
    void setDelegate(CCKeypadDelegate *pDelegate);


    virtual bool initWithDelegate(CCKeypadDelegate *pDelegate);

public:

    static CCKeypadHandler* handlerWithDelegate(CCKeypadDelegate *pDelegate);

protected:
    CCKeypadDelegate* m_pDelegate;
};




}
# 96 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDispatcher.h" 1
# 31 "Cacao/include/cocos2dx/keypad_dispatcher/CCKeypadDispatcher.h"
namespace cocos2d {






typedef enum {

    kTypeBackClicked = 1,
    kTypeMenuClicked,
} ccKeypadMSGType;

struct _ccCArray;






class CCKeypadDispatcher : public CCObject
{
public:
    CCKeypadDispatcher();
    ~CCKeypadDispatcher();




    void addDelegate(CCKeypadDelegate* pDelegate);




    void removeDelegate(CCKeypadDelegate* pDelegate);




    void forceAddDelegate(CCKeypadDelegate* pDelegate);




    void forceRemoveDelegate(CCKeypadDelegate* pDelegate);




    bool dispatchKeypadMSG(ccKeypadMSGType nMsgType);

protected:

    CCArray* m_pDelegates;
    bool m_bLocked;
    bool m_bToAdd;
    bool m_bToRemove;

    struct _ccCArray *m_pHandlersToAdd;
    struct _ccCArray *m_pHandlersToRemove;
};




}
# 97 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h" 1
# 28 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h"
# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h" 1
# 32 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
# 1 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h" 1
# 35 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h"
namespace cocos2d {

class CCTexture2D;
# 56 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h"
class CCTextureAtlas : public CCObject
{
protected:
    GLushort* m_pIndices;

    GLuint m_uVAOname;

    GLuint m_pBuffersVBO[2];
    bool m_bDirty;



    protected: unsigned int m_uTotalQuads;public: virtual unsigned int getTotalQuads(void);

    protected: unsigned int m_uCapacity;public: virtual unsigned int getCapacity(void);

    protected: CCTexture2D * m_pTexture;public: virtual CCTexture2D * getTexture(void);public: virtual void setTexture(CCTexture2D * var);

    protected: ccV3F_C4B_T2F_Quad * m_pQuads;public: virtual ccV3F_C4B_T2F_Quad * getQuads(void);public: virtual void setQuads(ccV3F_C4B_T2F_Quad * var);

public:



    CCTextureAtlas();




    virtual ~CCTextureAtlas();




    const char* description();




    static CCTextureAtlas* create(const char* file , unsigned int capacity);






    bool initWithFile(const char* file, unsigned int capacity);





    static CCTextureAtlas* createWithTexture(CCTexture2D *texture, unsigned int capacity);
# 117 "Cacao/include/cocos2dx/textures/CCTextureAtlas.h"
    bool initWithTexture(CCTexture2D *texture, unsigned int capacity);





    void updateQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);





    void insertQuad(ccV3F_C4B_T2F_Quad* quad, unsigned int index);






    void insertQuads(ccV3F_C4B_T2F_Quad* quads, unsigned int index, unsigned int amount);





    void insertQuadFromIndex(unsigned int fromIndex, unsigned int newIndex);





    void removeQuadAtIndex(unsigned int index);




    void removeQuadsAtIndex(unsigned int index, unsigned int amount);





    void removeAllQuads();







    bool resizeCapacity(unsigned int n);






    void increaseTotalQuadsWith(unsigned int amount);




    void moveQuadsFromIndex(unsigned int oldIndex, unsigned int amount, unsigned int newIndex);







    void moveQuadsFromIndex(unsigned int index, unsigned int newIndex);






    void fillWithEmptyQuadsFromIndex(unsigned int index, unsigned int amount);




    void drawNumberOfQuads(unsigned int n);






    void drawNumberOfQuads(unsigned int n, unsigned int start);



    void drawQuads();


    void listenBackToForeground(CCObject *obj);


    inline bool isDirty(void) { return m_bDirty; }

    inline void setDirty(bool bDirty) { m_bDirty = bDirty; }

private:
    void setupIndices();
    void mapBuffers();

    void setupVBOandVAO();



};




}
# 33 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h" 2







namespace cocos2d {

class CCSpriteBatchNode;
class CCSpriteFrame;
class CCAnimation;
class CCRect;
class CCPoint;
class CCSize;
class CCTexture2D;
struct transformValues_;
# 82 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
class CCSprite : public CCNodeRGBA, public CCTextureProtocol



{
public:
# 96 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* create();
# 107 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* create(const char *pszFileName);
# 116 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* create(const char *pszFileName, const CCRect& rect);
# 125 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* createWithTexture(CCTexture2D *pTexture);
# 137 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* createWithTexture(CCTexture2D *pTexture, const CCRect& rect);







    static CCSprite* createWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
# 156 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    static CCSprite* createWithSpriteFrameName(const char *pszSpriteFrameName);
# 169 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    CCSprite(void);






    virtual ~CCSprite(void);




    virtual bool init(void);
# 192 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithTexture(CCTexture2D *pTexture);
# 204 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithTexture(CCTexture2D *pTexture, const CCRect& rect);
# 217 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithTexture(CCTexture2D *pTexture, const CCRect& rect, bool rotated);







    virtual bool initWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
# 236 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithSpriteFrameName(const char *pszSpriteFrameName);
# 249 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithFile(const char *pszFilename);
# 263 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual bool initWithFile(const char *pszFilename, const CCRect& rect);





    virtual void setTexture(CCTexture2D *texture);
    virtual CCTexture2D* getTexture(void);
    inline void setBlendFunc(ccBlendFunc blendFunc) { m_sBlendFunc = blendFunc; }



    inline ccBlendFunc getBlendFunc(void) { return m_sBlendFunc; }



    virtual void setChildColor(const _ccColor3B&);
    virtual void setChildOpacity(unsigned char);



    virtual void setScaleX(float fScaleX);
    virtual void setScaleY(float fScaleY);



    virtual void setPosition(const CCPoint& pos);
    virtual void setRotation(float fRotation);
    virtual void setRotationX(float fRotationX);
    virtual void setRotationY(float fRotationY);
    virtual void setSkewX(float sx);
    virtual void setSkewY(float sy);
    virtual void removeChild(CCNode* pChild, bool bCleanup);
    virtual void removeAllChildrenWithCleanup(bool bCleanup);
    virtual void reorderChild(CCNode *pChild, int zOrder);
    virtual void addChild(CCNode *pChild);
    virtual void addChild(CCNode *pChild, int zOrder);
    virtual void addChild(CCNode *pChild, int zOrder, int tag);
    virtual void sortAllChildren();
    virtual void setScale(float fScale);
    virtual void setVertexZ(float fVertexZ);
    virtual void setAnchorPoint(const CCPoint& anchor);
    virtual void ignoreAnchorPointForPosition(bool value);
    virtual void setVisible(bool bVisible);
    virtual void draw(void);




    virtual void setColor(const ccColor3B& color3);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual void setOpacity(GLubyte opacity);
    virtual void setOpacityModifyRGB(bool modify);
    virtual bool isOpacityModifyRGB(void);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
# 327 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void updateTransform(void);







    virtual CCSpriteBatchNode* getBatchNode(void);
# 346 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setBatchNode(CCSpriteBatchNode *pobSpriteBatchNode);




    virtual void refreshTextureRect(void);
# 360 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setTextureRect(const CCRect& rect);





    virtual void setTextureRect(const CCRect& rect, bool rotated, const CCSize& untrimmedSize);







    virtual void setVertexRect(const CCRect& rect);
# 386 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setDisplayFrame(CCSpriteFrame *pNewFrame);




    virtual bool isFrameDisplayed(CCSpriteFrame *pFrame);





    virtual CCSpriteFrame* displayFrame(void);
# 408 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    virtual void setDisplayFrameWithAnimationName(const char *animationName, int frameIndex);
# 420 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    inline virtual bool isDirty(void) { return m_bDirty; }




    inline virtual void setDirty(bool bDirty) { m_bDirty = bDirty; }





    inline ccV3F_C4B_T2F_Quad getQuad(void) { return m_sQuad; }




    inline bool isTextureRectRotated(void) { return m_bRectRotated; }




    inline unsigned int getAtlasIndex(void) { return m_uAtlasIndex; }





    inline void setAtlasIndex(unsigned int uAtlasIndex) { m_uAtlasIndex = uAtlasIndex; }




    inline const CCRect& getTextureRect(void) { return m_obRect; }




    inline CCTextureAtlas* getTextureAtlas(void) { return m_pobTextureAtlas; }




    inline void setTextureAtlas(CCTextureAtlas *pobTextureAtlas) { m_pobTextureAtlas = pobTextureAtlas; }




    inline const CCPoint& getOffsetPosition(void) { return m_obOffsetPosition; }
# 481 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    bool isFlipX(void);





    void setFlipX(bool bFlipX);
# 500 "Cacao/include/cocos2dx/sprite_nodes/CCSprite.h"
    bool isFlipY(void);





    void setFlipY(bool bFlipY);




    float getBlVertexMod(void)const;
    float getBrVertexMod(void)const;
    bool getDontDraw(void)const;
    float getTlVertexMod(void)const;
    float getTrVertexMod(void)const;
    CCPoint const& getUnflippedOffsetPosition(void);
    void setBlVertexMod(float);
    void setBrVertexMod(float);
    void setDontDraw(bool);
    void setTlVertexMod(float);
    void setTrVertexMod(float);



protected:
    void updateColor(void);

    virtual void setTextureCoords(const CCRect& rect);
    virtual void updateBlendFunc(void);
    virtual void setReorderChildDirtyRecursively(void);
    virtual void setDirtyRecursively(bool bValue);




    CCTextureAtlas* m_pobTextureAtlas;
    unsigned int m_uAtlasIndex;
    CCSpriteBatchNode* m_pobBatchNode;

    bool m_bDirty;
    bool m_bRecursiveDirty;
    bool m_bHasChildren;
    bool m_bShouldBeHidden;
    CCAffineTransform m_transformToBatch;




    ccBlendFunc m_sBlendFunc;
    CCTexture2D* m_pobTexture;






    CCRect m_obRect;
    bool m_bRectRotated;


    CCPoint m_obOffsetPosition;
    CCPoint m_obUnflippedOffsetPositionFromCenter;


    ccV3F_C4B_T2F_Quad m_sQuad;


    bool m_bOpacityModifyRGB;


    bool m_bFlipX;
    bool m_bFlipY;


    bool m_bUnknown;
    uint32_t m_uUnknown0;
    uint32_t m_uUnknown1;
    uint32_t m_uUnknown2;
    uint32_t m_uUnknown3;
    uint32_t m_uUnknown4;
    uint32_t m_uUnknown5;
    uint32_t m_uUnknown6;
    uint32_t m_uUnknown8;
    uint8_t m_uUnknown9;
    uint32_t m_uUnknownA;

};





}
# 29 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h" 2


namespace cocos2d {
# 57 "Cacao/include/cocos2dx/label_nodes/CCLabelTTF.h"
class CCLabelTTF : public CCSprite, public CCLabelProtocol
{
public:



    CCLabelTTF();




    virtual ~CCLabelTTF();




    const char* description();




    static CCLabelTTF * create(const char *string, const char *fontName, float fontSize);




    static CCLabelTTF * create(const char *string, const char *fontName, float fontSize,
                               const CCSize& dimensions, CCTextAlignment hAlignment);




    static CCLabelTTF * create(const char *string, const char *fontName, float fontSize,
                               const CCSize& dimensions, CCTextAlignment hAlignment,
                               CCVerticalTextAlignment vAlignment);



    static CCLabelTTF * createWithFontDefinition(const char *string, ccFontDefinition &textDefinition);


    bool initWithString(const char *string, const char *fontName, float fontSize);


    bool initWithString(const char *string, const char *fontName, float fontSize,
                        const CCSize& dimensions, CCTextAlignment hAlignment);


    bool initWithString(const char *string, const char *fontName, float fontSize,
                        const CCSize& dimensions, CCTextAlignment hAlignment,
                        CCVerticalTextAlignment vAlignment);


    bool initWithStringAndTextDefinition(const char *string, ccFontDefinition &textDefinition);


    void setTextDefinition(ccFontDefinition *theDefinition);


    ccFontDefinition * getTextDefinition();




    void enableShadow(const CCSize &shadowOffset, float shadowOpacity, float shadowBlur, bool mustUpdateTexture = true);


    void disableShadow(bool mustUpdateTexture = true);


    void enableStroke(const ccColor3B &strokeColor, float strokeSize, bool mustUpdateTexture = true);


    void disableStroke(bool mustUpdateTexture = true);


    void setFontFillColor(const ccColor3B &tintColor, bool mustUpdateTexture = true);




    bool init();



    static CCLabelTTF * create();




    virtual void setString(const char *label);
    virtual const char* getString(void);

    CCTextAlignment getHorizontalAlignment();
    void setHorizontalAlignment(CCTextAlignment alignment);

    CCVerticalTextAlignment getVerticalAlignment();
    void setVerticalAlignment(CCVerticalTextAlignment verticalAlignment);

    CCSize getDimensions();
    void setDimensions(const CCSize &dim);

    float getFontSize();
    void setFontSize(float fontSize);

    const char* getFontName();
    void setFontName(const char *fontName);

private:
    bool updateTexture();
protected:


    void _updateWithTextDefinition(ccFontDefinition & textDefinition, bool mustUpdateTexture = true);
    ccFontDefinition _prepareTextDefinition(bool adjustForResolution = false);


    CCSize m_tDimensions;

    CCTextAlignment m_hAlignment;

    CCVerticalTextAlignment m_vAlignment;

    std::string * m_pFontName;

    float m_fFontSize;

    std::string m_string;


    bool m_shadowEnabled;
    CCSize m_shadowOffset;
    float m_shadowOpacity;
    float m_shadowBlur;



    bool m_strokeEnabled;
    ccColor3B m_strokeColor;
    float m_strokeSize;


    ccColor3B m_textFillColor;


};






}
# 101 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h" 1
# 36 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h"
# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h" 1
# 37 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h"
namespace cocos2d {
# 46 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h"
class CCSprite;
# 63 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteBatchNode.h"
class CCSpriteBatchNode : public CCNode, public CCTextureProtocol
{
public:



    CCSpriteBatchNode();




    ~CCSpriteBatchNode();




    inline CCTextureAtlas* getTextureAtlas(void) { return m_pobTextureAtlas; }
    inline void setTextureAtlas(CCTextureAtlas* textureAtlas)
    {
        if (textureAtlas != m_pobTextureAtlas)
        {
            do { if(textureAtlas) { (textureAtlas)->retain(); } } while(0);
            do { if(m_pobTextureAtlas) { (m_pobTextureAtlas)->release(); } } while(0);
            m_pobTextureAtlas = textureAtlas;
        }
    }

    inline CCArray* getDescendants(void) { return m_pobDescendants; }




    static CCSpriteBatchNode* createWithTexture(CCTexture2D* tex, unsigned int capacity);
    static CCSpriteBatchNode* createWithTexture(CCTexture2D* tex) {
        return CCSpriteBatchNode::createWithTexture(tex, 29);
    }





    static CCSpriteBatchNode* create(const char* fileImage, unsigned int capacity);
    static CCSpriteBatchNode* create(const char* fileImage) {
        return CCSpriteBatchNode::create(fileImage, 29);
    }




    bool initWithTexture(CCTexture2D *tex, unsigned int capacity);




    bool initWithFile(const char* fileImage, unsigned int capacity);
    bool init();

    void increaseAtlasCapacity();




    void removeChildAtIndex(unsigned int index, bool doCleanup);

    void insertChild(CCSprite *child, unsigned int index);
    void appendChild(CCSprite* sprite);
    void removeSpriteFromAtlas(CCSprite *sprite);

    unsigned int rebuildIndexInOrder(CCSprite *parent, unsigned int index);
    unsigned int highestAtlasIndexInChild(CCSprite *sprite);
    unsigned int lowestAtlasIndexInChild(CCSprite *sprite);
    unsigned int atlasIndexForChild(CCSprite *sprite, int z);

    void reorderBatch(bool reorder);

    virtual CCTexture2D* getTexture(void);
    virtual void setTexture(CCTexture2D *texture);
    virtual void setBlendFunc(ccBlendFunc blendFunc);



    virtual ccBlendFunc getBlendFunc(void);

    virtual void visit(void);
    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child, int zOrder, int tag);
    virtual void reorderChild(CCNode * child, int zOrder);

    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void removeAllChildrenWithCleanup(bool cleanup);
    virtual void sortAllChildren();
    virtual void draw(void);

protected:




    void insertQuadFromSprite(CCSprite *sprite, unsigned int index);




    void updateQuadFromSprite(CCSprite *sprite, unsigned int index);



    CCSpriteBatchNode * addSpriteWithoutQuad(CCSprite*child, unsigned int z, int aTag);


    bool getManualSortChildren(void)const;
    int getAtlasCapacity(void);
    int getUsedAtlasCapacity(void);
    void increaseAtlasCapacity(unsigned int);
    void manualSortAllChildren(void);
    void setManualSortChildren(bool);

private:
    void updateAtlasIndex(CCSprite* sprite, int* curIndex);
    void swap(int oldIndex, int newIndex);
    void updateBlendFunc();

protected:
    CCTextureAtlas *m_pobTextureAtlas;
    ccBlendFunc m_blendFunc;


    CCArray* m_pobDescendants;

    bool m_bManualSortChildren;
    bool m_bManualSortAllChildren;
};




}
# 37 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h" 2


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 1 3
# 43 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3




namespace std {
# 61 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:





      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 132 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 156 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 208 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   if (__testin)
     this->setg(this->eback(), this->gptr(), this->pptr());
   else
     this->setg(this->pptr(), this->pptr(), this->pptr());
      }
    };
# 265 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 303 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 323 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 345 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 378 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 416 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 436 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 458 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 491 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 527 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 545 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 567 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };

}



# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 1 3
# 44 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 1 3
# 46 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 2 3

namespace std {

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;



}
# 594 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/sstream" 2 3
# 40 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h" 2



namespace cocos2d {
# 52 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h"
enum {
    kCCLabelAutomaticWidth = -1,
};

struct _FontDefHashElement;





typedef struct _BMFontDef {

    unsigned int charID;

    CCRect rect;

    short xOffset;

    short yOffset;

    short xAdvance;
} ccBMFontDef;





typedef struct _BMFontPadding {

    int left;

    int top;

    int right;

    int bottom;
} ccBMFontPadding;

typedef struct _FontDefHashElement
{
 unsigned int key;
 ccBMFontDef fontDef;
 UT_hash_handle hh;
} tCCFontDefHashElement;


typedef struct _KerningHashElement
{
 int key;
 int amount;
 UT_hash_handle hh;
} tCCKerningHashElement;






class CCBMFontConfiguration : public CCObject
{

public:

    tCCFontDefHashElement *m_pFontDefDictionary;


    int m_nCommonHeight;

    ccBMFontPadding m_tPadding;

    std::string m_sAtlasName;

    tCCKerningHashElement *m_pKerningDictionary;


    std::set<unsigned int> *m_pCharacterSet;
public:
    CCBMFontConfiguration();




    virtual ~CCBMFontConfiguration();




    const char * description();


    static CCBMFontConfiguration * create(const char *FNTfile);


    bool initWithFNTfile(const char *FNTfile);

    inline const char* getAtlasName(){ return m_sAtlasName.c_str(); }
    inline void setAtlasName(const char* atlasName) { m_sAtlasName = atlasName; }

    std::set<unsigned int>* getCharacterSet() const;
private:
    std::set<unsigned int>* parseConfigFile(const char *controlFile);
    void parseCharacterDefinition(std::string line, ccBMFontDef *characterDefinition);
    void parseInfoArguments(std::string line);
    void parseCommonArguments(std::string line);
    void parseImageFileName(std::string line, const char *fntFile);
    void parseKerningEntry(std::string line);
    void purgeKerningDictionary();
    void purgeFontDefDictionary();
};
# 192 "Cacao/include/cocos2dx/label_nodes/CCLabelBMFont.h"
class CCLabelBMFont : public CCSpriteBatchNode, public CCLabelProtocol, public CCRGBAProtocol
{
public:



    CCLabelBMFont();




    virtual ~CCLabelBMFont();




    static void purgeCachedData();


    static CCLabelBMFont * create(const char *str, const char *fntFile, float width, CCTextAlignment alignment, CCPoint imageOffset);

 static CCLabelBMFont * create(const char *str, const char *fntFile, float width, CCTextAlignment alignment);

 static CCLabelBMFont * create(const char *str, const char *fntFile, float width);

 static CCLabelBMFont * create(const char *str, const char *fntFile);



    static CCLabelBMFont * create();

    bool init();

    bool initWithString(const char *str, const char *fntFile, float width = kCCLabelAutomaticWidth, CCTextAlignment alignment = kCCTextAlignmentLeft, CCPoint imageOffset = CCPointZero);


    void createFontChars();

    virtual void setString(const char *newString);
    virtual void setString(const char *newString, bool needUpdateLabel);

    virtual const char* getString(void);
    virtual void setCString(const char *label);
    virtual void setAnchorPoint(const CCPoint& var);
    virtual void updateLabel();
    virtual void setAlignment(CCTextAlignment alignment);
    virtual void setWidth(float width);
    virtual void setLineBreakWithoutSpace(bool breakWithoutSpace);
    virtual void setScale(float scale);
    virtual void setScaleX(float scaleX);
    virtual void setScaleY(float scaleY);


    virtual bool isOpacityModifyRGB();
    virtual void setOpacityModifyRGB(bool isOpacityModifyRGB); virtual GLubyte getOpacity();
    virtual GLubyte getDisplayedOpacity();
    virtual void setOpacity(GLubyte opacity);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual bool isCascadeOpacityEnabled();
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);
    virtual const ccColor3B& getColor(void);
    virtual const ccColor3B& getDisplayedColor();
    virtual void setColor(const ccColor3B& color);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual bool isCascadeColorEnabled();
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled);

    void setFntFile(const char* fntFile);
    const char* getFntFile();
 CCBMFontConfiguration* getConfiguration() const;


    static bool createBatched(char const*, char const*, CCArray*);
    bool getIsBatched(void)const;
    CCArray* getTargetArray(void)const;
    void limitLabelWidth(float, float, float);
    void setIsBatched(bool);
    void setTargetArray(CCArray*);




private:
    char * atlasNameFromFntFile(const char *fntFile);
    int kerningAmountForFirst(unsigned short first, unsigned short second);
    float getLetterPosXLeft( CCSprite* characterSprite );
    float getLetterPosXRight( CCSprite* characterSprite );

protected:
    virtual void setString(unsigned short *newString, bool needUpdateLabel);

    unsigned short* m_sString;


    std::string m_sFntFile;






    unsigned short* m_sInitialString;
    std::string m_sInitialStringUTF8;


    CCTextAlignment m_pAlignment;

    float m_fWidth;

    CCBMFontConfiguration *m_pConfiguration;

    bool m_bLineBreakWithoutSpaces;

    CCPoint m_tImageOffset;


    CCSprite *m_pReusedChar;


    GLubyte m_cDisplayedOpacity;
    GLubyte m_cRealOpacity;


    ccColor3B m_tDisplayedColor;
    ccColor3B m_tRealColor;
    bool m_bCascadeColorEnabled;
    bool m_bCascadeOpacityEnabled;

    bool m_bIsOpacityModifyRGB;

    bool m_bIsBatched;
    CCArray* m_pTargetArray;
    uint32_t m_uUnknown;




};



       CCBMFontConfiguration * FNTConfigLoadFile( const char *file );


       void FNTConfigRemoveCache( void );





}
# 102 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 1
# 32 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h" 1
# 32 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h"
namespace cocos2d {

class CCTouch;
class CCEvent;
class CCSet;
class CCTouchDispatcher;
# 46 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h"
class CCTouchDelegate
{
public:

    CCTouchDelegate() {}

    virtual ~CCTouchDelegate()
    {
    }

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent; return false;};


    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}


     virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}

};
# 86 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDelegateProtocol.h"
 class CCTargetedTouchDelegate : public CCTouchDelegate
 {
 public:



     virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent) { (void)pTouch; (void)pEvent;return false;};


     virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
     virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
     virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent) {(void)pTouch; (void)pEvent;}
 };







 class CCStandardTouchDelegate : public CCTouchDelegate
 {
 public:

     virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
     virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
    virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent) {(void)pTouches; (void)pEvent;}
 };




}
# 33 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 2



# 1 "Cacao/include/cocos2dx/custom/Delegates/CCKeyboardDelegate.h" 1




namespace cocos2d {

enum enumKeyCodes {
  KEY_NONE = 0, KEY_PAUSE = 0x0013, KEY_SCROLL_LOCK = 0x1014, KEY_PRINT = 0x1061,
  KEY_SYSREQ = 0x106A, KEY_BREAK = 0x106B, KEY_ESCAPE = 0x001B, KEY_BACKSPACE = 0x0008,
  KEY_TAB = 0x0009, KEY_BACK_TAB = 0x0089, KEY_RETURN = 0x000D, KEY_CAPS_LOCK = 0x00E5,
  KEY_SHIFT = 0x00E1, KEY_CTRL = 0x00E3, KEY_ALT = 0x00E9, KEY_MENU = 0x1067,
  KEY_HYPER = 0x10ED, KEY_INSERT = 0x1063, KEY_HOME = 0x1050, KEY_PG_UP = 0x1055,
  KEY_DELETE = 0x10FF, KEY_END = 0x1057, KEY_PG_DOWN = 0x1056, KEY_LEFT_ARROW = 0x1051,
  KEY_RIGHT_ARROW = 0x1053, KEY_UP_ARROW = 0x1052, KEY_DOWN_ARROW = 0x1054, KEY_NUM_LOCK = 0x107F,
  KEY_KP_PLUS = 0x10AB, KEY_KP_MINUS = 0x10AD, KEY_KP_MULTIPLY = 0x10AA, KEY_KP_DIVIDE = 0x10AF,
  KEY_KP_ENTER = 0x108D, KEY_KP_HOME = 0x10B7, KEY_KP_UP = 0x10B8, KEY_KP_PG_UP = 0x10B9,
  KEY_KP_LEFT = 0x10B4, KEY_KP_FIVE = 0x10B5, KEY_KP_RIGHT = 0x10B6, KEY_KP_END = 0x10B1,
  KEY_KP_DOWN = 0x10B2, KEY_KP_PG_DOWN = 0x10B3, KEY_KP_INSERT = 0x10B0, KEY_KP_DELETE = 0x10AE,
  KEY_F1 = 0x00BE, KEY_F2 = 0x00BF, KEY_F3 = 0x00C0, KEY_F4 = 0x00C1,
  KEY_F5 = 0x00C2, KEY_F6 = 0x00C3, KEY_F7 = 0x00C4, KEY_F8 = 0x00C5,
  KEY_F9 = 0x00C6, KEY_F10 = 0x00C7, KEY_F11 = 0x00C8, KEY_F12 = 0x00C9,
  KEY_SPACE = ' ', KEY_EXCLAM = '!', KEY_QUOTE = '"', KEY_NUMBER = '#',
  KEY_DOLLAR = '$', KEY_PERCENT = '%', KEY_CIRCUMFLEX = '^', KEY_AMPERSAND = '&',
  KEY_APOSTROPHE = '\'', KEY_LEFT_PARENTHESIS = '(', KEY_RIGHT_PARENTHESIS = ')', KEY_ASTERISK = '*',
  KEY_PLUS = '+', KEY_COMMA = ',', KEY_MINUS = '-', KEY_PERIOD = '.',
  KEY_SLASH = '/', KEY_0 = '0', KEY_1 = '1', KEY_2 = '2',
  KEY_3 = '3', KEY_4 = '4', KEY_5 = '5', KEY_6 = '6',
  KEY_7 = '7', KEY_8 = '8', KEY_9 = '9', KEY_COLON = ':',
  KEY_SEMICOLON = ';', KEY_LESS_THAN = '<', KEY_EQUAL = '=', KEY_GREATER_THAN = '>',
  KEY_QUESTION = '?', KEY_AT = '@', KEY_CAPITAL_A = 'A', KEY_CAPITAL_B = 'B',
  KEY_CAPITAL_C = 'C', KEY_CAPITAL_D = 'D', KEY_CAPITAL_E = 'E', KEY_CAPITAL_F = 'F',
  KEY_CAPITAL_G = 'G', KEY_CAPITAL_H = 'H', KEY_CAPITAL_I = 'I', KEY_CAPITAL_J = 'J',
  KEY_CAPITAL_K = 'K', KEY_CAPITAL_L = 'L', KEY_CAPITAL_M = 'M', KEY_CAPITAL_N = 'N',
  KEY_CAPITAL_O = 'O', KEY_CAPITAL_P = 'P', KEY_CAPITAL_Q = 'Q', KEY_CAPITAL_R = 'R',
  KEY_CAPITAL_S = 'S', KEY_CAPITAL_T = 'T', KEY_CAPITAL_U = 'U', KEY_CAPITAL_V = 'V',
  KEY_CAPITAL_W = 'W', KEY_CAPITAL_X = 'X', KEY_CAPITAL_Y = 'Y', KEY_CAPITAL_Z = 'Z',
  KEY_LEFT_BRACKET = '[', KEY_BACK_SLASH = '\\', KEY_RIGHT_BRACKET = ']', KEY_UNDERSCORE = '_',
  KEY_GRAVE = '`', KEY_A = 'a', KEY_B = 'b', KEY_C = 'c',
  KEY_D = 'd', KEY_E = 'e', KEY_F = 'f', KEY_G = 'g',
  KEY_H = 'h', KEY_I = 'i', KEY_J = 'j', KEY_K = 'k',
  KEY_L = 'l', KEY_M = 'm', KEY_N = 'n', KEY_O = 'o',
  KEY_P = 'p', KEY_Q = 'q', KEY_R = 'r', KEY_S = 's',
  KEY_T = 't', KEY_U = 'u', KEY_V = 'v', KEY_W = 'w',
  KEY_X = 'x', KEY_Y = 'y', KEY_Z = 'z', KEY_LEFT_BRACE = '{',
  KEY_BAR = '|', KEY_RIGHT_BRACE = '}', KEY_TILDE = '~', KEY_EURO = 0x20AC,
  KEY_POUND = 0x00A3, KEY_YEN = 0x00A5, KEY_MIDDLE_DOT = 0x0095, KEY_SEARCH = 0xFFAA
};
class CCKeyboardDelegate {
public:
 virtual void keyDown(enumKeyCodes);
 virtual void keyUp(enumKeyCodes);
};

}
# 37 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 2
# 1 "Cacao/include/cocos2dx/custom/Delegates/CCMouseDelegate.h" 1




namespace cocos2d {

class CCMouseDelegate {
public:
 virtual void rightKeyDown(void);
 virtual void rightKeyUp(void);
 virtual void scrollWheel(float, float);
};

}
# 38 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h" 2




namespace cocos2d {

typedef enum {
 kCCTouchesAllAtOnce,
 kCCTouchesOneByOne,
} ccTouchesMode;






class CCTouchScriptHandlerEntry;
# 65 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayer : public CCNode, public CCTouchDelegate, public CCAccelerometerDelegate, public CCKeypadDelegate,
    public CCKeyboardDelegate, public CCMouseDelegate
{
public:



    CCLayer();




    virtual ~CCLayer();
    virtual bool init();


    static CCLayer *create(void);




    virtual void onEnter();




    virtual void onExit();




    virtual void onEnterTransitionDidFinish();


    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);


    virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent);




    virtual void didAccelerate(CCAcceleration* pAccelerationValue);
    void registerScriptAccelerateHandler(int nHandler);
    void unregisterScriptAccelerateHandler(void);
# 127 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
    virtual void registerWithTouchDispatcher(void);


    virtual void registerScriptTouchHandler(int nHandler, bool bIsMultiTouches = false, int nPriority = (-2147483647-1), bool bSwallowsTouches = false);

    virtual void unregisterScriptTouchHandler(void);






    virtual bool isTouchEnabled();
    virtual void setTouchEnabled(bool value);

    virtual void setTouchMode(ccTouchesMode mode);
    virtual int getTouchMode();


    virtual void setTouchPriority(int priority);
    virtual int getTouchPriority();





    virtual bool isAccelerometerEnabled();
    virtual void setAccelerometerEnabled(bool value);
    virtual void setAccelerometerInterval(double interval);





    virtual bool isKeypadEnabled();
    virtual void setKeypadEnabled(bool value);


    virtual bool isKeyboardEnabled();
    virtual void setKeyboardEnabled(bool value);
    virtual bool isMouseEnabled();
    virtual void setMouseEnabled(bool value);


    void registerScriptKeypadHandler(int nHandler);

    void unregisterScriptKeypadHandler(void);

    virtual void keyBackClicked(void);
    virtual void keyMenuClicked(void);


    virtual void keyDown(enumKeyCodes key);

    inline CCTouchScriptHandlerEntry* getScriptTouchHandlerEntry() { return m_pScriptTouchHandlerEntry; };
    inline CCScriptHandlerEntry* getScriptKeypadHandlerEntry() { return m_pScriptKeypadHandlerEntry; };
    inline CCScriptHandlerEntry* getScriptAccelerateHandlerEntry() { return m_pScriptAccelerateHandlerEntry; };
protected:
    bool m_bTouchEnabled;
    bool m_bAccelerometerEnabled;
    bool m_bKeypadEnabled;
    bool m_bKeyboardEnabled;
    bool m_bMouseEnabled;

private:

    CCTouchScriptHandlerEntry* m_pScriptTouchHandlerEntry;
    CCScriptHandlerEntry* m_pScriptKeypadHandlerEntry;
    CCScriptHandlerEntry* m_pScriptAccelerateHandlerEntry;

    int m_nTouchPriority;
    ccTouchesMode m_eTouchMode;

    int excuteScriptTouchHandler(int nEventType, CCTouch *pTouch);
    int excuteScriptTouchHandler(int nEventType, CCSet *pTouches);
};
# 216 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayerRGBA : public CCLayer, public CCRGBAProtocol
{
public:
    static CCLayerRGBA* create() { CCLayerRGBA *pRet = new CCLayerRGBA(); if (pRet && pRet->init()) { pRet->autorelease(); return pRet; } else { delete pRet; pRet = __null; return __null; } };



    CCLayerRGBA();




    virtual ~CCLayerRGBA();

    virtual bool init();

    virtual GLubyte getOpacity();
    virtual GLubyte getDisplayedOpacity();
    virtual void setOpacity(GLubyte opacity);
    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual bool isCascadeOpacityEnabled();
    virtual void setCascadeOpacityEnabled(bool cascadeOpacityEnabled);

    virtual const ccColor3B& getColor();
    virtual const ccColor3B& getDisplayedColor();
    virtual void setColor(const ccColor3B& color);
    virtual void updateDisplayedColor(const ccColor3B& parentColor);
    virtual bool isCascadeColorEnabled();
    virtual void setCascadeColorEnabled(bool cascadeColorEnabled);

    virtual void setOpacityModifyRGB(bool bValue) {(void)bValue;}
    virtual bool isOpacityModifyRGB() { return false; }
protected:
 GLubyte _displayedOpacity, _realOpacity;
 ccColor3B _displayedColor, _realColor;
 bool _cascadeOpacityEnabled, _cascadeColorEnabled;
};
# 263 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayerColor : public CCLayerRGBA, public CCBlendProtocol



{
protected:
    ccVertex2F m_pSquareVertices[4];
    ccColor4F m_pSquareColors[4];

public:



    CCLayerColor();




    virtual ~CCLayerColor();

    virtual void draw();
    virtual void setContentSize(const CCSize & var);

    static CCLayerColor* create();


    static CCLayerColor * create(const ccColor4B& color, GLfloat width, GLfloat height);

    static CCLayerColor * create(const ccColor4B& color);

    virtual bool init();

    virtual bool initWithColor(const ccColor4B& color, GLfloat width, GLfloat height);

    virtual bool initWithColor(const ccColor4B& color);


    void changeWidth(GLfloat w);

    void changeHeight(GLfloat h);



    void changeWidthAndHeight(GLfloat w ,GLfloat h);


    protected: ccBlendFunc m_tBlendFunc;public: virtual ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(ccBlendFunc var);

    virtual void setColor(const ccColor3B &color);
    virtual void setOpacity(GLubyte opacity);

protected:
    virtual void updateColor();
};
# 340 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
class CCLayerGradient : public CCLayerColor
{
public:


    static CCLayerGradient* create(const ccColor4B& start, const ccColor4B& end);


    static CCLayerGradient* create(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);

    virtual bool init();



    virtual bool initWithColor(const ccColor4B& start, const ccColor4B& end);




    virtual bool initWithColor(const ccColor4B& start, const ccColor4B& end, const CCPoint& v);

    protected: ccColor3B m_startColor;public: virtual const ccColor3B& getStartColor(void);public: virtual void setStartColor(const ccColor3B& var);
    protected: ccColor3B m_endColor;public: virtual const ccColor3B& getEndColor(void);public: virtual void setEndColor(const ccColor3B& var);
    protected: GLubyte m_cStartOpacity;public: virtual GLubyte getStartOpacity(void);public: virtual void setStartOpacity(GLubyte var);
    protected: GLubyte m_cEndOpacity;public: virtual GLubyte getEndOpacity(void);public: virtual void setEndOpacity(GLubyte var);
    protected: CCPoint m_AlongVector;public: virtual const CCPoint& getVector(void);public: virtual void setVector(const CCPoint& var);




protected:
    bool m_bCompressedInterpolation;
public:
    virtual void setCompressedInterpolation(bool bCompressedInterpolation);
    virtual bool isCompressedInterpolation();

    static CCLayerGradient* create();

protected:
    virtual void updateColor();
};







class CCLayerMultiplex : public CCLayer
{
protected:
    unsigned int m_nEnabledLayer;
    CCArray* m_pLayers;
public:




    CCLayerMultiplex();




    virtual ~CCLayerMultiplex();



    static CCLayerMultiplex* create();





    static CCLayerMultiplex* createWithArray(CCArray* arrayOfLayers);




    static CCLayerMultiplex * create(CCLayer* layer, ... );





    static CCLayerMultiplex * createWithLayer(CCLayer* layer);

    void addLayer(CCLayer* layer);





    bool initWithLayers(CCLayer* layer, va_list params);
# 441 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h"
    bool initWithArray(CCArray* arrayOfLayers);

    void switchTo(unsigned int n);



    void switchToAndReleaseMe(unsigned int n);
};





}
# 105 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCScene.h" 1
# 32 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCScene.h"
namespace cocos2d {
# 49 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCScene.h"
class CCScene : public CCNode
{
public:



    CCScene();




    virtual ~CCScene();
    bool init();

    static CCScene *create(void);
};




}
# 106 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransition.h" 1
# 33 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransition.h"
namespace cocos2d {
# 44 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransition.h"
class CCActionInterval;
class CCNode;




class CCTransitionEaseScene
{
public:



    virtual CCActionInterval * easeActionWithAction(CCActionInterval * action) = 0;
};



typedef enum {

 kCCTransitionOrientationLeftOver = 0,

 kCCTransitionOrientationRightOver = 1,

 kCCTransitionOrientationUpOver = 0,

 kCCTransitionOrientationDownOver = 1,






} tOrientation;



class CCTransitionScene : public CCScene
{

protected:
    CCScene * m_pInScene;
    CCScene * m_pOutScene;
    float m_fDuration;
    bool m_bIsInSceneOnTop;
    bool m_bIsSendCleanupToScene;

public:



    CCTransitionScene();




    virtual ~CCTransitionScene();
    virtual void draw();




    virtual void onEnter();




    virtual void onExit();
    virtual void cleanup();


    static CCTransitionScene * create(float t, CCScene *scene);


    virtual bool initWithDuration(float t,CCScene* scene);


    void finish(void);


    void hideOutShowIn(void);

protected:
    virtual void sceneOrder();
private:
    void setNewScene(float dt);

};




class CCTransitionSceneOriented : public CCTransitionScene
{
protected:
    tOrientation m_eOrientation;

public:



    CCTransitionSceneOriented();




    virtual ~CCTransitionSceneOriented();


    static CCTransitionSceneOriented * create(float t,CCScene* scene, tOrientation orientation);


    virtual bool initWithDuration(float t,CCScene* scene,tOrientation orientation);
};




class CCTransitionRotoZoom : public CCTransitionScene
{
public:



    CCTransitionRotoZoom();




    virtual ~CCTransitionRotoZoom();




    virtual void onEnter();

    static CCTransitionRotoZoom* create(float t, CCScene* scene);
};




class CCTransitionJumpZoom : public CCTransitionScene
{
public:



    CCTransitionJumpZoom();




    virtual ~CCTransitionJumpZoom();




    virtual void onEnter();

    static CCTransitionJumpZoom* create(float t, CCScene* scene);
};




class CCTransitionMoveInL : public CCTransitionScene, public CCTransitionEaseScene
{
public:



    CCTransitionMoveInL();




    virtual ~CCTransitionMoveInL();

    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);




    virtual void onEnter();

    static CCTransitionMoveInL* create(float t, CCScene* scene);
};




class CCTransitionMoveInR : public CCTransitionMoveInL
{
public:



    CCTransitionMoveInR();




    virtual ~CCTransitionMoveInR();
    virtual void initScenes();

    static CCTransitionMoveInR* create(float t, CCScene* scene);
};




class CCTransitionMoveInT : public CCTransitionMoveInL
{
public:



    CCTransitionMoveInT();




    virtual ~CCTransitionMoveInT();
    virtual void initScenes();

    static CCTransitionMoveInT* create(float t, CCScene* scene);
};




class CCTransitionMoveInB : public CCTransitionMoveInL
{
public:



    CCTransitionMoveInB();




    virtual ~CCTransitionMoveInB();
    virtual void initScenes();

    static CCTransitionMoveInB* create(float t, CCScene* scene);
};




class CCTransitionSlideInL : public CCTransitionScene, public CCTransitionEaseScene
{
public:



    CCTransitionSlideInL();




    virtual ~CCTransitionSlideInL();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);




    virtual void onEnter();

    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);

    static CCTransitionSlideInL* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSlideInR : public CCTransitionSlideInL
{
public:



    CCTransitionSlideInR();




    virtual ~CCTransitionSlideInR();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    static CCTransitionSlideInR* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSlideInB : public CCTransitionSlideInL
{
public:



    CCTransitionSlideInB();




    virtual ~CCTransitionSlideInB();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    static CCTransitionSlideInB* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSlideInT : public CCTransitionSlideInL
{
public:



    CCTransitionSlideInT();




    virtual ~CCTransitionSlideInT();


    virtual void initScenes(void);

    virtual CCActionInterval* action(void);

    static CCTransitionSlideInT* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionShrinkGrow : public CCTransitionScene , public CCTransitionEaseScene
{
public:



    CCTransitionShrinkGrow();




    virtual ~CCTransitionShrinkGrow();




    virtual void onEnter();
    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);

    static CCTransitionShrinkGrow* create(float t, CCScene* scene);
};





class CCTransitionFlipX : public CCTransitionSceneOriented
{
public:



    CCTransitionFlipX();




    virtual ~CCTransitionFlipX();




    virtual void onEnter();

    static CCTransitionFlipX* create(float t, CCScene* s, tOrientation o);
    static CCTransitionFlipX* create(float t, CCScene* s);
};





class CCTransitionFlipY : public CCTransitionSceneOriented
{
public:



    CCTransitionFlipY();




    virtual ~CCTransitionFlipY();




    virtual void onEnter();

    static CCTransitionFlipY* create(float t, CCScene* s, tOrientation o);
    static CCTransitionFlipY* create(float t, CCScene* s);
};





class CCTransitionFlipAngular : public CCTransitionSceneOriented
{
public:



    CCTransitionFlipAngular();




    virtual ~CCTransitionFlipAngular();




    virtual void onEnter();

    static CCTransitionFlipAngular* create(float t, CCScene* s, tOrientation o);
    static CCTransitionFlipAngular* create(float t, CCScene* s);
};





class CCTransitionZoomFlipX : public CCTransitionSceneOriented
{
public:



    CCTransitionZoomFlipX();




    virtual ~CCTransitionZoomFlipX();




    virtual void onEnter();

    static CCTransitionZoomFlipX* create(float t, CCScene* s, tOrientation o);
    static CCTransitionZoomFlipX* create(float t, CCScene* s);
};





class CCTransitionZoomFlipY : public CCTransitionSceneOriented
{
public:



    CCTransitionZoomFlipY();




    virtual ~CCTransitionZoomFlipY();




    virtual void onEnter();

    static CCTransitionZoomFlipY* create(float t, CCScene* s, tOrientation o);
    static CCTransitionZoomFlipY* create(float t, CCScene* s);
};





class CCTransitionZoomFlipAngular : public CCTransitionSceneOriented
{
public:



    CCTransitionZoomFlipAngular();




    virtual ~CCTransitionZoomFlipAngular();




    virtual void onEnter();

    static CCTransitionZoomFlipAngular* create(float t, CCScene* s, tOrientation o);
    static CCTransitionZoomFlipAngular* create(float t, CCScene* s);
};




class CCTransitionFade : public CCTransitionScene
{
protected:
    ccColor4B m_tColor;

public:



    CCTransitionFade();




    virtual ~CCTransitionFade();




    static CCTransitionFade* create(float duration,CCScene* scene, const ccColor3B& color);
    static CCTransitionFade* create(float duration,CCScene* scene);


    virtual bool initWithDuration(float t, CCScene*scene ,const ccColor3B& color);

    virtual bool initWithDuration(float t,CCScene* scene);




    virtual void onEnter();




    virtual void onExit();
};

class CCRenderTexture;




class CCTransitionCrossFade : public CCTransitionScene
{
public :



    CCTransitionCrossFade();




    virtual ~CCTransitionCrossFade();

    virtual void draw();




    virtual void onEnter();




    virtual void onExit();

public:
    static CCTransitionCrossFade* create(float t, CCScene* scene);
};




class CCTransitionTurnOffTiles : public CCTransitionScene ,public CCTransitionEaseScene
{
public :



    CCTransitionTurnOffTiles();




    virtual ~CCTransitionTurnOffTiles();




    virtual void onEnter();
    virtual CCActionInterval * easeActionWithAction(CCActionInterval * action);

public:
    static CCTransitionTurnOffTiles* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionSplitCols : public CCTransitionScene , public CCTransitionEaseScene
{
public:



    CCTransitionSplitCols();




    virtual ~CCTransitionSplitCols();

    virtual CCActionInterval* action(void);




    virtual void onEnter();
    virtual CCActionInterval * easeActionWithAction(CCActionInterval * action);

public:

    static CCTransitionSplitCols* create(float t, CCScene* scene);
};




class CCTransitionSplitRows : public CCTransitionSplitCols
{
public:



    CCTransitionSplitRows();




    virtual ~CCTransitionSplitRows();

    virtual CCActionInterval* action(void);

public:

    static CCTransitionSplitRows* create(float t, CCScene* scene);
};




class CCTransitionFadeTR : public CCTransitionScene , public CCTransitionEaseScene
{
public:



    CCTransitionFadeTR();




    virtual ~CCTransitionFadeTR();
    virtual CCActionInterval* actionWithSize(const CCSize& size);




    virtual void onEnter();
    virtual CCActionInterval* easeActionWithAction(CCActionInterval * action);

public:

    static CCTransitionFadeTR* create(float t, CCScene* scene);
protected:
    virtual void sceneOrder();
};




class CCTransitionFadeBL : public CCTransitionFadeTR
{
public:



    CCTransitionFadeBL();




    virtual ~CCTransitionFadeBL();
    virtual CCActionInterval* actionWithSize(const CCSize& size);

public:

    static CCTransitionFadeBL* create(float t, CCScene* scene);
};




class CCTransitionFadeUp : public CCTransitionFadeTR
{
public:



    CCTransitionFadeUp();




    virtual ~CCTransitionFadeUp();
    virtual CCActionInterval* actionWithSize(const CCSize& size);

public:

    static CCTransitionFadeUp* create(float t, CCScene* scene);
};




class CCTransitionFadeDown : public CCTransitionFadeTR
{
public:



    CCTransitionFadeDown();




    virtual ~CCTransitionFadeDown();
    virtual CCActionInterval* actionWithSize(const CCSize& size);

public:

    static CCTransitionFadeDown* create(float t, CCScene* scene);
};




}
# 107 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionPageTurn.h" 1
# 31 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionPageTurn.h"
namespace cocos2d {
# 49 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionPageTurn.h"
class CCTransitionPageTurn : public CCTransitionScene
{
protected:
    bool m_bBack;

public:



    CCTransitionPageTurn();




    virtual ~CCTransitionPageTurn();






    static CCTransitionPageTurn* create(float t,CCScene* scene,bool backwards);






    virtual bool initWithDuration(float t,CCScene* scene,bool backwards);

    CCActionInterval* actionWithSize(const CCSize& vector);




    virtual void onEnter();

protected:
    virtual void sceneOrder();
};




}
# 108 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionProgress.h" 1
# 32 "Cacao/include/cocos2dx/layers_scenes_transitions_nodes/CCTransitionProgress.h"
namespace cocos2d {

class CCProgressTimer;
class CCRenderTexture;






class CCTransitionProgress : public CCTransitionScene
{
public:
    static CCTransitionProgress* create(float t, CCScene* scene);



    CCTransitionProgress();




    virtual void onEnter();




    virtual void onExit();
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);
    virtual void setupTransition();
    virtual void sceneOrder();
    float m_fTo;
    float m_fFrom;
    CCScene* m_pSceneToBeModified;
};





class CCTransitionProgressRadialCCW : public CCTransitionProgress
{
public:
    static CCTransitionProgressRadialCCW* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};





class CCTransitionProgressRadialCW : public CCTransitionProgress
{
public:
    static CCTransitionProgressRadialCW* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};




class CCTransitionProgressHorizontal : public CCTransitionProgress
{
public:

    static CCTransitionProgressHorizontal* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};

class CCTransitionProgressVertical : public CCTransitionProgress
{
public:

    static CCTransitionProgressVertical* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};

class CCTransitionProgressInOut : public CCTransitionProgress
{
public:

    static CCTransitionProgressInOut* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);
    virtual void sceneOrder();
    virtual void setupTransition();
};

class CCTransitionProgressOutIn : public CCTransitionProgress
{
public:

    static CCTransitionProgressOutIn* create(float t, CCScene* scene);
protected:
    virtual CCProgressTimer* progressTimerNodeWithRenderTexture(CCRenderTexture* texture);

};




}
# 109 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h" 1
# 28 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h"
# 1 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h" 1
# 34 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
namespace cocos2d {

class CCLabelTTF;
class CCLabelAtlas;
class CCSprite;
class CCSpriteFrame;
# 53 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItem : public CCNodeRGBA
{
protected:



    bool m_bSelected;
    bool m_bEnabled;

public:



    CCMenuItem()
    : m_bSelected(false)
    , m_bEnabled(false)
    , m_pListener(__null)
    , m_pfnSelector(__null)
    , m_nScriptTapHandler(0)
    {}




    virtual ~CCMenuItem();





    static CCMenuItem* create();

    static CCMenuItem* create(CCObject *rec, SEL_MenuHandler selector);



    bool initWithTarget(CCObject *rec, SEL_MenuHandler selector);

    CCRect rect();

    virtual void activate();

    virtual void selected();

    virtual void unselected();


    virtual void registerScriptTapHandler(int nHandler);
    virtual void unregisterScriptTapHandler(void);
    int getScriptTapHandler() { return m_nScriptTapHandler; };

    virtual bool isEnabled();

    virtual void setEnabled(bool value);
    virtual bool isSelected();


    void setTarget(CCObject *rec, SEL_MenuHandler selector);

protected:
    CCObject* m_pListener;
    SEL_MenuHandler m_pfnSelector;
    int m_nScriptTapHandler;
};
# 125 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItemLabel : public CCMenuItem
{

    protected: ccColor3B m_tDisabledColor;public: virtual const ccColor3B& getDisabledColor(void);public: virtual void setDisabledColor(const ccColor3B& var);;

    protected: CCNode* m_pLabel;public: virtual CCNode* getLabel(void);public: virtual void setLabel(CCNode* var);;
public:



    CCMenuItemLabel()
    : m_pLabel(__null)
    , m_fOriginalScale(0.0)
    {}




    virtual ~CCMenuItemLabel();




    static CCMenuItemLabel * create(CCNode*label, CCObject* target, SEL_MenuHandler selector);

    static CCMenuItemLabel* create(CCNode *label);


    bool initWithLabel(CCNode* label, CCObject* target, SEL_MenuHandler selector);

    void setString(const char * label);

    virtual void activate();
    virtual void selected();
    virtual void unselected();



    virtual void setEnabled(bool enabled);

protected:
    ccColor3B m_tColorBackup;
    float m_fOriginalScale;
};





class CCMenuItemAtlasFont : public CCMenuItemLabel
{
public:



    CCMenuItemAtlasFont(){}




    virtual ~CCMenuItemAtlasFont(){}


    static CCMenuItemAtlasFont* create(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap);



    static CCMenuItemAtlasFont* create(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap, CCObject* target, SEL_MenuHandler selector);

    bool initWithString(const char *value, const char *charMapFile, int itemWidth, int itemHeight, char startCharMap, CCObject* target, SEL_MenuHandler selector);
};





class CCMenuItemFont : public CCMenuItemLabel
{
public:



    CCMenuItemFont() : m_uFontSize(0), m_strFontName(""){}




    virtual ~CCMenuItemFont(){}

    static void setFontSize(unsigned int s);

    static unsigned int fontSize();

    static void setFontName(const char *name);

    static const char *fontName();


    static CCMenuItemFont * create(const char *value);



    static CCMenuItemFont * create(const char *value, CCObject* target, SEL_MenuHandler selector);


    bool initWithString(const char *value, CCObject* target, SEL_MenuHandler selector);






    void setFontSizeObj(unsigned int s);




    unsigned int fontSizeObj();






    void setFontNameObj(const char* name);



    const char* fontNameObj();

protected:
    void recreateLabel();

    unsigned int m_uFontSize;
    std::string m_strFontName;
};
# 271 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItemSprite : public CCMenuItem
{

    protected: CCNode* m_pNormalImage;public: virtual CCNode* getNormalImage(void);public: virtual void setNormalImage(CCNode* var);;

    protected: CCNode* m_pSelectedImage;public: virtual CCNode* getSelectedImage(void);public: virtual void setSelectedImage(CCNode* var);;

    protected: CCNode* m_pDisabledImage;public: virtual CCNode* getDisabledImage(void);public: virtual void setDisabledImage(CCNode* var);;
public:



    CCMenuItemSprite()
    :m_pNormalImage(__null)
    ,m_pSelectedImage(__null)
    ,m_pDisabledImage(__null)
    {}


    static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite = __null);



    static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCObject* target, SEL_MenuHandler selector);



    static CCMenuItemSprite * create(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite, CCObject* target, SEL_MenuHandler selector);


    bool initWithNormalSprite(CCNode* normalSprite, CCNode* selectedSprite, CCNode* disabledSprite, CCObject* target, SEL_MenuHandler selector);




    virtual void selected();
    virtual void unselected();
    virtual void setEnabled(bool bEnabled);

protected:
    virtual void updateImagesVisibility();
};
# 323 "Cacao/include/cocos2dx/menu_nodes/CCMenuItem.h"
class CCMenuItemImage : public CCMenuItemSprite
{
public:




    CCMenuItemImage(){}




    virtual ~CCMenuItemImage(){}


    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage);

    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, const char *disabledImage);



    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, CCObject* target, SEL_MenuHandler selector);



    static CCMenuItemImage* create(const char *normalImage, const char *selectedImage, const char *disabledImage, CCObject* target, SEL_MenuHandler selector);

    bool init();

    bool initWithNormalImage(const char *normalImage, const char *selectedImage, const char *disabledImage, CCObject* target, SEL_MenuHandler selector);

    void setNormalSpriteFrame(CCSpriteFrame* frame);

    void setSelectedSpriteFrame(CCSpriteFrame* frame);

    void setDisabledSpriteFrame(CCSpriteFrame* frame);




    static CCMenuItemImage* create();
};






class CCMenuItemToggle : public CCMenuItem
{

    protected: unsigned int m_uSelectedIndex;public: virtual unsigned int getSelectedIndex(void);public: virtual void setSelectedIndex(unsigned int var);;



    protected: CCArray* m_pSubItems;public: virtual CCArray* getSubItems(void);public: virtual void setSubItems(CCArray* var);;
public:



    CCMenuItemToggle()
    : m_uSelectedIndex(0)
    , m_pSubItems(__null)
    {}




    virtual ~CCMenuItemToggle();


    static CCMenuItemToggle * createWithTarget(CCObject* target, SEL_MenuHandler selector, CCArray* menuItems);


    static CCMenuItemToggle* createWithTarget(CCObject* target, SEL_MenuHandler selector, CCMenuItem* item, ...);





    static CCMenuItemToggle* create();


    bool initWithTarget(CCObject* target, SEL_MenuHandler selector, CCMenuItem* item, va_list args);


    static CCMenuItemToggle* create(CCMenuItem *item);


    bool initWithItem(CCMenuItem *item);

    void addSubItem(CCMenuItem *item);


    CCMenuItem* selectedItem();

    virtual void activate();
    virtual void selected();
    virtual void unselected();
    virtual void setEnabled(bool var);

};






}
# 29 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h" 2


namespace cocos2d {







typedef enum
{
    kCCMenuStateWaiting,
    kCCMenuStateTrackingTouch
} tCCMenuState;

enum {

    kCCMenuHandlerPriority = -128,
};







class CCMenu : public CCLayerRGBA
{

    bool m_bEnabled;

public:



    CCMenu() : m_pSelectedItem(__null) {}




    virtual ~CCMenu(){}


    static CCMenu* create();




    static CCMenu* create(CCMenuItem* item, ...);




    static CCMenu* createWithArray(CCArray* pArrayOfItems);






    static CCMenu* createWithItem(CCMenuItem* item);





    static CCMenu* createWithItems(CCMenuItem *firstItem, va_list args);


    bool init();




    bool initWithArray(CCArray* pArrayOfItems);


    void alignItemsVertically();



    void alignItemsVerticallyWithPadding(float padding);


    void alignItemsHorizontally();



    void alignItemsHorizontallyWithPadding(float padding);
# 127 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h"
    void alignItemsInColumns(unsigned int columns, ...);




    void alignItemsInColumns(unsigned int columns, va_list args);



    void alignItemsInColumnsWithArray(CCArray* rows);
# 145 "Cacao/include/cocos2dx/menu_nodes/CCMenu.h"
    void alignItemsInRows(unsigned int rows, ...);




    void alignItemsInRows(unsigned int rows, va_list args);



    void alignItemsInRowsWithArray(CCArray* columns);


    void setHandlerPriority(int newPriority);


    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child, int zOrder, int tag);
    virtual void registerWithTouchDispatcher();
    virtual void removeChild(CCNode* child, bool cleanup);




    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* event);
    virtual void ccTouchEnded(CCTouch* touch, CCEvent* event);
    virtual void ccTouchCancelled(CCTouch *touch, CCEvent* event);
    virtual void ccTouchMoved(CCTouch* touch, CCEvent* event);







    virtual void onExit();

    virtual void setOpacityModifyRGB(bool bValue) {(void)bValue;}
    virtual bool isOpacityModifyRGB(void) { return false;}

    virtual bool isEnabled() { return m_bEnabled; }
    virtual void setEnabled(bool value) { m_bEnabled = value; };

protected:
    CCMenuItem* itemForTouch(CCTouch * touch);
    tCCMenuState m_eState;
    CCMenuItem *m_pSelectedItem;
};





}
# 112 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/misc_nodes/CCClippingNode.h" 1
# 34 "Cacao/include/cocos2dx/misc_nodes/CCClippingNode.h"
namespace cocos2d {






class CCClippingNode : public CCNode
{
protected:
    CCNode* m_pStencil;
    GLfloat m_fAlphaThreshold;
    bool m_bInverted;

public:


    static CCClippingNode* create();




    static CCClippingNode* create(CCNode *pStencil);




    virtual ~CCClippingNode();



    virtual bool init();




    virtual bool init(CCNode *pStencil);




    virtual void onEnter();




    virtual void onEnterTransitionDidFinish();




    virtual void onExitTransitionDidStart();




    virtual void onExit();
    virtual void visit();





    CCNode* getStencil() const;
    void setStencil(CCNode *pStencil);






    GLfloat getAlphaThreshold() const;
    void setAlphaThreshold(GLfloat fAlphaThreshold);





    bool isInverted() const;
    void setInverted(bool bInverted);

protected:
    CCClippingNode();
};

}
# 116 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/misc_nodes/CCMotionStreak.h" 1
# 36 "Cacao/include/cocos2dx/misc_nodes/CCMotionStreak.h"
namespace cocos2d {
# 46 "Cacao/include/cocos2dx/misc_nodes/CCMotionStreak.h"
class CCMotionStreak : public CCNodeRGBA, public CCTextureProtocol



{
public:



    CCMotionStreak();




    virtual ~CCMotionStreak();


    static CCMotionStreak* create(float fade, float minSeg, float stroke, const ccColor3B& color, const char* path);

    static CCMotionStreak* create(float fade, float minSeg, float stroke, const ccColor3B& color, CCTexture2D* texture);


    bool initWithFade(float fade, float minSeg, float stroke, const ccColor3B& color, const char* path);

    bool initWithFade(float fade, float minSeg, float stroke, const ccColor3B& color, CCTexture2D* texture);


    void tintWithColor(ccColor3B colors);


    void reset();


    virtual void setPosition(const CCPoint& position);
    virtual void draw();
    virtual void update(float delta);


    virtual CCTexture2D* getTexture(void);
    virtual void setTexture(CCTexture2D *texture);



    virtual void setBlendFunc(ccBlendFunc blendFunc);



    virtual ccBlendFunc getBlendFunc(void);
    virtual GLubyte getOpacity(void);
    virtual void setOpacity(GLubyte opacity);
    virtual void setOpacityModifyRGB(bool bValue);
    virtual bool isOpacityModifyRGB(void);


    inline bool isFastMode() { return m_bFastMode; }
    inline void setFastMode(bool bFastMode) { m_bFastMode = bFastMode; }

    inline bool isStartingPositionInitialized() { return m_bStartingPositionInitialized; }
    inline void setStartingPositionInitialized(bool bStartingPositionInitialized)
    {
        m_bStartingPositionInitialized = bStartingPositionInitialized;
    }
protected:
    bool m_bFastMode;
    bool m_bStartingPositionInitialized;
private:

    CCTexture2D* m_pTexture;
    ccBlendFunc m_tBlendFunc;
    CCPoint m_tPositionR;

    float m_fStroke;
    float m_fFadeDelta;
    float m_fMinSeg;

    unsigned int m_uMaxPoints;
    unsigned int m_uNuPoints;
    unsigned int m_uPreviousNuPoints;


    CCPoint* m_pPointVertexes;
    float* m_pPointState;


    ccVertex2F* m_pVertices;
    GLubyte* m_pColorPointer;
    ccTex2F* m_pTexCoords;
};




}
# 117 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h" 1
# 33 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
namespace cocos2d {
# 43 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
typedef enum {

    kCCProgressTimerTypeRadial,

    kCCProgressTimerTypeBar,
} CCProgressTimerType;







class CCProgressTimer : public CCNodeRGBA



{
public:



    CCProgressTimer();




    ~CCProgressTimer(void);


    inline CCProgressTimerType getType(void) { return m_eType; }


    inline float getPercentage(void) {return m_fPercentage; }


    inline CCSprite* getSprite(void) { return m_pSprite; }


    bool initWithSprite(CCSprite* sp);

    void setPercentage(float fPercentage);
    void setSprite(CCSprite *pSprite);
    void setType(CCProgressTimerType type);



    void setReverseProgress(bool reverse);

    virtual void draw(void);
    void setAnchorPoint(CCPoint anchorPoint);

    virtual void setColor(const ccColor3B& color);
    virtual const ccColor3B& getColor() const;
    virtual GLubyte getOpacity() const;
    virtual void setOpacity(GLubyte opacity);

    inline bool isReverseDirection() { return m_bReverseDirection; };
    inline void setReverseDirection(bool value) { m_bReverseDirection = value; };

public:

    static CCProgressTimer* create(CCSprite* sp);


    void updateColor(void);

protected:
    ccTex2F textureCoordFromAlphaPoint(CCPoint alpha);
    ccVertex2F vertexFromAlphaPoint(CCPoint alpha);
    void updateProgress(void);
    void updateBar(void);
    void updateRadial(void);

    CCPoint boundaryTexCoord(char index);

protected:
    CCProgressTimerType m_eType;
    float m_fPercentage;
    CCSprite *m_pSprite;
    int m_nVertexDataCount;
    ccV2F_C4B_T2F *m_pVertexData;
# 136 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
    protected: CCPoint m_tMidpoint;public: virtual CCPoint getMidpoint(void);public: virtual void setMidpoint(CCPoint var);;
# 146 "Cacao/include/cocos2dx/misc_nodes/CCProgressTimer.h"
    protected: CCPoint m_tBarChangeRate;public: CCPoint getBarChangeRate(void) const { return m_tBarChangeRate; }public: void setBarChangeRate(CCPoint var){ m_tBarChangeRate = var; };

    bool m_bReverseDirection;
};




}
# 118 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/misc_nodes/CCRenderTexture.h" 1
# 32 "Cacao/include/cocos2dx/misc_nodes/CCRenderTexture.h"
namespace cocos2d {






typedef enum eImageFormat
{
    kCCImageFormatJPEG = 0,
    kCCImageFormatPNG = 1,
} tCCImageFormat;
# 54 "Cacao/include/cocos2dx/misc_nodes/CCRenderTexture.h"
class CCRenderTexture : public CCNode
{





    protected: CCSprite* m_pSprite;public: virtual CCSprite* getSprite(void);public: virtual void setSprite(CCSprite* var);
public:



    CCRenderTexture();




    virtual ~CCRenderTexture();

    virtual void visit();
    virtual void draw();


    static CCRenderTexture * create(int w ,int h, CCTexture2DPixelFormat eFormat, GLuint uDepthStencilFormat);


    static CCRenderTexture * create(int w, int h, CCTexture2DPixelFormat eFormat);


    static CCRenderTexture * create(int w, int h);


    bool initWithWidthAndHeight(int w, int h, CCTexture2DPixelFormat eFormat);


    bool initWithWidthAndHeight(int w, int h, CCTexture2DPixelFormat eFormat, GLuint uDepthStencilFormat);


    void begin();



    void beginWithClear(float r, float g, float b, float a);



    void beginWithClear(float r, float g, float b, float a, float depthValue);



    void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue);


    inline void endToLua(){ end();};


    void end();


    void clear(float r, float g, float b, float a);


    void clearDepth(float depthValue);


    void clearStencil(int stencilValue);



    CCImage* newCCImage(bool flipImage = true);




    bool saveToFile(const char *szFilePath);




    bool saveToFile(const char *name, tCCImageFormat format);




    void listenToBackground(CCObject *obj);




    void listenToForeground(CCObject *obj);


    unsigned int getClearFlags() const;
    void setClearFlags(unsigned int uClearFlags);


    const ccColor4F& getClearColor() const;
    void setClearColor(const ccColor4F &clearColor);


    float getClearDepth() const;
    void setClearDepth(float fClearDepth);


    int getClearStencil() const;
    void setClearStencil(float fClearStencil);




    bool isAutoDraw() const;
    void setAutoDraw(bool bAutoDraw);

private:
    void beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue, GLbitfield flags);

protected:
    GLuint m_uFBO;
    GLuint m_uDepthRenderBufffer;
    GLint m_nOldFBO;
    CCTexture2D* m_pTexture;
    CCTexture2D* m_pTextureCopy;
    CCImage* m_pUITextureImage;
    GLenum m_ePixelFormat;


    GLbitfield m_uClearFlags;
    ccColor4F m_sClearColor;
    GLclampf m_fClearDepth;
    GLint m_nClearStencil;
    bool m_bAutoDraw;
};




}
# 119 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleBatchNode.h" 1
# 35 "Cacao/include/cocos2dx/particle_nodes/CCParticleBatchNode.h"
namespace cocos2d {

class CCTexture2D;
class CCTextureAtlas;
class CCParticleSystem;
# 67 "Cacao/include/cocos2dx/particle_nodes/CCParticleBatchNode.h"
class CCParticleBatchNode : public CCNode, public CCTextureProtocol
{
public:



    CCParticleBatchNode();




    virtual ~CCParticleBatchNode();


    static CCParticleBatchNode* createWithTexture(CCTexture2D *tex, unsigned int capacity = 500);


    static CCParticleBatchNode* create(const char* fileImage, unsigned int capacity = 500);


    bool initWithTexture(CCTexture2D *tex, unsigned int capacity);


    bool initWithFile(const char* fileImage, unsigned int capacity);


    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child, int zOrder, int tag);


    void insertChild(CCParticleSystem* pSystem, unsigned int index);


    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void reorderChild(CCNode * child, int zOrder);
    void removeChildAtIndex(unsigned int index, bool doCleanup);
    void removeAllChildrenWithCleanup(bool doCleanup);

    void disableParticle(unsigned int particleIndex);
    virtual void draw(void);

    virtual CCTexture2D* getTexture(void);

    virtual void setTexture(CCTexture2D *texture);
    virtual void setBlendFunc(ccBlendFunc blendFunc);



    virtual ccBlendFunc getBlendFunc(void);

    void visit();

private:
    void updateAllAtlasIndexes();
    void increaseAtlasCapacityTo(unsigned int quantity);
    unsigned int searchNewPositionInChildrenForZ(int z);
    void getCurrentIndex(unsigned int* oldIndex, unsigned int* newIndex, CCNode* child, int z);
    unsigned int addChildHelper(CCParticleSystem* child, int z, int aTag);
    void updateBlendFunc(void);



    protected: CCTextureAtlas* m_pTextureAtlas;public: CCTextureAtlas* getTextureAtlas(void) const { return m_pTextureAtlas; }public: void setTextureAtlas(CCTextureAtlas* var){ m_pTextureAtlas = var; };
private:

    ccBlendFunc m_tBlendFunc;
};




}
# 122 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h" 1
# 34 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h"
namespace cocos2d {






class CCParticleBatchNode;


enum {

    kCCParticleDurationInfinity = -1,


    kCCParticleStartSizeEqualToEndSize = -1,


    kCCParticleStartRadiusEqualToEndRadius = -1,


    kParticleStartSizeEqualToEndSize = kCCParticleStartSizeEqualToEndSize,
    kParticleDurationInfinity = kCCParticleDurationInfinity,
};


enum {

    kCCParticleModeGravity,


    kCCParticleModeRadius,
};





typedef enum {

    kCCPositionTypeFree,




    kCCPositionTypeRelative,


    kCCPositionTypeGrouped,
}tCCPositionType;


enum {
    kPositionTypeFree = kCCPositionTypeFree,
    kPositionTypeGrouped = kCCPositionTypeGrouped,
};




typedef struct sCCParticle {
    CCPoint pos;
    CCPoint startPos;

    ccColor4F color;
    ccColor4F deltaColor;

    float size;
    float deltaSize;

    float rotation;
    float deltaRotation;

    float timeToLive;

    unsigned int atlasIndex;


    struct {
        CCPoint dir;
        float radialAccel;
        float tangentialAccel;
    } modeA;


    struct {
        float angle;
        float degreesPerSecond;
        float radius;
        float deltaRadius;
    } modeB;

}tCCParticle;



class CCTexture2D;
# 175 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h"
class CCParticleSystem : public CCNode, public CCTextureProtocol
{
protected:
    std::string m_sPlistFile;

    float m_fElapsed;



    struct {

        CCPoint gravity;

        float speed;

        float speedVar;

        float tangentialAccel;

        float tangentialAccelVar;

        float radialAccel;

        float radialAccelVar;

        bool rotationIsDir;
    } modeA;


    struct {

        float startRadius;

        float startRadiusVar;

        float endRadius;

        float endRadiusVar;

        float rotatePerSecond;

        float rotatePerSecondVar;
    } modeB;


    tCCParticle *m_pParticles;





    float m_fEmitCounter;


    unsigned int m_uParticleIdx;






    protected: CCParticleBatchNode* m_pBatchNode;public: virtual CCParticleBatchNode* getBatchNode(void);public: virtual void setBatchNode(CCParticleBatchNode* var);;



    protected: unsigned int m_uAtlasIndex;public: unsigned int getAtlasIndex(void) const { return m_uAtlasIndex; }public: void setAtlasIndex(unsigned int var){ m_uAtlasIndex = var; };


    bool m_bTransformSystemDirty;

    unsigned int m_uAllocatedParticles;


    bool m_bIsActive;

    protected: unsigned int m_uParticleCount;public: virtual unsigned int getParticleCount(void);

    protected: float m_fDuration;public: virtual float getDuration(void);public: virtual void setDuration(float var);

    protected: CCPoint m_tSourcePosition;public: virtual const CCPoint& getSourcePosition(void);public: virtual void setSourcePosition(const CCPoint& var);

    protected: CCPoint m_tPosVar;public: virtual const CCPoint& getPosVar(void);public: virtual void setPosVar(const CCPoint& var);

    protected: float m_fLife;public: virtual float getLife(void);public: virtual void setLife(float var);

    protected: float m_fLifeVar;public: virtual float getLifeVar(void);public: virtual void setLifeVar(float var);

    protected: float m_fAngle;public: virtual float getAngle(void);public: virtual void setAngle(float var);

    protected: float m_fAngleVar;public: virtual float getAngleVar(void);public: virtual void setAngleVar(float var);


public:

    virtual const CCPoint& getGravity();
    virtual void setGravity(const CCPoint& g);
    virtual float getSpeed();
    virtual void setSpeed(float speed);
    virtual float getSpeedVar();
    virtual void setSpeedVar(float speed);
    virtual float getTangentialAccel();
    virtual void setTangentialAccel(float t);
    virtual float getTangentialAccelVar();
    virtual void setTangentialAccelVar(float t);
    virtual float getRadialAccel();
    virtual void setRadialAccel(float t);
    virtual float getRadialAccelVar();
    virtual void setRadialAccelVar(float t);
    virtual bool getRotationIsDir();
    virtual void setRotationIsDir(bool t);

    virtual float getStartRadius();
    virtual void setStartRadius(float startRadius);
    virtual float getStartRadiusVar();
    virtual void setStartRadiusVar(float startRadiusVar);
    virtual float getEndRadius();
    virtual void setEndRadius(float endRadius);
    virtual float getEndRadiusVar();
    virtual void setEndRadiusVar(float endRadiusVar);
    virtual float getRotatePerSecond();
    virtual void setRotatePerSecond(float degrees);
    virtual float getRotatePerSecondVar();
    virtual void setRotatePerSecondVar(float degrees);

    virtual void setScale(float s);
    virtual void setRotation(float newRotation);
    virtual void setScaleX(float newScaleX);
    virtual void setScaleY(float newScaleY);

    virtual bool isActive();
    virtual bool isBlendAdditive();
    virtual void setBlendAdditive(bool value);



    protected: float m_fStartSize;public: virtual float getStartSize(void);public: virtual void setStartSize(float var);

    protected: float m_fStartSizeVar;public: virtual float getStartSizeVar(void);public: virtual void setStartSizeVar(float var);

    protected: float m_fEndSize;public: virtual float getEndSize(void);public: virtual void setEndSize(float var);

    protected: float m_fEndSizeVar;public: virtual float getEndSizeVar(void);public: virtual void setEndSizeVar(float var);

    protected: ccColor4F m_tStartColor;public: virtual const ccColor4F& getStartColor(void);public: virtual void setStartColor(const ccColor4F& var);

    protected: ccColor4F m_tStartColorVar;public: virtual const ccColor4F& getStartColorVar(void);public: virtual void setStartColorVar(const ccColor4F& var);

    protected: ccColor4F m_tEndColor;public: virtual const ccColor4F& getEndColor(void);public: virtual void setEndColor(const ccColor4F& var);

    protected: ccColor4F m_tEndColorVar;public: virtual const ccColor4F& getEndColorVar(void);public: virtual void setEndColorVar(const ccColor4F& var);

    protected: float m_fStartSpin;public: virtual float getStartSpin(void);public: virtual void setStartSpin(float var);

    protected: float m_fStartSpinVar;public: virtual float getStartSpinVar(void);public: virtual void setStartSpinVar(float var);

    protected: float m_fEndSpin;public: virtual float getEndSpin(void);public: virtual void setEndSpin(float var);

    protected: float m_fEndSpinVar;public: virtual float getEndSpinVar(void);public: virtual void setEndSpinVar(float var);

    protected: float m_fEmissionRate;public: virtual float getEmissionRate(void);public: virtual void setEmissionRate(float var);

    protected: unsigned int m_uTotalParticles;public: virtual unsigned int getTotalParticles(void);public: virtual void setTotalParticles(unsigned int var);

    protected: CCTexture2D* m_pTexture;public: virtual CCTexture2D* getTexture(void);public: virtual void setTexture(CCTexture2D* var);

    protected: ccBlendFunc m_tBlendFunc;public: virtual ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(ccBlendFunc var);

    protected: bool m_bOpacityModifyRGB;public: virtual bool getOpacityModifyRGB(void);public: virtual void setOpacityModifyRGB(bool var);
# 351 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystem.h"
    bool m_bIsBlendAdditive;



    protected: tCCPositionType m_ePositionType;public: virtual tCCPositionType getPositionType(void);public: virtual void setPositionType(tCCPositionType var);




protected:
    bool m_bIsAutoRemoveOnFinish;
public:
    virtual bool isAutoRemoveOnFinish();
    virtual void setAutoRemoveOnFinish(bool var);





    protected: int m_nEmitterMode;public: virtual int getEmitterMode(void);public: virtual void setEmitterMode(int var);
private:

    float m_fUnknown01;
    float m_fUnknown02;
    float m_fUnknown03;
    float m_fUnknown04;
    float m_fUnknown05;
    float m_fUnknown06;
    uint32_t m_uUnknown7;
public:



    CCParticleSystem();




    virtual ~CCParticleSystem();






    static CCParticleSystem * create(const char *plistFile);


    static CCParticleSystem* createWithTotalParticles(unsigned int numberOfParticles);


    bool init();





    bool initWithFile(const char *plistFile);




    bool initWithDictionary(CCDictionary *dictionary);




    bool initWithDictionary(CCDictionary *dictionary, const char *dirname);


    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    bool addParticle();

    void initParticle(tCCParticle* particle);

    void stopSystem();

    void resetSystem();

    bool isFull();


    virtual void updateQuadWithParticle(tCCParticle* particle, const CCPoint& newPosition);

    virtual void postStep();

    virtual void update(float dt);
    virtual void updateWithNoTime(void);

protected:
    virtual void updateBlendFunc();
public:

    void loadDefaults(void);
    void loadScaledDefaults(float);
    void resumeSystem(void);
    void saveDefaults(void);

};




}
# 123 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleExamples.h" 1
# 29 "Cacao/include/cocos2dx/particle_nodes/CCParticleExamples.h"
# 1 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystemQuad.h" 1
# 32 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystemQuad.h"
namespace cocos2d {

class CCSpriteFrame;
# 53 "Cacao/include/cocos2dx/particle_nodes/CCParticleSystemQuad.h"
class CCParticleSystemQuad : public CCParticleSystem
{
protected:
    ccV3F_C4B_T2F_Quad *m_pQuads;
    GLushort *m_pIndices;


    GLuint m_uVAOname;


    GLuint m_pBuffersVBO[2];

public:



    CCParticleSystemQuad();




    virtual ~CCParticleSystemQuad();




    static CCParticleSystemQuad * create(const char *plistFile);


    void initIndices();


    void initTexCoordsWithRect(const CCRect& rect);





    void setDisplayFrame(CCSpriteFrame *spriteFrame);




    void setTextureWithRect(CCTexture2D *texture, const CCRect& rect);




    virtual bool initWithTotalParticles(unsigned int numberOfParticles);



    virtual void setTexture(CCTexture2D* texture);



    virtual void updateQuadWithParticle(tCCParticle* particle, const CCPoint& newPosition);



    virtual void postStep();




    virtual void draw();



    virtual void setBatchNode(CCParticleBatchNode* batchNode);



    virtual void setTotalParticles(unsigned int tp);





    void listenBackToForeground(CCObject *obj);

    static CCParticleSystemQuad * create();
    static CCParticleSystemQuad * createWithTotalParticles(unsigned int numberOfParticles);
private:

    void setupVBOandVAO();



    bool allocMemory();
};




}
# 30 "Cacao/include/cocos2dx/particle_nodes/CCParticleExamples.h" 2

namespace cocos2d {







class CCParticleFire : public CCParticleSystemQuad
{
public:



    CCParticleFire(){}




    virtual ~CCParticleFire(){}
    bool init(){ return initWithTotalParticles(250); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleFire* create();
    static CCParticleFire* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleFireworks : public CCParticleSystemQuad
{
public:



    CCParticleFireworks(){}




    virtual ~CCParticleFireworks(){}
    bool init(){ return initWithTotalParticles(1500); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleFireworks* create();
    static CCParticleFireworks* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSun : public CCParticleSystemQuad
{
public:



    CCParticleSun(){}




    virtual ~CCParticleSun(){}
    bool init(){ return initWithTotalParticles(350); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSun* create();
    static CCParticleSun* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleGalaxy : public CCParticleSystemQuad
{
public:



    CCParticleGalaxy(){}




    virtual ~CCParticleGalaxy(){}
    bool init(){ return initWithTotalParticles(200); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleGalaxy* create();
    static CCParticleGalaxy* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleFlower : public CCParticleSystemQuad
{
public:



    CCParticleFlower(){}




    virtual ~CCParticleFlower(){}
    bool init(){ return initWithTotalParticles(250); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleFlower* create();
    static CCParticleFlower* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleMeteor : public CCParticleSystemQuad
{
public:



    CCParticleMeteor(){}




    virtual ~CCParticleMeteor(){}
    bool init(){ return initWithTotalParticles(150); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleMeteor * create();
    static CCParticleMeteor* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSpiral : public CCParticleSystemQuad
{
public:



    CCParticleSpiral(){}




    virtual ~CCParticleSpiral(){}
    bool init(){ return initWithTotalParticles(500); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSpiral* create();
    static CCParticleSpiral* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleExplosion : public CCParticleSystemQuad
{
public:



    CCParticleExplosion(){}




    virtual ~CCParticleExplosion(){}
    bool init(){ return initWithTotalParticles(700); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleExplosion* create();
    static CCParticleExplosion* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSmoke : public CCParticleSystemQuad
{
public:



    CCParticleSmoke(){}




    virtual ~CCParticleSmoke(){}
    bool init(){ return initWithTotalParticles(200); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSmoke* create();
    static CCParticleSmoke* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleSnow : public CCParticleSystemQuad
{
public:



    CCParticleSnow(){}




    virtual ~CCParticleSnow(){}
    bool init(){ return initWithTotalParticles(700); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleSnow* create();
    static CCParticleSnow* createWithTotalParticles(unsigned int numberOfParticles);
};


class CCParticleRain : public CCParticleSystemQuad
{
public:



    CCParticleRain(){}




    virtual ~CCParticleRain(){}
    bool init(){ return initWithTotalParticles(1000); }
    virtual bool initWithTotalParticles(unsigned int numberOfParticles);

    static CCParticleRain* create();
    static CCParticleRain* createWithTotalParticles(unsigned int numberOfParticles);
};




}
# 124 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/platform/CCDevice.h" 1





namespace cocos2d {




class CCDevice
{
private:
    CCDevice();
public:




    static int getDPI();
};


}
# 128 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/platform/CCFileUtils.h" 1
# 34 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
namespace cocos2d {

class CCDictionary;
class CCArray;






class CCFileUtils : public TypeInfo
{
    friend class CCArray;
    friend class CCDictionary;
public:







    virtual long getClassTypeInfo() {
  static const long id = cocos2d::getHashCodeByString(typeid(cocos2d::CCFileUtils).name());
  return id;
    }





    static CCFileUtils* sharedFileUtils();




    static void purgeFileUtils();






    virtual ~CCFileUtils();
# 87 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void purgeCachedEntries();
# 99 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual unsigned char* getFileData(const char* pszFileName, const char* pszMode, unsigned long * pSize);
# 110 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual unsigned char* getFileDataFromZip(const char* pszZipFilePath, const char* pszFileName, unsigned long * pSize);
# 158 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual std::string fullPathForFilename(const char* pszFileName);
# 192 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void loadFilenameLookupDictionaryFromFile(const char* filename);
# 201 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void setFilenameLookupDictionary(CCDictionary* pFilenameLookupDict);
# 212 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual const char* fullPathFromRelativeFile(const char *pszFilename, const char *pszRelativeFile);
# 223 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void setSearchResolutionsOrder(const std::vector<std::string>& searchResolutionsOrder);







    virtual void addSearchResolutionsOrder(const char* order);
# 241 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual const std::vector<std::string>& getSearchResolutionsOrder();
# 262 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual void setSearchPaths(const std::vector<std::string>& searchPaths);






     virtual void addSearchPath(const char* path);







  virtual void removeSearchPath(const char *path);







  void removeAllPaths();
# 295 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual const std::vector<std::string>& getSearchPaths();






    virtual std::string getWritablePath() = 0;
# 312 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual bool isFileExist(const std::string& strFilePath) = 0;
# 324 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual bool isAbsolutePath(const std::string& strPath);





    virtual void setPopupNotify(bool bNotify);
    virtual bool isPopupNotify();

protected:



    CCFileUtils();
# 347 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual bool init();







    virtual std::string getNewFilename(const char* pszFileName);
# 365 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual std::string getPathForFilename(const std::string& filename, const std::string& resolutionDirectory, const std::string& searchPath);
# 377 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    virtual std::string getFullPathForDirectoryAndFilename(const std::string& strDirectory, const std::string& strFilename);





    virtual CCDictionary* createCCDictionaryWithContentsOfFile(const std::string& filename);





    virtual bool writeToFile(CCDictionary *dict, const std::string& fullPath);





    virtual CCArray* createCCArrayWithContentsOfFile(const std::string& filename);
# 404 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    CCDictionary* m_pFilenameLookupDict;





    std::vector<std::string> m_searchResolutionsOrderArray;





    std::vector<std::string> m_searchPathArray;
# 425 "Cacao/include/cocos2dx/platform/CCFileUtils.h"
    std::string m_strDefaultResRootPath;





    std::map<std::string, std::string> m_fullPathCache;




    static CCFileUtils* s_sharedFileUtils;

};




}
# 130 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/CCImage.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCImage.h"
namespace cocos2d {
# 41 "Cacao/include/cocos2dx/platform/CCImage.h"
class CCImage : public CCObject
{
public:



    CCImage();




    ~CCImage();

    typedef enum
    {
        kFmtJpg = 0,
        kFmtPng,
        kFmtTiff,
        kFmtWebp,
        kFmtRawData,
        kFmtUnKnown
    }EImageFormat;

    typedef enum
    {
        kAlignCenter = 0x33,
        kAlignTop = 0x13,
        kAlignTopRight = 0x12,
        kAlignRight = 0x32,
        kAlignBottomRight = 0x22,
        kAlignBottom = 0x23,
        kAlignBottomLeft = 0x21,
        kAlignLeft = 0x31,
        kAlignTopLeft = 0x11,
    }ETextAlign;







    bool initWithImageFile(const char * strPath, EImageFormat imageType = kFmtPng);
# 92 "Cacao/include/cocos2dx/platform/CCImage.h"
    bool initWithImageFileThreadSafe(const char *fullpath, EImageFormat imageType = kFmtPng);
# 104 "Cacao/include/cocos2dx/platform/CCImage.h"
    bool initWithImageData(void * pData,
                           int nDataLen,
                           EImageFormat eFmt = kFmtUnKnown,
                           int nWidth = 0,
                           int nHeight = 0,
                           int nBitsPerComponent = 8);
# 121 "Cacao/include/cocos2dx/platform/CCImage.h"
    bool initWithString(
        const char * pText,
        int nWidth = 0,
        int nHeight = 0,
        ETextAlign eAlignMask = kAlignCenter,
        const char * pFontName = 0,
        int nSize = 0);
# 160 "Cacao/include/cocos2dx/platform/CCImage.h"
    unsigned char * getData() { return m_pData; }
    int getDataLen() { return m_nWidth * m_nHeight; }


    bool hasAlpha() { return m_bHasAlpha; }
    bool isPremultipliedAlpha() { return m_bPreMulti; }







    bool saveToFile(const char *pszFilePath, bool bIsToRGB = true);

    protected: unsigned short m_nWidth;public: unsigned short getWidth(void) const { return m_nWidth; };
    protected: unsigned short m_nHeight;public: unsigned short getHeight(void) const { return m_nHeight; };
    protected: int m_nBitsPerComponent;public: int getBitsPerComponent(void) const { return m_nBitsPerComponent; };

protected:
    bool _initWithJpgData(void *pData, int nDatalen);
    bool _initWithPngData(void *pData, int nDatalen);
    bool _initWithTiffData(void *pData, int nDataLen);
    bool _initWithWebpData(void *pData, int nDataLen);

    bool _initWithRawData(void *pData, int nDatalen, int nWidth, int nHeight, int nBitsPerComponent, bool bPreMulti);

    bool _saveImageToPNG(const char *pszFilePath, bool bIsToRGB = true);
    bool _saveImageToJPG(const char *pszFilePath);

    unsigned char *m_pData;
    bool m_bHasAlpha;
    bool m_bPreMulti;





private:

    CCImage(const CCImage& rImg);
    CCImage & operator=(const CCImage&);


};




}
# 131 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/CCSAXParser.h" 1
# 30 "Cacao/include/cocos2dx/platform/CCSAXParser.h"
namespace cocos2d {






typedef unsigned char CC_XML_CHAR;





class CCSAXDelegator
{
public:
    virtual void startElement(void *ctx, const char *name, const char **atts) = 0;
    virtual void endElement(void *ctx, const char *name) = 0;
    virtual void textHandler(void *ctx, const char *s, int len) = 0;
};





class CCSAXParser
{
    CCSAXDelegator* m_pDelegator;
public:

    CCSAXParser();
    ~CCSAXParser(void);

    bool init(const char *pszEncoding);
    bool parse(const char* pXMLData, unsigned int uDataLength);
    bool parse(const char *pszFile);
    void setDelegator(CCSAXDelegator* pDelegator);

    static void startElement(void *ctx, const CC_XML_CHAR *name, const CC_XML_CHAR **atts);
    static void endElement(void *ctx, const CC_XML_CHAR *name);
    static void textHandler(void *ctx, const CC_XML_CHAR *name, int len);
};




}
# 132 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/CCThread.h" 1
# 31 "Cacao/include/cocos2dx/platform/CCThread.h"
namespace cocos2d {
# 43 "Cacao/include/cocos2dx/platform/CCThread.h"
class CCThread
{
public:
    CCThread() : m_pAutoreasePool(0) {}
    ~CCThread();

    void createAutoreleasePool();

private:
    void *m_pAutoreasePool;
};




}
# 133 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/platform.h" 1
# 31 "Cacao/include/cocos2dx/platform/platform.h"
namespace cocos2d {






struct cc_timeval
{



    long tv_sec;

    int tv_usec;
};

class CCTime
{
public:
    static int gettimeofdayCocos2d(struct cc_timeval *tp, void *tzp);
    static double timersubCocos2d(struct cc_timeval *start, struct cc_timeval *end);
};




}
# 134 "Cacao/include/cocos2dx/cocos2d.h" 2
# 189 "Cacao/include/cocos2dx/cocos2d.h"
# 1 "Cacao/include/cocos2dx/platform/mac/CCApplication.h" 1
# 29 "Cacao/include/cocos2dx/platform/mac/CCApplication.h"
# 1 "Cacao/include/cocos2dx/platform/CCApplicationProtocol.h" 1
# 28 "Cacao/include/cocos2dx/platform/CCApplicationProtocol.h"
namespace cocos2d {

enum TargetPlatform
{
    kTargetWindows,
    kTargetLinux,
    kTargetMacOS,
    kTargetAndroid,
    kTargetIphone,
    kTargetIpad,
    kTargetBlackBerry,
    kTargetNaCl,
    kTargetEmscripten,
    kTargetTizen,
    kTargetWinRT,
    kTargetWP8
};
# 53 "Cacao/include/cocos2dx/platform/CCApplicationProtocol.h"
class CCApplicationProtocol
{
public:

    virtual ~CCApplicationProtocol() {}






    virtual bool applicationDidFinishLaunching() = 0;





    virtual void applicationDidEnterBackground() = 0;





    virtual void applicationWillEnterForeground() = 0;





    virtual void setAnimationInterval(double interval) = 0;





    virtual ccLanguageType getCurrentLanguage() = 0;




    virtual TargetPlatform getTargetPlatform() = 0;
};




}
# 30 "Cacao/include/cocos2dx/platform/mac/CCApplication.h" 2


namespace cocos2d {

class CCApplication : public CCApplicationProtocol
{
public:
    CCApplication();
    virtual ~CCApplication();





    virtual void setAnimationInterval(double interval);
# 53 "Cacao/include/cocos2dx/platform/mac/CCApplication.h"
    int run();





    static CCApplication* sharedApplication();





    virtual ccLanguageType getCurrentLanguage();




    virtual TargetPlatform getTargetPlatform();





    __attribute__((deprecated)) void setResourceRootPath(const std::string& rootResDir);





    __attribute__((deprecated)) const std::string& getResourceRootPath(void);

    void setStartupScriptFilename(const std::string& startupScriptFile);

    const std::string& getStartupScriptFilename(void);

protected:
    static CCApplication * sm_pSharedApplication;

    std::string m_resourceRootPath;
    std::string m_startupScriptFilename;
};

}
# 190 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/platform/mac/CCEGLView.h" 1
# 29 "Cacao/include/cocos2dx/platform/mac/CCEGLView.h"
# 1 "Cacao/include/cocos2dx/platform/CCEGLViewProtocol.h" 1





enum ResolutionPolicy
{


    kResolutionExactFit,


    kResolutionNoBorder,


    kResolutionShowAll,




    kResolutionFixedHeight,




    kResolutionFixedWidth,

    kResolutionUnKnown,
};

namespace cocos2d {



class EGLTouchDelegate;
class CCSet;







class CCEGLViewProtocol
{
public:



    CCEGLViewProtocol();



    virtual ~CCEGLViewProtocol();




    virtual void end() = 0;




    virtual bool isOpenGLReady() = 0;




    virtual void swapBuffers() = 0;




    virtual void setIMEKeyboardState(bool bOpen) = 0;





    virtual const CCSize& getFrameSize() const;




    virtual void setFrameSize(float width, float height);




    virtual CCSize getVisibleSize() const;




    virtual CCPoint getVisibleOrigin() const;
# 106 "Cacao/include/cocos2dx/platform/CCEGLViewProtocol.h"
    virtual void setDesignResolutionSize(float width, float height, ResolutionPolicy resolutionPolicy);




    virtual const CCSize& getDesignResolutionSize() const;


    virtual void setTouchDelegate(EGLTouchDelegate * pDelegate);




    virtual void setViewPortInPoints(float x , float y , float w , float h);




    virtual void setScissorInPoints(float x , float y , float w , float h);





    virtual bool isScissorEnabled();





    virtual CCRect getScissorRect();



    virtual void setViewName(const char* pszViewName);



    const char* getViewName();




    virtual void handleTouchesBegin(int num, int ids[], float xs[], float ys[]);



    virtual void handleTouchesMove(int num, int ids[], float xs[], float ys[]);



    virtual void handleTouchesEnd(int num, int ids[], float xs[], float ys[]);



    virtual void handleTouchesCancel(int num, int ids[], float xs[], float ys[]);




    const CCRect& getViewPortRect() const;




    float getScaleX() const;




    float getScaleY() const;
private:
    void getSetOfTouchesEndOrCancel(CCSet& set, int num, int ids[], float xs[], float ys[]);

protected:
    EGLTouchDelegate* m_pDelegate;


    CCSize m_obScreenSize;

    CCSize m_obDesignResolutionSize;

    CCRect m_obViewPortRect;

    char m_szViewName[50];

    float m_fScaleX;
    float m_fScaleY;
    ResolutionPolicy m_eResolutionPolicy;
};




}
# 30 "Cacao/include/cocos2dx/platform/mac/CCEGLView.h" 2

namespace cocos2d {

class CCSet;
class CCTouch;
class CCSize;

class CCEGLView : public CCEGLViewProtocol
{
public:
    static CCEGLView* sharedOpenGLView(void);

    virtual ~CCEGLView(void);

    virtual bool isOpenGLReady(void);
    virtual bool setContentScaleFactor(float contentScaleFactor);
    virtual void end();
    virtual void swapBuffers(void);



    virtual void setViewPortInPoints(float x , float y , float w , float h);
    virtual void setScissorInPoints(float x , float y , float w , float h);

    virtual void setIMEKeyboardState(bool bOpen);
 virtual void setMultiTouchMask(bool mask);

private:
    static CCEGLView* s_sharedView;

    CCEGLView(void);
};

}
# 191 "Cacao/include/cocos2dx/cocos2d.h" 2
# 247 "Cacao/include/cocos2dx/cocos2d.h"
# 1 "Cacao/include/cocos2dx/shaders/CCShaderCache.h" 1
# 32 "Cacao/include/cocos2dx/shaders/CCShaderCache.h"
namespace cocos2d {

class CCGLProgram;
# 45 "Cacao/include/cocos2dx/shaders/CCShaderCache.h"
class CCShaderCache : public CCObject
{
public:



    CCShaderCache();




    virtual ~CCShaderCache();



    static CCShaderCache* sharedShaderCache();


    static void purgeSharedShaderCache();


    void loadDefaultShaders();


    void reloadDefaultShaders();






    CCGLProgram * programForKey(const char* key);


    void addProgram(CCGLProgram* program, const char* key);

private:
    bool init();
    void loadDefaultShader(CCGLProgram *program, int type);

    CCDictionary* m_pPrograms;

};




}
# 248 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/shaders/ccShaders.h" 1
# 31 "Cacao/include/cocos2dx/shaders/ccShaders.h"
namespace cocos2d {






extern const GLchar * ccPosition_uColor_frag;
extern const GLchar * ccPosition_uColor_vert;

extern const GLchar * ccPositionColor_frag;
extern const GLchar * ccPositionColor_vert;

extern const GLchar * ccPositionTexture_frag;
extern const GLchar * ccPositionTexture_vert;

extern const GLchar * ccPositionTextureA8Color_frag;
extern const GLchar * ccPositionTextureA8Color_vert;

extern const GLchar * ccPositionTextureColor_frag;
extern const GLchar * ccPositionTextureColor_vert;

extern const GLchar * ccPositionTextureColorAlphaTest_frag;

extern const GLchar * ccPositionTexture_uColor_frag;
extern const GLchar * ccPositionTexture_uColor_vert;

extern const GLchar * ccPositionColorLengthTexture_frag;
extern const GLchar * ccPositionColorLengthTexture_vert;

extern const GLchar * ccExSwitchMask_frag;




}
# 249 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/sprite_nodes/CCAnimationCache.h" 1
# 34 "Cacao/include/cocos2dx/sprite_nodes/CCAnimationCache.h"
namespace cocos2d {

class CCAnimation;
# 50 "Cacao/include/cocos2dx/sprite_nodes/CCAnimationCache.h"
class CCAnimationCache : public CCObject
{
public:



    CCAnimationCache();




    ~CCAnimationCache();



    static CCAnimationCache* sharedAnimationCache(void);



    static void purgeSharedAnimationCache(void);



    void addAnimation(CCAnimation *animation, const char * name);




    void removeAnimationByName(const char* name);






    CCAnimation* animationByName(const char* name);






    void addAnimationsWithDictionary(CCDictionary* dictionary,const char* plist = __null);






    void addAnimationsWithFile(const char* plist);

    bool init(void);

private:
    void parseVersion1(CCDictionary* animations);
    void parseVersion2(CCDictionary* animations);
private:
    CCDictionary* m_pAnimations;
    static CCAnimationCache* s_pSharedAnimationCache;
};




}
# 253 "Cacao/include/cocos2dx/cocos2d.h" 2



# 1 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrameCache.h" 1
# 43 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrameCache.h"
namespace cocos2d {

class CCDictionary;
class CCArray;
class CCSprite;
# 58 "Cacao/include/cocos2dx/sprite_nodes/CCSpriteFrameCache.h"
class CCSpriteFrameCache : public CCObject
{
protected:




    CCSpriteFrameCache(void) : m_pSpriteFrames(__null), m_pSpriteFramesAliases(__null){}
public:
    bool init(void);




    ~CCSpriteFrameCache(void);

private:


    void addSpriteFramesWithDictionary(CCDictionary* pobDictionary, CCTexture2D *pobTexture);
public:





    void addSpriteFramesWithFile(const char *pszPlist);





    void addSpriteFramesWithFile(const char* plist, const char* textureFileName);




    void addSpriteFramesWithFile(const char *pszPlist, CCTexture2D *pobTexture);




    void addSpriteFrame(CCSpriteFrame *pobFrame, const char *pszFrameName);







    void removeSpriteFrames(void);





    void removeUnusedSpriteFrames(void);




    void removeSpriteFrameByName(const char *pszName);






    void removeSpriteFramesFromFile(const char* plist);

private:



    void removeSpriteFramesFromDictionary(CCDictionary* dictionary);
public:




    void removeSpriteFramesFromTexture(CCTexture2D* texture);






    CCSpriteFrame* spriteFrameByName(const char *pszName);

public:



    static CCSpriteFrameCache* sharedSpriteFrameCache(void);


    static void purgeSharedSpriteFrameCache(void);

private:


protected:
    CCDictionary* m_pSpriteFrames;
    CCDictionary* m_pSpriteFramesAliases;
    std::set<std::string>* m_pLoadedFileNames;
};




}
# 257 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/support/ccUTF8.h" 1
# 14 "Cacao/include/cocos2dx/support/ccUTF8.h"
namespace cocos2d {

       int cc_wcslen(const unsigned short* str);

       void cc_utf8_trim_ws(std::vector<unsigned short>* str);
# 27 "Cacao/include/cocos2dx/support/ccUTF8.h"
       bool isspace_unicode(unsigned short ch);
# 41 "Cacao/include/cocos2dx/support/ccUTF8.h"
       long
cc_utf8_strlen (const char * p, int max);







       unsigned int cc_utf8_find_last_not_char(std::vector<unsigned short> str, unsigned short c);

       std::vector<unsigned short> cc_utf16_vec_from_utf16_str(const unsigned short* str);
# 62 "Cacao/include/cocos2dx/support/ccUTF8.h"
       unsigned short* cc_utf8_to_utf16(const char* str_old, int length = -1, int* rUtf16Size = __null);
# 89 "Cacao/include/cocos2dx/support/ccUTF8.h"
       char *
cc_utf16_to_utf8 (const unsigned short *str,
                  long len,
                  long *items_read,
                  long *items_written);

}
# 260 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCNotificationCenter.h" 1
# 31 "Cacao/include/cocos2dx/support/CCNotificationCenter.h"
namespace cocos2d {



class CCNotificationCenter : public CCObject
{
public:

    CCNotificationCenter();


    ~CCNotificationCenter();


    static CCNotificationCenter *sharedNotificationCenter(void);


    static void purgeNotificationCenter(void);







    void addObserver(CCObject *target,
                     SEL_CallFuncO selector,
                     const char *name,
                     CCObject *obj);





    void removeObserver(CCObject *target,const char *name);





    int removeAllObservers(CCObject *target);





    void registerScriptObserver(CCObject *target,int handler,const char* name);


    void unregisterScriptObserver(CCObject *target,const char* name);




    void postNotification(const char *name);





    void postNotification(const char *name, CCObject *object);





    inline int getScriptHandler() { return m_scriptHandler; };





    int getObserverHandlerByName(const char* name);
private:



    bool observerExisted(CCObject *target,const char *name);



    CCArray *m_observers;
    int m_scriptHandler;
};





class CCNotificationObserver : public CCObject
{
public:






    CCNotificationObserver(CCObject *target,
                           SEL_CallFuncO selector,
                           const char *name,
                           CCObject *obj);


    ~CCNotificationObserver();


    void performSelector(CCObject *obj);
private:
    protected: CCObject * m_target;public: virtual CCObject * getTarget(void);;
    protected: SEL_CallFuncO m_selector;public: virtual SEL_CallFuncO getSelector(void);;
    protected: char * m_name;public: virtual char * getName(void);;
    protected: CCObject * m_object;public: virtual CCObject * getObject(void);;
    protected: int m_nHandler;public: virtual int getHandler(void);public: virtual void setHandler(int var);;
};

}
# 261 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCPointExtension.h" 1
# 49 "Cacao/include/cocos2dx/support/CCPointExtension.h"
namespace cocos2d {
# 66 "Cacao/include/cocos2dx/support/CCPointExtension.h"
static inline CCPoint
ccpNeg(const CCPoint& v)
{
    return -v;
}





static inline CCPoint
ccpAdd(const CCPoint& v1, const CCPoint& v2)
{
    return v1 + v2;
}





static inline CCPoint
ccpSub(const CCPoint& v1, const CCPoint& v2)
{
    return v1 - v2;
}





static inline CCPoint
ccpMult(const CCPoint& v, const float s)
{
    return v * s;
}





static inline CCPoint
ccpMidpoint(const CCPoint& v1, const CCPoint& v2)
{
    return (v1 + v2) / 2.f;
}





static inline float
ccpDot(const CCPoint& v1, const CCPoint& v2)
{
    return v1.dot(v2);
}





static inline float
ccpCross(const CCPoint& v1, const CCPoint& v2)
{
    return v1.cross(v2);
}





static inline CCPoint
ccpPerp(const CCPoint& v)
{
    return v.getPerp();
}





static inline CCPoint
ccpRPerp(const CCPoint& v)
{
    return v.getRPerp();
}





static inline CCPoint
ccpProject(const CCPoint& v1, const CCPoint& v2)
{
    return v1.project(v2);
}





static inline CCPoint
ccpRotate(const CCPoint& v1, const CCPoint& v2)
{
    return v1.rotate(v2);
}





static inline CCPoint
ccpUnrotate(const CCPoint& v1, const CCPoint& v2)
{
    return v1.unrotate(v2);
}





static inline float
ccpLengthSQ(const CCPoint& v)
{
    return v.getLengthSq();
}






static inline float
ccpDistanceSQ(const CCPoint p1, const CCPoint p2)
{
    return (p1 - p2).getLengthSq();
}






float ccpLength(const CCPoint& v);





float ccpDistance(const CCPoint& v1, const CCPoint& v2);





CCPoint ccpNormalize(const CCPoint& v);





CCPoint ccpForAngle(const float a);





float ccpToAngle(const CCPoint& v);





float clampf(float value, float min_inclusive, float max_inclusive);




CCPoint ccpClamp(const CCPoint& p, const CCPoint& from, const CCPoint& to);




CCPoint ccpFromSize(const CCSize& s);
# 257 "Cacao/include/cocos2dx/support/CCPointExtension.h"
CCPoint ccpCompOp(const CCPoint& p, float (*opFunc)(float));
# 266 "Cacao/include/cocos2dx/support/CCPointExtension.h"
CCPoint ccpLerp(const CCPoint& a, const CCPoint& b, float alpha);





bool ccpFuzzyEqual(const CCPoint& a, const CCPoint& b, float variance);






CCPoint ccpCompMult(const CCPoint& a, const CCPoint& b);




float ccpAngleSigned(const CCPoint& a, const CCPoint& b);




float ccpAngle(const CCPoint& a, const CCPoint& b);
# 298 "Cacao/include/cocos2dx/support/CCPointExtension.h"
CCPoint ccpRotateByAngle(const CCPoint& v, const CCPoint& pivot, float angle);
# 321 "Cacao/include/cocos2dx/support/CCPointExtension.h"
bool ccpLineIntersect(const CCPoint& p1, const CCPoint& p2,
                      const CCPoint& p3, const CCPoint& p4,
                      float *s, float *t);





bool ccpSegmentIntersect(const CCPoint& A, const CCPoint& B, const CCPoint& C, const CCPoint& D);





CCPoint ccpIntersectPoint(const CCPoint& A, const CCPoint& B, const CCPoint& C, const CCPoint& D);




}
# 262 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCProfiling.h" 1
# 34 "Cacao/include/cocos2dx/support/CCProfiling.h"
namespace cocos2d {






class CCProfilingTimer;
# 51 "Cacao/include/cocos2dx/support/CCProfiling.h"
class CCProfiler : public CCObject
{
public:
    ~CCProfiler(void);

    void displayTimers(void);
    bool init(void);

public:
    static CCProfiler* sharedProfiler(void);

    CCProfilingTimer* createAndAddTimerWithName(const char* timerName);

    void releaseTimer(const char* timerName);

    void releaseAllTimers();

    CCDictionary* m_pActiveTimers;
};




class CCProfilingTimer : public CCObject
{
public:
    CCProfilingTimer();
    ~CCProfilingTimer();
    bool initWithName(const char* timerName);
    const char* description(void);
    struct cc_timeval* getStartTime(void) { return &m_sStartTime; };

    void reset();

    std::string m_NameStr;
    int numberOfCalls;
    int m_dAverageTime1;
    int m_dAverageTime2;
    long long totalTime;
    int minTime;
    int maxTime;
    struct cc_timeval m_sStartTime;
};

extern void CCProfilingBeginTimingBlock(const char *timerName);
extern void CCProfilingEndTimingBlock(const char *timerName);
extern void CCProfilingResetTimingBlock(const char *timerName);






extern bool kCCProfilerCategorySprite;
extern bool kCCProfilerCategoryBatchSprite;
extern bool kCCProfilerCategoryParticles;




}
# 263 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/user_default/CCUserDefault.h" 1
# 30 "Cacao/include/cocos2dx/support/user_default/CCUserDefault.h"
namespace cocos2d {
# 45 "Cacao/include/cocos2dx/support/user_default/CCUserDefault.h"
class CCUserDefault
{
public:
    ~CCUserDefault();







    bool getBoolForKey(const char* pKey);
    bool getBoolForKey(const char* pKey, bool defaultValue);




    int getIntegerForKey(const char* pKey);
    int getIntegerForKey(const char* pKey, int defaultValue);




    float getFloatForKey(const char* pKey);
    float getFloatForKey(const char* pKey, float defaultValue);




    double getDoubleForKey(const char* pKey);
    double getDoubleForKey(const char* pKey, double defaultValue);




    std::string getStringForKey(const char* pKey);
    std::string getStringForKey(const char* pKey, const std::string & defaultValue);






    void setBoolForKey(const char* pKey, bool value);



    void setIntegerForKey(const char* pKey, int value);



    void setFloatForKey(const char* pKey, float value);



    void setDoubleForKey(const char* pKey, double value);



    void setStringForKey(const char* pKey, const std::string & value);



    void flush();

    static CCUserDefault* sharedUserDefault();
    static void purgeSharedUserDefault();
    const static std::string& getXMLFilePath();
    static bool isXMLFileExist();

private:
    CCUserDefault();
    static bool createXMLFile();
    static void initXMLFilePath();

    static CCUserDefault* m_spUserDefault;
    static std::string m_sFilePath;
    static bool m_sbIsFilePathInitialized;
};




}
# 264 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/CCVertex.h" 1
# 30 "Cacao/include/cocos2dx/support/CCVertex.h"
namespace cocos2d {
# 40 "Cacao/include/cocos2dx/support/CCVertex.h"
void ccVertexLineToPolygon(CCPoint *points, float stroke, ccVertex2F *vertices, unsigned int offset, unsigned int nuPoints);


bool ccVertexLineIntersect(float Ax, float Ay,
                             float Bx, float By,
                             float Cx, float Cy,
                             float Dx, float Dy, float *T);




}
# 265 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h" 1
# 104 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
static const int TIXML2_MAJOR_VERSION = 1;
static const int TIXML2_MINOR_VERSION = 0;
static const int TIXML2_PATCH_VERSION = 9;

namespace tinyxml2
{
class XMLDocument;
class XMLElement;
class XMLAttribute;
class XMLComment;
class XMLNode;
class XMLText;
class XMLDeclaration;
class XMLUnknown;

class XMLPrinter;







class StrPair
{
public:
    enum {
        NEEDS_ENTITY_PROCESSING = 0x01,
        NEEDS_NEWLINE_NORMALIZATION = 0x02,
        COLLAPSE_WHITESPACE = 0x04,

        TEXT_ELEMENT = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        TEXT_ELEMENT_LEAVE_ENTITIES = NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_NAME = 0,
        ATTRIBUTE_VALUE = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_VALUE_LEAVE_ENTITIES = NEEDS_NEWLINE_NORMALIZATION,
        COMMENT = NEEDS_NEWLINE_NORMALIZATION
    };

    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}
    ~StrPair();

    void Set( char* start, char* end, int flags ) {
        Reset();
        _start = start;
        _end = end;
        _flags = flags | NEEDS_FLUSH;
    }

    const char* GetStr();

    bool Empty() const {
        return _start == _end;
    }

    void SetInternedStr( const char* str ) {
        Reset();
        _start = const_cast<char*>(str);
    }

    void SetStr( const char* str, int flags=0 );

    char* ParseText( char* in, const char* endTag, int strFlags );
    char* ParseName( char* in );

private:
    void Reset();
    void CollapseWhitespace();

    enum {
        NEEDS_FLUSH = 0x100,
        NEEDS_DELETE = 0x200
    };


    int _flags;
    char* _start;
    char* _end;
};







template <class T, int INIT>
class DynArray
{
public:
    DynArray< T, INIT >() {
        _mem = _pool;
        _allocated = INIT;
        _size = 0;
    }

    ~DynArray() {
        if ( _mem != _pool ) {
            delete [] _mem;
        }
    }

    void Push( T t ) {
        EnsureCapacity( _size+1 );
        _mem[_size++] = t;
    }

    T* PushArr( int count ) {
        EnsureCapacity( _size+count );
        T* ret = &_mem[_size];
        _size += count;
        return ret;
    }

    T Pop() {
        return _mem[--_size];
    }

    void PopArr( int count ) {
        {};
        _size -= count;
    }

    bool Empty() const {
        return _size == 0;
    }

    T& operator[](int i) {
        {};
        return _mem[i];
    }

    const T& operator[](int i) const {
        {};
        return _mem[i];
    }

    int Size() const {
        return _size;
    }

    int Capacity() const {
        return _allocated;
    }

    const T* Mem() const {
        return _mem;
    }

    T* Mem() {
        return _mem;
    }

private:
    void EnsureCapacity( int cap ) {
        if ( cap > _allocated ) {
            int newAllocated = cap * 2;
            T* newMem = new T[newAllocated];
            memcpy( newMem, _mem, sizeof(T)*_size );
            if ( _mem != _pool ) {
                delete [] _mem;
            }
            _mem = newMem;
            _allocated = newAllocated;
        }
    }

    T* _mem;
    T _pool[INIT];
    int _allocated;
    int _size;
};






class MemPool
{
public:
    MemPool() {}
    virtual ~MemPool() {}

    virtual int ItemSize() const = 0;
    virtual void* Alloc() = 0;
    virtual void Free( void* ) = 0;
    virtual void SetTracked() = 0;
};





template< int SIZE >
class MemPoolT : public MemPool
{
public:
    MemPoolT() : _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0) {}
    ~MemPoolT() {

        for( int i=0; i<_blockPtrs.Size(); ++i ) {
            delete _blockPtrs[i];
        }
    }

    virtual int ItemSize() const {
        return SIZE;
    }
    int CurrentAllocs() const {
        return _currentAllocs;
    }

    virtual void* Alloc() {
        if ( !_root ) {

            Block* block = new Block();
            _blockPtrs.Push( block );

            for( int i=0; i<COUNT-1; ++i ) {
                block->chunk[i].next = &block->chunk[i+1];
            }
            block->chunk[COUNT-1].next = 0;
            _root = block->chunk;
        }
        void* result = _root;
        _root = _root->next;

        ++_currentAllocs;
        if ( _currentAllocs > _maxAllocs ) {
            _maxAllocs = _currentAllocs;
        }
        _nAllocs++;
        _nUntracked++;
        return result;
    }
    virtual void Free( void* mem ) {
        if ( !mem ) {
            return;
        }
        --_currentAllocs;
        Chunk* chunk = (Chunk*)mem;



        chunk->next = _root;
        _root = chunk;
    }
    void Trace( const char* name ) {
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
                name, _maxAllocs, _maxAllocs*SIZE/1024, _currentAllocs, SIZE, _nAllocs, _blockPtrs.Size() );
    }

    void SetTracked() {
        _nUntracked--;
    }

    int Untracked() const {
        return _nUntracked;
    }

    enum { COUNT = 1024/SIZE };

private:
    union Chunk {
        Chunk* next;
        char mem[SIZE];
    };
    struct Block {
        Chunk chunk[COUNT];
    };
    DynArray< Block*, 10 > _blockPtrs;
    Chunk* _root;

    int _currentAllocs;
    int _nAllocs;
    int _maxAllocs;
    int _nUntracked;
};
# 405 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLVisitor
{
public:
    virtual ~XMLVisitor() {}


    virtual bool VisitEnter( const XMLDocument& ) {
        return true;
    }

    virtual bool VisitExit( const XMLDocument& ) {
        return true;
    }


    virtual bool VisitEnter( const XMLElement& , const XMLAttribute* ) {
        return true;
    }

    virtual bool VisitExit( const XMLElement& ) {
        return true;
    }


    virtual bool Visit( const XMLDeclaration& ) {
        return true;
    }

    virtual bool Visit( const XMLText& ) {
        return true;
    }

    virtual bool Visit( const XMLComment& ) {
        return true;
    }

    virtual bool Visit( const XMLUnknown& ) {
        return true;
    }
};





class XMLUtil
{
public:


    static const char* SkipWhiteSpace( const char* p ) {
        while( !IsUTF8Continuation(*p) && isspace( *reinterpret_cast<const unsigned char*>(p) ) ) {
            ++p;
        }
        return p;
    }
    static char* SkipWhiteSpace( char* p ) {
        while( !IsUTF8Continuation(*p) && isspace( *reinterpret_cast<unsigned char*>(p) ) ) {
            ++p;
        }
        return p;
    }
    static bool IsWhiteSpace( char p ) {
        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );
    }

    inline static bool StringEqual( const char* p, const char* q, int nChar=2147483647 ) {
        int n = 0;
        if ( p == q ) {
            return true;
        }
        while( *p && *q && *p == *q && n<nChar ) {
            ++p;
            ++q;
            ++n;
        }
        if ( (n == nChar) || ( *p == 0 && *q == 0 ) ) {
            return true;
        }
        return false;
    }
    inline static int IsUTF8Continuation( const char p ) {
        return p & 0x80;
    }
    inline static int IsAlphaNum( unsigned char anyByte ) {
        return ( anyByte < 128 ) ? isalnum( anyByte ) : 1;
    }
    inline static int IsAlpha( unsigned char anyByte ) {
        return ( anyByte < 128 ) ? isalpha( anyByte ) : 1;
    }

    static const char* ReadBOM( const char* p, bool* hasBOM );


    static const char* GetCharacterRef( const char* p, char* value, int* length );
    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );


    static void ToStr( int v, char* buffer, int bufferSize );
    static void ToStr( unsigned v, char* buffer, int bufferSize );
    static void ToStr( bool v, char* buffer, int bufferSize );
    static void ToStr( float v, char* buffer, int bufferSize );
    static void ToStr( double v, char* buffer, int bufferSize );


    static bool ToInt( const char* str, int* value );
    static bool ToUnsigned( const char* str, unsigned* value );
    static bool ToBool( const char* str, bool* value );
    static bool ToFloat( const char* str, float* value );
    static bool ToDouble( const char* str, double* value );
};
# 543 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLNode
{
    friend class XMLDocument;
    friend class XMLElement;
public:


    const XMLDocument* GetDocument() const {
        return _document;
    }

    XMLDocument* GetDocument() {
        return _document;
    }


    virtual XMLElement* ToElement() {
        return 0;
    }

    virtual XMLText* ToText() {
        return 0;
    }

    virtual XMLComment* ToComment() {
        return 0;
    }

    virtual XMLDocument* ToDocument() {
        return 0;
    }

    virtual XMLDeclaration* ToDeclaration() {
        return 0;
    }

    virtual XMLUnknown* ToUnknown() {
        return 0;
    }

    virtual const XMLElement* ToElement() const {
        return 0;
    }
    virtual const XMLText* ToText() const {
        return 0;
    }
    virtual const XMLComment* ToComment() const {
        return 0;
    }
    virtual const XMLDocument* ToDocument() const {
        return 0;
    }
    virtual const XMLDeclaration* ToDeclaration() const {
        return 0;
    }
    virtual const XMLUnknown* ToUnknown() const {
        return 0;
    }
# 611 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    const char* Value() const {
        return _value.GetStr();
    }




    void SetValue( const char* val, bool staticMem=false );


    const XMLNode* Parent() const {
        return _parent;
    }

    XMLNode* Parent() {
        return _parent;
    }


    bool NoChildren() const {
        return !_firstChild;
    }


    const XMLNode* FirstChild() const {
        return _firstChild;
    }

    XMLNode* FirstChild() {
        return _firstChild;
    }




    const XMLElement* FirstChildElement( const char* value=0 ) const;

    XMLElement* FirstChildElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( value ));
    }


    const XMLNode* LastChild() const {
        return _lastChild;
    }

    XMLNode* LastChild() {
        return const_cast<XMLNode*>(const_cast<const XMLNode*>(this)->LastChild() );
    }




    const XMLElement* LastChildElement( const char* value=0 ) const;

    XMLElement* LastChildElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(value) );
    }


    const XMLNode* PreviousSibling() const {
        return _prev;
    }

    XMLNode* PreviousSibling() {
        return _prev;
    }


    const XMLElement* PreviousSiblingElement( const char* value=0 ) const ;

    XMLElement* PreviousSiblingElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( value ) );
    }


    const XMLNode* NextSibling() const {
        return _next;
    }

    XMLNode* NextSibling() {
        return _next;
    }


    const XMLElement* NextSiblingElement( const char* value=0 ) const;

    XMLElement* NextSiblingElement( const char* value=0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( value ) );
    }




    XMLNode* InsertEndChild( XMLNode* addThis );

    XMLNode* LinkEndChild( XMLNode* addThis ) {
        return InsertEndChild( addThis );
    }



    XMLNode* InsertFirstChild( XMLNode* addThis );



    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );




    void DeleteChildren();




    void DeleteChild( XMLNode* node );
# 738 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;







    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;
# 770 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    virtual bool Accept( XMLVisitor* visitor ) const = 0;


    virtual char* ParseDeep( char*, StrPair* );

protected:
    XMLNode( XMLDocument* );
    virtual ~XMLNode();
    XMLNode( const XMLNode& );
    XMLNode& operator=( const XMLNode& );

    XMLDocument* _document;
    XMLNode* _parent;
    mutable StrPair _value;

    XMLNode* _firstChild;
    XMLNode* _lastChild;

    XMLNode* _prev;
    XMLNode* _next;

private:
    MemPool* _memPool;
    void Unlink( XMLNode* child );
};
# 809 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLText : public XMLNode
{
    friend class XMLBase;
    friend class XMLDocument;
public:
    virtual bool Accept( XMLVisitor* visitor ) const;

    virtual XMLText* ToText() {
        return this;
    }
    virtual const XMLText* ToText() const {
        return this;
    }


    void SetCData( bool isCData ) {
        _isCData = isCData;
    }

    bool CData() const {
        return _isCData;
    }

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLText( XMLDocument* doc ) : XMLNode( doc ), _isCData( false ) {}
    virtual ~XMLText() {}
    XMLText( const XMLText& );
    XMLText& operator=( const XMLText& );

private:
    bool _isCData;
};



class XMLComment : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLComment* ToComment() {
        return this;
    }
    virtual const XMLComment* ToComment() const {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLComment( XMLDocument* doc );
    virtual ~XMLComment();
    XMLComment( const XMLComment& );
    XMLComment& operator=( const XMLComment& );

private:
};
# 886 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLDeclaration : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLDeclaration* ToDeclaration() {
        return this;
    }
    virtual const XMLDeclaration* ToDeclaration() const {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLDeclaration( XMLDocument* doc );
    virtual ~XMLDeclaration();
    XMLDeclaration( const XMLDeclaration& );
    XMLDeclaration& operator=( const XMLDeclaration& );
};
# 918 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLUnknown : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLUnknown* ToUnknown() {
        return this;
    }
    virtual const XMLUnknown* ToUnknown() const {
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    char* ParseDeep( char*, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    XMLUnknown( XMLDocument* doc );
    virtual ~XMLUnknown();
    XMLUnknown( const XMLUnknown& );
    XMLUnknown& operator=( const XMLUnknown& );
};


enum XMLError {
    XML_NO_ERROR = 0,
    XML_SUCCESS = 0,

    XML_NO_ATTRIBUTE,
    XML_WRONG_ATTRIBUTE_TYPE,

    XML_ERROR_FILE_NOT_FOUND,
    XML_ERROR_FILE_COULD_NOT_BE_OPENED,
    XML_ERROR_FILE_READ_ERROR,
    XML_ERROR_ELEMENT_MISMATCH,
    XML_ERROR_PARSING_ELEMENT,
    XML_ERROR_PARSING_ATTRIBUTE,
    XML_ERROR_IDENTIFYING_TAG,
    XML_ERROR_PARSING_TEXT,
    XML_ERROR_PARSING_CDATA,
    XML_ERROR_PARSING_COMMENT,
    XML_ERROR_PARSING_DECLARATION,
    XML_ERROR_PARSING_UNKNOWN,
    XML_ERROR_EMPTY_DOCUMENT,
    XML_ERROR_MISMATCHED_ELEMENT,
    XML_ERROR_PARSING,

    XML_CAN_NOT_CONVERT_TEXT,
    XML_NO_TEXT_NODE
};
# 977 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLAttribute
{
    friend class XMLElement;
public:

    const char* Name() const {
        return _name.GetStr();
    }

    const char* Value() const {
        return _value.GetStr();
    }

    const XMLAttribute* Next() const {
        return _next;
    }





    int IntValue() const {
        int i=0;
        QueryIntValue( &i );
        return i;
    }

    unsigned UnsignedValue() const {
        unsigned i=0;
        QueryUnsignedValue( &i );
        return i;
    }

    bool BoolValue() const {
        bool b=false;
        QueryBoolValue( &b );
        return b;
    }

    double DoubleValue() const {
        double d=0;
        QueryDoubleValue( &d );
        return d;
    }

    float FloatValue() const {
        float f=0;
        QueryFloatValue( &f );
        return f;
    }





    XMLError QueryIntValue( int* value ) const;

    XMLError QueryUnsignedValue( unsigned int* value ) const;

    XMLError QueryBoolValue( bool* value ) const;

    XMLError QueryDoubleValue( double* value ) const;

    XMLError QueryFloatValue( float* value ) const;


    void SetAttribute( const char* value );

    void SetAttribute( int value );

    void SetAttribute( unsigned value );

    void SetAttribute( bool value );

    void SetAttribute( double value );

    void SetAttribute( float value );

private:
    enum { BUF_SIZE = 200 };

    XMLAttribute() : _next( 0 ) {}
    virtual ~XMLAttribute() {}

    XMLAttribute( const XMLAttribute& );
    void operator=( const XMLAttribute& );
    void SetName( const char* name );

    char* ParseDeep( char* p, bool processEntities );

    mutable StrPair _name;
    mutable StrPair _value;
    XMLAttribute* _next;
    MemPool* _memPool;
};






class XMLElement : public XMLNode
{
    friend class XMLBase;
    friend class XMLDocument;
public:

    const char* Name() const {
        return Value();
    }

    void SetName( const char* str, bool staticMem=false ) {
        SetValue( str, staticMem );
    }

    virtual XMLElement* ToElement() {
        return this;
    }
    virtual const XMLElement* ToElement() const {
        return this;
    }
    virtual bool Accept( XMLVisitor* visitor ) const;
# 1123 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    const char* Attribute( const char* name, const char* value=0 ) const;






    int IntAttribute( const char* name ) const {
        int i=0;
        QueryIntAttribute( name, &i );
        return i;
    }

    unsigned UnsignedAttribute( const char* name ) const {
        unsigned i=0;
        QueryUnsignedAttribute( name, &i );
        return i;
    }

    bool BoolAttribute( const char* name ) const {
        bool b=false;
        QueryBoolAttribute( name, &b );
        return b;
    }

    double DoubleAttribute( const char* name ) const {
        double d=0;
        QueryDoubleAttribute( name, &d );
        return d;
    }

    float FloatAttribute( const char* name ) const {
        float f=0;
        QueryFloatAttribute( name, &f );
        return f;
    }
# 1173 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError QueryIntAttribute( const char* name, int* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryIntValue( value );
    }

    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryUnsignedValue( value );
    }

    XMLError QueryBoolAttribute( const char* name, bool* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryBoolValue( value );
    }

    XMLError QueryDoubleAttribute( const char* name, double* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryDoubleValue( value );
    }

    XMLError QueryFloatAttribute( const char* name, float* value ) const {
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryFloatValue( value );
    }


    void SetAttribute( const char* name, const char* value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, int value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, unsigned value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, bool value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    void SetAttribute( const char* name, double value ) {
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }




    void DeleteAttribute( const char* name );


    const XMLAttribute* FirstAttribute() const {
        return _rootAttribute;
    }

    const XMLAttribute* FindAttribute( const char* name ) const;
# 1279 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    const char* GetText() const;
# 1307 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError QueryIntText( int* ival ) const;

    XMLError QueryUnsignedText( unsigned* uval ) const;

    XMLError QueryBoolText( bool* bval ) const;

    XMLError QueryDoubleText( double* dval ) const;

    XMLError QueryFloatText( float* fval ) const;


    enum {
        OPEN,
        CLOSED,
        CLOSING
    };
    int ClosingType() const {
        return _closingType;
    }
    char* ParseDeep( char* p, StrPair* endTag );
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

private:
    XMLElement( XMLDocument* doc );
    virtual ~XMLElement();
    XMLElement( const XMLElement& );
    void operator=( const XMLElement& );

    XMLAttribute* FindAttribute( const char* name );
    XMLAttribute* FindOrCreateAttribute( const char* name );

    char* ParseAttributes( char* p );

    int _closingType;



    XMLAttribute* _rootAttribute;
};


enum Whitespace {
    PRESERVE_WHITESPACE,
    COLLAPSE_WHITESPACE
};







class XMLDocument : public XMLNode
{
    friend class XMLElement;
public:

    XMLDocument( bool processEntities = true, Whitespace = PRESERVE_WHITESPACE );
    ~XMLDocument();

    virtual XMLDocument* ToDocument() {
        return this;
    }
    virtual const XMLDocument* ToDocument() const {
        return this;
    }
# 1385 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError Parse( const char* xml, size_t nBytes=(size_t)(-1) );






    XMLError LoadFile( const char* filename );
# 1401 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError LoadFile( FILE* );






    XMLError SaveFile( const char* filename, bool compact = false );
# 1417 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLError SaveFile( FILE* fp, bool compact = false );

    bool ProcessEntities() const {
        return _processEntities;
    }
    Whitespace WhitespaceMode() const {
        return _whitespace;
    }




    bool HasBOM() const {
        return _writeBOM;
    }


    void SetBOM( bool useBOM ) {
        _writeBOM = useBOM;
    }




    XMLElement* RootElement() {
        return FirstChildElement();
    }
    const XMLElement* RootElement() const {
        return FirstChildElement();
    }
# 1462 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    void Print( XMLPrinter* streamer=0 );
    virtual bool Accept( XMLVisitor* visitor ) const;






    XMLElement* NewElement( const char* name );





    XMLComment* NewComment( const char* comment );





    XMLText* NewText( const char* text );
# 1494 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
    XMLDeclaration* NewDeclaration( const char* text=0 );





    XMLUnknown* NewUnknown( const char* text );





    void DeleteNode( XMLNode* node ) {
        node->_parent->DeleteChild( node );
    }

    void SetError( XMLError error, const char* str1, const char* str2 );


    bool Error() const {
        return _errorID != XML_NO_ERROR;
    }

    XMLError ErrorID() const {
        return _errorID;
    }

    const char* GetErrorStr1() const {
        return _errorStr1;
    }

    const char* GetErrorStr2() const {
        return _errorStr2;
    }

    void PrintError() const;


    char* Identify( char* p, XMLNode** node );

    virtual XMLNode* ShallowClone( XMLDocument* ) const {
        return 0;
    }
    virtual bool ShallowEqual( const XMLNode* ) const {
        return false;
    }

private:
    XMLDocument( const XMLDocument& );
    void operator=( const XMLDocument& );
    void InitDocument();

    bool _writeBOM;
    bool _processEntities;
    XMLError _errorID;
    Whitespace _whitespace;
    const char* _errorStr1;
    const char* _errorStr2;
    char* _charBuffer;

    MemPoolT< sizeof(XMLElement) > _elementPool;
    MemPoolT< sizeof(XMLAttribute) > _attributePool;
    MemPoolT< sizeof(XMLText) > _textPool;
    MemPoolT< sizeof(XMLComment) > _commentPool;
};
# 1616 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLHandle
{
public:

    XMLHandle( XMLNode* node ) {
        _node = node;
    }

    XMLHandle( XMLNode& node ) {
        _node = &node;
    }

    XMLHandle( const XMLHandle& ref ) {
        _node = ref._node;
    }

    XMLHandle& operator=( const XMLHandle& ref ) {
        _node = ref._node;
        return *this;
    }


    XMLHandle FirstChild() {
        return XMLHandle( _node ? _node->FirstChild() : 0 );
    }

    XMLHandle FirstChildElement( const char* value=0 ) {
        return XMLHandle( _node ? _node->FirstChildElement( value ) : 0 );
    }

    XMLHandle LastChild() {
        return XMLHandle( _node ? _node->LastChild() : 0 );
    }

    XMLHandle LastChildElement( const char* _value=0 ) {
        return XMLHandle( _node ? _node->LastChildElement( _value ) : 0 );
    }

    XMLHandle PreviousSibling() {
        return XMLHandle( _node ? _node->PreviousSibling() : 0 );
    }

    XMLHandle PreviousSiblingElement( const char* _value=0 ) {
        return XMLHandle( _node ? _node->PreviousSiblingElement( _value ) : 0 );
    }

    XMLHandle NextSibling() {
        return XMLHandle( _node ? _node->NextSibling() : 0 );
    }

    XMLHandle NextSiblingElement( const char* _value=0 ) {
        return XMLHandle( _node ? _node->NextSiblingElement( _value ) : 0 );
    }


    XMLNode* ToNode() {
        return _node;
    }

    XMLElement* ToElement() {
        return ( ( _node && _node->ToElement() ) ? _node->ToElement() : 0 );
    }

    XMLText* ToText() {
        return ( ( _node && _node->ToText() ) ? _node->ToText() : 0 );
    }

    XMLUnknown* ToUnknown() {
        return ( ( _node && _node->ToUnknown() ) ? _node->ToUnknown() : 0 );
    }

    XMLDeclaration* ToDeclaration() {
        return ( ( _node && _node->ToDeclaration() ) ? _node->ToDeclaration() : 0 );
    }

private:
    XMLNode* _node;
};






class XMLConstHandle
{
public:
    XMLConstHandle( const XMLNode* node ) {
        _node = node;
    }
    XMLConstHandle( const XMLNode& node ) {
        _node = &node;
    }
    XMLConstHandle( const XMLConstHandle& ref ) {
        _node = ref._node;
    }

    XMLConstHandle& operator=( const XMLConstHandle& ref ) {
        _node = ref._node;
        return *this;
    }

    const XMLConstHandle FirstChild() const {
        return XMLConstHandle( _node ? _node->FirstChild() : 0 );
    }
    const XMLConstHandle FirstChildElement( const char* value=0 ) const {
        return XMLConstHandle( _node ? _node->FirstChildElement( value ) : 0 );
    }
    const XMLConstHandle LastChild() const {
        return XMLConstHandle( _node ? _node->LastChild() : 0 );
    }
    const XMLConstHandle LastChildElement( const char* _value=0 ) const {
        return XMLConstHandle( _node ? _node->LastChildElement( _value ) : 0 );
    }
    const XMLConstHandle PreviousSibling() const {
        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );
    }
    const XMLConstHandle PreviousSiblingElement( const char* _value=0 ) const {
        return XMLConstHandle( _node ? _node->PreviousSiblingElement( _value ) : 0 );
    }
    const XMLConstHandle NextSibling() const {
        return XMLConstHandle( _node ? _node->NextSibling() : 0 );
    }
    const XMLConstHandle NextSiblingElement( const char* _value=0 ) const {
        return XMLConstHandle( _node ? _node->NextSiblingElement( _value ) : 0 );
    }


    const XMLNode* ToNode() const {
        return _node;
    }
    const XMLElement* ToElement() const {
        return ( ( _node && _node->ToElement() ) ? _node->ToElement() : 0 );
    }
    const XMLText* ToText() const {
        return ( ( _node && _node->ToText() ) ? _node->ToText() : 0 );
    }
    const XMLUnknown* ToUnknown() const {
        return ( ( _node && _node->ToUnknown() ) ? _node->ToUnknown() : 0 );
    }
    const XMLDeclaration* ToDeclaration() const {
        return ( ( _node && _node->ToDeclaration() ) ? _node->ToDeclaration() : 0 );
    }

private:
    const XMLNode* _node;
};
# 1807 "Cacao/include/cocos2dx/support/tinyxml2/tinyxml2.h"
class XMLPrinter : public XMLVisitor
{
public:






    XMLPrinter( FILE* file=0, bool compact = false );
    ~XMLPrinter() {}


    void PushHeader( bool writeBOM, bool writeDeclaration );



    void OpenElement( const char* name );

    void PushAttribute( const char* name, const char* value );
    void PushAttribute( const char* name, int value );
    void PushAttribute( const char* name, unsigned value );
    void PushAttribute( const char* name, bool value );
    void PushAttribute( const char* name, double value );

    void CloseElement();


    void PushText( const char* text, bool cdata=false );

    void PushText( int value );

    void PushText( unsigned value );

    void PushText( bool value );

    void PushText( float value );

    void PushText( double value );


    void PushComment( const char* comment );

    void PushDeclaration( const char* value );
    void PushUnknown( const char* value );

    virtual bool VisitEnter( const XMLDocument& );
    virtual bool VisitExit( const XMLDocument& ) {
        return true;
    }

    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute );
    virtual bool VisitExit( const XMLElement& element );

    virtual bool Visit( const XMLText& text );
    virtual bool Visit( const XMLComment& comment );
    virtual bool Visit( const XMLDeclaration& declaration );
    virtual bool Visit( const XMLUnknown& unknown );





    const char* CStr() const {
        return _buffer.Mem();
    }





    int CStrSize() const {
        return _buffer.Size();
    }

private:
    void SealElement();
    void PrintSpace( int depth );
    void PrintString( const char*, bool restrictedEntitySet );
    void Print( const char* format, ... );

    bool _elementJustOpened;
    bool _firstElement;
    FILE* _fp;
    int _depth;
    int _textDepth;
    bool _processEntities;
    bool _compactMode;

    enum {
        ENTITY_RANGE = 64,
        BUF_SIZE = 200
    };
    bool _entityFlag[ENTITY_RANGE];
    bool _restrictedEntityFlag[ENTITY_RANGE];

    DynArray< const char*, 10 > _stack;
    DynArray< char, 20 > _buffer;



};


}
# 266 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/text_input_node/CCIMEDelegate.h" 1
# 30 "Cacao/include/cocos2dx/text_input_node/CCIMEDelegate.h"
namespace cocos2d {






typedef struct
{
    CCRect begin;
    CCRect end;
    float duration;
} CCIMEKeyboardNotificationInfo;






class CCIMEDelegate
{
public:
    virtual ~CCIMEDelegate();

    virtual bool attachWithIME();
    virtual bool detachWithIME();

protected:
    friend class CCIMEDispatcher;






    virtual bool canAttachWithIME() { return false; }



    virtual void didAttachWithIME() {}




    virtual bool canDetachWithIME() { return false; }




    virtual void didDetachWithIME() {}




    virtual void insertText(const char * text, int len) {(void)text;(void)len;}




    virtual void deleteBackward() {}




    virtual const char * getContentText() { return 0; }




    virtual void keyboardWillShow(CCIMEKeyboardNotificationInfo& info) {(void)info;}
    virtual void keyboardDidShow(CCIMEKeyboardNotificationInfo& info) {(void)info;}
    virtual void keyboardWillHide(CCIMEKeyboardNotificationInfo& info) {(void)info;}
    virtual void keyboardDidHide(CCIMEKeyboardNotificationInfo& info) {(void)info;}

protected:
    CCIMEDelegate();
};




}
# 269 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h" 1
# 30 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h"
namespace cocos2d {
# 42 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h"
class CCIMEDispatcher
{
public:
    ~CCIMEDispatcher();




    static CCIMEDispatcher* sharedDispatcher();
# 60 "Cacao/include/cocos2dx/text_input_node/CCIMEDispatcher.h"
    void dispatchInsertText(const char * pText, int nLen);




    void dispatchDeleteBackward();




    const char * getContentText();




    void dispatchKeyboardWillShow(CCIMEKeyboardNotificationInfo& info);
    void dispatchKeyboardDidShow(CCIMEKeyboardNotificationInfo& info);
    void dispatchKeyboardWillHide(CCIMEKeyboardNotificationInfo& info);
    void dispatchKeyboardDidHide(CCIMEKeyboardNotificationInfo& info);

protected:
    friend class CCIMEDelegate;




    void addDelegate(CCIMEDelegate * pDelegate);






    bool attachDelegateWithIME(CCIMEDelegate * pDelegate);
    bool detachDelegateWithIME(CCIMEDelegate * pDelegate);




    void removeDelegate(CCIMEDelegate * pDelegate);

private:
    CCIMEDispatcher();

    class Impl;
    Impl * m_pImpl;
};




}
# 270 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/text_input_node/CCTextFieldTTF.h" 1
# 32 "Cacao/include/cocos2dx/text_input_node/CCTextFieldTTF.h"
namespace cocos2d {

class CCTextFieldTTF;
# 43 "Cacao/include/cocos2dx/text_input_node/CCTextFieldTTF.h"
class CCTextFieldDelegate
{
public:



    virtual bool onTextFieldAttachWithIME(CCTextFieldTTF * sender)
    {
        (void)sender;
        return false;
    }




    virtual bool onTextFieldDetachWithIME(CCTextFieldTTF * sender)
    {
        (void)sender;
        return false;
    }




    virtual bool onTextFieldInsertText(CCTextFieldTTF * sender, const char * text, int nLen)
    {
        (void)sender;
        (void)text;
        (void)nLen;
        return false;
    }




    virtual bool onTextFieldDeleteBackward(CCTextFieldTTF * sender, const char * delText, int nLen)
    {
        (void)sender;
        (void)delText;
        (void)nLen;
        return false;
    }




    virtual bool onDraw(CCTextFieldTTF * sender)
    {
        (void)sender;
        return false;
    }
};





class CCTextFieldTTF : public CCLabelTTF, public CCIMEDelegate
{
public:



    CCTextFieldTTF();



    virtual ~CCTextFieldTTF();




    static CCTextFieldTTF * textFieldWithPlaceHolder(const char *placeholder, const CCSize& dimensions, CCTextAlignment alignment, const char *fontName, float fontSize);

    static CCTextFieldTTF * textFieldWithPlaceHolder(const char *placeholder, const char *fontName, float fontSize);

    bool initWithPlaceHolder(const char *placeholder, const CCSize& dimensions, CCTextAlignment alignment, const char *fontName, float fontSize);

    bool initWithPlaceHolder(const char *placeholder, const char *fontName, float fontSize);




    virtual bool attachWithIME();




    virtual bool detachWithIME();






    protected: CCTextFieldDelegate * m_pDelegate;public: CCTextFieldDelegate * getDelegate(void) const { return m_pDelegate; }public: void setDelegate(CCTextFieldDelegate * var){ m_pDelegate = var; };
    protected: int m_nCharCount;public: int getCharCount(void) const { return m_nCharCount; };
    virtual const ccColor3B& getColorSpaceHolder();
    virtual void setColorSpaceHolder(const ccColor3B& color);


public:
    virtual void setString(const char *text);
    virtual const char* getString(void);
protected:
    std::string * m_pInputText;



public:
    virtual void setPlaceHolder(const char * text);
    virtual const char * getPlaceHolder(void);
protected:
    std::string * m_pPlaceHolder;
    ccColor3B m_ColorSpaceHolder;
public:
    virtual void setSecureTextEntry(bool value);
    virtual bool isSecureTextEntry();

protected:
    bool m_bSecureTextEntry;
protected:

    virtual void draw();





    virtual bool canAttachWithIME();
    virtual bool canDetachWithIME();
    virtual void insertText(const char * text, int len);
    virtual void deleteBackward();
    virtual const char * getContentText();
private:
    class LengthStack;
    LengthStack * m_pLens;
};




}
# 271 "Cacao/include/cocos2dx/cocos2d.h" 2




# 1 "Cacao/include/cocos2dx/textures/CCTextureCache.h" 1
# 42 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
namespace cocos2d {

class CCLock;
class CCImage;
# 56 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
class CCTextureCache : public CCObject
{
protected:
    CCDictionary* m_pTextures;



private:

    void addImageAsyncCallBack(float dt);
public:




    CCTextureCache();




    virtual ~CCTextureCache();




    const char* description(void);



    CCDictionary* snapshotTextures();




    static CCTextureCache * sharedTextureCache();




    static void purgeSharedTextureCache();
# 105 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
    CCTexture2D* addImage(char const* filename, bool);
# 117 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
    void addImageAsync(const char *path, CCObject *target, SEL_CallFuncO selector);
# 133 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
    CCTexture2D* addUIImage(CCImage *image, const char *key);




    CCTexture2D* textureForKey(const char* key);







    bool reloadTexture(const char* fileName);







    void removeAllTextures();






    void removeUnusedTextures();



    void removeTexture(CCTexture2D* texture);




    void removeTextureForKey(const char *textureKeyName);






    void dumpCachedTextureInfo();





    CCTexture2D* addPVRImage(const char* filename);






    CCTexture2D* addETCImage(const char* filename);




    static void reloadAllTextures();

};
# 262 "Cacao/include/cocos2dx/textures/CCTextureCache.h"
}
# 276 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/textures/CCTexturePVR.h" 1
# 34 "Cacao/include/cocos2dx/textures/CCTexturePVR.h"
namespace cocos2d {
# 44 "Cacao/include/cocos2dx/textures/CCTexturePVR.h"
struct CCPVRMipmap {
    unsigned char *address;
    unsigned int len;
};

typedef struct _ccPVRTexturePixelFormatInfo {
 GLenum internalFormat;
 GLenum format;
 GLenum type;
 uint32_t bpp;
 bool compressed;
 bool alpha;
 CCTexture2DPixelFormat ccPixelFormat;
} ccPVRTexturePixelFormatInfo;





enum {
    CC_PVRMIPMAP_MAX = 16,
};
# 92 "Cacao/include/cocos2dx/textures/CCTexturePVR.h"
class CCTexturePVR : public CCObject
{
public:
    CCTexturePVR();
    virtual ~CCTexturePVR();


    bool initWithContentsOfFile(const char* path);


    static CCTexturePVR* create(const char* path);




    inline unsigned int getName() { return m_uName; }

    inline unsigned int getWidth() { return m_uWidth; }

    inline unsigned int getHeight() { return m_uHeight; }

    inline bool hasAlpha() { return m_bHasAlpha; }

    inline bool hasPremultipliedAlpha() { return m_bHasPremultipliedAlpha; }

    inline bool isForcePremultipliedAlpha() { return m_bForcePremultipliedAlpha; }

    inline unsigned int getNumberOfMipmaps() { return m_uNumberOfMipmaps; }
    inline CCTexture2DPixelFormat getFormat() { return m_eFormat; }
    inline bool isRetainName() { return m_bRetainName; }
    inline void setRetainName(bool retainName) { m_bRetainName = retainName; }

private:
    bool unpackPVRv2Data(unsigned char* data, unsigned int len);
    bool unpackPVRv3Data(unsigned char* dataPointer, unsigned int dataLength);
    bool createGLTexture();

protected:
    struct CCPVRMipmap m_asMipmaps[CC_PVRMIPMAP_MAX];
    unsigned int m_uNumberOfMipmaps;

    unsigned int m_uWidth, m_uHeight;
    GLuint m_uName;
    bool m_bHasAlpha;
    bool m_bHasPremultipliedAlpha;
    bool m_bForcePremultipliedAlpha;


    bool m_bRetainName;
    CCTexture2DPixelFormat m_eFormat;

   const ccPVRTexturePixelFormatInfo *m_pPixelFormatInfo;
};




}
# 277 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCParallaxNode.h" 1
# 32 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCParallaxNode.h"
namespace cocos2d {

struct _ccArray;
# 46 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCParallaxNode.h"
class CCParallaxNode : public CCNode
{

    protected: struct _ccArray * m_pParallaxArray;public: virtual struct _ccArray * getParallaxArray(void) const { return m_pParallaxArray; }public: virtual void setParallaxArray(struct _ccArray * var){ m_pParallaxArray = var; }

public:





    CCParallaxNode();




    virtual ~CCParallaxNode();

    static CCParallaxNode * create();
    virtual void addChild(CCNode * child, unsigned int z, const CCPoint& parallaxRatio, const CCPoint& positionOffset);

    virtual void addChild(CCNode * child, unsigned int zOrder, int tag);
    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void removeAllChildrenWithCleanup(bool cleanup);
    virtual void visit(void);
private:
    CCPoint absolutePosition();
protected:
    CCPoint m_tLastPosition;
};




}
# 280 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h" 1
# 29 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXObjectGroup.h" 1
# 35 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXObjectGroup.h"
namespace cocos2d {
# 45 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXObjectGroup.h"
class CCTMXObjectGroup : public CCObject
{

    protected: CCPoint m_tPositionOffset;public: virtual const CCPoint& getPositionOffset(void) const { return m_tPositionOffset; }public: virtual void setPositionOffset(const CCPoint& var){ m_tPositionOffset = var; };

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;

    protected: CCArray* m_pObjects;public: virtual CCArray* getObjects(void);public: virtual void setObjects(CCArray* var);;
public:



    CCTMXObjectGroup();




    virtual ~CCTMXObjectGroup();

    inline const char* getGroupName(){ return m_sGroupName.c_str(); }
    inline void setGroupName(const char *groupName){ m_sGroupName = groupName; }


    CCString *propertyNamed(const char* propertyName);




    CCDictionary* objectNamed(const char *objectName);
protected:

    std::string m_sGroupName;
};




}
# 30 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h" 2


# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h" 1
# 38 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
namespace cocos2d {

class CCTMXObjectGroup;
# 55 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
enum {
    TMXLayerAttribNone = 1 << 0,
    TMXLayerAttribBase64 = 1 << 1,
    TMXLayerAttribGzip = 1 << 2,
    TMXLayerAttribZlib = 1 << 3,
};

enum {
    TMXPropertyNone,
    TMXPropertyMap,
    TMXPropertyLayer,
    TMXPropertyObjectGroup,
    TMXPropertyObject,
    TMXPropertyTile
};

typedef enum ccTMXTileFlags_ {
    kCCTMXTileHorizontalFlag = 0x80000000,
    kCCTMXTileVerticalFlag = 0x40000000,
    kCCTMXTileDiagonalFlag = 0x20000000,
    kCCFlipedAll = (kCCTMXTileHorizontalFlag|kCCTMXTileVerticalFlag|kCCTMXTileDiagonalFlag),
    kCCFlippedMask = ~(kCCFlipedAll)
} ccTMXTileFlags;
# 89 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
class CCTMXLayerInfo : public CCObject
{
    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:
    std::string m_sName;
    CCSize m_tLayerSize;
    unsigned int *m_pTiles;
    bool m_bVisible;
    unsigned char m_cOpacity;
    bool m_bOwnTiles;
    unsigned int m_uMinGID;
    unsigned int m_uMaxGID;
    CCPoint m_tOffset;
public:
    CCTMXLayerInfo();
    virtual ~CCTMXLayerInfo();
};
# 117 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
class CCTMXTilesetInfo : public CCObject
{
public:
    std::string m_sName;
    unsigned int m_uFirstGid;
    CCSize m_tTileSize;
    unsigned int m_uSpacing;
    unsigned int m_uMargin;

    std::string m_sSourceImage;

    CCSize m_tImageSize;
public:
    CCTMXTilesetInfo();
    virtual ~CCTMXTilesetInfo();
    CCRect rectForGID(unsigned int gid);
};
# 148 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXXMLParser.h"
class CCTMXMapInfo : public CCObject, public CCSAXDelegator
{
public:

    protected: int m_nOrientation;public: virtual int getOrientation(void) const { return m_nOrientation; }public: virtual void setOrientation(int var){ m_nOrientation = var; };

    protected: CCSize m_tMapSize;public: virtual const CCSize& getMapSize(void) const { return m_tMapSize; }public: virtual void setMapSize(const CCSize& var){ m_tMapSize = var; };

    protected: CCSize m_tTileSize;public: virtual const CCSize& getTileSize(void) const { return m_tTileSize; }public: virtual void setTileSize(const CCSize& var){ m_tTileSize = var; };

    protected: CCArray* m_pLayers;public: virtual CCArray* getLayers(void);public: virtual void setLayers(CCArray* var);;

    protected: CCArray* m_pTilesets;public: virtual CCArray* getTilesets(void);public: virtual void setTilesets(CCArray* var);;

    protected: CCArray* m_pObjectGroups;public: virtual CCArray* getObjectGroups(void);public: virtual void setObjectGroups(CCArray* var);;

    protected: int m_nParentElement;public: virtual int getParentElement(void) const { return m_nParentElement; }public: virtual void setParentElement(int var){ m_nParentElement = var; };

    protected: unsigned int m_uParentGID;public: virtual unsigned int getParentGID(void) const { return m_uParentGID; }public: virtual void setParentGID(unsigned int var){ m_uParentGID = var; };

    protected: int m_nLayerAttribs;public: virtual int getLayerAttribs(void) const { return m_nLayerAttribs; }public: virtual void setLayerAttribs(int var){ m_nLayerAttribs = var; };

    protected: bool m_bStoringCharacters;public: virtual bool getStoringCharacters(void) const { return m_bStoringCharacters; }public: virtual void setStoringCharacters(bool var){ m_bStoringCharacters = var; };

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:




    CCTMXMapInfo();




    virtual ~CCTMXMapInfo();

    static CCTMXMapInfo * formatWithTMXFile(const char *tmxFile);

    static CCTMXMapInfo * formatWithXML(const char* tmxString, const char* resourcePath);



    bool initWithTMXFile(const char *tmxFile);



    bool initWithXML(const char* tmxString, const char* resourcePath);

    bool parseXMLFile(const char *xmlFilename);

    bool parseXMLString(const char *xmlString);

    CCDictionary* getTileProperties();
    void setTileProperties(CCDictionary* tileProperties);




    void startElement(void *ctx, const char *name, const char **atts);



    void endElement(void *ctx, const char *name);



    void textHandler(void *ctx, const char *ch, int len);

    inline const char* getCurrentString(){ return m_sCurrentString.c_str(); }
    inline void setCurrentString(const char *currentString){ m_sCurrentString = currentString; }
    inline const char* getTMXFileName(){ return m_sTMXFileName.c_str(); }
    inline void setTMXFileName(const char *fileName){ m_sTMXFileName = fileName; }
private:
    void internalInit(const char* tmxFileName, const char* resourcePath);
protected:

    std::string m_sTMXFileName;

    std::string m_sResources;

    std::string m_sCurrentString;

    CCDictionary* m_pTileProperties;
    unsigned int m_uCurrentFirstGID;
};




}
# 33 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h" 2
namespace cocos2d {

class CCTMXMapInfo;
class CCTMXLayerInfo;
class CCTMXTilesetInfo;
struct _ccCArray;
# 74 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
class CCTMXLayer : public CCSpriteBatchNode
{

    protected: CCSize m_tLayerSize;public: virtual const CCSize& getLayerSize(void) const { return m_tLayerSize; }public: virtual void setLayerSize(const CCSize& var){ m_tLayerSize = var; };

    protected: CCSize m_tMapTileSize;public: virtual const CCSize& getMapTileSize(void) const { return m_tMapTileSize; }public: virtual void setMapTileSize(const CCSize& var){ m_tMapTileSize = var; };

    protected: unsigned int* m_pTiles;public: virtual unsigned int* getTiles(void) const { return m_pTiles; }public: virtual void setTiles(unsigned int* var){ m_pTiles = var; };

    protected: CCTMXTilesetInfo* m_pTileSet;public: virtual CCTMXTilesetInfo* getTileSet(void);public: virtual void setTileSet(CCTMXTilesetInfo* var);;

    protected: unsigned int m_uLayerOrientation;public: virtual unsigned int getLayerOrientation(void) const { return m_uLayerOrientation; }public: virtual void setLayerOrientation(unsigned int var){ m_uLayerOrientation = var; };

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:




    CCTMXLayer();




    virtual ~CCTMXLayer();


    static CCTMXLayer * create(CCTMXTilesetInfo *tilesetInfo, CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);




    bool initWithTilesetInfo(CCTMXTilesetInfo *tilesetInfo, CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);





    void releaseMap();
# 122 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
    CCSprite* tileAt(const CCPoint& tileCoordinate);






    unsigned int tileGIDAt(const CCPoint& tileCoordinate);






    unsigned int tileGIDAt(const CCPoint& tileCoordinate, ccTMXTileFlags* flags);





    void setTileGID(unsigned int gid, const CCPoint& tileCoordinate);
# 151 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXLayer.h"
    void setTileGID(unsigned int gid, const CCPoint& tileCoordinate, ccTMXTileFlags flags);


    void removeTileAt(const CCPoint& tileCoordinate);




    CCPoint positionAt(const CCPoint& tileCoordinate);




    CCString *propertyNamed(const char *propertyName);


    void setupTiles();





    virtual void addChild(CCNode * child, int zOrder, int tag);



    void removeChild(CCNode* child, bool cleanup);

    inline const char* getLayerName(){ return m_sLayerName.c_str(); }
    inline void setLayerName(const char *layerName){ m_sLayerName = layerName; }
private:
    CCPoint positionForIsoAt(const CCPoint& pos);
    CCPoint positionForOrthoAt(const CCPoint& pos);
    CCPoint positionForHexAt(const CCPoint& pos);

    CCPoint calculateLayerOffset(const CCPoint& offset);


    CCSprite* appendTileForGID(unsigned int gid, const CCPoint& pos);
    CCSprite* insertTileForGID(unsigned int gid, const CCPoint& pos);
    CCSprite* updateTileForGID(unsigned int gid, const CCPoint& pos);


    void parseInternalProperties();
    void setupTileSprite(CCSprite* sprite, CCPoint pos, unsigned int gid);
    CCSprite* reusedTileWithRect(CCRect rect);
    int vertexZForPos(const CCPoint& pos);


    unsigned int atlasIndexForExistantZ(unsigned int z);
    unsigned int atlasIndexForNewZ(int z);
protected:

    std::string m_sLayerName;

    unsigned char m_cOpacity;

    unsigned int m_uMinGID;
    unsigned int m_uMaxGID;


    int m_nVertexZvalue;
    bool m_bUseAutomaticVertexZ;


    CCSprite *m_pReusedTile;
    ccCArray *m_pAtlasIndexArray;


    float m_fContentScaleFactor;
};




}
# 281 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXTiledMap.h" 1
# 32 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXTiledMap.h"
namespace cocos2d {

class CCTMXObjectGroup;
class CCTMXLayer;
class CCTMXLayerInfo;
class CCTMXTilesetInfo;
class CCTMXMapInfo;







enum
{

    CCTMXOrientationOrtho,


    CCTMXOrientationHex,


    CCTMXOrientationIso,
};
# 109 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTMXTiledMap.h"
class CCTMXTiledMap : public CCNode
{

    protected: CCSize m_tMapSize;public: virtual const CCSize& getMapSize(void) const { return m_tMapSize; }public: virtual void setMapSize(const CCSize& var){ m_tMapSize = var; };

    protected: CCSize m_tTileSize;public: virtual const CCSize& getTileSize(void) const { return m_tTileSize; }public: virtual void setTileSize(const CCSize& var){ m_tTileSize = var; };

    protected: int m_nMapOrientation;public: virtual int getMapOrientation(void) const { return m_nMapOrientation; }public: virtual void setMapOrientation(int var){ m_nMapOrientation = var; };

    protected: CCArray* m_pObjectGroups;public: virtual CCArray* getObjectGroups(void);public: virtual void setObjectGroups(CCArray* var);;

    protected: CCDictionary* m_pProperties;public: virtual CCDictionary* getProperties(void);public: virtual void setProperties(CCDictionary* var);;
public:



    CCTMXTiledMap();




    virtual ~CCTMXTiledMap();


    static CCTMXTiledMap* create(const char *tmxFile);


    static CCTMXTiledMap* createWithXML(const char* tmxString, const char* resourcePath);


    bool initWithTMXFile(const char *tmxFile);


    bool initWithXML(const char* tmxString, const char* resourcePath);




    CCTMXLayer* layerNamed(const char *layerName);




    CCTMXObjectGroup* objectGroupNamed(const char *groupName);




    CCString *propertyNamed(const char *propertyName);


    CCDictionary* propertiesForGID(int GID);

private:
    CCTMXLayer * parseLayer(CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);
    CCTMXTilesetInfo * tilesetForLayer(CCTMXLayerInfo *layerInfo, CCTMXMapInfo *mapInfo);
    void buildWithMapInfo(CCTMXMapInfo* mapInfo);
protected:

    CCDictionary* m_pTileProperties;

};




}
# 283 "Cacao/include/cocos2dx/cocos2d.h" 2

# 1 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTileMapAtlas.h" 1
# 32 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTileMapAtlas.h"
namespace cocos2d {

struct sImageTGA;
class CCDictionary;
# 57 "Cacao/include/cocos2dx/tilemap_parallax_nodes/CCTileMapAtlas.h"
class CCTileMapAtlas : public CCAtlasNode
{

    protected: struct sImageTGA* m_pTGAInfo;public: virtual struct sImageTGA* getTGAInfo(void);public: virtual void setTGAInfo(struct sImageTGA* var);;
public:



    CCTileMapAtlas();




    virtual ~CCTileMapAtlas();




    static CCTileMapAtlas * create(const char *tile, const char *mapFile, int tileWidth, int tileHeight);




    bool initWithTileFile(const char *tile, const char *mapFile, int tileWidth, int tileHeight);




    ccColor3B tileAt(const CCPoint& position);



    void setTile(const ccColor3B& tile, const CCPoint& position);

    void releaseMap();
private:
    void loadTGAfile(const char *file);
    void calculateItemsToRender();
    void updateAtlasValueAt(const CCPoint& pos, const ccColor3B& value, unsigned int index);
    void updateAtlasValues();

protected:

    CCDictionary* m_pPosToAtlasIndex;

    int m_nItemsToRender;
};




}
# 285 "Cacao/include/cocos2dx/cocos2d.h" 2




# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDispatcher.h" 1
# 33 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDispatcher.h"
namespace cocos2d {






typedef enum
{
    ccTouchSelectorBeganBit = 1 << 0,
    ccTouchSelectorMovedBit = 1 << 1,
    ccTouchSelectorEndedBit = 1 << 2,
    ccTouchSelectorCancelledBit = 1 << 3,
    ccTouchSelectorAllBits = ( ccTouchSelectorBeganBit | ccTouchSelectorMovedBit | ccTouchSelectorEndedBit | ccTouchSelectorCancelledBit),
} ccTouchSelectorFlag;


enum {
    CCTOUCHBEGAN,
    CCTOUCHMOVED,
    CCTOUCHENDED,
    CCTOUCHCANCELLED,

    ccTouchMax,
};

class CCSet;
class CCEvent;

struct ccTouchHandlerHelperData {



    int m_type;
};




class EGLTouchDelegate
{
public:



    virtual void touchesBegan(CCSet* touches, CCEvent* pEvent) = 0;



    virtual void touchesMoved(CCSet* touches, CCEvent* pEvent) = 0;



    virtual void touchesEnded(CCSet* touches, CCEvent* pEvent) = 0;



    virtual void touchesCancelled(CCSet* touches, CCEvent* pEvent) = 0;



    virtual ~EGLTouchDelegate() {}
};

class CCTouchHandler;
struct _ccCArray;
# 116 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchDispatcher.h"
class CCTouchDispatcher : public CCObject, public EGLTouchDelegate
{
public:



    ~CCTouchDispatcher();



    bool init(void);



    CCTouchDispatcher()
        : m_pTargetedHandlers(__null)
        , m_pStandardHandlers(__null)
        , m_pHandlersToAdd(__null)
        , m_pHandlersToRemove(__null)

    {}

public:

    bool isDispatchEvents(void);
    void setDispatchEvents(bool bDispatchEvents);






    void addStandardDelegate(CCTouchDelegate *pDelegate, int nPriority);






    void addTargetedDelegate(CCTouchDelegate *pDelegate, int nPriority, bool bSwallowsTouches);





    void removeDelegate(CCTouchDelegate *pDelegate);




    void removeAllDelegates(void);





    void setPriority(int nPriority, CCTouchDelegate *pDelegate);


    void incrementForcePrio(int nPrio);



    void touches(CCSet *pTouches, CCEvent *pEvent, unsigned int uIndex);



    virtual void touchesBegan(CCSet* touches, CCEvent* pEvent);



    virtual void touchesMoved(CCSet* touches, CCEvent* pEvent);



    virtual void touchesEnded(CCSet* touches, CCEvent* pEvent);



    virtual void touchesCancelled(CCSet* touches, CCEvent* pEvent);

public:



    CCTouchHandler* findHandler(CCTouchDelegate *pDelegate);
protected:
    void forceRemoveDelegate(CCTouchDelegate *pDelegate);
    void forceAddHandler(CCTouchHandler *pHandler, CCArray* pArray);
    void forceRemoveAllDelegates(void);
    void rearrangeHandlers(CCArray* pArray);
    CCTouchHandler* findHandler(CCArray* pArray, CCTouchDelegate *pDelegate);

protected:
     CCArray* m_pTargetedHandlers;
     CCArray* m_pStandardHandlers;

    bool m_bLocked;
    bool m_bToAdd;
    bool m_bToRemove;
     CCArray* m_pHandlersToAdd;
    struct _ccCArray *m_pHandlersToRemove;
    bool m_bToQuit;
    bool m_bDispatchEvents;


    struct ccTouchHandlerHelperData m_sHandlerHelperData[ccTouchMax];
};




}
# 290 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h" 1
# 34 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h"
namespace cocos2d {
# 47 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h"
class CCTouchHandler : public CCObject
{
public:
    virtual ~CCTouchHandler(void);


    CCTouchDelegate* getDelegate();
    void setDelegate(CCTouchDelegate *pDelegate);


    int getPriority(void);
    void setPriority(int nPriority);


    int getEnabledSelectors(void);
    void setEnalbedSelectors(int nValue);


    virtual bool initWithDelegate(CCTouchDelegate *pDelegate, int nPriority);

public:

    static CCTouchHandler* handlerWithDelegate(CCTouchDelegate *pDelegate, int nPriority);

protected:
    CCTouchDelegate *m_pDelegate;
    int m_nPriority;
    int m_nEnabledSelectors;
};






class CCStandardTouchHandler : public CCTouchHandler
{
public:

    virtual bool initWithDelegate(CCTouchDelegate *pDelegate, int nPriority);

public:

    static CCStandardTouchHandler* handlerWithDelegate(CCTouchDelegate *pDelegate, int nPriority);
};
# 100 "Cacao/include/cocos2dx/touch_dispatcher/CCTouchHandler.h"
class CCTargetedTouchHandler : public CCTouchHandler
{
public:
    ~CCTargetedTouchHandler(void);


    bool isSwallowsTouches(void);
    void setSwallowsTouches(bool bSwallowsTouches);


    CCSet* getClaimedTouches(void);


    bool initWithDelegate(CCTouchDelegate *pDelegate, int nPriority, bool bSwallow);

public:

    static CCTargetedTouchHandler* handlerWithDelegate(CCTouchDelegate *pDelegate, int nPriority, bool bSwallow);

protected:
    bool m_bSwallowsTouches;
    CCSet *m_pClaimedTouches;
};




}
# 291 "Cacao/include/cocos2dx/cocos2d.h" 2





# 1 "Cacao/include/cocos2dx/CCScheduler.h" 1
# 33 "Cacao/include/cocos2dx/CCScheduler.h"
namespace cocos2d {
# 46 "Cacao/include/cocos2dx/CCScheduler.h"
class CCSet;





class CCTimer : public CCObject
{
public:




    CCTimer(void);


    float getInterval(void) const;

    void setInterval(float fInterval);



    SEL_SCHEDULE getSelector() const;




    bool initWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector);




    bool initWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector, float fSeconds, unsigned int nRepeat, float fDelay);


    bool initWithScriptHandler(int nHandler, float fSeconds);


    void update(float dt);

public:



    static CCTimer* timerWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector);




    static CCTimer* timerWithTarget(CCObject *pTarget, SEL_SCHEDULE pfnSelector, float fSeconds);


    static CCTimer* timerWithScriptHandler(int nHandler, float fSeconds);



    inline int getScriptHandler() { return m_nScriptHandler; };

protected:
    CCObject *m_pTarget;
    float m_fElapsed;
    bool m_bRunForever;
    bool m_bUseDelay;
    unsigned int m_uTimesExecuted;
    unsigned int m_uRepeat;
    float m_fDelay;
    float m_fInterval;
    SEL_SCHEDULE m_pfnSelector;

    int m_nScriptHandler;
};




struct _listEntry;
struct _hashSelectorEntry;
struct _hashUpdateEntry;

class CCArray;
# 138 "Cacao/include/cocos2dx/CCScheduler.h"
class CCScheduler : public CCObject
{
public:
    CCScheduler();




    ~CCScheduler(void);

    inline float getTimeScale(void) { return m_fTimeScale; }







    inline void setTimeScale(float fTimeScale) { m_fTimeScale = fTimeScale; }






    void update(float dt);
# 176 "Cacao/include/cocos2dx/CCScheduler.h"
    void scheduleSelector(SEL_SCHEDULE pfnSelector, CCObject *pTarget, float fInterval, unsigned int repeat, float delay, bool bPaused);





    void scheduleSelector(SEL_SCHEDULE pfnSelector, CCObject *pTarget, float fInterval, bool bPaused);






    void scheduleUpdateForTarget(CCObject *pTarget, int nPriority, bool bPaused);






    void unscheduleSelector(SEL_SCHEDULE pfnSelector, CCObject *pTarget);





    void unscheduleUpdateForTarget(const CCObject *pTarget);







    void unscheduleAllForTarget(CCObject *pTarget);
# 219 "Cacao/include/cocos2dx/CCScheduler.h"
    void unscheduleAll(void);







    void unscheduleAllWithMinPriority(int nMinPriority);







    unsigned int scheduleScriptFunc(unsigned int nHandler, float fInterval, bool bPaused);




    void unscheduleScriptEntry(unsigned int uScheduleScriptEntryID);







    void pauseTarget(CCObject *pTarget);







    void resumeTarget(CCObject *pTarget);





    bool isTargetPaused(CCObject *pTarget);






    CCSet* pauseAllTargets();






    CCSet* pauseAllTargetsWithMinPriority(int nMinPriority);






    void resumeTargets(CCSet* targetsToResume);

private:
    void removeHashElement(struct _hashSelectorEntry *pElement);
    void removeUpdateFromHash(struct _listEntry *entry);



    void priorityIn(struct _listEntry **ppList, CCObject *pTarget, int nPriority, bool bPaused);
    void appendIn(struct _listEntry **ppList, CCObject *pTarget, bool bPaused);

protected:
    float m_fTimeScale;




    struct _listEntry *m_pUpdatesNegList;
    struct _listEntry *m_pUpdates0List;
    struct _listEntry *m_pUpdatesPosList;
    struct _hashUpdateEntry *m_pHashForUpdates;


    struct _hashSelectorEntry *m_pHashForTimers;
    struct _hashSelectorEntry *m_pCurrentTarget;
    bool m_bCurrentTargetSalvaged;

    bool m_bUpdateHashLocked;
    CCArray* m_pScriptHandlerEntries;
};




}
# 297 "Cacao/include/cocos2dx/cocos2d.h" 2


# 1 "Cacao/include/cocos2dx/support/component/CCComponent.h" 1
# 31 "Cacao/include/cocos2dx/support/component/CCComponent.h"
namespace cocos2d {

class CCComponent : public CCObject
{
protected:
    CCComponent(void);
public:




    virtual ~CCComponent(void);
    virtual bool init();




    virtual void onEnter();




    virtual void onExit();
    virtual void update(float delta);
    virtual bool serialize(void* r);
    virtual bool isEnabled() const;
    virtual void setEnabled(bool b);
    static CCComponent* create(void);

    const char* getName() const;
 void setName(const char *pName);

    void setOwner(CCNode *pOwner);
    CCNode* getOwner() const;

protected:
    CCNode *m_pOwner;
    std::string m_strName;
    bool m_bEnabled;
};

}
# 300 "Cacao/include/cocos2dx/cocos2d.h" 2
# 1 "Cacao/include/cocos2dx/support/component/CCComponentContainer.h" 1
# 30 "Cacao/include/cocos2dx/support/component/CCComponentContainer.h"
namespace cocos2d {

class CCComponent;
class CCNode;




class CCComponentContainer
{
protected:
    CCComponentContainer(CCNode *pNode);

public:
    virtual ~CCComponentContainer(void);
    virtual CCComponent* get(const char *pName) const;
    virtual bool add(CCComponent *pCom);
    virtual bool remove(const char *pName);
    virtual void removeAll();
    virtual void visit(float fDelta);
public:
    bool isEmpty() const;

private:
    void alloc(void);

private:
    CCDictionary *m_pComponents;
    CCNode *m_pOwner;

    friend class CCNode;
};

}
# 301 "Cacao/include/cocos2dx/cocos2d.h" 2

namespace cocos2d {

       const char* cocos2dVersion();

}
# 3 "Cacao/include/cocos2dx/custom/Sprites/CCMenuItemSpriteExtra/CCMenuItemSpriteExtra.h" 2

class CCMenuItemSpriteExtra : public cocos2d::CCMenuItemSprite{
private:
 float m_sizeMult = 1.25;
 float m_origScale = 1.f;
public:
 virtual void selected() override;
 virtual void unselected() override;
 virtual void activate() override;
 virtual void setScale(float scale) override;
 static CCMenuItemSpriteExtra* create(CCNode *normalSprite, CCNode *selectedSprite, CCObject *target, cocos2d::SEL_MenuHandler selector);
 void setSizeMult(float multiplier) { m_sizeMult = multiplier; }
};
# 10 "Cacao/include/cc_defs.hpp" 2

# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1



# 1 "Cacao/include/cocos2dext/ExtensionMacros.h" 1
# 5 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCBFileLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCInvocation.h" 1
# 36 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCInvocation.h"
namespace cocos2d { namespace extension {
# 45 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCInvocation.h"
typedef unsigned int CCControlEvent;

typedef void (CCObject::*SEL_CCControlHandler)(CCObject*, CCControlEvent);







class CCInvocation : public CCObject
{
    protected: SEL_CCControlHandler m_action;public: virtual SEL_CCControlHandler getAction(void) const { return m_action; };
    protected: CCObject* m_target;public: virtual CCObject* getTarget(void) const { return m_target; };
    protected: CCControlEvent m_controlEvent;public: virtual CCControlEvent getControlEvent(void) const { return m_controlEvent; };

public:
    static CCInvocation* create(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);
    CCInvocation(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);

    void invoke(CCObject* sender);
};





}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCBReader.h" 1







# 1 "Cacao/include/cocos2dext/CCBReader/CCBSequence.h" 1






# 1 "Cacao/include/cocos2dext/CCBReader/CCBSequenceProperty.h" 1





# 1 "Cacao/include/cocos2dext/CCBReader/CCBKeyframe.h" 1






namespace cocos2d { namespace extension {




class CCBKeyframe : public CCObject
{
private:
    CCObject *mValue;
    float mTime;
    int mEasingType;
    float mEasingOpt;

public:
    CCBKeyframe();
    ~CCBKeyframe();

    CCObject* getValue();
    void setValue(CCObject *pValue);

    float getTime();
    void setTime(float fTime);

    int getEasingType();
    void setEasingType(int nEasingType);

    float getEasingOpt();
    void setEasingOpt(float fEasingOpt);
};

}}
# 7 "Cacao/include/cocos2dext/CCBReader/CCBSequenceProperty.h" 2

namespace cocos2d { namespace extension {




class CCBSequenceProperty : public CCObject
{
private:
    std::string mName;
    int mType;
    CCArray *mKeyframes;

public:
    CCBSequenceProperty();
    ~CCBSequenceProperty();

    virtual bool init();

    const char* getName();
    void setName(const char* pName);

    int getType();
    void setType(int nType);

    CCArray* getKeyframes();
};

}}
# 8 "Cacao/include/cocos2dext/CCBReader/CCBSequence.h" 2

namespace cocos2d { namespace extension {




class CCBSequence : public CCObject
{
private:
    float mDuration;
    std::string mName;
    int mSequenceId;
    int mChainedSequenceId;
    CCBSequenceProperty* mCallbackChannel;
    CCBSequenceProperty* mSoundChannel;

public:
    CCBSequence();
    ~CCBSequence();
    float getDuration();
    void setDuration(float fDuration);

    CCBSequenceProperty* getCallbackChannel();
    void setCallbackChannel(CCBSequenceProperty* callbackChannel);

    CCBSequenceProperty* getSoundChannel();
    void setSoundChannel(CCBSequenceProperty* soundChannel);

    const char* getName();
    void setName(const char *pName);

    int getSequenceId();
    void setSequenceId(int nSequenceId);

    int getChainedSequenceId();
    void setChainedSequenceId(int nChainedSequenceId);
};


}}
# 9 "Cacao/include/cocos2dext/CCBReader/CCBReader.h" 2
# 1 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h" 1
# 34 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlUtils.h" 1
# 40 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlUtils.h"
namespace cocos2d { namespace extension {

typedef struct
{
    double r;
    double g;
    double b;
    double a;
} RGBA;

typedef struct
{
    double h;
    double s;
    double v;
} HSV;
# 68 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlUtils.h"
class CCColor3bObject : public CCObject
{
public:
    ccColor3B value;
    CCColor3bObject(ccColor3B s_value):value(s_value){}
};

class CCControlUtils
{
public:
    static CCSprite* addSpriteToTargetWithPosAndAnchor(const char* spriteName, CCNode * target, CCPoint pos, CCPoint anchor);
    static HSV HSVfromRGB(RGBA value);
    static RGBA RGBfromHSV(HSV value);
    static CCRect CCRectUnion(const CCRect& src1, const CCRect& src2);
};





}}
# 35 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h" 2


namespace cocos2d { namespace extension {

class CCInvocation;
# 52 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
enum
{
    CCControlEventTouchDown = 1 << 0,
    CCControlEventTouchDragInside = 1 << 1,
    CCControlEventTouchDragOutside = 1 << 2,
    CCControlEventTouchDragEnter = 1 << 3,
    CCControlEventTouchDragExit = 1 << 4,
    CCControlEventTouchUpInside = 1 << 5,
    CCControlEventTouchUpOutside = 1 << 6,
    CCControlEventTouchCancel = 1 << 7,
    CCControlEventValueChanged = 1 << 8
};
typedef unsigned int CCControlEvent;


enum
{
    CCControlStateNormal = 1 << 0,
    CCControlStateHighlighted = 1 << 1,
    CCControlStateDisabled = 1 << 2,
    CCControlStateSelected = 1 << 3
};
typedef unsigned int CCControlState;
# 88 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
class CCControl : public CCLayerRGBA
{


    bool m_bIsOpacityModifyRGB;


    protected: CCControlState m_eState;public: virtual CCControlState getState(void) const { return m_eState; };


protected:
    bool m_hasVisibleParents;

public:

    virtual void setEnabled(bool bEnabled);
    virtual bool isEnabled();

    virtual void setSelected(bool bSelected);
    virtual bool isSelected();

    virtual void setHighlighted(bool bHighlighted);
    virtual bool isHighlighted();
    bool hasVisibleParents();



    virtual void needsLayout();

    virtual bool isOpacityModifyRGB();
    virtual void setOpacityModifyRGB(bool bOpacityModifyRGB);

protected:
    bool m_bEnabled;
    bool m_bSelected;
    bool m_bHighlighted;






    CCDictionary* m_pDispatchTable;

public:



    CCControl();
    virtual bool init(void);




    virtual ~CCControl();





    virtual void onEnter();




    virtual void onExit();
    virtual void registerWithTouchDispatcher();







    virtual void sendActionsForControlEvents(CCControlEvent controlEvents);
# 177 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    virtual void addTargetWithActionForControlEvents(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvents);
# 191 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    virtual void removeTargetWithActionForControlEvents(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvents);






    virtual CCPoint getTouchLocation(CCTouch* touch);
# 209 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    virtual bool isTouchInside(CCTouch * touch);


protected:
# 226 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    CCInvocation* invocationWithTargetAndActionForControlEvent(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);
# 240 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    CCArray* dispatchListforControlEvent(CCControlEvent controlEvent);
# 254 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    void addTargetWithActionForControlEvent(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);
# 268 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControl.h"
    void removeTargetWithActionForControlEvent(CCObject* target, SEL_CCControlHandler action, CCControlEvent controlEvent);

    static CCControl* create();
public:



    void addHandleOfControlEvent(int nFunID,CCControlEvent controlEvent);



    void removeHandleOfControlEvent(CCControlEvent controlEvent);
private:
    int getHandleOfControlEvent(CCControlEvent controlEvent);
private:
    std::map<int,int> m_mapHandleOfControlEvent;
};





}}
# 10 "Cacao/include/cocos2dext/CCBReader/CCBReader.h" 2
# 34 "Cacao/include/cocos2dext/CCBReader/CCBReader.h"
enum {
    kCCBPropTypePosition = 0,
    kCCBPropTypeSize,
    kCCBPropTypePoint,
    kCCBPropTypePointLock,
    kCCBPropTypeScaleLock,
    kCCBPropTypeDegrees,
    kCCBPropTypeInteger,
    kCCBPropTypeFloat,
    kCCBPropTypeFloatVar,
    kCCBPropTypeCheck,
    kCCBPropTypeSpriteFrame,
    kCCBPropTypeTexture,
    kCCBPropTypeByte,
    kCCBPropTypeColor3,
    kCCBPropTypeColor4FVar,
    kCCBPropTypeFlip,
    kCCBPropTypeBlendmode,
    kCCBPropTypeFntFile,
    kCCBPropTypeText,
    kCCBPropTypeFontTTF,
    kCCBPropTypeIntegerLabeled,
    kCCBPropTypeBlock,
 kCCBPropTypeAnimation,
    kCCBPropTypeCCBFile,
    kCCBPropTypeString,
    kCCBPropTypeBlockCCControl,
    kCCBPropTypeFloatScale,
    kCCBPropTypeFloatXY
};

enum {
    kCCBFloat0 = 0,
    kCCBFloat1,
    kCCBFloatMinus1,
    kCCBFloat05,
    kCCBFloatInteger,
    kCCBFloatFull
};

enum {
    kCCBPlatformAll = 0,
    kCCBPlatformIOS,
    kCCBPlatformMac
};

enum {
    kCCBTargetTypeNone = 0,
    kCCBTargetTypeDocumentRoot = 1,
    kCCBTargetTypeOwner = 2,
};

enum
{
    kCCBKeyframeEasingInstant,

    kCCBKeyframeEasingLinear,

    kCCBKeyframeEasingCubicIn,
    kCCBKeyframeEasingCubicOut,
    kCCBKeyframeEasingCubicInOut,

    kCCBKeyframeEasingElasticIn,
    kCCBKeyframeEasingElasticOut,
    kCCBKeyframeEasingElasticInOut,

    kCCBKeyframeEasingBounceIn,
    kCCBKeyframeEasingBounceOut,
    kCCBKeyframeEasingBounceInOut,

    kCCBKeyframeEasingBackIn,
    kCCBKeyframeEasingBackOut,
    kCCBKeyframeEasingBackInOut,
};

enum
{
    kCCBPositionTypeRelativeBottomLeft,
    kCCBPositionTypeRelativeTopLeft,
    kCCBPositionTypeRelativeTopRight,
    kCCBPositionTypeRelativeBottomRight,
    kCCBPositionTypePercent,
    kCCBPositionTypeMultiplyResolution,
};

enum
{
    kCCBSizeTypeAbsolute,
    kCCBSizeTypePercent,
    kCCBSizeTypeRelativeContainer,
    kCCBSizeTypeHorizontalPercent,
    kCCBSizeTypeVerticalPercent,
    kCCBSizeTypeMultiplyResolution,
};

enum
{
    kCCBScaleTypeAbsolute,
    kCCBScaleTypeMultiplyResolution
};


namespace cocos2d { namespace extension {
# 145 "Cacao/include/cocos2dext/CCBReader/CCBReader.h"
class CCBFile : public CCNode
{
private:
    CCNode *mCCBFileNode;

public:
    CCBFile();

    static CCBFile* create();

    CCNode* getCCBFileNode();
    void setCCBFileNode(CCNode *pNode);
};


class CCNodeLoader;
class CCNodeLoaderLibrary;
class CCNodeLoaderListener;
class CCBMemberVariableAssigner;
class CCBSelectorResolver;
class CCBAnimationManager;
class CCData;
class CCBKeyframe;




class CCBReader : public CCObject
{
private:

    CCData *mData;
    unsigned char *mBytes;
    int mCurrentByte;
    int mCurrentBit;

    std::vector<std::string> mStringCache;
    std::set<std::string> mLoadedSpriteSheets;

    CCObject *mOwner;

    CCBAnimationManager *mActionManager;
    CCDictionary* mActionManagers;

    std::set<std::string> *mAnimatedProps;

    CCNodeLoaderLibrary *mCCNodeLoaderLibrary;
    CCNodeLoaderListener *mCCNodeLoaderListener;
    CCBMemberVariableAssigner *mCCBMemberVariableAssigner;
    CCBSelectorResolver *mCCBSelectorResolver;

    std::vector<std::string> mOwnerOutletNames;
    CCArray* mOwnerOutletNodes;
    CCArray* mNodesWithAnimationManagers;
    CCArray* mAnimationManagersForNodes;

    std::vector<std::string> mOwnerCallbackNames;
    CCArray* mOwnerCallbackNodes;
    CCArray* mOwnerOwnerCallbackControlEvents;
    std::string mCCBRootPath;
    bool hasScriptingOwner;
    bool init();
public:

    bool jsControlled;




    CCBReader(CCNodeLoaderLibrary *pCCNodeLoaderLibrary, CCBMemberVariableAssigner *pCCBMemberVariableAssigner = __null, CCBSelectorResolver *pCCBSelectorResolver = __null, CCNodeLoaderListener *pCCNodeLoaderListener = __null);




    CCBReader(CCBReader *pCCBReader);




    virtual ~CCBReader();



    CCBReader();

    void setCCBRootPath(const char* pCCBRootPath);
    const std::string& getCCBRootPath() const;




    CCNode* readNodeGraphFromFile(const char *pCCBFileName);




    CCNode* readNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner);




    CCNode* readNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner, const CCSize &parentSize);




    CCNode* readNodeGraphFromData(CCData *pData, CCObject *pOwner, const CCSize &parentSize);




    CCScene* createSceneWithNodeGraphFromFile(const char *pCCBFileName);




    CCScene* createSceneWithNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner);




    CCScene* createSceneWithNodeGraphFromFile(const char *pCCBFileName, CCObject *pOwner, const CCSize &parentSize);




    CCBMemberVariableAssigner* getCCBMemberVariableAssigner();




    CCBSelectorResolver* getCCBSelectorResolver();



    CCBAnimationManager* getAnimationManager();



    void setAnimationManager(CCBAnimationManager *pAnimationManager);





    std::set<std::string>* getAnimatedProperties();




    std::set<std::string>& getLoadedSpriteSheet();
    CCObject* getOwner();





    static std::string lastPathComponent(const char* pString);




    static std::string deletePathExtension(const char* pString);




    static std::string toLowerCase(const char* pCCString);




    static bool endsWith(const char* pString, const char* pEnding);





    int readInt(bool pSigned);




    unsigned char readByte();




    bool readBool();
    std::string readUTF8();




    float readFloat();




    std::string readCachedString();




    bool isJSControlled();


    bool readCallbackKeyframesForSeq(CCBSequence* seq);
    bool readSoundKeyframesForSeq(CCBSequence* seq);



    CCArray* getOwnerCallbackNames();
    CCArray* getOwnerCallbackNodes();
    CCArray* getOwnerCallbackControlEvents();
    CCArray* getOwnerOutletNames();
    CCArray* getOwnerOutletNodes();
    CCArray* getNodesWithAnimationManagers();
    CCArray* getAnimationManagersForNodes();




    CCDictionary* getAnimationManagers();



    void setAnimationManagers(CCDictionary* x);




    void addOwnerCallbackName(const std::string& name);




    void addOwnerCallbackNode(CCNode *node);




    void addOwnerCallbackControlEvents(CCControlEvent type);




    void addDocumentCallbackName(const std::string& name);




    void addDocumentCallbackNode(CCNode *node);




    void addDocumentCallbackControlEvents(CCControlEvent eventType);




    static float getResolutionScale();
    static void setResolutionScale(float scale);




    CCNode* readFileWithCleanUp(bool bCleanUp, CCDictionary* am);

    void addOwnerOutletName(std::string name);
    void addOwnerOutletNode(CCNode *node);

private:
    void cleanUpNodeGraph(CCNode *pNode);
    bool readSequences();
    CCBKeyframe* readKeyframe(int type);

    bool readHeader();
    bool readStringCache();

    CCNode* readNodeGraph();
    CCNode* readNodeGraph(CCNode * pParent);

    bool getBit();
    void alignBits();

    friend class CCNodeLoader;
};




}}
# 7 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCBValue.h" 1
# 11 "Cacao/include/cocos2dext/CCBReader/CCBValue.h"
namespace cocos2d { namespace extension {




class ccColor3BWapper : public CCObject
{
private:
    ccColor3B color;

public:
    static ccColor3BWapper* create(const ccColor3B& color);

    const ccColor3B& getColor() const;
};

enum
{
    kIntValue,
    kFloatValue,
    kBoolValue,
    kUnsignedCharValue,
    kStringValue,
    kArrayValue
};




class CCBValue : public CCObject
{
private:
    union
    {
        int nValue;
        float fValue;
    } mValue;

    std::string m_strValue;
    CCArray* m_arrValue;
    int mType;

public:
    static CCBValue* create(int nValue);
    static CCBValue* create(bool bValue);
    static CCBValue* create(float fValue);
    static CCBValue* create(unsigned char byte);
    static CCBValue* create(const char* pStr);
    static CCBValue* create(CCArray* pArr);


    int getIntValue();
    float getFloatValue();
    bool getBoolValue();
    unsigned char getByteValue();
    const char* getStringValue();
    CCArray *getArrayValue();

    int getType();
};

}}
# 8 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h" 2

namespace cocos2d { namespace extension {
# 32 "Cacao/include/cocos2dext/CCBReader/CCNodeLoader.h"
struct BlockData {
    SEL_MenuHandler mSELMenuHandler;
    CCObject * mTarget;
};

struct BlockCCControlData {
    SEL_CCControlHandler mSELCCControlHandler;
    CCObject * mTarget;
    int mControlEvents;
};


class CCBReader;




class CCNodeLoader : public CCObject {
    public:
        CCNodeLoader();
        virtual ~CCNodeLoader();
        static CCNodeLoader * loader() { CCNodeLoader * ptr = new CCNodeLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

        virtual CCNode * loadCCNode(CCNode *, CCBReader * pCCBReader);
        virtual void parseProperties(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCDictionary* getCustomProperties();

    protected:
        virtual CCNode * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCNode::create(); };

        virtual CCPoint parsePropTypePosition(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual CCPoint parsePropTypePoint(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCPoint parsePropTypePointLock(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCSize parsePropTypeSize(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float * parsePropTypeScaleLock(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual float parsePropTypeFloat(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float parsePropTypeDegrees(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual float parsePropTypeFloatScale(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual int parsePropTypeInteger(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual int parsePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float * parsePropTypeFloatVar(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual bool parsePropTypeCheck(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual CCSpriteFrame * parsePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual CCAnimation * parsePropTypeAnimation(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCTexture2D * parsePropTypeTexture(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual unsigned char parsePropTypeByte(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual ccColor3B parsePropTypeColor3(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader, const char *pPropertyName);
        virtual ccColor4F * parsePropTypeColor4FVar(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual bool * parsePropTypeFlip(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual ccBlendFunc parsePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeFntFile(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeString(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeText(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual std::string parsePropTypeFontTTF(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual BlockData * parsePropTypeBlock(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual BlockCCControlData * parsePropTypeBlockCCControl(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual CCNode * parsePropTypeCCBFile(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);
        virtual float * parsePropTypeFloatXY(CCNode * pNode, CCNode * pParent, CCBReader * pCCBReader);


        virtual void onHandlePropTypePosition(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCPoint pPosition, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypePointLock(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCPoint pPointLock, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeScaleLock(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float * pScaleLock, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float pFloat, CCBReader * pCCBReader);
        virtual void onHandlePropTypeDegrees(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float pDegrees, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatScale(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float pFloatScale, CCBReader * pCCBReader);
        virtual void onHandlePropTypeInteger(CCNode * pNode, CCNode * pParent, const char* pPropertyName, int pInteger, CCBReader * pCCBReader);
        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char* pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatVar(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float * pFoatVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatXY(CCNode * pNode, CCNode * pParent, const char* pPropertyName, float * pFoatVar, CCBReader * pCCBReader);

        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char* pPropertyName, bool pCheck, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeAnimation(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCAnimation * pCCAnimation, CCBReader * pCCBReader);
        virtual void onHandlePropTypeTexture(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCTexture2D * pCCTexture2D, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char* pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char* pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor4FVar(CCNode * pNode, CCNode * pParent, const char* pPropertyName, ccColor4F * pCCColor4FVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFlip(CCNode * pNode, CCNode * pParent, const char* pPropertyName, bool * pFlip, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char* pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFntFile(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pFntFile, CCBReader * pCCBReader);
        virtual void onHandlePropTypeString(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pString, CCBReader * pCCBReader);
        virtual void onHandlePropTypeText(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pText, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFontTTF(CCNode * pNode, CCNode * pParent, const char* pPropertyName, const char * pFontTTF, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlock(CCNode * pNode, CCNode * pParent, const char* pPropertyName, BlockData * pBlockData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlockCCControl(CCNode * pNode, CCNode * pParent, const char* pPropertyName, BlockCCControlData * pBlockCCControlData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCCBFile(CCNode * pNode, CCNode * pParent, const char* pPropertyName, CCNode * pCCBFileNode, CCBReader * pCCBReader);

protected:
        CCDictionary* m_pCustomProperties;
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCBFileLoader.h" 2


namespace cocos2d { namespace extension {


class CCBReader;




class CCBFileLoader : public CCNodeLoader {
    public:
        virtual ~CCBFileLoader() {};
        static CCBFileLoader * loader() { CCBFileLoader * ptr = new CCBFileLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCBFile * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCBFile::create(); };

        virtual void onHandlePropTypeCCBFile(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCNode * pCCBFileNode, CCBReader * pCCBReader);
};

}}
# 7 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h" 1






namespace cocos2d { namespace extension {
# 31 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h"
class CCBMemberVariableAssigner {
    public:
        virtual ~CCBMemberVariableAssigner() {};
# 43 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h"
        virtual bool onAssignCCBMemberVariable(CCObject* pTarget, const char* pMemberVariableName, CCNode* pNode) = 0;
# 53 "Cacao/include/cocos2dext/CCBReader/CCBMemberVariableAssigner.h"
        virtual bool onAssignCCBCustomProperty(CCObject* pTarget, const char* pMemberVariableName, CCBValue* pCCBValue) { return false; };
};

}}
# 8 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCBSelectorResolver.h" 1








namespace cocos2d { namespace extension {
# 26 "Cacao/include/cocos2dext/CCBReader/CCBSelectorResolver.h"
class CCBSelectorResolver {
    public:
        virtual ~CCBSelectorResolver() {};
    virtual SEL_MenuHandler onResolveCCBCCMenuItemSelector(CCObject * pTarget, const char* pSelectorName) = 0;
    virtual SEL_CallFuncN onResolveCCBCCCallFuncSelector(CCObject * pTarget, const char* pSelectorName) { return __null; };
    virtual SEL_CCControlHandler onResolveCCBCCControlSelector(CCObject * pTarget, const char* pSelectorName) = 0;
};





class CCBScriptOwnerProtocol {
public:
    virtual ~CCBScriptOwnerProtocol() {};
    virtual CCBSelectorResolver * createNew() = 0;
};

}}
# 10 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCControlButtonLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCControlLoader.h" 1






namespace cocos2d { namespace extension {


class CCBReader;




class CCControlLoader : public CCNodeLoader {
    public:
        virtual ~CCControlLoader() {};

    protected:
        virtual CCControl * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) = 0;

        virtual void onHandlePropTypeBlockCCControl(CCNode * pNode, CCNode * pParent, const char * pPropertyName, BlockCCControlData * pBlockCCControlData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCControlButtonLoader.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h" 1
# 35 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h" 1
# 34 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
namespace cocos2d { namespace extension {
# 53 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
class CCScale9Sprite : public CCNodeRGBA
{
public:
    CCScale9Sprite();
    virtual ~CCScale9Sprite();

public:

    protected: CCSize m_originalSize;public: virtual CCSize getOriginalSize(void) const { return m_originalSize; };



    protected: CCSize m_preferredSize;public: virtual CCSize getPreferredSize(void);public: virtual void setPreferredSize(CCSize var);;





    protected: CCRect m_capInsets;public: virtual CCRect getCapInsets(void);public: virtual void setCapInsets(CCRect var);;

    protected: float m_insetLeft;public: virtual float getInsetLeft(void);public: virtual void setInsetLeft(float var);;

    protected: float m_insetTop;public: virtual float getInsetTop(void);public: virtual void setInsetTop(float var);;

    protected: float m_insetRight;public: virtual float getInsetRight(void);public: virtual void setInsetRight(float var);;

    protected: float m_insetBottom;public: virtual float getInsetBottom(void);public: virtual void setInsetBottom(float var);;

protected:
    bool m_bSpritesGenerated;
    CCRect m_spriteRect;
    bool m_bSpriteFrameRotated;
    CCRect m_capInsetsInternal;
    bool m_positionsAreDirty;

    CCSpriteBatchNode* _scale9Image;
    CCSprite* _topLeft;
    CCSprite* _top;
    CCSprite* _topRight;
    CCSprite* _left;
    CCSprite* _centre;
    CCSprite* _right;
    CCSprite* _bottomLeft;
    CCSprite* _bottom;
    CCSprite* _bottomRight;

    bool _opacityModifyRGB;
    GLubyte _opacity;
    ccColor3B _color;

    void updateCapInset();
    void updatePositions();

public:

    virtual void setContentSize(const CCSize & size);



    virtual void visit();

    virtual bool init();

    virtual bool initWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);
    virtual bool initWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, CCRect capInsets);
# 131 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(const char* file, CCRect rect, CCRect capInsets);







    static CCScale9Sprite* create(const char* file, CCRect rect, CCRect capInsets);
# 153 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(const char* file, CCRect rect);







    static CCScale9Sprite* create(const char* file, CCRect rect);
# 173 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(CCRect capInsets, const char* file);







    static CCScale9Sprite* create(CCRect capInsets, const char* file);
# 193 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithFile(const char* file);







    static CCScale9Sprite* create(const char* file);
# 213 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrame(CCSpriteFrame* spriteFrame, CCRect capInsets);
# 223 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrame(CCSpriteFrame* spriteFrame, CCRect capInsets);
# 232 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrame(CCSpriteFrame* spriteFrame);
# 242 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrame(CCSpriteFrame* spriteFrame);
# 254 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrameName(const char*spriteFrameName, CCRect capInsets);
# 265 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrameName(const char*spriteFrameName, CCRect capInsets);
# 275 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual bool initWithSpriteFrameName(const char*spriteFrameName);
# 285 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    static CCScale9Sprite* createWithSpriteFrameName(const char*spriteFrameName);
# 295 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    CCScale9Sprite* resizableSpriteWithCapInsets(CCRect capInsets);

    static CCScale9Sprite* create();
# 307 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCScale9Sprite.h"
    virtual void setOpacityModifyRGB(bool bValue);




    virtual bool isOpacityModifyRGB(void);
    virtual void setOpacity(GLubyte opacity);
 virtual GLubyte getOpacity();
    virtual void setColor(const ccColor3B& color);
 virtual const ccColor3B& getColor();

    virtual bool updateWithBatchNode(CCSpriteBatchNode* batchnode, CCRect rect, bool rotated, CCRect capInsets);

    virtual void setSpriteFrame(CCSpriteFrame * spriteFrame);

    virtual void updateDisplayedOpacity(GLubyte parentOpacity);
    virtual void updateDisplayedColor(const cocos2d::ccColor3B& parentColor);
};





}}
# 36 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h" 2

namespace cocos2d { namespace extension {
# 53 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
class CCControlButton : public CCControl
{
public:
    CCControlButton();
    virtual ~CCControlButton();
    virtual void needsLayout(void);

    virtual void setEnabled(bool enabled);
    virtual void setSelected(bool enabled);
    virtual void setHighlighted(bool enabled);
protected:




    protected: CCString* m_currentTitle;public: virtual CCString* getCurrentTitle(void) const { return m_currentTitle; };


    protected: ccColor3B m_currentTitleColor;public: virtual const ccColor3B& getCurrentTitleColor(void) const { return m_currentTitleColor; };



    bool doesAdjustBackgroundImage();
    void setAdjustBackgroundImage(bool adjustBackgroundImage);
    bool m_doesAdjustBackgroundImage;


    private: CCNode* m_titleLabel; public: virtual CCNode* getTitleLabel(void) const { return m_titleLabel; } public: virtual void setTitleLabel(CCNode* var) { if (m_titleLabel != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleLabel) { (m_titleLabel)->release(); } } while(0); m_titleLabel = var; } };


    private: CCScale9Sprite* m_backgroundSprite; public: virtual CCScale9Sprite* getBackgroundSprite(void) const { return m_backgroundSprite; } public: virtual void setBackgroundSprite(CCScale9Sprite* var) { if (m_backgroundSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_backgroundSprite) { (m_backgroundSprite)->release(); } } while(0); m_backgroundSprite = var; } };


    protected: CCSize m_preferredSize;public: virtual CCSize getPreferredSize(void);public: virtual void setPreferredSize(CCSize var);;


    protected: bool m_zoomOnTouchDown;public: virtual bool getZoomOnTouchDown(void);public: virtual void setZoomOnTouchDown(bool var);;

    protected: CCPoint m_labelAnchorPoint;public: virtual CCPoint getLabelAnchorPoint(void);public: virtual void setLabelAnchorPoint(CCPoint var);;


    virtual GLubyte getOpacity(void);
    virtual void setOpacity(GLubyte var);
 virtual const ccColor3B& getColor(void);
 virtual void setColor(const ccColor3B&);


protected:
    bool m_isPushed;
    bool m_bParentInited;
public:
    bool isPushed() { return m_isPushed; }


    private: CCDictionary* m_titleDispatchTable; public: virtual CCDictionary* getTitleDispatchTable(void) const { return m_titleDispatchTable; } public: virtual void setTitleDispatchTable(CCDictionary* var) { if (m_titleDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleDispatchTable) { (m_titleDispatchTable)->release(); } } while(0); m_titleDispatchTable = var; } };

    private: CCDictionary* m_titleColorDispatchTable; public: virtual CCDictionary* getTitleColorDispatchTable(void) const { return m_titleColorDispatchTable; } public: virtual void setTitleColorDispatchTable(CCDictionary* var) { if (m_titleColorDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleColorDispatchTable) { (m_titleColorDispatchTable)->release(); } } while(0); m_titleColorDispatchTable = var; } };

    private: CCDictionary* m_titleLabelDispatchTable; public: virtual CCDictionary* getTitleLabelDispatchTable(void) const { return m_titleLabelDispatchTable; } public: virtual void setTitleLabelDispatchTable(CCDictionary* var) { if (m_titleLabelDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_titleLabelDispatchTable) { (m_titleLabelDispatchTable)->release(); } } while(0); m_titleLabelDispatchTable = var; } };

    private: CCDictionary* m_backgroundSpriteDispatchTable; public: virtual CCDictionary* getBackgroundSpriteDispatchTable(void) const { return m_backgroundSpriteDispatchTable; } public: virtual void setBackgroundSpriteDispatchTable(CCDictionary* var) { if (m_backgroundSpriteDispatchTable != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_backgroundSpriteDispatchTable) { (m_backgroundSpriteDispatchTable)->release(); } } while(0); m_backgroundSpriteDispatchTable = var; } };


    protected: int m_marginV;public: virtual int getVerticalMargin(void) const { return m_marginV; };

    protected: int m_marginH;public: virtual int getHorizontalOrigin(void) const { return m_marginH; };

    virtual void setMargins(int marginH, int marginV);


public:
    virtual bool init();
    virtual bool initWithLabelAndBackgroundSprite(CCNode* label, CCScale9Sprite* backgroundSprite);

    static CCControlButton* create(CCNode* label, CCScale9Sprite* backgroundSprite);

    virtual bool initWithTitleAndFontNameAndFontSize(std::string title, const char * fontName, float fontSize);

    static CCControlButton* create(std::string title, const char * fontName, float fontSize);

    virtual bool initWithBackgroundSprite(CCScale9Sprite* sprite);

    static CCControlButton* create(CCScale9Sprite* sprite);


    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
# 151 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual CCString* getTitleForState(CCControlState state);
# 162 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setTitleForState(CCString* title, CCControlState state);
# 173 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual const ccColor3B getTitleColorForState(CCControlState state);
# 182 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setTitleColorForState(ccColor3B color, CCControlState state);







    virtual CCNode* getTitleLabelForState(CCControlState state);
# 201 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setTitleLabelForState(CCNode* label, CCControlState state);

    virtual void setTitleTTFForState(const char * fntFile, CCControlState state);
    virtual const char * getTitleTTFForState(CCControlState state);

    virtual void setTitleTTFSizeForState(float size, CCControlState state);
    virtual float getTitleTTFSizeForState(CCControlState state);







    virtual void setTitleBMFontForState(const char * fntFile, CCControlState state);
    virtual const char * getTitleBMFontForState(CCControlState state);







    virtual CCScale9Sprite* getBackgroundSpriteForState(CCControlState state);
# 233 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setBackgroundSpriteForState(CCScale9Sprite* sprite, CCControlState state);
# 242 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlButton.h"
    virtual void setBackgroundSpriteFrameForState(CCSpriteFrame * spriteFrame, CCControlState state);

    static CCControlButton* create();
};





}}
# 6 "Cacao/include/cocos2dext/CCBReader/CCControlButtonLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;

class CCControlButtonLoader : public CCControlLoader {
    public:
        virtual ~CCControlButtonLoader() {};
        static CCControlButtonLoader * loader() { CCControlButtonLoader * ptr = new CCControlButtonLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCControlButton * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCControlButton::create(); };

        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
        virtual void onHandlePropTypeString(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pString, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFontTTF(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pFontTTF, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatScale(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloatScale, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
};

}}
# 11 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCLabelBMFontLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLabelBMFontLoader : public CCNodeLoader {
    public:
        virtual ~CCLabelBMFontLoader() {};
        static CCLabelBMFontLoader * loader() { CCLabelBMFontLoader * ptr = new CCLabelBMFontLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLabelBMFont * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLabelBMFont::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFntFile(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char* pFntFile, CCBReader * pCCBReader);
        virtual void onHandlePropTypeText(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char* pText, CCBReader * pCCBReader);
};

}}
# 13 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCLabelTTFLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLabelTTFLoader : public CCNodeLoader {
    public:
        virtual ~CCLabelTTFLoader() {};
        static CCLabelTTFLoader * loader() { CCLabelTTFLoader * ptr = new CCLabelTTFLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLabelTTF * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLabelTTF::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFontTTF(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pFontTTF, CCBReader * pCCBReader);
        virtual void onHandlePropTypeText(CCNode * pNode, CCNode * pParent, const char * pPropertyName, const char * pText, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatScale(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloatScale, CCBReader * pCCBReader);
        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
};

}}
# 14 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCLayerColorLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCLayerLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLayerLoader : public CCNodeLoader {
    public:
        virtual ~CCLayerLoader() {};
        static CCLayerLoader * loader() { CCLayerLoader * ptr = new CCLayerLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLayer * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLayer::create(); };

        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCLayerColorLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;




class CCLayerColorLoader : public CCLayerLoader {
    public:
        virtual ~CCLayerColorLoader() {};
        static CCLayerColorLoader * loader() { CCLayerColorLoader * ptr = new CCLayerColorLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLayerColor * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLayerColor::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
};

}}
# 15 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCLayerGradientLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCLayerGradientLoader : public CCLayerLoader {
    public:
        virtual ~CCLayerGradientLoader() {};
        static CCLayerGradientLoader * loader() { CCLayerGradientLoader * ptr = new CCLayerGradientLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCLayerGradient * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCLayerGradient::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
};

}}
# 16 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCMenuItemImageLoader.h" 1



# 1 "Cacao/include/cocos2dext/CCBReader/CCMenuItemLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCMenuItemLoader : public CCNodeLoader {
    public:
        virtual ~CCMenuItemLoader() {};

    protected:
        virtual CCMenuItem * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) = 0;

        virtual void onHandlePropTypeBlock(CCNode * pNode, CCNode * pParent, const char * pPropertyName, BlockData * pBlockData, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
};

}}
# 5 "Cacao/include/cocos2dext/CCBReader/CCMenuItemImageLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;




class CCMenuItemImageLoader : public CCMenuItemLoader {
    public:
        virtual ~CCMenuItemImageLoader() {};
        static CCMenuItemImageLoader * loader() { CCMenuItemImageLoader * ptr = new CCMenuItemImageLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCMenuItemImage * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCMenuItemImage::create(); };

        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
};

}}
# 18 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCMenuLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCMenuLoader : public CCLayerLoader {
    public:
        virtual ~CCMenuLoader() {};
        static CCMenuLoader * loader() { CCMenuLoader * ptr = new CCMenuLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCMenu * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCMenu::create(); };
};

}}
# 20 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CCBReader/CCNodeLoaderLibrary.h" 1






namespace cocos2d { namespace extension {

class CCNodeLoader;

typedef std::map<std::string, CCNodeLoader *> CCNodeLoaderMap;
typedef std::pair<std::string, CCNodeLoader *> CCNodeLoaderMapEntry;




class CCNodeLoaderLibrary : public CCObject {
    private:
        CCNodeLoaderMap mCCNodeLoaders;

    public:
        static CCNodeLoaderLibrary * library() { CCNodeLoaderLibrary * ptr = new CCNodeLoaderLibrary(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

        CCNodeLoaderLibrary();
        virtual ~CCNodeLoaderLibrary();

        void registerDefaultCCNodeLoaders();
        void registerCCNodeLoader(const char * pClassName, CCNodeLoader * pCCNodeLoader);

        void unregisterCCNodeLoader(const char * pClassName);

        CCNodeLoader * getCCNodeLoader(const char * pClassName);

        void purge(bool pDelete);

    public:
        static CCNodeLoaderLibrary * sharedCCNodeLoaderLibrary();
        static void purgeSharedCCNodeLoaderLibrary();

        static CCNodeLoaderLibrary * newDefaultCCNodeLoaderLibrary();
};

}}
# 22 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCNodeLoaderListener.h" 1





namespace cocos2d { namespace extension {




class CCNodeLoaderListener {
    public:
        virtual ~CCNodeLoaderListener() {};

        virtual void onNodeLoaded(CCNode * pNode, CCNodeLoader * pNodeLoader) = 0;
};

}}
# 23 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCParticleSystemQuadLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCParticleSystemQuadLoader : public CCNodeLoader {
    public:
        virtual ~CCParticleSystemQuadLoader() {};
        static CCParticleSystemQuadLoader * loader() { CCParticleSystemQuadLoader * ptr = new CCParticleSystemQuadLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCParticleSystemQuad * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCParticleSystemQuad::create(); };

        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
        virtual void onHandlePropTypePoint(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCPoint pPoint, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloat, CCBReader * pCCBReader);
        virtual void onHandlePropTypeInteger(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pInteger, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloatVar(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float * pFloatVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeColor4FVar(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor4F * pCCColor4FVar, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeTexture(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCTexture2D * pCCTexture2D, CCBReader * pCCBReader);
};

}}
# 24 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCScale9SpriteLoader.h" 1




# 1 "Cacao/include/cocos2dext/CCBReader/CCScale9SpriteLoader.h" 1
# 6 "Cacao/include/cocos2dext/CCBReader/CCScale9SpriteLoader.h" 2


namespace cocos2d { namespace extension {


class CCBReader;




class CCScale9SpriteLoader : public CCNodeLoader {
    public:
        virtual ~CCScale9SpriteLoader() {};
        static CCScale9SpriteLoader * loader() { CCScale9SpriteLoader * ptr = new CCScale9SpriteLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCScale9Sprite * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCScale9Sprite::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloat, CCBReader * pCCBReader);
};

}}
# 25 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCScrollViewLoader.h" 1




# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h" 1
# 32 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
namespace cocos2d { namespace extension {






typedef enum {
 kCCScrollViewDirectionNone = -1,
    kCCScrollViewDirectionHorizontal = 0,
    kCCScrollViewDirectionVertical,
    kCCScrollViewDirectionBoth
} CCScrollViewDirection;

class CCScrollView;




class CCScrollViewDelegate
{
public:
    virtual ~CCScrollViewDelegate() {}
    virtual void scrollViewDidScroll(CCScrollView* view) = 0;
    virtual void scrollViewDidZoom(CCScrollView* view) = 0;
};







class CCScrollView : public CCLayer
{
public:



    CCScrollView();




    virtual ~CCScrollView();

    bool init();
    virtual void registerWithTouchDispatcher();
# 88 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    static CCScrollView* create(CCSize size, CCNode* container = __null);
# 97 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    static CCScrollView* create();
# 106 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    bool initWithViewSize(CCSize size, CCNode* container = __null);
# 115 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCScrollView.h"
    void setContentOffset(CCPoint offset, bool animated = false);
    CCPoint getContentOffset();







    void setContentOffsetInDuration(CCPoint offset, float dt);

    void setZoomScale(float s);






    void setZoomScale(float s, bool animated);

    float getZoomScale();







    void setZoomScaleInDuration(float s, float dt);



    CCPoint minContainerOffset();



    CCPoint maxContainerOffset();





    bool isNodeVisible(CCNode * node);



    void pause(CCObject* sender);



    void resume(CCObject* sender);


    bool isDragging() {return m_bDragging;}
    bool isTouchMoved() { return m_bTouchMoved; }
    bool isBounceable() { return m_bBounceable; }
    void setBounceable(bool bBounceable) { m_bBounceable = bBounceable; }






    CCSize getViewSize() { return m_tViewSize; }
    void setViewSize(CCSize size);

    CCNode * getContainer();
    void setContainer(CCNode * pContainer);




    CCScrollViewDirection getDirection() { return m_eDirection; }
    virtual void setDirection(CCScrollViewDirection eDirection) { m_eDirection = eDirection; }

    CCScrollViewDelegate* getDelegate() { return m_pDelegate; }
    void setDelegate(CCScrollViewDelegate* pDelegate) { m_pDelegate = pDelegate; }



    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

    virtual void setContentSize(const CCSize & size);
    virtual const CCSize& getContentSize() const;

 void updateInset();



    bool isClippingToBounds() { return m_bClippingToBounds; }
    void setClippingToBounds(bool bClippingToBounds) { m_bClippingToBounds = bClippingToBounds; }



    virtual void visit();
    virtual void addChild(CCNode * child, int zOrder, int tag);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode * child);
    void setTouchEnabled(bool e);
private:





    void relocateContainer(bool animated);






    void deaccelerateScrolling(float dt);



    void performedAnimatedScroll(float dt);



    void stoppedAnimatedScroll(CCNode* node);



    void beforeDraw();




    void afterDraw();



    void handleZoom();

protected:
    CCRect getViewRect();




    float m_fZoomScale;



    float m_fMinZoomScale;



    float m_fMaxZoomScale;



    CCScrollViewDelegate* m_pDelegate;

    CCScrollViewDirection m_eDirection;



    bool m_bDragging;




    CCPoint m_tContentOffset;




    CCNode* m_pContainer;



    bool m_bTouchMoved;



    CCPoint m_fMaxInset;



    CCPoint m_fMinInset;



    bool m_bBounceable;

    bool m_bClippingToBounds;




    CCPoint m_tScrollDistance;



    CCPoint m_tTouchPoint;



    float m_fTouchLength;



    CCArray* m_pTouches;





    CCSize m_tViewSize;



    float m_fMinScale, m_fMaxScale;



    CCRect m_tParentScissorRect;
    bool m_bScissorRestored;
public:
    enum ScrollViewScriptEventType
    {
        kScrollViewScroll = 0,
        kScrollViewZoom,
    };
    void registerScriptHandler(int nFunID,int nScriptEventType);
    void unregisterScriptHandler(int nScriptEventType);
    int getScriptHandler(int nScriptEventType);
private:
    std::map<int,int> m_mapScriptHandler;
};




}}
# 6 "Cacao/include/cocos2dext/CCBReader/CCScrollViewLoader.h" 2

namespace cocos2d { namespace extension {


class CCBReader;




class CCScrollViewLoader : public CCNodeLoader {
    public:
        virtual ~CCScrollViewLoader() {};
        static CCScrollViewLoader * loader() { CCScrollViewLoader * ptr = new CCScrollViewLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCScrollView * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCScrollView::create(); };
  virtual void onHandlePropTypeSize(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSize pSize, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCCBFile(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCNode * pCCBFileNode, CCBReader * pCCBReader);
        virtual void onHandlePropTypeCheck(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool pCheck, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFloat(CCNode * pNode, CCNode * pParent, const char * pPropertyName, float pFloat, CCBReader * pCCBReader);
        virtual void onHandlePropTypeIntegerLabeled(CCNode * pNode, CCNode * pParent, const char * pPropertyName, int pIntegerLabeled, CCBReader * pCCBReader);
};

}}
# 26 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCSpriteLoader.h" 1





namespace cocos2d { namespace extension {


class CCBReader;




class CCSpriteLoader : public CCNodeLoader {
    public:
        virtual ~CCSpriteLoader() {};
        static CCSpriteLoader * loader() { CCSpriteLoader * ptr = new CCSpriteLoader(); if(ptr != __null) { ptr->autorelease(); return ptr; } do { if(ptr) { delete (ptr); (ptr) = 0; } } while(0); return __null; };

    protected:
        virtual CCSprite * createCCNode(cocos2d::CCNode * pParent, cocos2d::extension::CCBReader * pCCBReader) { return CCSprite::create(); };

        virtual void onHandlePropTypeColor3(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccColor3B pCCColor3B, CCBReader * pCCBReader);
        virtual void onHandlePropTypeByte(CCNode * pNode, CCNode * pParent, const char * pPropertyName, unsigned char pByte, CCBReader * pCCBReader);
        virtual void onHandlePropTypeBlendFunc(CCNode * pNode, CCNode * pParent, const char * pPropertyName, ccBlendFunc pCCBBlendFunc, CCBReader * pCCBReader);
        virtual void onHandlePropTypeSpriteFrame(CCNode * pNode, CCNode * pParent, const char * pPropertyName, CCSpriteFrame * pCCSpriteFrame, CCBReader * pCCBReader);
        virtual void onHandlePropTypeFlip(CCNode * pNode, CCNode * pParent, const char * pPropertyName, bool * pFlip, CCBReader * pCCBReader);
};

}}
# 27 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCBAnimationManager.h" 1
# 11 "Cacao/include/cocos2dext/CCBReader/CCBAnimationManager.h"
namespace cocos2d { namespace extension {




class CCBAnimationManagerDelegate
{
public:
    virtual void completedAnimationSequenceNamed(const char *name) = 0;
};

class CCBAnimationManager : public CCObject
{
private:
    CCArray *mSequences;
    CCDictionary *mNodeSequences;
    CCDictionary *mBaseValues;
    int mAutoPlaySequenceId;

    CCNode *mRootNode;

    CCSize mRootContainerSize;

    CCBAnimationManagerDelegate *mDelegate;
    CCBSequence *mRunningSequence;

    CCArray *mDocumentOutletNames;
    CCArray *mDocumentOutletNodes;
    CCArray *mDocumentCallbackNames;
    CCArray *mDocumentCallbackNodes;
    CCArray *mDocumentCallbackControlEvents;
    CCArray *mKeyframeCallbacks;
    CCDictionary *mKeyframeCallFuncs;

    std::string mDocumentControllerName;
    std::string lastCompletedSequenceName;

    SEL_CallFunc mAnimationCompleteCallbackFunc;
    CCObject *mTarget;


public:
    bool jsControlled;



    CCBAnimationManager();



    ~CCBAnimationManager();


    CCObject *mOwner;

    virtual bool init();

    CCArray* getSequences();
    void setSequences(CCArray* seq);


    int getAutoPlaySequenceId();
    void setAutoPlaySequenceId(int autoPlaySequenceId);

    CCNode* getRootNode();
    void setRootNode(CCNode* pRootNode);


    void addDocumentCallbackNode(CCNode *node);
    void addDocumentCallbackName(std::string name);
    void addDocumentCallbackControlEvents(CCControlEvent eventType);
    void addDocumentOutletNode(CCNode *node);
    void addDocumentOutletName(std::string name);

    void setDocumentControllerName(const std::string &name);

    std::string getDocumentControllerName();
    CCArray* getDocumentCallbackNames();
    CCArray* getDocumentCallbackNodes();
    CCArray* getDocumentCallbackControlEvents();
    CCArray* getDocumentOutletNames();
    CCArray* getDocumentOutletNodes();
    std::string getLastCompletedSequenceName();

    CCArray* getKeyframeCallbacks();

    const CCSize& getRootContainerSize();
    void setRootContainerSize(const CCSize &rootContainerSize);

    CCBAnimationManagerDelegate* getDelegate();
    void setDelegate(CCBAnimationManagerDelegate* pDelegate);

    const char* getRunningSequenceName();

    const CCSize& getContainerSize(CCNode* pNode);

    void addNode(CCNode *pNode, CCDictionary *pSeq);
    void setBaseValue(CCObject *pValue, CCNode *pNode, const char *pPropName);
    void moveAnimationsFromNode(CCNode* fromNode, CCNode* toNode);


    __attribute__((deprecated)) void runAnimations(const char *pName, float fTweenDuration);

    __attribute__((deprecated)) void runAnimations(const char *pName);

    __attribute__((deprecated)) void runAnimations(int nSeqId, float fTweenDuraiton);

    void runAnimationsForSequenceNamedTweenDuration(const char *pName, float fTweenDuration);
    void runAnimationsForSequenceNamed(const char *pName);
    void runAnimationsForSequenceIdTweenDuration(int nSeqId, float fTweenDuraiton);



    void setAnimationCompletedCallback(CCObject *target, SEL_CallFunc callbackFunc);

    void debug();



    void setCallFunc(CCCallFunc *callFunc, const std::string &callbackNamed);

    CCObject* actionForCallbackChannel(CCBSequenceProperty* channel);
    CCObject* actionForSoundChannel(CCBSequenceProperty* channel);

private:
    CCObject* getBaseValue(CCNode *pNode, const char* pPropName);
    int getSequenceId(const char* pSequenceName);
    CCBSequence* getSequence(int nSequenceId);
    CCActionInterval* getAction(CCBKeyframe *pKeyframe0, CCBKeyframe *pKeyframe1, const char *pPropName, CCNode *pNode);
    void setAnimatedProperty(const char *pPropName, CCNode *pNode, CCObject *pValue, float fTweenDuraion);
    void setFirstFrame(CCNode *pNode, CCBSequenceProperty *pSeqProp, float fTweenDuration);
    CCActionInterval* getEaseAction(CCActionInterval *pAction, int nEasingType, float fEasingOpt);
    void runAction(CCNode *pNode, CCBSequenceProperty *pSeqProp, float fTweenDuration);
    void sequenceCompleted();
};




class CCBSetSpriteFrame : public CCActionInstant
{
private:
    CCSpriteFrame *mSpriteFrame;

public:
    ~CCBSetSpriteFrame();


    static CCBSetSpriteFrame* create(CCSpriteFrame *pSpriteFrame);
    bool initWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
    virtual void update(float time);
    virtual CCObject* copyWithZone(CCZone *pZone);
};






class CCBSoundEffect : public CCActionInstant
{
private:
  std::string mSoundFile;
  float mPitch, mPan, mGain;

public:
    ~CCBSoundEffect();

    static CCBSoundEffect* actionWithSoundFile(const std::string &file, float pitch, float pan, float gain);
    bool initWithSoundFile(const std::string &file, float pitch, float pan, float gain);
    virtual void update(float time);
    virtual CCObject* copyWithZone(CCZone *pZone);
};





class CCBRotateTo : public CCActionInterval
{
private:
    float mStartAngle;
    float mDstAngle;
    float mDiffAngle;

public:
    static CCBRotateTo* create(float fDuration, float fAngle);
    bool initWithDuration(float fDuration, float fAngle);
    virtual void update(float time);
    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void startWithTarget(CCNode *pNode);
};





class CCBRotateXTo: public CCActionInterval {
private:
    float mStartAngle;
    float mDstAngle;
    float mDiffAngle;
public:
    static CCBRotateXTo* create(float fDuration, float fAngle);
    bool initWithDuration(float fDuration, float fAngle);
    virtual void startWithTarget(CCNode *pNode);
    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void update(float time);
};





class CCBRotateYTo: public CCActionInterval {
private:
    float mStartAngle;
    float mDstAngle;
    float mDiffAngle;

public:
    static CCBRotateYTo* create(float fDuration, float fAngle);
    bool initWithDuration(float fDuration, float fAngle);
    virtual void startWithTarget(CCNode *pNode);
    virtual CCObject* copyWithZone(CCZone *pZone);
    virtual void update(float time);
};


class CCBEaseInstant : public CCActionEase
{
public:
    static CCBEaseInstant* create(CCActionInterval *pAction);

    virtual void update(float dt);
};


}}
# 28 "Cacao/include/cocos2dext/cocos-ext.h" 2




# 1 "Cacao/include/cocos2dext/CCBReader/CCData.h" 1







namespace cocos2d { namespace extension {




class CCData : public CCObject
{
public:
    CCData(unsigned char *pBytes, const unsigned long nSize);
    CCData(CCData *pData);
    ~CCData();

    unsigned char* getBytes();
    unsigned long getSize();

private:
    unsigned char* m_pBytes;
    unsigned long m_nSize;
};

}}
# 33 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/CCNode+CCBRelativePositioning.h" 1






namespace cocos2d { namespace extension {

extern CCPoint getAbsolutePosition(const CCPoint &pt, int nType, const CCSize &containerSize, const char *pPropName);

extern void setRelativeScale(CCNode *pNode, float fScaleX, float fScaleY, int nType, const char* pPropName);

}}
# 34 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 1
# 31 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h" 1
# 38 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlHuePicker.h" 1
# 39 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlHuePicker.h"
namespace cocos2d { namespace extension {
# 48 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlHuePicker.h"
class CCControlHuePicker : public CCControl
{

    protected: float m_hue;public: virtual float getHue(void) const { return m_hue; };
    virtual void setHue(float val);
    protected: float m_huePercentage;public: virtual float getHuePercentage(void) const { return m_huePercentage; };
    virtual void setHuePercentage(float val);



    private: CCSprite* m_background; public: virtual CCSprite* getBackground(void) const { return m_background; } public: virtual void setBackground(CCSprite* var) { if (m_background != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_background) { (m_background)->release(); } } while(0); m_background = var; } };
    private: CCSprite* m_slider; public: virtual CCSprite* getSlider(void) const { return m_slider; } public: virtual void setSlider(CCSprite* var) { if (m_slider != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_slider) { (m_slider)->release(); } } while(0); m_slider = var; } };
    protected: CCPoint m_startPos;public: virtual CCPoint getStartPos(void) const { return m_startPos; };

public:
    CCControlHuePicker();
    virtual ~CCControlHuePicker();
    virtual bool initWithTargetAndPos(CCNode* target, CCPoint pos);

    static CCControlHuePicker* create(CCNode* target, CCPoint pos);
    virtual void setEnabled(bool enabled);
protected:
    void updateSliderPosition(CCPoint location);
    bool checkSliderPosition(CCPoint location);

    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
};





}}
# 39 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSaturationBrightnessPicker.h" 1
# 39 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSaturationBrightnessPicker.h"
namespace cocos2d { namespace extension {
# 48 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSaturationBrightnessPicker.h"
class CCControlSaturationBrightnessPicker : public CCControl
{

    protected: float m_saturation;public: virtual float getSaturation(void) const { return m_saturation; };

    protected: float m_brightness;public: virtual float getBrightness(void) const { return m_brightness; };


    protected: CCSprite* m_background;public: virtual CCSprite* getBackground(void) const { return m_background; };
    protected: CCSprite* m_overlay;public: virtual CCSprite* getOverlay(void) const { return m_overlay; };
    protected: CCSprite* m_shadow;public: virtual CCSprite* getShadow(void) const { return m_shadow; };
    protected: CCSprite* m_slider;public: virtual CCSprite* getSlider(void) const { return m_slider; };
    protected: CCPoint m_startPos;public: virtual CCPoint getStartPos(void) const { return m_startPos; };

protected:
    int boxPos;
    int boxSize;

public:
    CCControlSaturationBrightnessPicker();
    virtual ~CCControlSaturationBrightnessPicker();
    virtual bool initWithTargetAndPos(CCNode* target, CCPoint pos);

    static CCControlSaturationBrightnessPicker* create(CCNode* target, CCPoint pos);

    virtual void setEnabled(bool enabled);
    virtual void updateWithHSV(HSV hsv);
    virtual void updateDraggerWithHSV(HSV hsv);

protected:
    void updateSliderPosition(CCPoint location);
    bool checkSliderPosition(CCPoint location);

    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
};





}}
# 40 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h" 2

namespace cocos2d { namespace extension {
# 50 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlColourPicker.h"
class CCControlColourPicker: public CCControl
{
public:
    CCControlColourPicker();
    virtual ~CCControlColourPicker();
    virtual void setColor(const ccColor3B& colorValue);
    virtual void setEnabled(bool bEnabled);
protected:
    HSV m_hsv;
    private: CCControlSaturationBrightnessPicker* m_colourPicker; public: virtual CCControlSaturationBrightnessPicker* getcolourPicker(void) const { return m_colourPicker; } public: virtual void setcolourPicker(CCControlSaturationBrightnessPicker* var) { if (m_colourPicker != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_colourPicker) { (m_colourPicker)->release(); } } while(0); m_colourPicker = var; } }
    private: CCControlHuePicker* m_huePicker; public: virtual CCControlHuePicker* getHuePicker(void) const { return m_huePicker; } public: virtual void setHuePicker(CCControlHuePicker* var) { if (m_huePicker != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_huePicker) { (m_huePicker)->release(); } } while(0); m_huePicker = var; } }
    private: CCSprite* m_background; public: virtual CCSprite* getBackground(void) const { return m_background; } public: virtual void setBackground(CCSprite* var) { if (m_background != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_background) { (m_background)->release(); } } while(0); m_background = var; } }

public:

    static CCControlColourPicker* create();

    virtual bool init();

    void hueSliderValueChanged(CCObject * sender, CCControlEvent controlEvent);
    void colourSliderValueChanged(CCObject * sender, CCControlEvent controlEvent);

protected:
    void updateControlPicker();
    void updateHueAndControlPicker();
    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);

};





}}
# 32 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlPotentiometer.h" 1
# 32 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlPotentiometer.h"
namespace cocos2d { namespace extension {
# 42 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlPotentiometer.h"
class CCControlPotentiometer : public CCControl
{
public:
    CCControlPotentiometer();
    virtual ~CCControlPotentiometer();



    static CCControlPotentiometer* create(const char* backgroundFile, const char* progressFile, const char* thumbFile);







    bool initWithTrackSprite_ProgressTimer_ThumbSprite(CCSprite* trackSprite, CCProgressTimer* progressTimer, CCSprite* thumbSprite);
    void setValue(float value);
    float getValue();

    void setMinimumValue(float minimumValue);
    float getMinimumValue();

    void setMaximumValue(float maximumValue);
    float getMaximumValue();

    void setEnabled(bool enabled);

    virtual bool isTouchInside(CCTouch * touch);

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);

protected:
    private: CCSprite* m_pThumbSprite; public: virtual CCSprite* getThumbSprite(void) const { return m_pThumbSprite; } public: virtual void setThumbSprite(CCSprite* var) { if (m_pThumbSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pThumbSprite) { (m_pThumbSprite)->release(); } } while(0); m_pThumbSprite = var; } }
    private: CCProgressTimer* m_pProgressTimer; public: virtual CCProgressTimer* getProgressTimer(void) const { return m_pProgressTimer; } public: virtual void setProgressTimer(CCProgressTimer* var) { if (m_pProgressTimer != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pProgressTimer) { (m_pProgressTimer)->release(); } } while(0); m_pProgressTimer = var; } }
    protected: CCPoint m_tPreviousLocation;public: virtual CCPoint getPreviousLocation(void) const { return m_tPreviousLocation; }public: virtual void setPreviousLocation(CCPoint var){ m_tPreviousLocation = var; }

    float m_fValue;


    float m_fMinimumValue;


    float m_fMaximumValue;

    void potentiometerBegan(CCPoint location);
    void potentiometerMoved(CCPoint location);
    void potentiometerEnded(CCPoint location);


    float distanceBetweenPointAndPoint(CCPoint point1, CCPoint point2);

    float angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(
        CCPoint beginLineA,
        CCPoint endLineA,
        CCPoint beginLineB,
        CCPoint endLineB);

};





}}
# 33 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h" 1
# 36 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h"
namespace cocos2d { namespace extension {
# 45 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h"
class CCControlSlider: public CCControl
{


    protected: float m_value;public: virtual float getValue(void) const { return m_value; };
    virtual void setValue(float val);


    protected: float m_minimumValue;public: virtual float getMinimumValue(void) const { return m_minimumValue; };
    virtual void setMinimumValue(float val);


    protected: float m_maximumValue;public: virtual float getMaximumValue(void) const { return m_maximumValue; };
    virtual void setMaximumValue(float val);
    virtual void setEnabled(bool enabled);
    virtual bool isTouchInside(CCTouch * touch);
    CCPoint locationFromTouch(CCTouch* touch);

    protected: float m_minimumAllowedValue;public: virtual float getMinimumAllowedValue(void) const { return m_minimumAllowedValue; }public: virtual void setMinimumAllowedValue(float var){ m_minimumAllowedValue = var; };
    protected: float m_maximumAllowedValue;public: virtual float getMaximumAllowedValue(void) const { return m_maximumAllowedValue; }public: virtual void setMaximumAllowedValue(float var){ m_maximumAllowedValue = var; };


    private: CCSprite* m_thumbSprite; public: virtual CCSprite* getThumbSprite(void) const { return m_thumbSprite; } public: virtual void setThumbSprite(CCSprite* var) { if (m_thumbSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_thumbSprite) { (m_thumbSprite)->release(); } } while(0); m_thumbSprite = var; } };
    private: CCSprite* m_progressSprite; public: virtual CCSprite* getProgressSprite(void) const { return m_progressSprite; } public: virtual void setProgressSprite(CCSprite* var) { if (m_progressSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_progressSprite) { (m_progressSprite)->release(); } } while(0); m_progressSprite = var; } };
    private: CCSprite* m_backgroundSprite; public: virtual CCSprite* getBackgroundSprite(void) const { return m_backgroundSprite; } public: virtual void setBackgroundSprite(CCSprite* var) { if (m_backgroundSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_backgroundSprite) { (m_backgroundSprite)->release(); } } while(0); m_backgroundSprite = var; } };

public:
    CCControlSlider();
    virtual ~CCControlSlider();
# 83 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSlider.h"
    virtual bool initWithSprites(CCSprite * backgroundSprite, CCSprite* progressSprite, CCSprite* thumbSprite);





    static CCControlSlider* create(const char* bgFile, const char* progressFile, const char* thumbFile);







    static CCControlSlider* create(CCSprite * backgroundSprite, CCSprite* pogressSprite, CCSprite* thumbSprite);

    virtual void needsLayout();
protected:
    void sliderBegan(CCPoint location);
    void sliderMoved(CCPoint location);
    void sliderEnded(CCPoint location);

    virtual bool ccTouchBegan(CCTouch* touch, CCEvent* pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);


    float valueForLocation(CCPoint location);
};





}}
# 34 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlStepper.h" 1
# 33 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlStepper.h"
namespace cocos2d { namespace extension {
# 42 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlStepper.h"
typedef enum
{
    kCCControlStepperPartMinus,
    kCCControlStepperPartPlus,
    kCCControlStepperPartNone,
} CCControlStepperPart;

class CCControlStepper : public CCControl
{
public:
    CCControlStepper();
    virtual ~CCControlStepper();

    bool initWithMinusSpriteAndPlusSprite(CCSprite *minusSprite, CCSprite *plusSprite);
    static CCControlStepper* create(CCSprite *minusSprite, CCSprite *plusSprite);
    virtual void setWraps(bool wraps);
    virtual void setMinimumValue(double minimumValue);
    virtual void setMaximumValue(double maximumValue);
    virtual void setValue(double value);
    virtual double getValue();
    virtual void setStepValue(double stepValue);

    virtual void setValueWithSendingEvent(double value, bool send);
    virtual bool isContinuous();
    void update(float dt);


    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);

protected:

 private: CCSprite* m_pMinusSprite; public: virtual CCSprite* getMinusSprite(void) const { return m_pMinusSprite; } public: virtual void setMinusSprite(CCSprite* var) { if (m_pMinusSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pMinusSprite) { (m_pMinusSprite)->release(); } } while(0); m_pMinusSprite = var; } }
    private: CCSprite* m_pPlusSprite; public: virtual CCSprite* getPlusSprite(void) const { return m_pPlusSprite; } public: virtual void setPlusSprite(CCSprite* var) { if (m_pPlusSprite != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pPlusSprite) { (m_pPlusSprite)->release(); } } while(0); m_pPlusSprite = var; } }
    private: CCLabelTTF* m_pMinusLabel; public: virtual CCLabelTTF* getMinusLabel(void) const { return m_pMinusLabel; } public: virtual void setMinusLabel(CCLabelTTF* var) { if (m_pMinusLabel != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pMinusLabel) { (m_pMinusLabel)->release(); } } while(0); m_pMinusLabel = var; } }
    private: CCLabelTTF* m_pPlusLabel; public: virtual CCLabelTTF* getPlusLabel(void) const { return m_pPlusLabel; } public: virtual void setPlusLabel(CCLabelTTF* var) { if (m_pPlusLabel != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pPlusLabel) { (m_pPlusLabel)->release(); } } while(0); m_pPlusLabel = var; } }


    void updateLayoutUsingTouchLocation(CCPoint location);


    void startAutorepeat();


    void stopAutorepeat();


    double m_dValue;

    bool m_bContinuous;

    bool m_bAutorepeat;

    bool m_bWraps;

    double m_dMinimumValue;

    double m_dMaximumValue;

    double m_dStepValue;
    bool m_bTouchInsideFlag;
    CCControlStepperPart m_eTouchedPart;
    int m_nAutorepeatCount;
};





}}
# 35 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h" 1
# 34 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h"
namespace cocos2d { class CCSprite; }
namespace cocos2d { class CCLabelTTF; }

namespace cocos2d { namespace extension {

class CCControlSwitchSprite;
# 49 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h"
class CCControlSwitch : public CCControl
{
public:
    CCControlSwitch();
    virtual ~CCControlSwitch();

    bool initWithMaskSprite(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite);


    static CCControlSwitch* create(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite);



    bool initWithMaskSprite(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);


    static CCControlSwitch* create(CCSprite *maskSprite, CCSprite * onSprite, CCSprite * offSprite, CCSprite * thumbSprite, CCLabelTTF* onLabel, CCLabelTTF* offLabel);
# 76 "Cacao/include/cocos2dext/CCBReader/../GUI/CCControlExtension/CCControlSwitch.h"
    void setOn(bool isOn, bool animated);
    void setOn(bool isOn);
    bool isOn(void) { return m_bOn; }
    bool hasMoved() { return m_bMoved; }
    virtual void setEnabled(bool enabled);

    CCPoint locationFromTouch(CCTouch* touch);

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

protected:

    CCControlSwitchSprite* m_pSwitchSprite;
    float m_fInitialTouchXPosition;

    bool m_bMoved;

    bool m_bOn;
};





}}
# 36 "Cacao/include/cocos2dext/GUI/CCControlExtension/CCControlExtensions.h" 2
# 36 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h" 1
# 30 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCTableViewCell.h" 1
# 30 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCTableViewCell.h"
# 1 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h" 1
# 32 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
namespace cocos2d { namespace extension {




class CCSortableObject
{
public:
    virtual ~CCSortableObject() {}
    virtual void setObjectID(unsigned int objectID) = 0;
    virtual unsigned int getObjectID() = 0;
};




class CCArrayForObjectSorting : public CCArray
{
public:
    CCArrayForObjectSorting() : CCArray() {}
# 63 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    void insertSortedObject(CCSortableObject* object);
# 73 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    void removeSortedObject(CCSortableObject* object);
# 84 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    void setObjectID_ofSortedObject(unsigned int tag, CCSortableObject* object);

    CCSortableObject* objectWithObjectID(unsigned int tag);
# 96 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    CCSortableObject* getObjectWithObjectID(unsigned int tag);
# 109 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCSorting.h"
    unsigned int indexOfSortedObject(CCSortableObject* obj);

};

}}
# 31 "Cacao/include/cocos2dext/CCBReader/../GUI/CCScrollView/CCTableViewCell.h" 2

namespace cocos2d { namespace extension {





class CCTableViewCell: public CCNode, public CCSortableObject
{
public:
    CCTableViewCell() {}



    unsigned int getIdx();
    void setIdx(unsigned int uIdx);



    void reset();

    void setObjectID(unsigned int uIdx);
    unsigned int getObjectID();
private:
    unsigned int m_uIdx;
};

}}
# 31 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h" 2




namespace cocos2d { namespace extension {

class CCTableView;
class CCArrayForObjectSorting;

typedef enum {
    kCCTableViewFillTopDown,
    kCCTableViewFillBottomUp
} CCTableViewVerticalFillOrder;






class CCTableViewDelegate : public CCScrollViewDelegate
{
public:






    virtual void tableCellTouched(CCTableView* table, CCTableViewCell* cell) = 0;







    virtual void tableCellHighlight(CCTableView* table, CCTableViewCell* cell){};







    virtual void tableCellUnhighlight(CCTableView* table, CCTableViewCell* cell){};
# 85 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
    virtual void tableCellWillRecycle(CCTableView* table, CCTableViewCell* cell){};

};






class CCTableViewDataSource
{
public:
    virtual ~CCTableViewDataSource() {}







    virtual CCSize tableCellSizeForIndex(CCTableView *table, unsigned int idx) {
        return cellSizeForTable(table);
    };






    virtual CCSize cellSizeForTable(CCTableView *table) {
        return CCSizeZero;
    };






    virtual CCTableViewCell* tableCellAtIndex(CCTableView *table, unsigned int idx) = 0;





    virtual unsigned int numberOfCellsInTableView(CCTableView *table) = 0;

};
# 140 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
class CCTableView : public CCScrollView, public CCScrollViewDelegate
{
public:



    CCTableView();



    virtual ~CCTableView();
# 159 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
    static CCTableView* create(CCTableViewDataSource* dataSource, CCSize size);
# 168 "Cacao/include/cocos2dext/GUI/CCScrollView/CCTableView.h"
    static CCTableView* create(CCTableViewDataSource* dataSource, CCSize size, CCNode *container);





    CCTableViewDataSource* getDataSource() { return m_pDataSource; }
    void setDataSource(CCTableViewDataSource* source) { m_pDataSource = source; }




    CCTableViewDelegate* getDelegate() { return m_pTableViewDelegate; }
    void setDelegate(CCTableViewDelegate* pDelegate) { m_pTableViewDelegate = pDelegate; }




    void setVerticalFillOrder(CCTableViewVerticalFillOrder order);
    CCTableViewVerticalFillOrder getVerticalFillOrder();


    bool initWithViewSize(CCSize size, CCNode* container = __null);





    void updateCellAtIndex(unsigned int idx);





    void insertCellAtIndex(unsigned int idx);





    void removeCellAtIndex(unsigned int idx);



    void reloadData();





    CCTableViewCell *dequeueCell();







    CCTableViewCell *cellAtIndex(unsigned int idx);


    virtual void scrollViewDidScroll(CCScrollView* view);
    virtual void scrollViewDidZoom(CCScrollView* view) {}

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

protected:

    CCTableViewCell *m_pTouchedCell;



    CCTableViewVerticalFillOrder m_eVordering;




    std::set<unsigned int>* m_pIndices;




    std::vector<float> m_vCellsPositions;




    CCArrayForObjectSorting* m_pCellsUsed;



    CCArrayForObjectSorting* m_pCellsFreed;



    CCTableViewDataSource* m_pDataSource;



    CCTableViewDelegate* m_pTableViewDelegate;

 CCScrollViewDirection m_eOldDirection;

    int __indexFromOffset(CCPoint offset);
    unsigned int _indexFromOffset(CCPoint offset);
    CCPoint __offsetFromIndex(unsigned int index);
    CCPoint _offsetFromIndex(unsigned int index);

    void _moveCellOutOfSight(CCTableViewCell *cell);
    void _setIndexForCell(unsigned int index, CCTableViewCell *cell);
    void _addCellIfNecessary(CCTableViewCell * cell);

    void _updateCellPositions();
public:
    void _updateContentSize();

    enum TableViewScriptEventType
    {
        kTableViewScroll = 0,
        kTableViewZoom,
        kTableCellTouched,
        kTableCellHighLight,
        kTableCellUnhighLight,
        kTableCellWillRecycle,
        kTableCellSizeForIndex,
        kTableCellSizeAtIndex,
        kNumberOfCellsInTableView,
    };
    void unregisterAllScriptHandler();
};


}}
# 38 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h" 1
# 33 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
namespace cocos2d { namespace extension {


enum KeyboardReturnType {
    kKeyboardReturnTypeDefault = 0,
    kKeyboardReturnTypeDone,
    kKeyboardReturnTypeSend,
    kKeyboardReturnTypeSearch,
    kKeyboardReturnTypeGo
};






enum EditBoxInputMode
{



    kEditBoxInputModeAny = 0,




    kEditBoxInputModeEmailAddr,




    kEditBoxInputModeNumeric,




    kEditBoxInputModePhoneNumber,




    kEditBoxInputModeUrl,





    kEditBoxInputModeDecimal,




    kEditBoxInputModeSingleLine
};




enum EditBoxInputFlag
{




    kEditBoxInputFlagPassword = 0,







    kEditBoxInputFlagSensitive,





    kEditBoxInputFlagInitialCapsWord,





    kEditBoxInputFlagInitialCapsSentence,




    kEditBoxInputFlagInitialCapsAllCharacters

};


class CCEditBox;
class CCEditBoxImpl;





class CCEditBoxDelegate
{
public:
    virtual ~CCEditBoxDelegate() {};





    virtual void editBoxEditingDidBegin(CCEditBox* editBox) {};






    virtual void editBoxEditingDidEnd(CCEditBox* editBox) {};






    virtual void editBoxTextChanged(CCEditBox* editBox, const std::string& text) {};





    virtual void editBoxReturn(CCEditBox* editBox) = 0;

};
# 174 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
class CCEditBox
: public CCControlButton
, public CCIMEDelegate
{
public:



    CCEditBox(void);




    virtual ~CCEditBox(void);





    static CCEditBox* create(const CCSize& size, CCScale9Sprite* pNormal9SpriteBg, CCScale9Sprite* pPressed9SpriteBg = __null, CCScale9Sprite* pDisabled9SpriteBg = __null);





    bool initWithSizeAndBackgroundSprite(const CCSize& size, CCScale9Sprite* pNormal9SpriteBg);





    void setDelegate(CCEditBoxDelegate* pDelegate);




    CCEditBoxDelegate* getDelegate();
# 236 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
    void registerScriptEditBoxHandler(int handler);





    void unregisterScriptEditBoxHandler(void);




    int getScriptEditBoxHandler(void){ return m_nScriptEditBoxHandler ;}




    void setText(const char* pText);





    const char* getText(void);






 void setFont(const char* pFontName, int fontSize);





 void setFontName(const char* pFontName);





 void setFontSize(int fontSize);




    void setFontColor(const ccColor3B& color);






 void setPlaceholderFont(const char* pFontName, int fontSize);





 void setPlaceholderFontName(const char* pFontName);





 void setPlaceholderFontSize(int fontSize);





    void setPlaceholderFontColor(const ccColor3B& color);






    void setPlaceHolder(const char* pText);





    const char* getPlaceHolder(void);





    void setInputMode(EditBoxInputMode inputMode);
# 335 "Cacao/include/cocos2dext/GUI/CCEditBox/CCEditBox.h"
    void setMaxLength(int maxLength);






    int getMaxLength();





    void setInputFlag(EditBoxInputFlag inputFlag);





    void setReturnType(KeyboardReturnType returnType);


    virtual void setPosition(const CCPoint& pos);
    virtual void setVisible(bool visible);
    virtual void setContentSize(const CCSize& size);
 virtual void setAnchorPoint(const CCPoint& anchorPoint);



    virtual void visit(void);




 virtual void onEnter(void);




    virtual void onExit(void);




    virtual void keyboardWillShow(CCIMEKeyboardNotificationInfo& info);




    virtual void keyboardDidShow(CCIMEKeyboardNotificationInfo& info);




    virtual void keyboardWillHide(CCIMEKeyboardNotificationInfo& info);




    virtual void keyboardDidHide(CCIMEKeyboardNotificationInfo& info);




    void touchDownAction(CCObject *sender, CCControlEvent controlEvent);

protected:
    CCEditBoxImpl* m_pEditBoxImpl;
    CCEditBoxDelegate* m_pDelegate;

    EditBoxInputMode m_eEditBoxInputMode;
    EditBoxInputFlag m_eEditBoxInputFlag;
    KeyboardReturnType m_eKeyboardReturnType;

    std::string m_strText;
    std::string m_strPlaceHolder;

    std::string m_strFontName;
    std::string m_strPlaceholderFontName;

    int m_nFontSize;
    int m_nPlaceholderFontSize;

    ccColor3B m_colText;
    ccColor3B m_colPlaceHolder;

    int m_nMaxLength;
    float m_fAdjustHeight;
    int m_nScriptEditBoxHandler;
};

}}
# 39 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/network/HttpRequest.h" 1
# 31 "Cacao/include/cocos2dext/network/HttpRequest.h"
namespace cocos2d { namespace extension {

class CCHttpClient;
class CCHttpResponse;
typedef void (CCObject::*SEL_HttpResponse)(CCHttpClient* client, CCHttpResponse* response);
# 46 "Cacao/include/cocos2dext/network/HttpRequest.h"
class CCHttpRequest : public CCObject
{
public:

    typedef enum
    {
        kHttpGet,
        kHttpPost,
        kHttpPut,
        kHttpDelete,
        kHttpUnkown,
    } HttpRequestType;







    CCHttpRequest()
    {
        _requestType = kHttpUnkown;
        _url.clear();
        _requestData.clear();
        _tag.clear();
        _pTarget = __null;
        _pSelector = __null;
        _pUserData = __null;
    };


    virtual ~CCHttpRequest()
    {
        if (_pTarget)
        {
            _pTarget->release();
        }
    };


    CCObject* autorelease(void)
    {
        ((void)(false));

        return __null;
    }






    inline void setRequestType(HttpRequestType type)
    {
        _requestType = type;
    };

    inline HttpRequestType getRequestType()
    {
        return _requestType;
    };



    inline void setUrl(const char* url)
    {
        _url = url;
    };

    inline const char* getUrl()
    {
        return _url.c_str();
    };



    inline void setRequestData(const char* buffer, unsigned int len)
    {
        _requestData.assign(buffer, buffer + len);
    };

    inline char* getRequestData()
    {
        return &(_requestData.front());
    }

    inline int getRequestDataSize()
    {
        return _requestData.size();
    }



    inline void setTag(const char* tag)
    {
        _tag = tag;
    };



    inline const char* getTag()
    {
        return _tag.c_str();
    };




    inline void setUserData(void* pUserData)
    {
        _pUserData = pUserData;
    };



    inline void* getUserData()
    {
        return _pUserData;
    };



    __attribute__((deprecated)) inline void setResponseCallback(CCObject* pTarget, SEL_CallFuncND pSelector)
    {
        setResponseCallback(pTarget, (SEL_HttpResponse) pSelector);
    }

    inline void setResponseCallback(CCObject* pTarget, SEL_HttpResponse pSelector)
    {
        _pTarget = pTarget;
        _pSelector = pSelector;

        if (_pTarget)
        {
            _pTarget->retain();
        }
    }

    inline CCObject* getTarget()
    {
        return _pTarget;
    }



    class _prxy
    {
    public:
        _prxy( SEL_HttpResponse cb ) :_cb(cb) {}
        ~_prxy(){};
        operator SEL_HttpResponse() const { return _cb; }
        __attribute__((deprecated)) operator SEL_CallFuncND() const { return (SEL_CallFuncND) _cb; }
    protected:
        SEL_HttpResponse _cb;
    };


    inline _prxy getSelector()
    {
        return _prxy(_pSelector);
    }


    inline void setHeaders(std::vector<std::string> pHeaders)
    {
     _headers=pHeaders;
    }


    inline std::vector<std::string> getHeaders()
    {
     return _headers;
    }


protected:

    HttpRequestType _requestType;
    std::string _url;
    std::vector<char> _requestData;
    std::string _tag;
    CCObject* _pTarget;
    SEL_HttpResponse _pSelector;
    void* _pUserData;
    std::vector<std::string> _headers;
};

}}
# 41 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/network/HttpResponse.h" 1
# 32 "Cacao/include/cocos2dext/network/HttpResponse.h"
namespace cocos2d { namespace extension {
# 41 "Cacao/include/cocos2dext/network/HttpResponse.h"
class CCHttpResponse : public CCObject
{
public:



    CCHttpResponse(CCHttpRequest* request)
    {
        _pHttpRequest = request;
        if (_pHttpRequest)
        {
            _pHttpRequest->retain();
        }

        _succeed = false;
        _responseData.clear();
        _errorBuffer.clear();
    }




    virtual ~CCHttpResponse()
    {
        if (_pHttpRequest)
        {
            _pHttpRequest->release();
        }
    }


    CCObject* autorelease(void)
    {
        ((void)(false));

        return __null;
    }






    inline CCHttpRequest* getHttpRequest()
    {
        return _pHttpRequest;
    }





    inline bool isSucceed()
    {
        return _succeed;
    };


    inline std::vector<char>* getResponseData()
    {
        return &_responseData;
    }


    inline std::vector<char>* getResponseHeader()
    {
        return &_responseHeader;
    }




    inline int getResponseCode()
    {
        return _responseCode;
    }



    inline const char* getErrorBuffer()
    {
        return _errorBuffer.c_str();
    }
# 133 "Cacao/include/cocos2dext/network/HttpResponse.h"
    inline void setSucceed(bool value)
    {
        _succeed = value;
    };




    inline void setResponseData(std::vector<char>* data)
    {
        _responseData = *data;
    }



    inline void setResponseHeader(std::vector<char>* data)
    {
        _responseHeader = *data;
    }




    inline void setResponseCode(int value)
    {
        _responseCode = value;
    }




    inline void setErrorBuffer(const char* value)
    {
        _errorBuffer.clear();
        _errorBuffer.assign(value);
    };

protected:
    bool initWithRequest(CCHttpRequest* request);


    CCHttpRequest* _pHttpRequest;
    bool _succeed;
    std::vector<char> _responseData;
    std::vector<char> _responseHeader;
    int _responseCode;
    std::string _errorBuffer;

};

}}
# 42 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/network/HttpClient.h" 1
# 35 "Cacao/include/cocos2dext/network/HttpClient.h"
namespace cocos2d { namespace extension {
# 48 "Cacao/include/cocos2dext/network/HttpClient.h"
class CCHttpClient : public CCObject
{
public:

    static CCHttpClient *getInstance();


    static void destroyInstance();







    void send(CCHttpRequest* request);







    inline void setTimeoutForConnect(int value) {_timeoutForConnect = value;};






    inline int getTimeoutForConnect() {return _timeoutForConnect;}







    inline void setTimeoutForRead(int value) {_timeoutForRead = value;};






    inline int getTimeoutForRead() {return _timeoutForRead;};

private:
    CCHttpClient();
    virtual ~CCHttpClient();
    bool init(void);





    bool lazyInitThreadSemphore();

    void dispatchResponseCallbacks(float delta);

private:
    int _timeoutForConnect;
    int _timeoutForRead;


};




}}
# 43 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDefine.h" 1
# 65 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDefine.h"
namespace cocos2d { namespace extension {

const char *armatureVersion();

}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/../utils/CCTweenFunction.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/../utils/CCTweenFunction.h"
namespace cocos2d { namespace extension {

enum CCTweenType
{
    CUSTOM_EASING = -1,

    Linear,

    Sine_EaseIn,
    Sine_EaseOut,
    Sine_EaseInOut,


    Quad_EaseIn,
    Quad_EaseOut,
    Quad_EaseInOut,

    Cubic_EaseIn,
    Cubic_EaseOut,
    Cubic_EaseInOut,

    Quart_EaseIn,
    Quart_EaseOut,
    Quart_EaseInOut,

    Quint_EaseIn,
    Quint_EaseOut,
    Quint_EaseInOut,

    Expo_EaseIn,
    Expo_EaseOut,
    Expo_EaseInOut,

    Circ_EaseIn,
    Circ_EaseOut,
    Circ_EaseInOut,

    Elastic_EaseIn,
    Elastic_EaseOut,
    Elastic_EaseInOut,

    Back_EaseIn,
    Back_EaseOut,
    Back_EaseInOut,

    Bounce_EaseIn,
    Bounce_EaseOut,
    Bounce_EaseInOut,

    TWEEN_EASING_MAX = 10000
};




class CCTweenFunction
{
public:

    static float tweenTo(float time, CCTweenType type, float *easingParam);

    static float linear(float time);

    static float sineEaseIn(float time);
    static float sineEaseOut(float time);
    static float sineEaseInOut(float time);

    static float quadEaseIn(float time);
    static float quadEaseOut(float time);
    static float quadEaseInOut(float time);

    static float cubicEaseIn(float time);
    static float cubicEaseOut(float time);
    static float cubicEaseInOut(float time);

    static float quartEaseIn(float time);
    static float quartEaseOut(float time);
    static float quartEaseInOut(float time);

    static float quintEaseIn(float time);
    static float quintEaseOut(float time);
    static float quintEaseInOut(float time);

    static float expoEaseIn(float time);
    static float expoEaseOut(float time);
    static float expoEaseInOut(float time);

    static float circEaseIn(float time);
    static float circEaseOut(float time);
    static float circEaseInOut(float time);

    static float elasticEaseIn(float time, float *easingParam);
    static float elasticEaseOut(float time, float *easingParam);
    static float elasticEaseInOut(float time, float *easingParam);

    static float backEaseIn(float time);
    static float backEaseOut(float time);
    static float backEaseInOut(float time);

    static float bounceEaseIn(float time);
    static float bounceEaseOut(float time);
    static float bounceEaseInOut(float time);

    static float customEase(float time, float *easingParam);
};


}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h" 2
# 58 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
namespace cocos2d { namespace extension {





class CCBaseData : public CCObject
{
public:
    public: static inline CCBaseData *create(void){ CCBaseData *var = new CCBaseData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:



    CCBaseData();



    ~CCBaseData(void);





    virtual void copy(const CCBaseData *node);







    virtual void subtract(CCBaseData *from, CCBaseData *to, bool limit);

    virtual void setColor(const ccColor4B &color);
    virtual ccColor4B getColor();
public:
    float x;
    float y;
    int zOrder;






    float skewX;
    float skewY;
    float scaleX;
    float scaleY;

    float tweenRotate;

    bool isUseColorInfo;
    int a, r, g, b;

};





enum DisplayType
{
    CS_DISPLAY_SPRITE,
    CS_DISPLAY_ARMATURE,
    CS_DISPLAY_PARTICLE,

    CS_DISPLAY_MAX
};




class CCDisplayData : public CCObject
{
public:
    public: static inline CCDisplayData *create(void){ CCDisplayData *var = new CCDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}

    static const char *changeDisplayToTexture(const char *displayName);
public:
    CCDisplayData();
    virtual ~CCDisplayData(void) {};

    virtual void copy(CCDisplayData *displayData);

    DisplayType displayType;
    std::string displayName;
};






class CCSpriteDisplayData : public CCDisplayData
{
public:
    public: static inline CCSpriteDisplayData *create(void){ CCSpriteDisplayData *var = new CCSpriteDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCSpriteDisplayData();
    virtual ~CCSpriteDisplayData() {};

    void copy(CCDisplayData *displayData);
public:
    CCBaseData skinData;
};





class CCArmatureDisplayData : public CCDisplayData
{
public:
    public: static inline CCArmatureDisplayData *create(void){ CCArmatureDisplayData *var = new CCArmatureDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCArmatureDisplayData();
    virtual ~CCArmatureDisplayData() {};
};





class CCParticleDisplayData : public CCDisplayData
{
public:
    public: static inline CCParticleDisplayData *create(void){ CCParticleDisplayData *var = new CCParticleDisplayData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCParticleDisplayData();
    virtual ~CCParticleDisplayData() {};
public:
};
# 202 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCBoneData : public CCBaseData
{
public:
    public: static inline CCBoneData *create(void){ CCBoneData *var = new CCBoneData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCBoneData(void);
    ~CCBoneData(void);

    virtual bool init();

    void addDisplayData(CCDisplayData *displayData);
    CCDisplayData *getDisplayData(int index);
public:
    std::string name;
    std::string parentName;
    CCArray displayDataList;
    CCAffineTransform boneDataTransform;
};
# 229 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCArmatureData : public CCObject
{
public:
    public: static inline CCArmatureData *create(void){ CCArmatureData *var = new CCArmatureData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCArmatureData();
    ~CCArmatureData();

    bool init();
    void addBoneData(CCBoneData *boneData);
    CCBoneData *getBoneData(const char *boneName);
public:
    std::string name;
    CCDictionary boneDataDic;
    float dataVersion;
};

enum CCBlendType
{
    BLEND_NORMAL,
    BLEND_LAYER,
    BLEND_DARKEN,
    BLEND_MULTIPLY,
    BLEND_LIGHTEN,
    BLEND_SCREEN,
    BLEND_OVERLAY,
    BLEND_HARD_LIGHT,
    BLEND_ADD,
    BLEND_SUBSTRACT,
    BLEND_DIFFERENCE,
    BLEND_INVERT,
    BLEND_ALPHA,
    BLEND_ERASE
};





class CCFrameData : public CCBaseData
{
public:
    public: static inline CCFrameData *create(void){ CCFrameData *var = new CCFrameData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCFrameData();
    ~CCFrameData();

    virtual void copy(const CCBaseData *node);
public:
    int frameID;
    int duration;

    CCTweenType tweenEasing;
    int easingParamNumber;
    float *easingParams;

    bool isTween;





    int displayIndex;

    ccBlendFunc blendFunc;

    std::string strEvent;



    std::string strMovement;
    std::string strSound;
    std::string strSoundEffect;
};





class CCMovementBoneData : public CCObject
{
public:
    public: static inline CCMovementBoneData *create(void){ CCMovementBoneData *var = new CCMovementBoneData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCMovementBoneData();
    ~CCMovementBoneData(void);

    virtual bool init();

    void addFrameData(CCFrameData *frameData);
    CCFrameData *getFrameData(int index);
public:
    float delay;
    float scale;
    float duration;
    std::string name;

    CCArray frameList;
};





class CCMovementData : public CCObject
{
public:
    public: static inline CCMovementData *create(void){ CCMovementData *var = new CCMovementData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCMovementData(void);
    ~CCMovementData(void);

    void addMovementBoneData(CCMovementBoneData *movBoneData);
    CCMovementBoneData *getMovementBoneData(const char *boneName);
public:
    std::string name;
    int duration;
    float scale;







    int durationTo;







    int durationTween;

    bool loop;





    CCTweenType tweenEasing;






    CCDictionary movBoneDataDic;
};
# 388 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCAnimationData : public CCObject
{
public:
    public: static inline CCAnimationData *create(void){ CCAnimationData *var = new CCAnimationData(); if (var){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCAnimationData(void);
    ~CCAnimationData(void);

    void addMovement(CCMovementData *movData);
    CCMovementData *getMovement(const char *movementName);
    int getMovementCount();
public:
    std::string name;
    CCDictionary movementDataDic;
    std::vector<std::string> movementNames;
};


struct CCContourVertex2 : public CCObject
{
    CCContourVertex2(float xx, float yy)
    {
        this->x = xx;
        this->y = yy;
    }

    float x;
    float y;
};






class CCContourData : public CCObject
{
public:
    public: static inline CCContourData *create(void){ CCContourData *var = new CCContourData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCContourData();
    ~CCContourData(void);

    virtual bool init();
    virtual void addVertex(CCPoint *vertex);
public:
    CCArray vertexList;
};
# 445 "Cacao/include/cocos2dext/CocoStudio/Armature/datas/CCDatas.h"
class CCTextureData : public CCObject
{
public:
    public: static inline CCTextureData *create(void){ CCTextureData *var = new CCTextureData(); if (var && var->init()){ var->autorelease(); return var;} do { if(var) { delete (var); (var) = 0; } } while(0); return __null;}
public:
    CCTextureData();
    ~CCTextureData(void);

    virtual bool init();

    void addContourData(CCContourData *contourData);
    CCContourData *getContourData(int index);
public:

    float height;
    float width;

    float pivotX;
    float pivotY;

    std::string name;

    CCArray contourDataList;
};


}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h"
namespace cocos2d { namespace extension {

enum AnimationType
{
    SINGLE_FRAME = -4,
    ANIMATION_NO_LOOP,

    ANIMATION_TO_LOOP_FRONT,
    ANIMATION_TO_LOOP_BACK,

    ANIMATION_LOOP_FRONT,
    ANIMATION_LOOP_BACK,

    ANIMATION_MAX,

};





class CCProcessBase : public CCObject
{
public:
    CCProcessBase(void);
    ~CCProcessBase(void);
# 86 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h"
    virtual void play(int durationTo, int durationTween, int loop, int tweenEasing);




    virtual void pause();



    virtual void resume();



    virtual void stop();
# 109 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCProcessBase.h"
    virtual void update(float dt);

    virtual int getCurrentFrameIndex();

protected:

    virtual void gotoFrame(int frameIndex);




    virtual void updateHandler() {};

protected:

    protected: float m_fProcessScale;public: virtual float getProcessScale(void) const { return m_fProcessScale; }public: virtual void setProcessScale(float var){ m_fProcessScale = var; };


    protected: bool m_bIsPause;public: virtual bool getIsPause(void) const { return m_bIsPause; }public: virtual void setIsPause(bool var){ m_bIsPause = var; };


    protected: bool m_bIsComplete;public: virtual bool getIsComplete(void) const { return m_bIsComplete; }public: virtual void setIsComplete(bool var){ m_bIsComplete = var; };


    protected: bool m_bIsPlaying;public: virtual bool getIsPlaying(void) const { return m_bIsPlaying; }public: virtual void setIsPlaying(bool var){ m_bIsPlaying = var; };


    protected: float m_fCurrentPercent;public: virtual float getCurrentPercent(void) const { return m_fCurrentPercent; }public: virtual void setCurrentPercent(float var){ m_fCurrentPercent = var; };


    protected: int m_iRawDuration;public: virtual int getRawDuration(void) const { return m_iRawDuration; }public: virtual void setRawDuration(int var){ m_iRawDuration = var; };


    protected: AnimationType m_eLoopType;public: virtual AnimationType getLoopType(void) const { return m_eLoopType; }public: virtual void setLoopType(AnimationType var){ m_eLoopType = var; };


    protected: CCTweenType m_eTweenEasing;public: virtual CCTweenType getTweenEasing(void) const { return m_eTweenEasing; }public: virtual void setTweenEasing(CCTweenType var){ m_eTweenEasing = var; };

protected:

    int m_iDurationTween;


    float m_fCurrentFrame;

    int m_iCurFrameIndex;


    int m_iNextFrameIndex;


    bool m_bIsLoopBack;


    float m_fAnimationInternal;
};

}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h" 2


namespace cocos2d { namespace extension {

class CCBone;
class CCArmatureAnimation;




class CCTween : public CCProcessBase
{
public:




    static CCTween *create(CCBone *bone);
public:
    CCTween(void);
    virtual ~CCTween(void);





    virtual bool init(CCBone *bone);

    using CCProcessBase::play;
# 81 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCTween.h"
    virtual void play(CCMovementBoneData *movementBoneData, int durationTo, int durationTween, int loop, int tweenEasing);

    virtual void gotoAndPlay(int frameIndex);
    virtual void gotoAndPause(int frameIndex);

    inline void setAnimation(CCArmatureAnimation *animation) { m_pAnimation = animation; }
    inline CCArmatureAnimation *getAnimation() const { return m_pAnimation; }
protected:




    virtual void updateHandler();




    virtual float updateFrameData(float currentPercent);




    virtual void setBetween(CCFrameData *from, CCFrameData *to, bool limit = true);




    virtual CCFrameData *tweenNodeTo(float percent, CCFrameData *node = __null);




    virtual void tweenColorTo(float percent, CCFrameData *node);




    virtual void arriveKeyFrame(CCFrameData *keyFrameData);
protected:

    protected: CCMovementBoneData * m_pMovementBoneData;public: virtual CCMovementBoneData * getMovementBoneData(void) const { return m_pMovementBoneData; }public: virtual void setMovementBoneData(CCMovementBoneData * var){ m_pMovementBoneData = var; }

    CCFrameData *m_pTweenData;
    CCFrameData *m_pFrom;
    CCFrameData *m_pTo;
    CCFrameData *m_pBetween;


    CCBone *m_pBone;

    CCTweenType m_eFrameTweenEasing;

    int m_iBetweenDuration;
    int m_iTotalDuration;


    int m_iFromIndex;
    int m_iToIndex;

    CCArmatureAnimation *m_pAnimation;

    bool m_bPassLastFrame;
};

}}
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayFactory.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayFactory.h"
namespace cocos2d { namespace extension {

class CCSkin;
class CCBone;
class CCDecorativeDisplay;
class CCDisplayData;




class CCDisplayFactory
{
public:
    static void addDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void updateDisplay(CCBone *bone, float dt, bool dirty);

    static void addSpriteDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createSpriteDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void initSpriteDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, const char *displayName, CCSkin *skin);


    static void addArmatureDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createArmatureDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void updateArmatureDisplay(CCBone *bone, CCNode *display, float dt);

    static void addParticleDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay, CCDisplayData *displayData);
    static void createParticleDisplay(CCBone *bone, CCDecorativeDisplay *decoDisplay);
    static void updateParticleDisplay(CCBone *bone, CCNode *display, float dt);
};


}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h" 2




# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h" 1
# 45 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h"
namespace cocos2d { namespace extension {

class CCBone;




class CCColliderFilter
{
public:
    ~CCColliderFilter() { }
# 73 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h"
};





class ColliderBody : public CCObject
{
public:





    protected: CCArray * m_pCalculatedVertexList;public: virtual CCArray * getCalculatedVertexList(void) const { return m_pCalculatedVertexList; };


public:
    ColliderBody(CCContourData *contourData);
    ~ColliderBody();

    inline CCContourData *getContourData() { return m_pContourData; }
# 103 "Cacao/include/cocos2dext/CocoStudio/Armature/display/../physics/CCColliderDetector.h"
private:
    CCContourData *m_pContourData;
};






class CCColliderDetector : public CCObject
{
public:
    static CCColliderDetector *create();
    static CCColliderDetector *create(CCBone *bone);
public:
    CCColliderDetector();
    ~CCColliderDetector(void);

    virtual bool init();
    virtual bool init(CCBone *bone);

    void addContourData(CCContourData *contourData);
    void addContourDataList(CCArray *contourDataList);

    void removeContourData(CCContourData *contourData);
    void removeAll();

    void updateTransform(CCAffineTransform &t);

    void setActive(bool active);
    bool getActive();

    CCArray *getColliderBodyList();







protected:
    CCArray *m_pColliderBodyList;

    protected: CCBone * m_pBone;public: virtual CCBone * getBone(void) const { return m_pBone; }public: virtual void setBone(CCBone * var){ m_pBone = var; };







protected:
    bool m_bActive;
};

}}
# 35 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDecorativeDisplay.h" 2


namespace cocos2d { namespace extension {




class CCDecorativeDisplay: public CCObject
{
public:
    static CCDecorativeDisplay *create();
public:
    CCDecorativeDisplay(void);
    ~CCDecorativeDisplay(void);

    virtual bool init();

protected:

    private: CCNode * m_pDisplay; public: virtual CCNode * getDisplay(void) const { return m_pDisplay; } public: virtual void setDisplay(CCNode * var) { if (m_pDisplay != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pDisplay) { (m_pDisplay)->release(); } } while(0); m_pDisplay = var; } };
    private: CCDisplayData * m_pDisplayData; public: virtual CCDisplayData * getDisplayData(void) const { return m_pDisplayData; } public: virtual void setDisplayData(CCDisplayData * var) { if (m_pDisplayData != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pDisplayData) { (m_pDisplayData)->release(); } } while(0); m_pDisplayData = var; } };


    private: CCColliderDetector * m_pColliderDetector; public: virtual CCColliderDetector * getColliderDetector(void) const { return m_pColliderDetector; } public: virtual void setColliderDetector(CCColliderDetector * var) { if (m_pColliderDetector != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pColliderDetector) { (m_pColliderDetector)->release(); } } while(0); m_pColliderDetector = var; } };

};

}}
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h"
namespace cocos2d { namespace extension {

class CCBone;





class CCDisplayManager : public CCObject
{
public:
    static CCDisplayManager *create(CCBone *bone);

public:
    CCDisplayManager();
    ~CCDisplayManager();

    bool init(CCBone *bone);






    virtual void initDisplayList(CCBoneData *boneData);
# 69 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h"
    void addDisplay(CCDisplayData *displayData, int index);

    void addDisplay(CCNode *display, int index);

    void removeDisplay(int index);

    CCArray *getDecorativeDisplayList();




    __attribute__((deprecated)) void changeDisplayByIndex(int index, bool force);
    __attribute__((deprecated)) void changeDisplayByName(const char *name, bool force);
# 92 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCDisplayManager.h"
    void changeDisplayWithIndex(int index, bool force);
    void changeDisplayWithName(const char *name, bool force);

    CCNode *getDisplayRenderNode();
    DisplayType getDisplayRenderNodeType();

    int getCurrentDisplayIndex();

    virtual void setCurrentDecorativeDisplay(CCDecorativeDisplay *decoDisplay);
    virtual CCDecorativeDisplay *getCurrentDecorativeDisplay();
    virtual CCDecorativeDisplay *getDecorativeDisplayByIndex( int index);







    virtual void setVisible(bool visible);






    virtual bool isVisible();

    CCSize getContentSize();
    CCRect getBoundingBox();

    CCPoint getAnchorPoint();
    CCPoint getAnchorPointInPoints();




    virtual bool containPoint(CCPoint &_point);




    virtual bool containPoint(float x, float y);

protected:
    CCArray *m_pDecoDisplayList;

    CCNode *m_pDisplayRenderNode;

    DisplayType m_eDisplayType;

    CCDecorativeDisplay *m_pCurrentDecoDisplay;

    int m_iDisplayIndex;

    protected: bool m_bForceChangeDisplay;public: virtual bool getForceChangeDisplay(void) const { return m_bForceChangeDisplay; }public: virtual void setForceChangeDisplay(bool var){ m_bForceChangeDisplay = var; }


    bool m_bVisible;

    CCBone *m_pBone;
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h" 2

namespace cocos2d { namespace extension {

class CCArmature;



class CCBone : public CCNodeRGBA
{
public:




    static CCBone *create();






    static CCBone *create(const char *name);

public:



    CCBone();



    virtual ~CCBone(void);




    virtual bool init();





    virtual bool init(const char *name);
# 88 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h"
    void addDisplay(CCDisplayData *displayData, int index);

    void addDisplay(CCNode *display, int index);

    void removeDisplay(int index);




    __attribute__((deprecated)) void changeDisplayByIndex(int index, bool force);
    __attribute__((deprecated)) void changeDisplayByName(const char *name, bool force);

    void changeDisplayWithIndex(int index, bool force);
    void changeDisplayWithName(const char *name, bool force);





    void addChildBone(CCBone *child);
# 117 "Cacao/include/cocos2dext/CocoStudio/Armature/CCBone.h"
    void setParentBone(CCBone *parent);





    CCBone *getParentBone();

    using CCNode::removeFromParent;




    void removeFromParent(bool recursion);





    void removeChildBone(CCBone *bone, bool recursion);

    void update(float delta);

    void updateDisplayedColor(const ccColor3B &parentColor);
    void updateDisplayedOpacity(GLubyte parentOpacity);

    void setColor(const ccColor3B &color);
    void setOpacity(GLubyte opacity);


    void updateColor();


    void updateZOrder();

    virtual void setZOrder(int zOrder);

    CCTween *getTween();




    virtual inline void setTransformDirty(bool dirty) { m_bBoneTransformDirty = dirty; }
    virtual inline bool isTransformDirty() { return m_bBoneTransformDirty; }




    virtual void setBlendFunc(const ccBlendFunc& blendFunc);
    virtual ccBlendFunc getBlendFunc(void) { return m_sBlendFunc; }




    virtual void setBlendDirty(bool dirty) { m_bBlendDirty = dirty; }
    virtual bool isBlendDirty(void) { return m_bBlendDirty; }

    virtual CCAffineTransform nodeToArmatureTransform();
    virtual CCAffineTransform nodeToWorldTransform();

    CCNode *getDisplayRenderNode();
    DisplayType getDisplayRenderNodeType();




    virtual CCArray *getColliderBodyList();






public:




    protected: CCBoneData * m_pBoneData;public: virtual CCBoneData * getBoneData(void);public: virtual void setBoneData(CCBoneData * var);;


    protected: CCArmature * m_pArmature;public: virtual CCArmature * getArmature(void);public: virtual void setArmature(CCArmature * var);;


    protected: CCArmature * m_pChildArmature;public: virtual CCArmature * getChildArmature(void);public: virtual void setChildArmature(CCArmature * var);;

    protected: CCDisplayManager * m_pDisplayManager;public: virtual CCDisplayManager * getDisplayManager(void) const { return m_pDisplayManager; }public: virtual void setDisplayManager(CCDisplayManager * var){ m_pDisplayManager = var; }





    protected: bool m_bIgnoreMovementBoneData;public: virtual bool getIgnoreMovementBoneData(void) const { return m_bIgnoreMovementBoneData; }public: virtual void setIgnoreMovementBoneData(bool var){ m_bIgnoreMovementBoneData = var; }

protected:
    virtual void applyParentTransform(CCBone *parent);

    CCTween *m_pTween;


    protected: CCFrameData * m_pTweenData;public: virtual CCFrameData * getTweenData(void) const { return m_pTweenData; };

    protected: std::string m_strName;public: virtual std::string getName(void) const { return m_strName; }public: virtual void setName(std::string var){ m_strName = var; };

    CCBone *m_pParentBone;
    bool m_bBoneTransformDirty;


    CCAffineTransform m_tWorldTransform;


    protected: CCBaseData * m_tWorldInfo;public: virtual CCBaseData * getWorldInfo(void) const { return m_tWorldInfo; };


    CCBone *m_pArmatureParentBone;


    float m_fDataVersion;

    ccBlendFunc m_sBlendFunc;
    bool m_bBlendDirty;
};

}}
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCBatchNode.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCBatchNode.h"
namespace cocos2d { namespace extension {



class CCBatchNode : public CCNode
{
public:
    static CCBatchNode *create();
public:



    CCBatchNode();



    ~CCBatchNode();



    virtual bool init();
    virtual void addChild(CCNode *pChild);
    virtual void addChild(CCNode *pChild, int zOrder);
    virtual void addChild(CCNode *pChild, int zOrder, int tag);
    virtual void removeChild(CCNode* child, bool cleanup);
    virtual void visit();



    void draw();

    virtual CCTextureAtlas *getTexureAtlasWithTexture(CCTexture2D *texture);
protected:
    CCTextureAtlas *m_pAtlas;
    CCDictionary *m_pTextureAtlasDic;
};

}}
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 3
# 73 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 1 3
# 64 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 3






# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 1 3
# 69 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
namespace std {
# 83 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
# 101 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) {}

      _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) {}

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }







      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value);
# 370 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }

      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 478 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 628 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;






      using _Base::_M_impl;

    public:





      explicit
      deque(const allocator_type& __a = allocator_type())
      : _Base(__a, 0) {}
# 693 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 706 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 726 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 751 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 764 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 780 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }


      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }



      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 886 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }





      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 916 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 931 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 956 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 974 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1031 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1052 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1073 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1094 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1116 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1142 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1165 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1184 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1196 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:



      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(__n);
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1257 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1281 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);





      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
   _M_fill_assign(static_cast<size_type>(__n),
    static_cast<value_type>(__val));
 }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }







      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);

      void _M_pop_back_aux();

      void _M_pop_front_aux();






      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        {
   _M_fill_insert(__pos, static_cast<size_type>(__n),
    static_cast<value_type>(__x));
 }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);


      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);

      void
      _M_destroy_data_dispatch(iterator, iterator, __true_type) { }

      void
      _M_destroy_data_dispatch(iterator __first, iterator __last, __false_type)
      { _M_destroy_data_aux(__first, __last); }



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 typedef typename std::__is_scalar<value_type>::__type
   _Has_trivial_destructor;
 _M_destroy_data_dispatch(__first, __last, _Has_trivial_destructor());
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }
# 1477 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1515 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1547 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1565 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }

}
# 71 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 2 3


# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/deque.tcc" 1 3
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/deque.tcc" 3
namespace std {

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_back_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_back();
      *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t_copy);
          this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
           + 1);
          this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
        }
      catch(...)
        {
          _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_push_front_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_front();
      *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
      try
        {
          this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
          - 1);
          this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
          this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t_copy);
        }
      catch(...)
        {
          ++this->_M_impl._M_start;
          _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, const value_type& __x)
    {
      difference_type __index = __pos - this->_M_impl._M_start;
      value_type __x_copy = __x;
      if (static_cast<size_type>(__index) < size() / 2)
 {
   push_front(front());
   iterator __front1 = this->_M_impl._M_start;
   ++__front1;
   iterator __front2 = __front1;
   ++__front2;
   __pos = this->_M_impl._M_start + __index;
   iterator __pos1 = __pos;
   ++__pos1;
   std::copy(__front2, __pos1, __front1);
 }
      else
 {
   push_back(back());
   iterator __back1 = this->_M_impl._M_finish;
   --__back1;
   iterator __back2 = __back1;
   --__back2;
   __pos = this->_M_impl._M_start + __index;
   std::copy_backward(__pos, __back2, __back1);
 }
      *__pos = __x_copy;
      return __pos;
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_copy_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_copy_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_copy(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_copy_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_copy_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_copy_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_copy(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

}
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/deque" 2 3
# 74 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 2 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 1 3
# 68 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
namespace std {
# 94 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;





      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 128 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      _Sequence c;

    public:



      explicit
      queue(const _Sequence& __c = _Sequence()) : c(__c) {}




      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
                              ;
 return c.front();
      }





      const_reference
      front() const
      {
                              ;
 return c.front();
      }





      reference
      back()
      {
                              ;
 return c.back();
      }





      const_reference
      back() const
      {
                              ;
 return c.back();
      }
# 202 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }
# 217 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      pop()
      {
                              ;
 c.pop_front();
      }
    };
# 237 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 255 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }
# 320 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;







    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;
      _Compare comp;

    public:



      explicit
      priority_queue(const _Compare& __x = _Compare(),
       const _Sequence& __s = _Sequence())
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }
# 370 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         const _Sequence& __s = _Sequence())
 : c(__s), comp(__x)
        {
                                                  ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }




      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
                              ;
 return c.front();
      }
# 412 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }
# 430 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/bits/stl_queue.h" 3
      void
      pop()
      {
                              ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }
    };



}
# 76 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/queue" 2 3
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h" 2

namespace cocos2d { namespace extension {


enum MovementEventType
{
    START,
    COMPLETE,
    LOOP_COMPLETE
};


class CCArmature;
class CCBone;

typedef void (CCObject::*SEL_MovementEventCallFunc)(CCArmature *, MovementEventType, const char *);
typedef void (CCObject::*SEL_FrameEventCallFunc)(CCBone *, const char *, int, int);




struct CCFrameEvent
{
    CCBone *bone;
    const char *frameEventName;
    int originFrameIndex;
    int currentFrameIndex;
};

struct CCMovementEvent
{
    CCArmature *armature;
    MovementEventType movementType;
    const char *movementID;
};




class CCArmatureAnimation : public CCProcessBase
{
public:




    static CCArmatureAnimation *create(CCArmature *armature);
public:



    CCArmatureAnimation();



    virtual ~CCArmatureAnimation(void);





    virtual bool init(CCArmature *armature);






    __attribute__((deprecated)) virtual void setAnimationScale(float animationScale);
    __attribute__((deprecated)) virtual float getAnimationScale() const;





    virtual void setSpeedScale(float speedScale);
    virtual float getSpeedScale() const;


    __attribute__((deprecated)) virtual void setAnimationInternal(float animationInternal) {};

    using CCProcessBase::play;
# 141 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    virtual void play(const char *animationName, int durationTo = -1, int durationTween = -1, int loop = -1, int tweenEasing = TWEEN_EASING_MAX);






    __attribute__((deprecated)) virtual void playByIndex(int animationIndex, int durationTo = -1, int durationTween = -1, int loop = -1, int tweenEasing = TWEEN_EASING_MAX);
    virtual void playWithIndex(int animationIndex, int durationTo = -1, int durationTween = -1, int loop = -1, int tweenEasing = TWEEN_EASING_MAX);




    virtual void playWithNames(const std::vector<std::string>& movementNames, int durationTo = -1, bool loop = true);




    virtual void playWithIndexes(const std::vector<int>& movementIndexes, int durationTo = -1, bool loop = true);



    virtual void playWithArray(cocos2d::CCArray *movementNames, int durationTo = -1, bool loop = true);
    virtual void playWithIndexArray(cocos2d::CCArray *movementIndexes, int durationTo = -1, bool loop = true);
# 176 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    virtual void gotoAndPlay(int frameIndex);




    virtual void gotoAndPause(int frameIndex);




    virtual void pause();



    virtual void resume();



    virtual void stop();





    int getMovementCount();

    void update(float dt);





    std::string getCurrentMovementID();





    void setMovementEventCallFunc(CCObject *target, SEL_MovementEventCallFunc callFunc);





    void setFrameEventCallFunc(CCObject *target, SEL_FrameEventCallFunc callFunc);







    virtual CCObject* getUserObject();
# 238 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    virtual void setUserObject(CCObject *pUserObject);
protected:





    void updateHandler();





    void updateFrameData(float currentPercent);





    void frameEvent(CCBone *bone, const char *frameEventName, int originFrameIndex, int currentFrameIndex);




    void movementEvent(CCArmature *armature, MovementEventType movementType, const char *movementID);

    void updateMovementList();

    inline bool isIgnoreFrameEvent() { return m_bIgnoreFrameEvent; }

    friend class CCTween;
protected:

    private: CCAnimationData * m_pAnimationData; public: virtual CCAnimationData * getAnimationData(void) const { return m_pAnimationData; } public: virtual void setAnimationData(CCAnimationData * var) { if (m_pAnimationData != var) { do { if(var) { (var)->retain(); } } while(0); do { if(m_pAnimationData) { (m_pAnimationData)->release(); } } while(0); m_pAnimationData = var; } };


    float m_fSpeedScale;

    CCMovementData *m_pMovementData;

    CCArmature *m_pArmature;

    std::string m_strMovementID;

    int m_iToIndex;

    CCArray *m_pTweenList;

    bool m_bIgnoreFrameEvent;

    std::queue<CCFrameEvent*> m_sFrameEventQueue;
    std::queue<CCMovementEvent*> m_sMovementEventQueue;

    std::vector<std::string> m_sMovementList;

    bool m_bOnMovementList;
    bool m_bMovementListLoop;
    unsigned int m_uMovementIndex;
 int m_iMovementListDurationTo;

    CCObject *m_pUserObject;
protected:






    SEL_MovementEventCallFunc m_sMovementEventCallFunc;
# 315 "Cacao/include/cocos2dext/CocoStudio/Armature/animation/CCArmatureAnimation.h"
    SEL_FrameEventCallFunc m_sFrameEventCallFunc;


    CCObject *m_sMovementEventTarget;
    CCObject *m_sFrameEventTarget;
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h" 2

class b2Body;
struct cpBody;

namespace cocos2d { namespace extension {



class CCArmature : public CCNodeRGBA, public CCBlendProtocol
{

public:





    static CCArmature *create();







    static CCArmature *create(const char *name);

    static CCArmature *create(const char *name, CCBone *parentBone);

public:



    CCArmature();



    ~CCArmature(void);




    virtual bool init();





    virtual bool init(const char *name);

    virtual bool init(const char *name, CCBone *parentBone);






    virtual void addBone(CCBone *bone, const char *parentName);





    virtual CCBone *getBone(const char *name) const;






    virtual void changeBoneParent(CCBone *bone, const char *parentName);






    virtual void removeBone(CCBone *bone, bool recursion);





    CCDictionary *getBoneDic();




    virtual CCRect boundingBox();

    CCBone *getBoneAtPoint(float x, float y);

    virtual void visit();
    virtual void update(float dt);
    virtual void draw();

    virtual const CCAffineTransform nodeToParentTransform();

    virtual void onEnter();
    virtual void onExit();




    virtual void updateOffsetPoint();

    inline void setBlendFunc(ccBlendFunc blendFunc)
    {
        m_sBlendFunc = blendFunc;
    }
    inline ccBlendFunc getBlendFunc(void)
    {
        return m_sBlendFunc;
    }

    virtual void setAnimation(CCArmatureAnimation *animation);
    virtual CCArmatureAnimation *getAnimation();

    virtual CCTextureAtlas *getTexureAtlasWithTexture(CCTexture2D *texture);




    virtual void drawContour();
# 171 "Cacao/include/cocos2dext/CocoStudio/Armature/CCArmature.h"
protected:





    CCBone *createBone(const char *boneName );

    protected: CCArmatureData * m_pArmatureData;public: virtual CCArmatureData * getArmatureData(void) const { return m_pArmatureData; }public: virtual void setArmatureData(CCArmatureData * var){ m_pArmatureData = var; };

    protected: CCBatchNode * m_pBatchNode;public: virtual CCBatchNode * getBatchNode(void) const { return m_pBatchNode; }public: virtual void setBatchNode(CCBatchNode * var){ m_pBatchNode = var; };

    protected: std::string m_strName;public: virtual std::string getName(void) const { return m_strName; }public: virtual void setName(std::string var){ m_strName = var; };

    protected: CCTextureAtlas * m_pAtlas;public: virtual CCTextureAtlas * getTextureAtlas(void) const { return m_pAtlas; }public: virtual void setTextureAtlas(CCTextureAtlas * var){ m_pAtlas = var; };

    protected: CCBone * m_pParentBone;public: virtual CCBone * getParentBone(void);public: virtual void setParentBone(CCBone * var);;

    protected: float m_fVersion;public: virtual float getVersion(void) const { return m_fVersion; }public: virtual void setVersion(float var){ m_fVersion = var; };

    protected: bool m_bArmatureTransformDirty;public: virtual bool getArmatureTransformDirty(void) const { return m_bArmatureTransformDirty; };
protected:
    CCDictionary *m_pBoneDic;

    CCArray *m_pTopBoneList;

    static std::map<int, CCArmature *> m_sArmatureIndexDic;

    ccBlendFunc m_sBlendFunc;

    CCPoint m_pOffsetPoint;

    CCArmatureAnimation *m_pAnimation;

    CCDictionary *m_pTextureAtlasDic;






};

}}
# 45 "Cacao/include/cocos2dext/cocos-ext.h" 2






# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCSkin.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/display/CCSkin.h"
namespace cocos2d { namespace extension {



class CCSkin : public CCSprite
{
public:
    static CCSkin *create();
    static CCSkin *createWithSpriteFrameName(const char *pszSpriteFrameName);
    static CCSkin *create(const char *pszFileName);
public:



    CCSkin();

    bool initWithSpriteFrameName(const char *pszSpriteFrameName);
    bool initWithFile(const char *pszFilename);

    void updateArmatureTransform();
    void updateTransform();

    CCAffineTransform nodeToWorldTransform();
    CCAffineTransform nodeToWorldTransformAR();

    protected: CCBaseData m_sSkinData;public: virtual const CCBaseData& getSkinData(void);public: virtual void setSkinData(const CCBaseData& var);;
    protected: CCBone * m_pBone;public: virtual CCBone * getBone(void);public: virtual void setBone(CCBone * var);;

protected:
    CCArmature *m_pArmature;
    CCAffineTransform m_tSkinTransform;
    protected: std::string m_strDisplayName;public: virtual std::string getDisplayName(void) const { return m_strDisplayName; }
};

}}
# 52 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDataManager.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDataManager.h"
namespace cocos2d { namespace extension {

struct CCRelativeData
{
    std::vector<std::string> plistFiles;
    std::vector<std::string> armatures;
    std::vector<std::string> animations;
    std::vector<std::string> textures;
};





class CCArmatureDataManager : public CCObject
{
public:



    static CCArmatureDataManager *sharedArmatureDataManager();

    static void purge();
private:
    CCArmatureDataManager(void);
    ~CCArmatureDataManager(void);

public:




    virtual bool init();
# 73 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCArmatureDataManager.h"
    void addArmatureData(const char *id, CCArmatureData *armatureData, const char *configFilePath = "");






    CCArmatureData *getArmatureData(const char *id);





    void removeArmatureData(const char *id);






    void addAnimationData(const char *id, CCAnimationData *animationData, const char *configFilePath = "");






    CCAnimationData *getAnimationData(const char *id);





    void removeAnimationData(const char *id);






    void addTextureData(const char *id, CCTextureData *textureData, const char *configFilePath = "");






    CCTextureData *getTextureData(const char *id);





    void removeTextureData(const char *id);




    void addArmatureFileInfo(const char *configFilePath);





    void addArmatureFileInfoAsync(const char *configFilePath, CCObject *target, SEL_SCHEDULE selector);




    void addArmatureFileInfo(const char *imagePath, const char *plistPath, const char *configFilePath);





    void addArmatureFileInfoAsync(const char *imagePath, const char *plistPath, const char *configFilePath, CCObject *target, SEL_SCHEDULE selector);


    virtual void removeArmatureFileInfo(const char *configFilePath);





    void addSpriteFrameFromFile(const char *plistPath, const char *imagePath, const char *configFilePath = "");





    bool isAutoLoadSpriteFile();


    CCDictionary *getArmatureDatas() const;
    CCDictionary *getAnimationDatas() const;
    CCDictionary *getTextureDatas() const;

protected:
    void addRelativeData(const char* configFilePath);
    CCRelativeData *getRelativeData(const char* configFilePath);
private:





    CCDictionary *m_pArmarureDatas;






    CCDictionary *m_pAnimationDatas;






    CCDictionary *m_pTextureDatas;

    bool m_bAutoLoadSpriteFile;

    std::map<std::string, CCRelativeData> m_sRelativeDatas;
};


}}
# 54 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCDataReaderHelper.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCDataReaderHelper.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/DictionaryHelper.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/DictionaryHelper.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h" 1



# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 1






# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h" 1
# 63 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
namespace rapidjson {



typedef unsigned SizeType;
}
# 79 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cassert" 1 3
# 48 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cassert" 3

# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 1 3
# 75 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/assert.h" 3
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));



}
# 50 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk//usr/include/c++/4.2.1/cassert" 2 3
# 80 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h" 2
# 90 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
namespace rapidjson {
# 132 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
class CrtAllocator {
public:
 static const bool kNeedFree = true;
 void* Malloc(size_t size) { return malloc(size); }
 void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) { (void)originalSize; return realloc(originalPtr, newSize); }
 static void Free(void *ptr) { free(ptr); }
};
# 159 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template <typename BaseAllocator = CrtAllocator>
class MemoryPoolAllocator {
public:
 static const bool kNeedFree = false;





 MemoryPoolAllocator(size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :
  chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(0), baseAllocator_(baseAllocator), ownBaseAllocator_(0)
 {
  if (!baseAllocator_)
   ownBaseAllocator_ = baseAllocator_ = new BaseAllocator();
  AddChunk(chunk_capacity_);
 }
# 186 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
 MemoryPoolAllocator(char *buffer, size_t size, size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :
  chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(buffer), baseAllocator_(baseAllocator), ownBaseAllocator_(0)
 {
  (__builtin_expect(!(buffer != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 189, "buffer != 0") : (void)0);
  (__builtin_expect(!(size > sizeof(ChunkHeader)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 190, "size > sizeof(ChunkHeader)") : (void)0);
  chunkHead_ = (ChunkHeader*)buffer;
  chunkHead_->capacity = size - sizeof(ChunkHeader);
  chunkHead_->size = 0;
  chunkHead_->next = 0;
 }




 ~MemoryPoolAllocator() {
  Clear();
  delete ownBaseAllocator_;
 }


 void Clear() {
  while(chunkHead_ != 0 && chunkHead_ != (ChunkHeader *)userBuffer_) {
   ChunkHeader* next = chunkHead_->next;
   baseAllocator_->Free(chunkHead_);
   chunkHead_ = next;
  }
 }




 size_t Capacity() {
  size_t capacity = 0;
  for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)
   capacity += c->capacity;
  return capacity;
 }




 size_t Size() {
  size_t size = 0;
  for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)
   size += c->size;
  return size;
 }


 void* Malloc(size_t size) {
  size = (size + 3) & ~3;

  if (chunkHead_->size + size > chunkHead_->capacity)
   AddChunk(chunk_capacity_ > size ? chunk_capacity_ : size);

  char *buffer = (char *)(chunkHead_ + 1) + chunkHead_->size;
  (__builtin_expect(!(((uintptr_t)buffer & 3) == 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 242, "((uintptr_t)buffer & 3) == 0") : (void)0);
  chunkHead_->size += size;

  return buffer;
 }


 void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {
  if (originalPtr == 0)
   return Malloc(newSize);


  if (originalSize >= newSize)
   return originalPtr;


  if (originalPtr == (char *)(chunkHead_ + 1) + chunkHead_->size - originalSize) {
   size_t increment = newSize - originalSize;
   increment = (increment + 3) & ~3;
   if (chunkHead_->size + increment <= chunkHead_->capacity) {
    chunkHead_->size += increment;
    (__builtin_expect(!(((uintptr_t)originalPtr & 3) == 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 263, "((uintptr_t)originalPtr & 3) == 0") : (void)0);
    return originalPtr;
   }
  }


  void* newBuffer = Malloc(newSize);
  (__builtin_expect(!(newBuffer != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 270, "newBuffer != 0") : (void)0);
  return memcpy(newBuffer, originalPtr, originalSize);
 }


 static void Free(void *) {}

private:



 void AddChunk(size_t capacity) {
  ChunkHeader* chunk = (ChunkHeader*)baseAllocator_->Malloc(sizeof(ChunkHeader) + capacity);
  chunk->capacity = capacity;
  chunk->size = 0;
  chunk->next = chunkHead_;
  chunkHead_ = chunk;
 }

 static const int kDefaultChunkCapacity = 64 * 1024;




 struct ChunkHeader {
  size_t capacity;
  size_t size;
  ChunkHeader *next;
 };

 ChunkHeader *chunkHead_;
 size_t chunk_capacity_;
 char *userBuffer_;
 BaseAllocator* baseAllocator_;
 BaseAllocator* ownBaseAllocator_;
};
# 334 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename CharType = char>
struct UTF8 {
 typedef CharType Ch;

 static Ch* Encode(Ch *buffer, unsigned codepoint) {
  if (codepoint <= 0x7F)
   *buffer++ = codepoint & 0xFF;
  else if (codepoint <= 0x7FF) {
   *buffer++ = 0xC0 | ((codepoint >> 6) & 0xFF);
   *buffer++ = 0x80 | ((codepoint & 0x3F));
  }
  else if (codepoint <= 0xFFFF) {
   *buffer++ = 0xE0 | ((codepoint >> 12) & 0xFF);
   *buffer++ = 0x80 | ((codepoint >> 6) & 0x3F);
   *buffer++ = 0x80 | (codepoint & 0x3F);
  }
  else {
   (__builtin_expect(!(codepoint <= 0x10FFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 351, "codepoint <= 0x10FFFF") : (void)0);
   *buffer++ = 0xF0 | ((codepoint >> 18) & 0xFF);
   *buffer++ = 0x80 | ((codepoint >> 12) & 0x3F);
   *buffer++ = 0x80 | ((codepoint >> 6) & 0x3F);
   *buffer++ = 0x80 | (codepoint & 0x3F);
  }
  return buffer;
 }
};
# 369 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename CharType = wchar_t>
struct UTF16 {
 typedef CharType Ch;

 static Ch* Encode(Ch* buffer, unsigned codepoint) {
  if (codepoint <= 0xFFFF) {
   (__builtin_expect(!(codepoint < 0xD800 || codepoint > 0xDFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 375, "codepoint < 0xD800 || codepoint > 0xDFFF") : (void)0);
   *buffer++ = static_cast<Ch>(codepoint);
  }
  else {
   (__builtin_expect(!(codepoint <= 0x10FFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 379, "codepoint <= 0x10FFFF") : (void)0);
   unsigned v = codepoint - 0x10000;
   *buffer++ = static_cast<Ch>((v >> 10) + 0xD800);
   *buffer++ = (v & 0x3FF) + 0xDC00;
  }
  return buffer;
 }
};
# 396 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename CharType = unsigned>
struct UTF32 {
 typedef CharType Ch;

 static Ch *Encode(Ch* buffer, unsigned codepoint) {
  (__builtin_expect(!(codepoint <= 0x10FFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 401, "codepoint <= 0x10FFFF") : (void)0);
  *buffer++ = codepoint;
  return buffer;
 }
};
# 447 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template<typename Stream, typename Ch>
inline void PutN(Stream& stream, Ch c, size_t n) {
 for (size_t i = 0; i < n; i++)
  stream.Put(c);
}







template <typename Encoding>
struct GenericStringStream {
 typedef typename Encoding::Ch Ch;

 GenericStringStream(const Ch *src) : src_(src), head_(src) {}

 Ch Peek() const { return *src_; }
 Ch Take() { return *src_++; }
 size_t Tell() const { return src_ - head_; }

 Ch* PutBegin() { (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 469, "false") : (void)0); return 0; }
 void Put(Ch) { (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 470, "false") : (void)0); }
 size_t PutEnd(Ch*) { (__builtin_expect(!(false), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 471, "false") : (void)0); return 0; }

 const Ch* src_;
 const Ch* head_;
};

typedef GenericStringStream<UTF8<> > StringStream;
# 486 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h"
template <typename Encoding>
struct GenericInsituStringStream {
 typedef typename Encoding::Ch Ch;

 GenericInsituStringStream(Ch *src) : src_(src), dst_(0), head_(src) {}


 Ch Peek() { return *src_; }
 Ch Take() { return *src_++; }
 size_t Tell() { return src_ - head_; }


 Ch* PutBegin() { return dst_ = src_; }
 void Put(Ch c) { (__builtin_expect(!(dst_ != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/rapidjson.h", 499, "dst_ != 0") : (void)0); *dst_++ = c; }
 size_t PutEnd(Ch* begin) { return dst_ - begin; }

 Ch* src_;
 Ch* dst_;
 Ch* head_;
};

typedef GenericInsituStringStream<UTF8<> > InsituStringStream;





enum Type {
 kNullType = 0,
 kFalseType = 1,
 kTrueType = 2,
 kObjectType = 3,
 kArrayType = 4,
 kStringType = 5,
 kNumberType = 6,
};

}
# 8 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/pow10.h" 1



namespace rapidjson {
namespace internal {






inline double Pow10(int n) {
 static const double e[] = {
  1e-308,1e-307,1e-306,1e-305,1e-304,1e-303,1e-302,1e-301,1e-300,
  1e-299,1e-298,1e-297,1e-296,1e-295,1e-294,1e-293,1e-292,1e-291,1e-290,1e-289,1e-288,1e-287,1e-286,1e-285,1e-284,1e-283,1e-282,1e-281,1e-280,
  1e-279,1e-278,1e-277,1e-276,1e-275,1e-274,1e-273,1e-272,1e-271,1e-270,1e-269,1e-268,1e-267,1e-266,1e-265,1e-264,1e-263,1e-262,1e-261,1e-260,
  1e-259,1e-258,1e-257,1e-256,1e-255,1e-254,1e-253,1e-252,1e-251,1e-250,1e-249,1e-248,1e-247,1e-246,1e-245,1e-244,1e-243,1e-242,1e-241,1e-240,
  1e-239,1e-238,1e-237,1e-236,1e-235,1e-234,1e-233,1e-232,1e-231,1e-230,1e-229,1e-228,1e-227,1e-226,1e-225,1e-224,1e-223,1e-222,1e-221,1e-220,
  1e-219,1e-218,1e-217,1e-216,1e-215,1e-214,1e-213,1e-212,1e-211,1e-210,1e-209,1e-208,1e-207,1e-206,1e-205,1e-204,1e-203,1e-202,1e-201,1e-200,
  1e-199,1e-198,1e-197,1e-196,1e-195,1e-194,1e-193,1e-192,1e-191,1e-190,1e-189,1e-188,1e-187,1e-186,1e-185,1e-184,1e-183,1e-182,1e-181,1e-180,
  1e-179,1e-178,1e-177,1e-176,1e-175,1e-174,1e-173,1e-172,1e-171,1e-170,1e-169,1e-168,1e-167,1e-166,1e-165,1e-164,1e-163,1e-162,1e-161,1e-160,
  1e-159,1e-158,1e-157,1e-156,1e-155,1e-154,1e-153,1e-152,1e-151,1e-150,1e-149,1e-148,1e-147,1e-146,1e-145,1e-144,1e-143,1e-142,1e-141,1e-140,
  1e-139,1e-138,1e-137,1e-136,1e-135,1e-134,1e-133,1e-132,1e-131,1e-130,1e-129,1e-128,1e-127,1e-126,1e-125,1e-124,1e-123,1e-122,1e-121,1e-120,
  1e-119,1e-118,1e-117,1e-116,1e-115,1e-114,1e-113,1e-112,1e-111,1e-110,1e-109,1e-108,1e-107,1e-106,1e-105,1e-104,1e-103,1e-102,1e-101,1e-100,
  1e-99, 1e-98, 1e-97, 1e-96, 1e-95, 1e-94, 1e-93, 1e-92, 1e-91, 1e-90, 1e-89, 1e-88, 1e-87, 1e-86, 1e-85, 1e-84, 1e-83, 1e-82, 1e-81, 1e-80,
  1e-79, 1e-78, 1e-77, 1e-76, 1e-75, 1e-74, 1e-73, 1e-72, 1e-71, 1e-70, 1e-69, 1e-68, 1e-67, 1e-66, 1e-65, 1e-64, 1e-63, 1e-62, 1e-61, 1e-60,
  1e-59, 1e-58, 1e-57, 1e-56, 1e-55, 1e-54, 1e-53, 1e-52, 1e-51, 1e-50, 1e-49, 1e-48, 1e-47, 1e-46, 1e-45, 1e-44, 1e-43, 1e-42, 1e-41, 1e-40,
  1e-39, 1e-38, 1e-37, 1e-36, 1e-35, 1e-34, 1e-33, 1e-32, 1e-31, 1e-30, 1e-29, 1e-28, 1e-27, 1e-26, 1e-25, 1e-24, 1e-23, 1e-22, 1e-21, 1e-20,
  1e-19, 1e-18, 1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e+0,
  1e+1, 1e+2, 1e+3, 1e+4, 1e+5, 1e+6, 1e+7, 1e+8, 1e+9, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20,
  1e+21, 1e+22, 1e+23, 1e+24, 1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31, 1e+32, 1e+33, 1e+34, 1e+35, 1e+36, 1e+37, 1e+38, 1e+39, 1e+40,
  1e+41, 1e+42, 1e+43, 1e+44, 1e+45, 1e+46, 1e+47, 1e+48, 1e+49, 1e+50, 1e+51, 1e+52, 1e+53, 1e+54, 1e+55, 1e+56, 1e+57, 1e+58, 1e+59, 1e+60,
  1e+61, 1e+62, 1e+63, 1e+64, 1e+65, 1e+66, 1e+67, 1e+68, 1e+69, 1e+70, 1e+71, 1e+72, 1e+73, 1e+74, 1e+75, 1e+76, 1e+77, 1e+78, 1e+79, 1e+80,
  1e+81, 1e+82, 1e+83, 1e+84, 1e+85, 1e+86, 1e+87, 1e+88, 1e+89, 1e+90, 1e+91, 1e+92, 1e+93, 1e+94, 1e+95, 1e+96, 1e+97, 1e+98, 1e+99, 1e+100,
  1e+101,1e+102,1e+103,1e+104,1e+105,1e+106,1e+107,1e+108,1e+109,1e+110,1e+111,1e+112,1e+113,1e+114,1e+115,1e+116,1e+117,1e+118,1e+119,1e+120,
  1e+121,1e+122,1e+123,1e+124,1e+125,1e+126,1e+127,1e+128,1e+129,1e+130,1e+131,1e+132,1e+133,1e+134,1e+135,1e+136,1e+137,1e+138,1e+139,1e+140,
  1e+141,1e+142,1e+143,1e+144,1e+145,1e+146,1e+147,1e+148,1e+149,1e+150,1e+151,1e+152,1e+153,1e+154,1e+155,1e+156,1e+157,1e+158,1e+159,1e+160,
  1e+161,1e+162,1e+163,1e+164,1e+165,1e+166,1e+167,1e+168,1e+169,1e+170,1e+171,1e+172,1e+173,1e+174,1e+175,1e+176,1e+177,1e+178,1e+179,1e+180,
  1e+181,1e+182,1e+183,1e+184,1e+185,1e+186,1e+187,1e+188,1e+189,1e+190,1e+191,1e+192,1e+193,1e+194,1e+195,1e+196,1e+197,1e+198,1e+199,1e+200,
  1e+201,1e+202,1e+203,1e+204,1e+205,1e+206,1e+207,1e+208,1e+209,1e+210,1e+211,1e+212,1e+213,1e+214,1e+215,1e+216,1e+217,1e+218,1e+219,1e+220,
  1e+221,1e+222,1e+223,1e+224,1e+225,1e+226,1e+227,1e+228,1e+229,1e+230,1e+231,1e+232,1e+233,1e+234,1e+235,1e+236,1e+237,1e+238,1e+239,1e+240,
  1e+241,1e+242,1e+243,1e+244,1e+245,1e+246,1e+247,1e+248,1e+249,1e+250,1e+251,1e+252,1e+253,1e+254,1e+255,1e+256,1e+257,1e+258,1e+259,1e+260,
  1e+261,1e+262,1e+263,1e+264,1e+265,1e+266,1e+267,1e+268,1e+269,1e+270,1e+271,1e+272,1e+273,1e+274,1e+275,1e+276,1e+277,1e+278,1e+279,1e+280,
  1e+281,1e+282,1e+283,1e+284,1e+285,1e+286,1e+287,1e+288,1e+289,1e+290,1e+291,1e+292,1e+293,1e+294,1e+295,1e+296,1e+297,1e+298,1e+299,1e+300,
  1e+301,1e+302,1e+303,1e+304,1e+305,1e+306,1e+307,1e+308
 };
 (__builtin_expect(!(n <= 308), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/pow10.h", 47, "n <= 308") : (void)0);
 return n < -308 ? 0.0 : e[n + 308];
}

}
}
# 9 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h" 1



namespace rapidjson {
namespace internal {







template <typename Allocator>
class Stack {
public:
 Stack(Allocator* allocator, size_t stack_capacity) : allocator_(allocator), own_allocator_(0), stack_(0), stack_top_(0), stack_end_(0), stack_capacity_(stack_capacity) {
  (__builtin_expect(!(stack_capacity_ > 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h", 17, "stack_capacity_ > 0") : (void)0);
  if (!allocator_)
   own_allocator_ = allocator_ = new Allocator();
  stack_top_ = stack_ = (char*)allocator_->Malloc(stack_capacity_);
  stack_end_ = stack_ + stack_capacity_;
 }

 ~Stack() {
  Allocator::Free(stack_);
  delete own_allocator_;
 }

 void Clear() { stack_top_ = stack_; }

 template<typename T>
 T* Push(size_t count = 1) {

  if (stack_top_ + sizeof(T) * count >= stack_end_) {
   size_t new_capacity = stack_capacity_ * 2;
   size_t size = GetSize();
   size_t new_size = GetSize() + sizeof(T) * count;
   if (new_capacity < new_size)
    new_capacity = new_size;
   stack_ = (char*)allocator_->Realloc(stack_, stack_capacity_, new_capacity);
   stack_capacity_ = new_capacity;
   stack_top_ = stack_ + size;
   stack_end_ = stack_ + stack_capacity_;
  }
  T* ret = (T*)stack_top_;
  stack_top_ += sizeof(T) * count;
  return ret;
 }

 template<typename T>
 T* Pop(size_t count) {
  (__builtin_expect(!(GetSize() >= count * sizeof(T)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h", 52, "GetSize() >= count * sizeof(T)") : (void)0);
  stack_top_ -= count * sizeof(T);
  return (T*)stack_top_;
 }

 template<typename T>
 T* Top() {
  (__builtin_expect(!(GetSize() >= sizeof(T)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/stack.h", 59, "GetSize() >= sizeof(T)") : (void)0);
  return (T*)(stack_top_ - sizeof(T));
 }

 template<typename T>
 T* Bottom() { return (T*)stack_; }

 Allocator& GetAllocator() { return *allocator_; }
 size_t GetSize() const { return stack_top_ - stack_; }
 size_t GetCapacity() const { return stack_capacity_; }

private:
 Allocator* allocator_;
 Allocator* own_allocator_;
 char *stack_;
 char *stack_top_;
 char *stack_end_;
 size_t stack_capacity_;
};

}
}
# 10 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/setjmp.h" 1 3
# 26 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/setjmp.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/setjmp.h" 1 3
# 35 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/setjmp.h" 3
# 1 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/setjmp.h" 1 3
# 47 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/setjmp.h" 3
typedef int jmp_buf[((9 * 2) + 3 + 16)];
typedef int sigjmp_buf[((9 * 2) + 3 + 16) + 1];
# 65 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/i386/setjmp.h" 3
extern "C" {
int setjmp(jmp_buf);
void longjmp(jmp_buf, int);


int _setjmp(jmp_buf);
void _longjmp(jmp_buf, int);
int sigsetjmp(sigjmp_buf, int);
void siglongjmp(sigjmp_buf, int);



void longjmperror(void);

}
# 36 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/machine/setjmp.h" 2 3
# 27 "/Users/jakrillis/projects/builds/macosx-sdks/MacOSX10.7.sdk/usr/include/setjmp.h" 2 3
# 11 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h" 2
# 32 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
namespace rapidjson {





enum ParseFlag {
 kParseDefaultFlags = 0,
 kParseInsituFlag = 1
};
# 74 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
template<typename Encoding = UTF8<> >
struct BaseReaderHandler {
 typedef typename Encoding::Ch Ch;

 void Default() {}
 void Null() { Default(); }
 void Bool(bool) { Default(); }
 void Int(int) { Default(); }
 void Uint(unsigned) { Default(); }
 void Int64(int64_t) { Default(); }
 void Uint64(uint64_t) { Default(); }
 void Double(double) { Default(); }
 void String(const Ch*, SizeType, bool) { Default(); }
 void StartObject() { Default(); }
 void EndObject(SizeType) { Default(); }
 void StartArray() { Default(); }
 void EndArray(SizeType) { Default(); }
};
# 100 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
template<typename Stream>
void SkipWhitespace(Stream& stream) {
 Stream s = stream;
 while (s.Peek() == ' ' || s.Peek() == '\n' || s.Peek() == '\r' || s.Peek() == '\t')
  s.Take();
 stream = s;
}
# 201 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >
class GenericReader {
public:
 typedef typename Encoding::Ch Ch;





 GenericReader(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity) : stack_(allocator, stackCapacity), parseError_(0), errorOffset_(0) {}
# 220 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
 template <unsigned parseFlags, typename Stream, typename Handler>
 bool Parse(Stream& stream, Handler& handler) {
  parseError_ = 0;
  errorOffset_ = 0;





  if (setjmp(jmpbuf_)) {



   stack_.Clear();
   return false;
  }

  SkipWhitespace(stream);

  if (stream.Peek() == '\0')
   do { parseError_ = "Text only contains white space(s)"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
  else {
   switch (stream.Peek()) {
    case '{': ParseObject<parseFlags>(stream, handler); break;
    case '[': ParseArray<parseFlags>(stream, handler); break;
    default: do { parseError_ = "Expect either an object or array at root"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   }
   SkipWhitespace(stream);

   if (stream.Peek() != '\0')
    do { parseError_ = "Nothing should follow the root object or array."; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
  }

  return true;
 }

 bool HasParseError() const { return parseError_ != 0; }
 const char* GetParseError() const { return parseError_; }
 size_t GetErrorOffset() const { return errorOffset_; }

private:

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseObject(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == '{'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 264, "stream.Peek() == '{'") : (void)0);
  stream.Take();
  handler.StartObject();
  SkipWhitespace(stream);

  if (stream.Peek() == '}') {
   stream.Take();
   handler.EndObject(0);
   return;
  }

  for (SizeType memberCount = 0;;) {
   if (stream.Peek() != '"') {
    do { parseError_ = "Name of an object member must be a string"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    break;
   }

   ParseString<parseFlags>(stream, handler);
   SkipWhitespace(stream);

   if (stream.Take() != ':') {
    do { parseError_ = "There must be a colon after the name of object member"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    break;
   }
   SkipWhitespace(stream);

   ParseValue<parseFlags>(stream, handler);
   SkipWhitespace(stream);

   ++memberCount;

   switch(stream.Take()) {
    case ',': SkipWhitespace(stream); break;
    case '}': handler.EndObject(memberCount); return;
    default: do { parseError_ = "Must be a comma or '}' after an object member"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   }
  }
 }


 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseArray(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == '['), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 306, "stream.Peek() == '['") : (void)0);
  stream.Take();
  handler.StartArray();
  SkipWhitespace(stream);

  if (stream.Peek() == ']') {
   stream.Take();
   handler.EndArray(0);
   return;
  }

  for (SizeType elementCount = 0;;) {
   ParseValue<parseFlags>(stream, handler);
   ++elementCount;
   SkipWhitespace(stream);

   switch (stream.Take()) {
    case ',': SkipWhitespace(stream); break;
    case ']': handler.EndArray(elementCount); return;
    default: do { parseError_ = "Must be a comma or ']' after an array element."; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   }
  }
 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseNull(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == 'n'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 332, "stream.Peek() == 'n'") : (void)0);
  stream.Take();

  if (stream.Take() == 'u' && stream.Take() == 'l' && stream.Take() == 'l')
   handler.Null();
  else
   do { parseError_ = "Invalid value"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseTrue(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == 't'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 343, "stream.Peek() == 't'") : (void)0);
  stream.Take();

  if (stream.Take() == 'r' && stream.Take() == 'u' && stream.Take() == 'e')
   handler.Bool(true);
  else
   do { parseError_ = "Invalid value"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseFalse(Stream& stream, Handler& handler) {
  (__builtin_expect(!(stream.Peek() == 'f'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 354, "stream.Peek() == 'f'") : (void)0);
  stream.Take();

  if (stream.Take() == 'a' && stream.Take() == 'l' && stream.Take() == 's' && stream.Take() == 'e')
   handler.Bool(false);
  else
   do { parseError_ = "Invalid value"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
 }


 template<typename Stream>
 unsigned ParseHex4(Stream& stream) {
  Stream s = stream;
  unsigned codepoint = 0;
  for (int i = 0; i < 4; i++) {
   Ch c = s.Take();
   codepoint <<= 4;
   codepoint += c;
   if (c >= '0' && c <= '9')
    codepoint -= '0';
   else if (c >= 'A' && c <= 'F')
    codepoint -= 'A' - 10;
   else if (c >= 'a' && c <= 'f')
    codepoint -= 'a' - 10;
   else
    do { parseError_ = "Incorrect hex digit after \\u escape"; errorOffset_ = s.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
  }
  stream = s;
  return codepoint;
 }


 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseString(Stream& stream, Handler& handler) {

  static const Ch escape[256] = {
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,'\"', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'/',
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
   0, 0,'\b', 0, 0, 0,'\f', 0, 0, 0, 0, 0, 0, 0,'\n', 0,
   0, 0,'\r', 0,'\t', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  };


  Stream s = stream;
  (__builtin_expect(!(s.Peek() == '\"'), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 399, "s.Peek() == '\\\"'") : (void)0);
  s.Take();
  Ch *head;
  SizeType len;
  if (parseFlags & kParseInsituFlag)
   head = s.PutBegin();
  else
   len = 0;
# 418 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h"
  for (;;) {
   Ch c = s.Take();
   if (c == '\\') {
    Ch e = s.Take();
    if ((sizeof(Ch) == 1 || e < 256) && escape[(unsigned char)e])
     do { if (parseFlags & kParseInsituFlag) s.Put(escape[(unsigned char)e]); else { *stack_.template Push<Ch>() = escape[(unsigned char)e]; ++len; } } while(false);
    else if (e == 'u') {
     unsigned codepoint = ParseHex4(s);
     if (codepoint >= 0xD800 && codepoint <= 0xDBFF) {
      if (s.Take() != '\\' || s.Take() != 'u') {
       do { parseError_ = "Missing the second \\u in surrogate pair"; errorOffset_ = s.Tell() - 2; longjmp(jmpbuf_, 1); } while((void)0, 0);
       return;
      }
      unsigned codepoint2 = ParseHex4(s);
      if (codepoint2 < 0xDC00 || codepoint2 > 0xDFFF) {
       do { parseError_ = "The second \\u in surrogate pair is invalid"; errorOffset_ = s.Tell() - 2; longjmp(jmpbuf_, 1); } while((void)0, 0);
       return;
      }
      codepoint = (((codepoint - 0xD800) << 10) | (codepoint2 - 0xDC00)) + 0x10000;
     }

     Ch buffer[4];
     SizeType count = SizeType(Encoding::Encode(buffer, codepoint) - &buffer[0]);

     if (parseFlags & kParseInsituFlag)
      for (SizeType i = 0; i < count; i++)
       s.Put(buffer[i]);
     else {
      memcpy(stack_.template Push<Ch>(count), buffer, count * sizeof(Ch));
      len += count;
     }
    }
    else {
     do { parseError_ = "Unknown escape character"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
     return;
    }
   }
   else if (c == '"') {
    if (parseFlags & kParseInsituFlag) {
     size_t length = s.PutEnd(head);
     (__builtin_expect(!(length <= 0xFFFFFFFF), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/reader.h", 458, "length <= 0xFFFFFFFF") : (void)0);
     do { if (parseFlags & kParseInsituFlag) s.Put('\0'); else { *stack_.template Push<Ch>() = '\0'; ++len; } } while(false);
     handler.String(head, SizeType(length), false);
    }
    else {
     do { if (parseFlags & kParseInsituFlag) s.Put('\0'); else { *stack_.template Push<Ch>() = '\0'; ++len; } } while(false);
     handler.String(stack_.template Pop<Ch>(len), len - 1, true);
    }
    stream = s;
    return;
   }
   else if (c == '\0') {
    do { parseError_ = "lacks ending quotation before the end of string"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }
   else if ((unsigned)c < 0x20) {
    do { parseError_ = "Incorrect unescaped character in string"; errorOffset_ = stream.Tell() - 1; longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }
   else
    do { if (parseFlags & kParseInsituFlag) s.Put(c); else { *stack_.template Push<Ch>() = c; ++len; } } while(false);
  }

 }

 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseNumber(Stream& stream, Handler& handler) {
  Stream s = stream;

  bool minus = false;
  if (s.Peek() == '-') {
   minus = true;
   s.Take();
  }


  unsigned i;
  bool try64bit = false;
  if (s.Peek() == '0') {
   i = 0;
   s.Take();
  }
  else if (s.Peek() >= '1' && s.Peek() <= '9') {
   i = s.Take() - '0';

   if (minus)
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i >= 214748364) {
      if (i != 214748364 || s.Peek() > '8') {
       try64bit = true;
       break;
      }
     }
     i = i * 10 + (s.Take() - '0');
    }
   else
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i >= 429496729) {
      if (i != 429496729 || s.Peek() > '5') {
       try64bit = true;
       break;
      }
     }
     i = i * 10 + (s.Take() - '0');
    }
  }
  else {
   do { parseError_ = "Expect a value here."; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
   return;
  }


  uint64_t i64 = 0;
  bool useDouble = false;
  if (try64bit) {
   i64 = i;
   if (minus)
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i64 >= 922337203685477580uLL)
      if (i64 != 922337203685477580uLL || s.Peek() > '8') {
       useDouble = true;
       break;
      }
     i64 = i64 * 10 + (s.Take() - '0');
    }
   else
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     if (i64 >= 1844674407370955161uLL)
      if (i64 != 1844674407370955161uLL || s.Peek() > '5') {
       useDouble = true;
       break;
      }
     i64 = i64 * 10 + (s.Take() - '0');
    }
  }


  double d = 0.0;
  if (useDouble) {
   d = (double)i64;
   while (s.Peek() >= '0' && s.Peek() <= '9') {
    if (d >= 1E307) {
     do { parseError_ = "Number too big to store in double"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
     return;
    }
    d = d * 10 + (s.Take() - '0');
   }
  }


  int expFrac = 0;
  if (s.Peek() == '.') {
   if (!useDouble) {
    d = try64bit ? (double)i64 : (double)i;
    useDouble = true;
   }
   s.Take();

   if (s.Peek() >= '0' && s.Peek() <= '9') {
    d = d * 10 + (s.Take() - '0');
    --expFrac;
   }
   else {
    do { parseError_ = "At least one digit in fraction part"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }

   while (s.Peek() >= '0' && s.Peek() <= '9') {
    if (expFrac > -16) {
     d = d * 10 + (s.Peek() - '0');
     --expFrac;
    }
    s.Take();
   }
  }


  int exp = 0;
  if (s.Peek() == 'e' || s.Peek() == 'E') {
   if (!useDouble) {
    d = try64bit ? (double)i64 : (double)i;
    useDouble = true;
   }
   s.Take();

   bool expMinus = false;
   if (s.Peek() == '+')
    s.Take();
   else if (s.Peek() == '-') {
    s.Take();
    expMinus = true;
   }

   if (s.Peek() >= '0' && s.Peek() <= '9') {
    exp = s.Take() - '0';
    while (s.Peek() >= '0' && s.Peek() <= '9') {
     exp = exp * 10 + (s.Take() - '0');
     if (exp > 308) {
      do { parseError_ = "Number too big to store in double"; errorOffset_ = stream.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
      return;
     }
    }
   }
   else {
    do { parseError_ = "At least one digit in exponent"; errorOffset_ = s.Tell(); longjmp(jmpbuf_, 1); } while((void)0, 0);
    return;
   }

   if (expMinus)
    exp = -exp;
  }


  if (useDouble) {
   d *= internal::Pow10(exp + expFrac);
   handler.Double(minus ? -d : d);
  }
  else {
   if (try64bit) {
    if (minus)
     handler.Int64(-(int64_t)i64);
    else
     handler.Uint64(i64);
   }
   else {
    if (minus)
     handler.Int(-(int)i);
    else
     handler.Uint(i);
   }
  }

  stream = s;
 }


 template<unsigned parseFlags, typename Stream, typename Handler>
 void ParseValue(Stream& stream, Handler& handler) {
  switch (stream.Peek()) {
   case 'n': ParseNull <parseFlags>(stream, handler); break;
   case 't': ParseTrue <parseFlags>(stream, handler); break;
   case 'f': ParseFalse <parseFlags>(stream, handler); break;
   case '"': ParseString<parseFlags>(stream, handler); break;
   case '{': ParseObject<parseFlags>(stream, handler); break;
   case '[': ParseArray <parseFlags>(stream, handler); break;
   default : ParseNumber<parseFlags>(stream, handler);
  }
 }

 static const size_t kDefaultStackCapacity = 256;
 internal::Stack<Allocator> stack_;
 jmp_buf jmpbuf_;
 const char* parseError_;
 size_t errorOffset_;
};


typedef GenericReader<UTF8<> > Reader;

}
# 5 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/internal/strfunc.h" 1



namespace rapidjson {
namespace internal {







template <typename Ch>
inline SizeType StrLen(const Ch* s) {
 const Ch* p = s;
 while (*p != '\0')
  ++p;
 return SizeType(p - s);
}

}
}
# 6 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h" 2







namespace rapidjson {
# 28 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
#pragma pack (push, 4)
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >
class GenericValue {
public:

 struct Member {
  GenericValue<Encoding, Allocator> name;
  GenericValue<Encoding, Allocator> value;
 };

 typedef Encoding EncodingType;
 typedef Allocator AllocatorType;
 typedef typename Encoding::Ch Ch;
 typedef Member* MemberIterator;
 typedef const Member* ConstMemberIterator;
 typedef GenericValue* ValueIterator;
 typedef const GenericValue* ConstValueIterator;





 GenericValue() : flags_(kNullFlag) {}


private:
 GenericValue(const GenericValue& rhs);

public:






 GenericValue(Type type) {
  static const unsigned defaultFlags[7] = {
   kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kConstStringFlag,
   kNumberFlag | kIntFlag | kUintFlag | kInt64Flag | kUint64Flag | kDoubleFlag
  };
  (__builtin_expect(!(type <= kNumberType), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 68, "type <= kNumberType") : (void)0);
  flags_ = defaultFlags[type];
  memset(&data_, 0, sizeof(data_));
 }


 GenericValue(bool b) : flags_(b ? kTrueFlag : kFalseFlag) {}


 GenericValue(int i) : flags_(kNumberIntFlag) {
  data_.n.i64 = i;
  if (i >= 0)
   flags_ |= kUintFlag | kUint64Flag;
 }


 GenericValue(unsigned u) : flags_(kNumberUintFlag) {
  data_.n.u64 = u;
  if (!(u & 0x80000000))
   flags_ |= kIntFlag | kInt64Flag;
 }


 GenericValue(int64_t i64) : flags_(kNumberInt64Flag) {
  data_.n.i64 = i64;
  if (i64 >= 0) {
   flags_ |= kNumberUint64Flag;
   if (!(i64 & 0xFFFFFFFF00000000LL))
    flags_ |= kUintFlag;
   if (!(i64 & 0xFFFFFFFF80000000LL))
    flags_ |= kIntFlag;
  }
  else if (i64 >= -2147483648LL)
   flags_ |= kIntFlag;
 }


 GenericValue(uint64_t u64) : flags_(kNumberUint64Flag) {
  data_.n.u64 = u64;
  if (!(u64 & 0x8000000000000000ULL))
   flags_ |= kInt64Flag;
  if (!(u64 & 0xFFFFFFFF00000000ULL))
   flags_ |= kUintFlag;
  if (!(u64 & 0xFFFFFFFF80000000ULL))
   flags_ |= kIntFlag;
 }


 GenericValue(double d) : flags_(kNumberDoubleFlag) { data_.n.d = d; }


 GenericValue(const Ch* s, SizeType length) {
  (__builtin_expect(!(s != __null), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 120, "s != __null") : (void)0);
  flags_ = kConstStringFlag;
  data_.s.str = s;
  data_.s.length = length;
 }


 GenericValue(const Ch* s) { SetStringRaw(s, internal::StrLen(s)); }


 GenericValue(const Ch* s, SizeType length, Allocator& allocator) { SetStringRaw(s, length, allocator); }


 GenericValue(const Ch*s, Allocator& allocator) { SetStringRaw(s, internal::StrLen(s), allocator); }




 ~GenericValue() {
  if (Allocator::kNeedFree) {
   switch(flags_) {
   case kArrayFlag:
    for (GenericValue* v = data_.a.elements; v != data_.a.elements + data_.a.size; ++v)
     v->~GenericValue();
    Allocator::Free(data_.a.elements);
    break;

   case kObjectFlag:
    for (Member* m = data_.o.members; m != data_.o.members + data_.o.size; ++m) {
     m->name.~GenericValue();
     m->value.~GenericValue();
    }
    Allocator::Free(data_.o.members);
    break;

   case kCopyStringFlag:
    Allocator::Free(const_cast<Ch*>(data_.s.str));
    break;
   }
  }
 }
# 170 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& operator=(GenericValue& rhs) {
  (__builtin_expect(!(this != &rhs), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 171, "this != &rhs") : (void)0);
  this->~GenericValue();
  memcpy(this, &rhs, sizeof(GenericValue));
  rhs.flags_ = kNullFlag;
  return *this;
 }





 template <typename T>
 GenericValue& operator=(T value) {
  this->~GenericValue();
  new (this) GenericValue(value);
  return *this;
 }





 Type GetType() const { return static_cast<Type>(flags_ & kTypeMask); }
 bool IsNull() const { return flags_ == kNullFlag; }
 bool IsFalse() const { return flags_ == kFalseFlag; }
 bool IsTrue() const { return flags_ == kTrueFlag; }
 bool IsBool() const { return (flags_ & kBoolFlag) != 0; }
 bool IsObject() const { return flags_ == kObjectFlag; }
 bool IsArray() const { return flags_ == kArrayFlag; }
 bool IsNumber() const { return (flags_ & kNumberFlag) != 0; }
 bool IsInt() const { return (flags_ & kIntFlag) != 0; }
 bool IsUint() const { return (flags_ & kUintFlag) != 0; }
 bool IsInt64() const { return (flags_ & kInt64Flag) != 0; }
 bool IsUint64() const { return (flags_ & kUint64Flag) != 0; }
 bool IsDouble() const { return (flags_ & kDoubleFlag) != 0; }
 bool IsString() const { return (flags_ & kStringFlag) != 0; }






 GenericValue& SetNull() { this->~GenericValue(); new (this) GenericValue(); return *this; }






 bool GetBool() const { (__builtin_expect(!(IsBool()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 220, "IsBool()") : (void)0); return flags_ == kTrueFlag; }
 GenericValue& SetBool(bool b) { this->~GenericValue(); new (this) GenericValue(b); return *this; }







 GenericValue& SetObject() { this->~GenericValue(); new (this) GenericValue(kObjectType); return *this; }


 GenericValue& operator[](const Ch* name) {
  if (Member* member = FindMember(name))
   return member->value;
  else {
   static GenericValue NullValue;
   return NullValue;
  }
 }
 const GenericValue& operator[](const Ch* name) const { return const_cast<GenericValue&>(*this)[name]; }


 ConstMemberIterator MemberonBegin() const { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 243, "IsObject()") : (void)0); return data_.o.members; }
 ConstMemberIterator MemberonEnd() const { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 244, "IsObject()") : (void)0); return data_.o.members + data_.o.size; }
 MemberIterator MemberonBegin() { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 245, "IsObject()") : (void)0); return data_.o.members; }
 MemberIterator MemberonEnd() { (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 246, "IsObject()") : (void)0); return data_.o.members + data_.o.size; }


 bool HasMember(const Ch* name) const { return FindMember(name) != 0; }
# 258 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& AddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {
  (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 259, "IsObject()") : (void)0);
  (__builtin_expect(!(name.IsString()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 260, "name.IsString()") : (void)0);
  Object& o = data_.o;
  if (o.size >= o.capacity) {
   if (o.capacity == 0) {
    o.capacity = kDefaultObjectCapacity;
    o.members = (Member*)allocator.Malloc(o.capacity * sizeof(Member));
   }
   else {
    SizeType oldCapacity = o.capacity;
    o.capacity *= 2;
    o.members = (Member*)allocator.Realloc(o.members, oldCapacity * sizeof(Member), o.capacity * sizeof(Member));
   }
  }
  o.members[o.size].name.RawAssign(name);
  o.members[o.size].value.RawAssign(value);
  o.size++;
  return *this;
 }

 GenericValue& AddMember(const Ch* name, Allocator& nameAllocator, GenericValue& value, Allocator& allocator) {
  GenericValue n(name, internal::StrLen(name), nameAllocator);
  return AddMember(n, value, allocator);
 }

 GenericValue& AddMember(const Ch* name, GenericValue& value, Allocator& allocator) {
  GenericValue n(name, internal::StrLen(name));
  return AddMember(n, value, allocator);
 }

 template <typename T>
 GenericValue& AddMember(const Ch* name, T value, Allocator& allocator) {
  GenericValue n(name, internal::StrLen(name));
  GenericValue v(value);
  return AddMember(n, v, allocator);
 }






 bool RemoveMember(const Ch* name) {
  (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 302, "IsObject()") : (void)0);
  if (Member* m = FindMember(name)) {
   (__builtin_expect(!(data_.o.size > 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 304, "data_.o.size > 0") : (void)0);
   (__builtin_expect(!(data_.o.members != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 305, "data_.o.members != 0") : (void)0);

   Member* last = data_.o.members + (data_.o.size - 1);
   if (data_.o.size > 1 && m != last) {

    m->name = last->name;
    m->value = last->value;
   }
   else {

    m->name.~GenericValue();
    m->value.~GenericValue();
   }
   --data_.o.size;
   return true;
  }
  return false;
 }







 GenericValue& SetArray() { this->~GenericValue(); new (this) GenericValue(kArrayType); return *this; }


 SizeType Size() const { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 333, "IsArray()") : (void)0); return data_.a.size; }


 SizeType Capacity() const { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 336, "IsArray()") : (void)0); return data_.a.capacity; }


 bool Empty() const { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 339, "IsArray()") : (void)0); return data_.a.size == 0; }




 void Clear() {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 345, "IsArray()") : (void)0);
  for (SizeType i = 0; i < data_.a.size; ++i)
   data_.a.elements[i].~GenericValue();
  data_.a.size = 0;
 }
# 362 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& operator[](SizeType index) {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 363, "IsArray()") : (void)0);
  (__builtin_expect(!(index < data_.a.size), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 364, "index < data_.a.size") : (void)0);
  return data_.a.elements[index];
 }
 const GenericValue& operator[](SizeType index) const { return const_cast<GenericValue&>(*this)[index]; }


 ValueIterator onBegin() { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 370, "IsArray()") : (void)0); return data_.a.elements; }
 ValueIterator onEnd() { (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 371, "IsArray()") : (void)0); return data_.a.elements + data_.a.size; }
 ConstValueIterator onBegin() const { return const_cast<GenericValue&>(*this).onBegin(); }
 ConstValueIterator onEnd() const { return const_cast<GenericValue&>(*this).onEnd(); }






 GenericValue& Reserve(SizeType newCapacity, Allocator &allocator) {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 381, "IsArray()") : (void)0);
  if (newCapacity > data_.a.capacity) {
   data_.a.elements = (GenericValue*)allocator.Realloc(data_.a.elements, data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue));
   data_.a.capacity = newCapacity;
  }
  return *this;
 }
# 396 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& PushBack(GenericValue& value, Allocator& allocator) {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 397, "IsArray()") : (void)0);
  if (data_.a.size >= data_.a.capacity)
   Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : data_.a.capacity * 2, allocator);
  data_.a.elements[data_.a.size++].RawAssign(value);
  return *this;
 }

 template <typename T>
 GenericValue& PushBack(T value, Allocator& allocator) {
  GenericValue v(value);
  return PushBack(v, allocator);
 }


 GenericValue& PopBack() {
  (__builtin_expect(!(IsArray()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 412, "IsArray()") : (void)0);
  (__builtin_expect(!(!Empty()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 413, "!Empty()") : (void)0);
  data_.a.elements[--data_.a.size].~GenericValue();
  return *this;
 }





 int GetInt() const { (__builtin_expect(!(flags_ & kIntFlag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 422, "flags_ & kIntFlag") : (void)0); return data_.n.i.i; }
 unsigned GetUint() const { (__builtin_expect(!(flags_ & kUintFlag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 423, "flags_ & kUintFlag") : (void)0); return data_.n.u.u; }
 int64_t GetInt64() const { (__builtin_expect(!(flags_ & kInt64Flag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 424, "flags_ & kInt64Flag") : (void)0); return data_.n.i64; }
 uint64_t GetUint64() const { (__builtin_expect(!(flags_ & kUint64Flag), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 425, "flags_ & kUint64Flag") : (void)0); return data_.n.u64; }

 double GetDouble() const {
  (__builtin_expect(!(IsNumber()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 428, "IsNumber()") : (void)0);
  if ((flags_ & kDoubleFlag) != 0) return data_.n.d;
  if ((flags_ & kIntFlag) != 0) return data_.n.i.i;
  if ((flags_ & kUintFlag) != 0) return data_.n.u.u;
  if ((flags_ & kInt64Flag) != 0) return (double)data_.n.i64;
  (__builtin_expect(!((flags_ & kUint64Flag) != 0), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 433, "(flags_ & kUint64Flag) != 0") : (void)0); return (double)data_.n.u64;
 }

 GenericValue& SetInt(int i) { this->~GenericValue(); new (this) GenericValue(i); return *this; }
 GenericValue& SetUint(unsigned u) { this->~GenericValue(); new (this) GenericValue(u); return *this; }
 GenericValue& SetInt64(int64_t i64) { this->~GenericValue(); new (this) GenericValue(i64); return *this; }
 GenericValue& SetUint64(uint64_t u64) { this->~GenericValue(); new (this) GenericValue(u64); return *this; }
 GenericValue& SetDouble(double d) { this->~GenericValue(); new (this) GenericValue(d); return *this; }






 const Ch* GetString() const { (__builtin_expect(!(IsString()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 447, "IsString()") : (void)0); return data_.s.str; }




 SizeType GetStringLength() const { (__builtin_expect(!(IsString()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 452, "IsString()") : (void)0); return data_.s.length; }







 GenericValue& SetString(const Ch* s, SizeType length) { this->~GenericValue(); SetStringRaw(s, length); return *this; }





 GenericValue& SetString(const Ch* s) { return SetString(s, internal::StrLen(s)); }
# 475 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 GenericValue& SetString(const Ch* s, SizeType length, Allocator& allocator) { this->~GenericValue(); SetStringRaw(s, length, allocator); return *this; }






 GenericValue& SetString(const Ch* s, Allocator& allocator) { SetString(s, internal::StrLen(s), allocator); return *this; }
# 493 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
 template <typename Handler>
 const GenericValue& Accept(Handler& handler) const {
  switch(GetType()) {
  case kNullType: handler.Null(); break;
  case kFalseType: handler.Bool(false); break;
  case kTrueType: handler.Bool(true); break;

  case kObjectType:
   handler.StartObject();
   for (Member* m = data_.o.members; m != data_.o.members + data_.o.size; ++m) {
    handler.String(m->name.data_.s.str, m->name.data_.s.length, false);
    m->value.Accept(handler);
   }
   handler.EndObject(data_.o.size);
   break;

  case kArrayType:
   handler.StartArray();
   for (GenericValue* v = data_.a.elements; v != data_.a.elements + data_.a.size; ++v)
    v->Accept(handler);
   handler.EndArray(data_.a.size);
   break;

  case kStringType:
   handler.String(data_.s.str, data_.s.length, false);
   break;

  case kNumberType:
   if (IsInt()) handler.Int(data_.n.i.i);
   else if (IsUint()) handler.Uint(data_.n.u.u);
   else if (IsInt64()) handler.Int64(data_.n.i64);
   else if (IsUint64()) handler.Uint64(data_.n.u64);
   else handler.Double(data_.n.d);
   break;
  }
  return *this;
 }

private:
 template <typename, typename>
 friend class GenericDocument;

 enum {
  kBoolFlag = 0x100,
  kNumberFlag = 0x200,
  kIntFlag = 0x400,
  kUintFlag = 0x800,
  kInt64Flag = 0x1000,
  kUint64Flag = 0x2000,
  kDoubleFlag = 0x4000,
  kStringFlag = 0x100000,
  kCopyFlag = 0x200000,


  kNullFlag = kNullType,
  kTrueFlag = kTrueType | kBoolFlag,
  kFalseFlag = kFalseType | kBoolFlag,
  kNumberIntFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag,
  kNumberUintFlag = kNumberType | kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag,
  kNumberInt64Flag = kNumberType | kNumberFlag | kInt64Flag,
  kNumberUint64Flag = kNumberType | kNumberFlag | kUint64Flag,
  kNumberDoubleFlag = kNumberType | kNumberFlag | kDoubleFlag,
  kConstStringFlag = kStringType | kStringFlag,
  kCopyStringFlag = kStringType | kStringFlag | kCopyFlag,
  kObjectFlag = kObjectType,
  kArrayFlag = kArrayType,

  kTypeMask = 0xFF
 };

 static const SizeType kDefaultArrayCapacity = 16;
 static const SizeType kDefaultObjectCapacity = 16;

 struct String {
  const Ch* str;
  SizeType length;
  unsigned hashcode;
 };


 union Number {

  struct I {
   int i;
   char padding[4];
  }i;
  struct U {
   unsigned u;
   char padding2[4];
  }u;
# 593 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
  int64_t i64;
  uint64_t u64;
  double d;
 };

 struct Object {
  Member* members;
  SizeType size;
  SizeType capacity;
 };

 struct Array {
  GenericValue<Encoding, Allocator>* elements;
  SizeType size;
  SizeType capacity;
 };

 union Data {
  String s;
  Number n;
  Object o;
  Array a;
 };


 Member* FindMember(const Ch* name) {
  (__builtin_expect(!(name), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 619, "name") : (void)0);
  (__builtin_expect(!(IsObject()), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 620, "IsObject()") : (void)0);

  SizeType length = internal::StrLen(name);

  Object& o = data_.o;
  for (Member* member = o.members; member != data_.o.members + data_.o.size; ++member)
   if (length == member->name.data_.s.length && memcmp(member->name.data_.s.str, name, length * sizeof(Ch)) == 0)
    return member;

  return 0;
 }
 const Member* FindMember(const Ch* name) const { return const_cast<GenericValue&>(*this).FindMember(name); }


 void SetArrayRaw(GenericValue* values, SizeType count, Allocator& alloctaor) {
  flags_ = kArrayFlag;
  data_.a.elements = (GenericValue*)alloctaor.Malloc(count * sizeof(GenericValue));
  memcpy(data_.a.elements, values, count * sizeof(GenericValue));
  data_.a.size = data_.a.capacity = count;
 }


 void SetObjectRaw(Member* members, SizeType count, Allocator& alloctaor) {
  flags_ = kObjectFlag;
  data_.o.members = (Member*)alloctaor.Malloc(count * sizeof(Member));
  memcpy(data_.o.members, members, count * sizeof(Member));
  data_.o.size = data_.o.capacity = count;
 }


 void SetStringRaw(const Ch* s, SizeType length) {
  (__builtin_expect(!(s != __null), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 651, "s != __null") : (void)0);
  flags_ = kConstStringFlag;
  data_.s.str = s;
  data_.s.length = length;
 }


 void SetStringRaw(const Ch* s, SizeType length, Allocator& allocator) {
  (__builtin_expect(!(s != __null), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 659, "s != __null") : (void)0);
  flags_ = kCopyStringFlag;
  data_.s.str = (Ch *)allocator.Malloc((length + 1) * sizeof(Ch));
  data_.s.length = length;
  memcpy(const_cast<Ch*>(data_.s.str), s, length * sizeof(Ch));
  const_cast<Ch*>(data_.s.str)[length] = '\0';
 }


 void RawAssign(GenericValue& rhs) {
  memcpy(this, &rhs, sizeof(GenericValue));
  rhs.flags_ = kNullFlag;
 }

 Data data_;
 unsigned flags_;
};
#pragma pack (pop)


typedef GenericValue<UTF8<> > Value;
# 690 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h"
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >
class GenericDocument : public GenericValue<Encoding, Allocator> {
public:
 typedef typename Encoding::Ch Ch;
 typedef GenericValue<Encoding, Allocator> ValueType;
 typedef Allocator AllocatorType;





 GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity) : stack_(allocator, stackCapacity), parseError_(0), errorOffset_(0) {}






 template <unsigned parseFlags, typename Stream>
 GenericDocument& ParseStream(Stream& stream) {
  ValueType::SetNull();
  GenericReader<Encoding, Allocator> reader;
  if (reader.template Parse<parseFlags>(stream, *this)) {
   (__builtin_expect(!(stack_.GetSize() == sizeof(ValueType)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 713, "stack_.GetSize() == sizeof(ValueType)") : (void)0);
   this->RawAssign(*stack_.template Pop<ValueType>(1));
   parseError_ = 0;
   errorOffset_ = 0;
  }
  else {
   parseError_ = reader.GetParseError();
   errorOffset_ = reader.GetErrorOffset();
   ClearStack();
  }
  return *this;
 }






 template <unsigned parseFlags>
 GenericDocument& ParseInsitu(Ch* str) {
  GenericInsituStringStream<Encoding> s(str);
  return ParseStream<parseFlags | kParseInsituFlag>(s);
 }





 template <unsigned parseFlags>
 GenericDocument& Parse(const Ch* str) {
  (__builtin_expect(!(!(parseFlags & kParseInsituFlag)), 0) ? __assert_rtn(__func__, "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/rapidjson/document.h", 743, "!(parseFlags & kParseInsituFlag)") : (void)0);
  GenericStringStream<Encoding> s(str);
  return ParseStream<parseFlags>(s);
 }


 bool HasParseError() const { return parseError_ != 0; }


 const char* GetParseError() const { return parseError_; }


 size_t GetErrorOffset() const { return errorOffset_; }


 Allocator& GetAllocator() { return stack_.GetAllocator(); }


 size_t GetStackCapacity() const { return stack_.GetCapacity(); }

private:

 GenericDocument& operator=(const GenericDocument&);

 friend class GenericReader<Encoding, Allocator>;


 void Null() { new (stack_.template Push<ValueType>()) ValueType(); }
 void Bool(bool b) { new (stack_.template Push<ValueType>()) ValueType(b); }
 void Int(int i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Uint(unsigned i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Int64(int64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Uint64(uint64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); }
 void Double(double d) { new (stack_.template Push<ValueType>()) ValueType(d); }

 void String(const Ch* str, SizeType length, bool copy) {
  if (copy)
   new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
  else
   new (stack_.template Push<ValueType>()) ValueType(str, length);
 }

 void StartObject() { new (stack_.template Push<ValueType>()) ValueType(kObjectType); }

 void EndObject(SizeType memberCount) {
  typename ValueType::Member* members = stack_.template Pop<typename ValueType::Member>(memberCount);
  stack_.template Top<ValueType>()->SetObjectRaw(members, (SizeType)memberCount, GetAllocator());
 }

 void StartArray() { new (stack_.template Push<ValueType>()) ValueType(kArrayType); }

 void EndArray(SizeType elementCount) {
  ValueType* elements = stack_.template Pop<ValueType>(elementCount);
  stack_.template Top<ValueType>()->SetArrayRaw(elements, elementCount, GetAllocator());
 }

 void ClearStack() {
  if (Allocator::kNeedFree)
   while (stack_.GetSize() > 0)
    (stack_.template Pop<ValueType>(1))->~ValueType();
  else
   stack_.Clear();
 }

 static const size_t kDefaultStackCapacity = 1024;
 internal::Stack<Allocator> stack_;
 const char* parseError_;
 size_t errorOffset_;
};

typedef GenericDocument<UTF8<> > Document;

}
# 31 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/../../Json/DictionaryHelper.h" 2



namespace cocos2d { namespace extension {




class DictionaryHelper
{
public:
    DictionaryHelper();
    ~DictionaryHelper();
    static DictionaryHelper* shareHelper();
 static void purgeDictionaryHelper();
    cocos2d::CCDictionary* getSubDictionary(cocos2d::CCDictionary* root,const char* key);
    int getIntValue(cocos2d::CCDictionary* root,const char* key);
    float getFloatValue(cocos2d::CCDictionary* root,const char* key);
    const char* getStringValue(cocos2d::CCDictionary* root,const char* key);
    bool getBooleanValue(cocos2d::CCDictionary* root,const char* key);
    cocos2d::CCArray* getArrayValue(cocos2d::CCDictionary* root,const char* key);
    cocos2d::CCObject* checkObjectExist(cocos2d::CCDictionary* root,const char* key);
    int objectToIntValue(cocos2d::CCObject* obj);
    float objectToFloatValue(cocos2d::CCObject* obj);
    const char* objectToStringValue(cocos2d::CCObject* obj);
    bool objectToBooleanValue(cocos2d::CCObject* obj);
    cocos2d::CCArray* objectToCCArray(cocos2d::CCObject* obj);

 const rapidjson::Value& getSubDictionary_json(const rapidjson::Value &root, const char* key);
    const rapidjson::Value& getSubDictionary_json(const rapidjson::Value &root, const char* key, int idx);
    const rapidjson::Value& getSubDictionary_json(const rapidjson::Value &root, int idx);

 int getIntValue_json(const rapidjson::Value& root, const char* key, int def = 0);
 float getFloatValue_json(const rapidjson::Value& root,const char* key, float def = 0.0f);
    bool getBooleanValue_json(const rapidjson::Value& root,const char* key, bool def = false);
    const char* getStringValue_json(const rapidjson::Value& root,const char* key, const char *def = __null);
    int getArrayCount_json(const rapidjson::Value& root,const char* key, int def = 0);

    int getIntValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, int def = 0);
 float getFloatValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, float def = 0.0f);
 bool getBoolValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, bool def = false);
 const char* getStringValueFromArray_json(const rapidjson::Value& root,const char* arrayKey,int idx, const char *def = __null);
 const rapidjson::Value &getDictionaryFromArray_json(const rapidjson::Value &root, const char* key,int idx);
 bool checkObjectExist_json(const rapidjson::Value &root);
    bool checkObjectExist_json(const rapidjson::Value &root, const char* key);
    bool checkObjectExist_json(const rapidjson::Value &root, int index);
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Armature/utils/CCDataReaderHelper.h" 2


namespace tinyxml2
{
    class XMLElement;
}

namespace cocos2d { namespace extension {

typedef struct _DataInfo DataInfo;




class CCDataReaderHelper : CCObject
{
public:
    static CCDataReaderHelper *sharedDataReaderHelper();





    static void setPositionReadScale(float scale);
    static float getPositionReadScale();

    static void purge();

public:
    ~CCDataReaderHelper();

    void addDataFromFile(const char *filePath);
    void addDataFromFileAsync(const char *imagePath, const char *plistPath, const char *filePath, CCObject *target, SEL_SCHEDULE selector);

    void addDataAsyncCallBack(float dt);

    void removeConfigFile(const char *configFile);
public:







    static void addDataFromCache(const char *pFileContent, DataInfo *dataInfo = __null);






    static CCArmatureData *decodeArmature(tinyxml2::XMLElement *armatureXML, DataInfo *dataInfo);
    static CCBoneData *decodeBone(tinyxml2::XMLElement *boneXML, tinyxml2::XMLElement *parentXML, DataInfo *dataInfo);
    static CCDisplayData *decodeBoneDisplay(tinyxml2::XMLElement *displayXML, DataInfo *dataInfo);





    static CCAnimationData *decodeAnimation(tinyxml2::XMLElement *animationXML, DataInfo *dataInfo);
    static CCMovementData *decodeMovement(tinyxml2::XMLElement *movementXML, CCArmatureData *armatureData, DataInfo *dataInfo);
    static CCMovementBoneData *decodeMovementBone(tinyxml2::XMLElement *movBoneXml, tinyxml2::XMLElement *parentXml, CCBoneData *boneData, DataInfo *dataInfo);
    static CCFrameData *decodeFrame(tinyxml2::XMLElement *frameXML, tinyxml2::XMLElement *parentFrameXml, CCBoneData *boneData, DataInfo *dataInfo);





    static CCTextureData *decodeTexture(tinyxml2::XMLElement *textureXML, DataInfo *dataInfo);




    static CCContourData *decodeContour(tinyxml2::XMLElement *contourXML, DataInfo *dataInfo);

public:
    static void addDataFromJsonCache(const char *fileContent, DataInfo *dataInfo = __null);

 static CCArmatureData *decodeArmature(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCBoneData *decodeBone(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCDisplayData *decodeBoneDisplay(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCAnimationData *decodeAnimation(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCMovementData *decodeMovement(const rapidjson::Value &json, DataInfo *dataInfo);

 static CCMovementBoneData *decodeMovementBone(const rapidjson::Value &json, DataInfo *dataInfo);
 static CCFrameData *decodeFrame(const rapidjson::Value &json, DataInfo *dataInfo);

 static CCTextureData *decodeTexture(const rapidjson::Value &json);
 static CCContourData *decodeContour(const rapidjson::Value &json);

 static void decodeNode(CCBaseData *node, const rapidjson::Value &json, DataInfo *dataInfo);
private:
    static std::vector<std::string> s_arrConfigFileList;

    static CCDataReaderHelper *s_DataReaderHelper;
};

}}
# 55 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Armature/external_tool/sigslot.h" 1
# 110 "Cacao/include/cocos2dext/CocoStudio/Armature/external_tool/sigslot.h"
namespace sigslot {

 class single_threaded
 {
 public:
  single_threaded()
  {
   ;
  }

  virtual ~single_threaded()
  {
   ;
  }

  virtual void lock()
  {
   ;
  }

  virtual void unlock()
  {
   ;
  }
 };
# 215 "Cacao/include/cocos2dext/CocoStudio/Armature/external_tool/sigslot.h"
 class multi_threaded_global
 {
 public:
  multi_threaded_global()
  {
   pthread_mutex_init(get_mutex(), __null);
  }

  multi_threaded_global(const multi_threaded_global&)
  {
   ;
  }

  virtual ~multi_threaded_global()
  {
   ;
  }

  virtual void lock()
  {
   pthread_mutex_lock(get_mutex());
  }

  virtual void unlock()
  {
   pthread_mutex_unlock(get_mutex());
  }

 private:
  pthread_mutex_t* get_mutex()
  {
   static pthread_mutex_t g_mutex;
   return &g_mutex;
  }
 };

 class multi_threaded_local
 {
 public:
  multi_threaded_local()
  {
   pthread_mutex_init(&m_mutex, __null);
  }

  multi_threaded_local(const multi_threaded_local&)
  {
   pthread_mutex_init(&m_mutex, __null);
  }

  virtual ~multi_threaded_local()
  {
   pthread_mutex_destroy(&m_mutex);
  }

  virtual void lock()
  {
   pthread_mutex_lock(&m_mutex);
  }

  virtual void unlock()
  {
   pthread_mutex_unlock(&m_mutex);
  }

 private:
  pthread_mutex_t m_mutex;
 };


 template<class mt_policy>
 class lock_block
 {
 public:
  mt_policy *m_mutex;

  lock_block(mt_policy *mtx)
        : m_mutex(mtx)
  {
   m_mutex->lock();
  }

  ~lock_block()
  {
   m_mutex->unlock();
  }
 };

 template<class mt_policy>
 class has_slots;

 template<class mt_policy>
 class _connection_base0
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit() = 0;
  virtual _connection_base0* clone() = 0;
  virtual _connection_base0* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class mt_policy>
 class _connection_base1
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type) = 0;
  virtual _connection_base1<arg1_type, mt_policy>* clone() = 0;
  virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class mt_policy>
 class _connection_base2
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type) = 0;
  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone() = 0;
  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _connection_base3
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type) = 0;
  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone() = 0;
  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
 class _connection_base4
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type) = 0;
  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone() = 0;
  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy>
 class _connection_base5
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type,
                          arg5_type) = 0;
  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* clone() = 0;
  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy>
 class _connection_base6
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
                          arg6_type) = 0;
  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* clone() = 0;
  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _connection_base7
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
                          arg6_type, arg7_type) = 0;
  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* clone() = 0;
  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
 class _connection_base8
 {
 public:
  virtual has_slots<mt_policy>* getdest() const = 0;
  virtual void emit(arg1_type, arg2_type, arg3_type, arg4_type, arg5_type,
                          arg6_type, arg7_type, arg8_type) = 0;
  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone() = 0;
  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest) = 0;
 };

 template<class mt_policy>
 class _signal_base : public mt_policy
 {
 public:
  virtual void slot_disconnect(has_slots<mt_policy>* pslot) = 0;
  virtual void slot_duplicate(const has_slots<mt_policy>* poldslot, has_slots<mt_policy>* pnewslot) = 0;
 };

 template<class mt_policy = multi_threaded_local>
 class has_slots : public mt_policy
 {
 private:
  typedef std::set<_signal_base<mt_policy> *> sender_set;
  typedef typename sender_set::const_iterator const_iterator;

 public:
  has_slots()
  {
   ;
  }

  has_slots(const has_slots& hs)
        : mt_policy(hs)
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = hs.m_senders.begin();
   const_iterator itEnd = hs.m_senders.end();

   while(it != itEnd)
   {
    (*it)->slot_duplicate(&hs, this);
    m_senders.insert(*it);
    ++it;
   }
  }

  void signal_connect(_signal_base<mt_policy>* sender)
  {
   lock_block<mt_policy> lock(this);
   m_senders.insert(sender);
  }

  void signal_disconnect(_signal_base<mt_policy>* sender)
  {
   lock_block<mt_policy> lock(this);
   m_senders.erase(sender);
  }

  virtual ~has_slots()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   const_iterator it = m_senders.begin();
   const_iterator itEnd = m_senders.end();

   while(it != itEnd)
   {
    (*it)->slot_disconnect(this);
    ++it;
   }

   m_senders.erase(m_senders.begin(), m_senders.end());
  }

 private:
  sender_set m_senders;
 };

 template<class mt_policy>
 class _signal_base0 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base0<mt_policy> *> connections_list;

  _signal_base0()
  {
   ;
  }

  _signal_base0(const _signal_base0& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  ~_signal_base0()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class mt_policy>
 class _signal_base1 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base1<arg1_type, mt_policy> *> connections_list;

  _signal_base1()
  {
   ;
  }

  _signal_base1(const _signal_base1<arg1_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base1()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }


 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class mt_policy>
 class _signal_base2 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base2<arg1_type, arg2_type, mt_policy> *>
        connections_list;

  _signal_base2()
  {
   ;
  }

  _signal_base2(const _signal_base2<arg1_type, arg2_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base2()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _signal_base3 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base3<arg1_type, arg2_type, arg3_type, mt_policy> *>
        connections_list;

  _signal_base3()
  {
   ;
  }

  _signal_base3(const _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base3()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy>
 class _signal_base4 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base4<arg1_type, arg2_type, arg3_type,
        arg4_type, mt_policy> *> connections_list;

  _signal_base4()
  {
   ;
  }

  _signal_base4(const _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base4()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy>
 class _signal_base5 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base5<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, mt_policy> *> connections_list;

  _signal_base5()
  {
   ;
  }

  _signal_base5(const _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base5()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy>
 class _signal_base6 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base6<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, mt_policy> *> connections_list;

  _signal_base6()
  {
   ;
  }

  _signal_base6(const _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, arg6_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base6()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _signal_base7 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base7<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> *> connections_list;

  _signal_base7()
  {
   ;
  }

  _signal_base7(const _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, arg6_type, arg7_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base7()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy>
 class _signal_base8 : public _signal_base<mt_policy>
 {
 public:
  typedef std::list<_connection_base8<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> *>
        connections_list;

  _signal_base8()
  {
   ;
  }

  _signal_base8(const _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
                      arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
        : _signal_base<mt_policy>(s)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = s.m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = s.m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_connect(this);
    m_connected_slots.push_back((*it)->clone());

    ++it;
   }
  }

  void slot_duplicate(const has_slots<mt_policy>* oldtarget, has_slots<mt_policy>* newtarget)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == oldtarget)
    {
     m_connected_slots.push_back((*it)->duplicate(newtarget));
    }

    ++it;
   }
  }

  ~_signal_base8()
  {
   disconnect_all();
  }

  void disconnect_all()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator it = m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    (*it)->getdest()->signal_disconnect(this);
    delete *it;

    ++it;
   }

   m_connected_slots.erase(m_connected_slots.begin(), m_connected_slots.end());
  }

  void disconnect(has_slots<mt_policy>* pclass)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    if((*it)->getdest() == pclass)
    {
     delete *it;
     m_connected_slots.erase(it);
     pclass->signal_disconnect(this);
     return;
    }

    ++it;
   }
  }

  void slot_disconnect(has_slots<mt_policy>* pslot)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::iterator it = m_connected_slots.begin();
   typename connections_list::iterator itEnd = m_connected_slots.end();

   while(it != itEnd)
   {
    typename connections_list::iterator itNext = it;
    ++itNext;

    if((*it)->getdest() == pslot)
    {
     delete *it;
     m_connected_slots.erase(it);
    }

    it = itNext;
   }
  }

 protected:
  connections_list m_connected_slots;
 };


 template<class dest_type, class mt_policy>
 class _connection0 : public _connection_base0<mt_policy>
 {
 public:
  _connection0()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection0(dest_type* pobject, void (dest_type::*pmemfun)())
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base0<mt_policy>* clone()
  {
   return new _connection0<dest_type, mt_policy>(*this);
  }

  virtual _connection_base0<mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection0<dest_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit()
  {
   (m_pobject->*m_pmemfun)();
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)();
 };

 template<class dest_type, class arg1_type, class mt_policy>
 class _connection1 : public _connection_base1<arg1_type, mt_policy>
 {
 public:
  _connection1()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection1(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base1<arg1_type, mt_policy>* clone()
  {
   return new _connection1<dest_type, arg1_type, mt_policy>(*this);
  }

  virtual _connection_base1<arg1_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection1<dest_type, arg1_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1)
  {
   (m_pobject->*m_pmemfun)(a1);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class mt_policy>
 class _connection2 : public _connection_base2<arg1_type, arg2_type, mt_policy>
 {
 public:
  _connection2()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection2(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* clone()
  {
   return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>(*this);
  }

  virtual _connection_base2<arg1_type, arg2_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection2<dest_type, arg1_type, arg2_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2)
  {
   (m_pobject->*m_pmemfun)(a1, a2);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type, class mt_policy>
 class _connection3 : public _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>
 {
 public:
  _connection3()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection3(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* clone()
  {
   return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>(*this);
  }

  virtual _connection_base3<arg1_type, arg2_type, arg3_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection3<dest_type, arg1_type, arg2_type, arg3_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class mt_policy>
 class _connection4 : public _connection_base4<arg1_type, arg2_type,
    arg3_type, arg4_type, mt_policy>
 {
 public:
  _connection4()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection4(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* clone()
  {
   return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(*this);
  }

  virtual _connection_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection4<dest_type, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3,
                          arg4_type a4)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type,
                                      arg4_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class mt_policy>
 class _connection5 : public _connection_base5<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, mt_policy>
 {
 public:
  _connection5()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection5(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* clone()
  {
   return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, mt_policy>(*this);
  }

  virtual _connection_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection5<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class mt_policy>
 class _connection6 : public _connection_base6<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, arg6_type, mt_policy>
 {
 public:
  _connection6()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection6(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* clone()
  {
   return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, mt_policy>(*this);
  }

  virtual _connection_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection6<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5, arg6_type a6)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type, arg6_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class arg7_type, class mt_policy>
 class _connection7 : public _connection_base7<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
 {
 public:
  _connection7()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection7(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type, arg6_type, arg7_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* clone()
  {
   return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, mt_policy>(*this);
  }

  virtual _connection_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection7<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5, arg6_type a6, arg7_type a7)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type, arg6_type, arg7_type);
 };

 template<class dest_type, class arg1_type, class arg2_type, class arg3_type,
 class arg4_type, class arg5_type, class arg6_type, class arg7_type,
 class arg8_type, class mt_policy>
 class _connection8 : public _connection_base8<arg1_type, arg2_type,
    arg3_type, arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
 {
 public:
  _connection8()
  {
   m_pobject = __null;
   m_pmemfun = __null;
  }

  _connection8(dest_type* pobject, void (dest_type::*pmemfun)(arg1_type,
                                                                    arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
                                                                    arg7_type, arg8_type))
  {
   m_pobject = pobject;
   m_pmemfun = pmemfun;
  }

  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* clone()
  {
   return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(*this);
  }

  virtual _connection_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* duplicate(has_slots<mt_policy>* pnewdest)
  {
   return new _connection8<dest_type, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>((dest_type *)pnewdest, m_pmemfun);
  }

  virtual void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                          arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   (m_pobject->*m_pmemfun)(a1, a2, a3, a4, a5, a6, a7, a8);
  }

  virtual has_slots<mt_policy>* getdest() const
  {
   return m_pobject;
  }

 private:
  dest_type* m_pobject;
  void (dest_type::* m_pmemfun)(arg1_type, arg2_type, arg3_type, arg4_type,
                                      arg5_type, arg6_type, arg7_type, arg8_type);
 };

 template<class mt_policy = multi_threaded_local>
 class signal0 : public _signal_base0<mt_policy>
 {
 public:
        typedef std::list<_connection_base0<mt_policy> *> connections_list;
  signal0()
  {
   ;
  }

  signal0(const signal0<mt_policy>& s)
        : _signal_base0<mt_policy>(s)
  {
   ;
  }


  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)())
  {
   lock_block<mt_policy> lock(this);
   _connection0<desttype, mt_policy>* conn =
            new _connection0<desttype, mt_policy>(pclass, pmemfun);

   _signal_base0<mt_policy>::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = _signal_base0<mt_policy>::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = _signal_base0<mt_policy>::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit();

    it = itNext;
   }
  }

  void operator()()
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = _signal_base0<mt_policy>::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = _signal_base0<mt_policy>::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit();

    it = itNext;
   }
  }

 };

 template<class arg1_type, class mt_policy = multi_threaded_local>
 class signal1 : public _signal_base1<arg1_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base1<arg1_type, mt_policy> *> connections_list;
        typedef _signal_base1<arg1_type, mt_policy> signal_base;
  signal1()
  {
   ;
  }

  signal1(const signal1<arg1_type, mt_policy>& s)
        : _signal_base1<arg1_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type))
  {
   lock_block<mt_policy> lock(this);
   _connection1<desttype, arg1_type, mt_policy>* conn =
            new _connection1<desttype, arg1_type, mt_policy>(pclass, pmemfun);
   signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1);

    it = itNext;
   }
  }

  void operator()(arg1_type a1)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class mt_policy = multi_threaded_local>
 class signal2 : public _signal_base2<arg1_type, arg2_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base2<arg1_type, arg2_type, mt_policy> *>
        connections_list;
        typedef _signal_base2<arg1_type, arg2_type, mt_policy> signal_base;
  signal2()
  {
   ;
  }

  signal2(const signal2<arg1_type, arg2_type, mt_policy>& s)
        : _signal_base2<arg1_type, arg2_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type))
  {
   lock_block<mt_policy> lock(this);
   _connection2<desttype, arg1_type, arg2_type, mt_policy>* conn = new
            _connection2<desttype, arg1_type, arg2_type, mt_policy>(pclass, pmemfun);
   signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class mt_policy = multi_threaded_local>
 class signal3 : public _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base3<arg1_type, arg2_type, arg3_type, mt_policy> *>
        connections_list;
        typedef _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy> signal_base;
  signal3()
  {
   ;
  }

  ~signal3()
  {

  }

  signal3(const signal3<arg1_type, arg2_type, arg3_type, mt_policy>& s)
        : _signal_base3<arg1_type, arg2_type, arg3_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type))
  {
   lock_block<mt_policy> lock(this);
   _connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>* conn =
            new _connection3<desttype, arg1_type, arg2_type, arg3_type, mt_policy>(pclass,
                                                                                   pmemfun);
   signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type, class mt_policy = multi_threaded_local>
 class signal4 : public _signal_base4<arg1_type, arg2_type, arg3_type,
    arg4_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base4<arg1_type, arg2_type, arg3_type,
        arg4_type, mt_policy> *> connections_list;
        typedef _signal_base4<arg1_type, arg2_type, arg3_type,
        arg4_type, mt_policy> signal_base;
  signal4()
  {
   ;
  }

  signal4(const signal4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>& s)
        : _signal_base4<arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type))
  {
   lock_block<mt_policy> lock(this);
   _connection4<desttype, arg1_type, arg2_type, arg3_type, arg4_type, mt_policy>*
            conn = new _connection4<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class mt_policy = multi_threaded_local>
 class signal5 : public _signal_base5<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base5<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, mt_policy> *> connections_list;
        typedef _signal_base5<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, mt_policy> signal_base;
  signal5()
  {
   ;
  }

  signal5(const signal5<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, mt_policy>& s)
        : _signal_base5<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type))
  {
   lock_block<mt_policy> lock(this);
   _connection5<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, mt_policy>* conn = new _connection5<desttype, arg1_type, arg2_type,
            arg3_type, arg4_type, arg5_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5);

    it = itNext;
   }
  }
 };


 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class mt_policy = multi_threaded_local>
 class signal6 : public _signal_base6<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base6<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, mt_policy> *> connections_list;
        typedef _signal_base6<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, mt_policy> signal_base;
  signal6()
  {
   ;
  }

  signal6(const signal6<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, arg6_type, mt_policy>& s)
        : _signal_base6<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type, arg6_type))
  {
   lock_block<mt_policy> lock(this);
   _connection6<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, mt_policy>* conn =
            new _connection6<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, arg5_type, arg6_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5, arg6_type a6)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5, arg6_type a6)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class mt_policy = multi_threaded_local>
 class signal7 : public _signal_base7<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base7<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> *> connections_list;
        typedef _signal_base7<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, mt_policy> signal_base;
  signal7()
  {
   ;
  }

  signal7(const signal7<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, arg6_type, arg7_type, mt_policy>& s)
        : _signal_base7<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
                                                                 arg7_type))
  {
   lock_block<mt_policy> lock(this);
   _connection7<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, mt_policy>* conn =
            new _connection7<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, arg5_type, arg6_type, arg7_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5, arg6_type a6, arg7_type a7)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5, arg6_type a6, arg7_type a7)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7);

    it = itNext;
   }
  }
 };

 template<class arg1_type, class arg2_type, class arg3_type, class arg4_type,
 class arg5_type, class arg6_type, class arg7_type, class arg8_type, class mt_policy = multi_threaded_local>
 class signal8 : public _signal_base8<arg1_type, arg2_type, arg3_type,
    arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>
 {
 public:
        typedef std::list<_connection_base8<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> *>
        connections_list;
        typedef _signal_base8<arg1_type, arg2_type, arg3_type,
        arg4_type, arg5_type, arg6_type, arg7_type, arg8_type, mt_policy> signal_base;
  signal8()
  {
   ;
  }

  signal8(const signal8<arg1_type, arg2_type, arg3_type, arg4_type,
                arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>& s)
        : _signal_base8<arg1_type, arg2_type, arg3_type, arg4_type,
        arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>(s)
  {
   ;
  }

  template<class desttype>
        void connect(desttype* pclass, void (desttype::*pmemfun)(arg1_type,
                                                                 arg2_type, arg3_type, arg4_type, arg5_type, arg6_type,
                                                                 arg7_type, arg8_type))
  {
   lock_block<mt_policy> lock(this);
   _connection8<desttype, arg1_type, arg2_type, arg3_type, arg4_type,
            arg5_type, arg6_type, arg7_type, arg8_type, mt_policy>* conn =
            new _connection8<desttype, arg1_type, arg2_type, arg3_type,
            arg4_type, arg5_type, arg6_type, arg7_type,
            arg8_type, mt_policy>(pclass, pmemfun);
            signal_base::m_connected_slots.push_back(conn);
   pclass->signal_connect(this);
  }

  void emit(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                  arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);

    it = itNext;
   }
  }

  void operator()(arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4,
                        arg5_type a5, arg6_type a6, arg7_type a7, arg8_type a8)
  {
   lock_block<mt_policy> lock(this);
   typename connections_list::const_iterator itNext, it = signal_base::m_connected_slots.begin();
   typename connections_list::const_iterator itEnd = signal_base::m_connected_slots.end();

   while(it != itEnd)
   {
    itNext = it;
    ++itNext;

    (*it)->emit(a1, a2, a3, a4, a5, a6, a7, a8);

    it = itNext;
   }
  }
 };

};
# 57 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h"
# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/ObjectFactory.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/ObjectFactory.h"
namespace cocos2d
{
    namespace ui
    {
        class Widget;
    }
    namespace extension
    {
        class WidgetReaderProtocol;
    }
}


namespace cocos2d { namespace extension {

class ObjectFactory
{
public:
    typedef cocos2d::CCObject* (*Instance)(void);
    struct TInfo
    {
        TInfo(void);
        TInfo(const std::string& type, Instance ins = __null);
        TInfo(const TInfo &t);
        ~TInfo(void);
        TInfo& operator= (const TInfo &t);
        std::string _class;
        Instance _fun;
    };
    typedef std::map<std::string, TInfo> FactoryMap;
    ObjectFactory(void);
    virtual ~ObjectFactory(void);
    static ObjectFactory* getInstance();
    void destroyInstance();
    CCObject* createObject(std::string name);
 CCComponent* createComponent(std::string name);
    ui::Widget* createGUI(std::string name);
    WidgetReaderProtocol* createWidgetReaderProtocol(std::string name);
    void registerType(const TInfo &t);
    void removeAll();
private:
    static ObjectFactory *_sharedFactory;
    FactoryMap _typeMap;
};


}}
# 32 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerObj.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerObj.h"
namespace cocos2d { namespace extension {


class BaseTriggerCondition : public CCObject
{
protected:
    BaseTriggerCondition(void);
public:
 virtual ~BaseTriggerCondition(void);
    virtual bool init();
    virtual bool detect();
 virtual void serialize(const rapidjson::Value &val);
    virtual void removeAll();
};

class BaseTriggerAction : public CCObject
{
protected:
    BaseTriggerAction(void);
public:
 virtual ~BaseTriggerAction(void);
    virtual bool init();
    virtual void done();
 virtual void serialize(const rapidjson::Value &val);
    virtual void removeAll();
};


class TriggerObj : public CCObject
{
public:
    TriggerObj(void);
    virtual ~TriggerObj(void);
    virtual bool init();
    static TriggerObj* create(void);

    virtual bool detect();
    virtual void done();
    virtual void removeAll();
    virtual void serialize(const rapidjson::Value &val);
 unsigned int getId();
 void setEnable(bool bEnable);
 std::vector<int>& getEvents();

private:
    CCArray *_cons;
    CCArray *_acts;
 unsigned int _id;
 bool _bEnable;
 std::vector<int> _vInt;
};

}}
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerMng.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerMng.h"
namespace cocos2d { namespace extension {

class TriggerObj;

class ArmatureMovementDispatcher : public CCObject
{
public:
 ArmatureMovementDispatcher(void);
 ~ArmatureMovementDispatcher(void);
public:
 void addAnimationEventCallBack(CCObject*pTarget, SEL_MovementEventCallFunc mecf);
 void removeAnnimationEventCallBack(CCObject*pTarget, SEL_MovementEventCallFunc mecf);
 void animationEvent(cocos2d::extension::CCArmature *armature, cocos2d::extension::MovementEventType movementType, const char *movementID);
 std::map<CCObject*, SEL_MovementEventCallFunc> *_mapEventAnimation;

};

class TriggerMng
{
public:
 TriggerMng(void);
 virtual ~TriggerMng(void);

public:
    static TriggerMng* getInstance();
    static const char* triggerMngVersion();
    void destroyInstance();

public:
 void parse(const rapidjson::Value &root);
 void removeAll(void);
 CCArray* get(unsigned int event) const;
 TriggerObj* getTriggerObj(unsigned int id) const;
    bool add(unsigned int event, TriggerObj *pObj);
    bool remove(unsigned int event);
 bool remove(unsigned int event, TriggerObj *pObj);
 bool removeTriggerObj(unsigned int id);
    bool isEmpty(void) const;
    void addArmatureMovementCallBack(CCArmature *pAr, CCObject *pTarget, SEL_MovementEventCallFunc mecf);
 void removeArmatureMovementCallBack(CCArmature *pAr, CCObject *pTarget, SEL_MovementEventCallFunc mecf);
 void removeArmatureAllMovementCallBack(CCArmature *pAr);
 void removeAllArmatureMovementCallBack();
private:
    void alloc(void);
private:
    CCDictionary *_eventTriggers;
    static TriggerMng *_sharedTriggerMng;
 CCDictionary *_triggerObjs;
 std::map<CCArmature*, ArmatureMovementDispatcher*> *_movementDispatches;
};

}}
# 34 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h" 2

namespace cocos2d { namespace extension {
# 50 "Cacao/include/cocos2dext/CocoStudio/Trigger/TriggerBase.h"
void sendEvent(unsigned int event);

}}
# 59 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComBase.h" 1
# 61 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAttribute.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAttribute.h"
namespace cocos2d { namespace extension {



class CCComAttribute : public cocos2d::CCComponent
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
protected:



    CCComAttribute(void);



    virtual ~CCComAttribute(void);

public:
   virtual bool init();
   static CCComAttribute* create(void);
   virtual bool serialize(void* r);

   void setInt(const char *key, int value);
   void setFloat(const char *key, float value);
   void setBool(const char *key, bool value);
   void setCString(const char *key, const char *value);

   int getInt(const char *key, int def = 0) const;
   float getFloat(const char *key, float def = 0.0f) const;
   bool getBool(const char *key, bool def = false) const;
   const char* getCString(const char *key, const char *def = __null) const;

   bool parse(const std::string &jsonPath);
private:
   cocos2d::CCDictionary *_dict;
   rapidjson::Document _doc;
};

}}
# 62 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAudio.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComAudio.h"
namespace cocos2d { namespace extension {



class CCComAudio : public cocos2d::CCComponent
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
protected:
    CCComAudio(void);
    virtual ~CCComAudio(void);

public:
   virtual bool init();
   virtual void onEnter();
   virtual void onExit();
   virtual bool isEnabled() const;
   virtual void setEnabled(bool b);
   virtual bool serialize(void* r);

   static CCComAudio* create(void);

public:
   void end();
   void preloadBackgroundMusic(const char* pszFilePath);
   void playBackgroundMusic(const char* pszFilePath, bool bLoop);
   void playBackgroundMusic(const char* pszFilePath);
   void playBackgroundMusic();
   void stopBackgroundMusic(bool bReleaseData);
   void stopBackgroundMusic();
   void pauseBackgroundMusic();
   void resumeBackgroundMusic();
   void rewindBackgroundMusic();
   bool willPlayBackgroundMusic();
   bool isBackgroundMusicPlaying();
   float getBackgroundMusicVolume();
   void setBackgroundMusicVolume(float volume);
   float getEffectsVolume();
   void setEffectsVolume(float volume);
   unsigned int playEffect(const char* pszFilePath, bool bLoop);
   unsigned int playEffect(const char* pszFilePath);
   unsigned int playEffect();
   void pauseEffect(unsigned int nSoundId);
   void pauseAllEffects();
   void resumeEffect(unsigned int nSoundId);
   void resumeAllEffects();
   void stopEffect(unsigned int nSoundId);
   void stopAllEffects();
   void preloadEffect(const char* pszFilePath);
   void unloadEffect(const char* pszFilePath);
   void setFile(const char* pszFilePath);
   const char* getFile();
   void setLoop(bool bLoop);
   bool isLoop();
private:
   std::string m_strFilePath;
   bool m_bLoop;
};

}}
# 63 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComController.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Components/CCComController.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCInputDelegate.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/Components/CCInputDelegate.h"
namespace cocos2d { namespace extension {



class CCInputDelegate : public CCTouchDelegate, public CCAccelerometerDelegate, public CCKeypadDelegate
{
protected:
    CCInputDelegate(void);
    virtual ~CCInputDelegate(void);

public:
    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);

    virtual void ccTouchesBegan(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesMoved(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesEnded(CCSet *pTouches, CCEvent *pEvent);
    virtual void ccTouchesCancelled(CCSet *pTouches, CCEvent *pEvent);



    virtual void didAccelerate(CCAcceleration* pAccelerationValue);
public:
    virtual bool isTouchEnabled();
    virtual void setTouchEnabled(bool value);

    virtual bool isAccelerometerEnabled();
    virtual void setAccelerometerEnabled(bool value);

    virtual bool isKeypadEnabled();
    virtual void setKeypadEnabled(bool value);

    virtual void setTouchMode(ccTouchesMode mode);
    virtual int getTouchMode();

    virtual void setTouchPriority(int priority);
    virtual int getTouchPriority();

protected:
    bool m_bTouchEnabled;
    bool m_bAccelerometerEnabled;
    bool m_bKeypadEnabled;

private:
     int m_nTouchPriority;
     ccTouchesMode m_eTouchMode;
};

}}
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComController.h" 2

namespace cocos2d { namespace extension {



class CCComController : public cocos2d::CCComponent, public CCInputDelegate
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
public:



   CCComController(void);



   virtual ~CCComController(void);
   virtual bool init();
   virtual void onEnter();
   virtual void onExit();
   virtual void update(float delta);
   virtual bool isEnabled() const;
   virtual void setEnabled(bool b);

   static CCComController* create(void);
};

}}
# 64 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/Components/CCComRender.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Components/CCComRender.h"
namespace cocos2d { namespace extension {




class CCComRender : public cocos2d::CCComponent
{
 public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);
public:



    CCComRender(void);
    CCComRender(cocos2d::CCNode *node, const char *comName);



    virtual ~CCComRender(void);

public:
   virtual void onEnter();
   virtual void onExit();
   virtual bool serialize(void* r);
   virtual cocos2d::CCNode* getNode();
   virtual void setNode(cocos2d::CCNode *pNode);

   static CCComRender* create(cocos2d::CCNode *pNode, const char *comName);
   static CCComRender* create(void);
private:
   bool readJson(const char *pszFileName, rapidjson::Document &doc);
private:
   cocos2d::CCNode *m_pRender;
};

}}
# 65 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutDefine.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutDefine.h"
namespace cocos2d {

namespace ui {




class Margin
{
public:
    float left;
    float top;
    float right;
    float bottom;

public:
    Margin();
    Margin(float l, float t, float r, float b);
    Margin(const Margin& other);
    Margin& operator= (const Margin& other);
    void setMargin(float l, float t, float r, float b);
    bool equals(const Margin& target) const;
};

const Margin MarginZero = Margin();

typedef enum
{
    LINEAR_GRAVITY_NONE,
    LINEAR_GRAVITY_LEFT,
    LINEAR_GRAVITY_TOP,
    LINEAR_GRAVITY_RIGHT,
    LINEAR_GRAVITY_BOTTOM,
    LINEAR_GRAVITY_CENTER_VERTICAL,
    LINEAR_GRAVITY_CENTER_HORIZONTAL
}LinearGravity;

typedef enum
{
    RELATIVE_ALIGN_NONE,
    RELATIVE_ALIGN_PARENT_TOP_LEFT,
    RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL,
    RELATIVE_ALIGN_PARENT_TOP_RIGHT,
    RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL,
    RELATIVE_CENTER_IN_PARENT,
    RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL,
    RELATIVE_ALIGN_PARENT_LEFT_BOTTOM,
    RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL,
    RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM,

    RELATIVE_LOCATION_ABOVE_LEFTALIGN,
    RELATIVE_LOCATION_ABOVE_CENTER,
    RELATIVE_LOCATION_ABOVE_RIGHTALIGN,
    RELATIVE_LOCATION_LEFT_OF_TOPALIGN,
    RELATIVE_LOCATION_LEFT_OF_CENTER,
    RELATIVE_LOCATION_LEFT_OF_BOTTOMALIGN,
    RELATIVE_LOCATION_RIGHT_OF_TOPALIGN,
    RELATIVE_LOCATION_RIGHT_OF_CENTER,
    RELATIVE_LOCATION_RIGHT_OF_BOTTOMALIGN,
    RELATIVE_LOCATION_BELOW_LEFTALIGN,
    RELATIVE_LOCATION_BELOW_CENTER,
    RELATIVE_LOCATION_BELOW_RIGHTALIGN
}RelativeAlign;

}
}
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    LAYOUT_PARAMETER_NONE,
    LAYOUT_PARAMETER_LINEAR,
    LAYOUT_PARAMETER_RELATIVE
}LayoutParameterType;




class LayoutParameter : public CCObject
{
public:



    LayoutParameter() : _margin(Margin()){_layoutParameterType = LAYOUT_PARAMETER_NONE;};




    virtual ~LayoutParameter(){};





    static LayoutParameter* create();
# 70 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    void setMargin(const Margin& margin);
# 79 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    const Margin& getMargin() const;
# 88 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    LayoutParameterType getLayoutType() const;

    LayoutParameter* clone();
    virtual LayoutParameter* createCloneInstance();
    virtual void copyProperties(LayoutParameter* model);
protected:
    Margin _margin;
    LayoutParameterType _layoutParameterType;
};




class LinearLayoutParameter : public LayoutParameter
{
public:



    LinearLayoutParameter() : _linearGravity(LINEAR_GRAVITY_NONE){_layoutParameterType = LAYOUT_PARAMETER_LINEAR;};




    virtual ~LinearLayoutParameter(){};





    static LinearLayoutParameter* create();
# 127 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    void setGravity(LinearGravity gravity);
# 136 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    LinearGravity getGravity() const;
    virtual LayoutParameter* createCloneInstance();
    virtual void copyProperties(LayoutParameter* model);
protected:
    LinearGravity _linearGravity;
};





class RelativeLayoutParameter : public LayoutParameter
{
public:



    RelativeLayoutParameter() : _relativeAlign(RELATIVE_ALIGN_NONE),_relativeWidgetName(""),_relativeLayoutName(""),_put(false){_layoutParameterType = LAYOUT_PARAMETER_RELATIVE;};




    virtual ~RelativeLayoutParameter(){};





    static RelativeLayoutParameter* create();
# 173 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    void setAlign(RelativeAlign align);
# 182 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../Layouts/UILayoutParameter.h"
    RelativeAlign getAlign() const;






    void setRelativeToWidgetName(const char* name);






    const char* getRelativeToWidgetName() const;






    void setRelativeName(const char* name);






    const char* getRelativeName() const;

    virtual LayoutParameter* createCloneInstance();
    virtual void copyProperties(LayoutParameter* model);
protected:
    RelativeAlign _relativeAlign;
    std::string _relativeWidgetName;
    std::string _relativeLayoutName;
    bool _put;
    friend class Layout;
};

}

}
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/../System/GUIDefine.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h" 2

namespace cocos2d {

namespace ui {

typedef enum
{
    BRIGHT_NONE = -1,
    BRIGHT_NORMAL,
    BRIGHT_HIGHLIGHT
}BrightStyle;

typedef enum
{
    WidgetTypeWidget,
    WidgetTypeContainer
}WidgetType;

typedef enum
{
    UI_TEX_TYPE_LOCAL,
    UI_TEX_TYPE_PLIST
}TextureResType;

typedef enum
{
    TOUCH_EVENT_BEGAN,
    TOUCH_EVENT_MOVED,
    TOUCH_EVENT_ENDED,
    TOUCH_EVENT_CANCELED
}TouchEventType;

typedef enum
{
    SIZE_ABSOLUTE,
    SIZE_PERCENT
}SizeType;

typedef enum
{
    POSITION_ABSOLUTE,
    POSITION_PERCENT
}PositionType;

typedef void (CCObject::*SEL_TouchEvent)(CCObject*,TouchEventType);





class Widget : public CCNode
{
public:



    Widget(void);




    virtual ~Widget();




    static Widget* create();
# 108 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void setEnabled(bool enabled);






    bool isEnabled() const;
# 124 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setBright(bool bright);






    bool isBright() const;
# 140 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void setTouchEnabled(bool enabled);
# 149 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setBrightStyle(BrightStyle style);






    bool isTouchEnabled() const;






    bool isFocused() const;
# 172 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setFocused(bool fucosed);






    float getLeftInParent();






    float getBottomInParent();






    float getRightInParent();






    float getTopInParent();
# 209 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void addChild(CCNode * child);
# 218 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void addChild(CCNode * child, int zOrder);
# 228 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);







    virtual CCNode * getChildByTag(int tag);

    virtual void sortAllChildren();
# 255 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual CCArray* getChildren();






    virtual unsigned int getChildrenCount() const;






    virtual void removeFromParent();







    virtual void removeFromParentAndCleanup(bool cleanup);

    virtual void removeChild(CCNode* child);







    virtual void removeChild(CCNode* child, bool cleanup);







    virtual void removeChildByTag(int tag, bool cleanup);





    virtual void removeAllChildren();







    virtual void removeAllChildrenWithCleanup(bool cleanup);
# 318 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual Widget* getChildByName(const char* name);

    virtual void addNode(CCNode* node);

    virtual void addNode(CCNode * node, int zOrder);

    virtual void addNode(CCNode* node, int zOrder, int tag);

    virtual CCNode * getNodeByTag(int tag);

    virtual CCArray* getNodes();

    virtual void removeNode(CCNode* node);

    virtual void removeNodeByTag(int tag);

    virtual void removeAllNodes();

    virtual void visit();




    void addTouchEventListener(CCObject* target,SEL_TouchEvent selector);
# 354 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setPosition(const CCPoint &pos);
# 364 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setPositionPercent(const CCPoint &percent);
# 373 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    const CCPoint& getPositionPercent();
# 382 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setPositionType(PositionType type);
# 391 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    PositionType getPositionType() const;






    virtual void setFlipX(bool flipX);
# 410 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual bool isFlipX(){return _flippedX;};






    virtual void setFlipY(bool flipY);
# 429 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual bool isFlipY(){return _flippedY;};

    virtual void setColor(const ccColor3B& color);

    virtual void setOpacity(GLubyte opacity);

    const ccColor3B& getColor(){return _color;};

    GLubyte getOpacity(){return _opacity;};




    void didNotSelectSelf();
# 451 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    bool clippingParentAreaContainPoint(const CCPoint &pt);




    virtual void checkChildInfo(int handleState,Widget* sender,const CCPoint &touchPoint);






    const CCPoint& getTouchStartPos();






    const CCPoint& getTouchMovePos();






    const CCPoint& getTouchEndPos();






    void setName(const char* name);
# 493 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    const char* getName() const;
# 502 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    WidgetType getWidgetType() const;






    virtual void setSize(const CCSize &size);






    virtual void setSizePercent(const CCPoint &percent);
# 525 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setSizeType(SizeType type);
# 534 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    SizeType getSizeType() const;






    const CCSize& getSize() const;

    virtual const CCSize& getLayoutSize() {return _size;};






    const CCPoint& getSizePercent() const;

    const CCSize& getCustomSize() const;
# 561 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual bool hitTest(const CCPoint &pt);

    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unused_event);
# 577 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    void setLayoutParameter(LayoutParameter* parameter);
# 588 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    LayoutParameter* getLayoutParameter(LayoutParameterType type);






    virtual void ignoreContentAdaptWithSize(bool ignore);






    bool isIgnoreContentAdaptWithSize() const;






    CCPoint getWorldPosition();
# 618 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../BaseClasses/UIWidget.h"
    virtual CCNode* getVirtualRenderer();






    virtual const CCSize& getContentSize() const;




    virtual std::string getDescription() const;

    Widget* clone();

    virtual void onEnter();
    virtual void onExit();

    void updateSizeAndPosition();

    void updateSizeAndPosition(const CCSize& parentSize);


    void setActionTag(int tag);
 int getActionTag();
protected:

    virtual void onSizeChanged();


    virtual bool init();


    virtual void initRenderer(){};


    virtual void onPressStateChangedToNormal();


    virtual void onPressStateChangedToPressed();


    virtual void onPressStateChangedToDisabled();
    void pushDownEvent();
    void moveEvent();
    void releaseUpEvent();
    void cancelUpEvent();
    void updateAnchorPoint();
    virtual void updateTextureColor(){};
    virtual void updateTextureOpacity(){};
    virtual void updateTextureRGBA(){};
    virtual void updateFlippedX(){};
    virtual void updateFlippedY(){};
    void updateColorToRenderer(CCNode* renderer);
    void updateOpacityToRenderer(CCNode* renderer);
    void updateRGBAToRenderer(CCNode* renderer);
    void copyProperties(Widget* model);
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    Widget* getWidgetParent();
protected:
    bool _enabled;
    bool _bright;
    bool _touchEnabled;
    bool _touchPassedEnabled;
    bool _focus;
    BrightStyle _brightStyle;
    CCPoint _touchStartPos;
    CCPoint _touchMovePos;
    CCPoint _touchEndPos;

    CCObject* _touchEventListener;
    SEL_TouchEvent _touchEventSelector;



    std::string _name;
    WidgetType _widgetType;
 int _actionTag;
    CCSize _size;
    CCSize _customSize;
    bool _ignoreSize;
    bool _affectByClipping;
    SizeType _sizeType;
    CCPoint _sizePercent;
    PositionType _positionType;
    CCPoint _positionPercent;
    bool _reorderWidgetChildDirty;
    bool _hitted;
    CCArray* _widgetChildren;
    CCDictionary* _layoutParameterDictionary;

    CCArray* _nodes;

    ccColor3B _color;
    GLubyte _opacity;

    bool _flippedX;
    bool _flippedY;

    friend class TouchGroup;
};
}

namespace gui = ui;

}
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    LAYOUT_COLOR_NONE,
    LAYOUT_COLOR_SOLID,
    LAYOUT_COLOR_GRADIENT
}LayoutBackGroundColorType;

typedef enum
{
    LAYOUT_ABSOLUTE,
    LAYOUT_LINEAR_VERTICAL,
    LAYOUT_LINEAR_HORIZONTAL,
    LAYOUT_RELATIVE
}LayoutType;

typedef enum {
    LAYOUT_CLIPPING_STENCIL,
    LAYOUT_CLIPPING_SCISSOR
}LayoutClippingType;





class Layout : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Layout();




    virtual ~Layout();




    static Layout* create();
# 87 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    void setBackGroundImage(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);







    void setBackGroundImageCapInsets(const CCRect& capInsets);

    const CCRect& getBackGroundImageCapInsets();






    void setBackGroundColorType(LayoutBackGroundColorType type);

    LayoutBackGroundColorType getBackGroundColorType();






    void setBackGroundImageScale9Enabled(bool enabled);

    bool isBackGroundImageScale9Enabled();






    void setBackGroundColor(const ccColor3B &color);

    const ccColor3B& getBackGroundColor();
# 133 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    void setBackGroundColor(const ccColor3B &startColor, const ccColor3B &endColor);

    const ccColor3B& getBackGroundStartColor();

    const ccColor3B& getBackGroundEndColor();






    void setBackGroundColorOpacity(GLubyte opacity);

    GLubyte getBackGroundColorOpacity();






    void setBackGroundColorVector(const CCPoint &vector);

    const CCPoint& getBackGroundColorVector();

    void setBackGroundImageColor(const ccColor3B& color);

    void setBackGroundImageOpacity(GLubyte opacity);

    const ccColor3B& getBackGroundImageColor();

    GLubyte getBackGroundImageOpacity();




    void removeBackGroundImage();






    const CCSize& getBackGroundImageTextureSize() const;
# 184 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void setClippingEnabled(bool enabled);

    void setClippingType(LayoutClippingType type);

    LayoutClippingType getClippingType();






    virtual bool isClippingEnabled();




    virtual std::string getDescription() const;
# 209 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void setLayoutType(LayoutType type);
# 218 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual LayoutType getLayoutType() const;

    virtual void addChild(CCNode * child);
# 229 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void addChild(CCNode * child, int zOrder);
# 239 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../Layouts/UILayout.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);

    virtual void removeChild(CCNode* child);

    virtual void removeChild(CCNode* widget, bool cleanup);

    virtual void removeAllChildren();

    virtual void removeAllChildrenWithCleanup(bool cleanup);

    virtual void visit();

    virtual void sortAllChildren();

    void requestDoLayout();

    virtual void onEnter();
    virtual void onExit();

    virtual bool hitTest(const CCPoint &pt);
protected:

    virtual bool init();


    virtual void onSizeChanged();


    void addBackGroundImage();

    void supplyTheLayoutParameterLackToChild(Widget* child);
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);

    void stencilClippingVisit();
    void scissorClippingVisit();

    void setStencilClippingSize(const CCSize& size);
    const CCRect& getClippingRect();
    virtual void doLayout();
    void updateBackGroundImageColor();
    void updateBackGroundImageOpacity();
    void updateBackGroundImageRGBA();
protected:
    bool _clippingEnabled;


    bool _backGroundScale9Enabled;
    CCNode* _backGroundImage;
    std::string _backGroundImageFileName;
    CCRect _backGroundImageCapInsets;
    LayoutBackGroundColorType _colorType;
    TextureResType _bgImageTexType;
    CCLayerColor* _colorRender;
    CCLayerGradient* _gradientRender;
    ccColor3B _cColor;
    ccColor3B _gStartColor;
    ccColor3B _gEndColor;
    CCPoint _alongVector;
    GLubyte _cOpacity;
    CCSize _backGroundImageTextureSize;
    LayoutType _layoutType;
    LayoutClippingType _clippingType;
    CCDrawNode* _clippingStencil;
    bool _handleScissor;
    bool _scissorRectDirty;
    CCRect _clippingRect;
    Layout* _clippingParent;
    bool _doLayoutDirty;
    bool _clippingRectDirty;
    ccColor3B _backGroundImageColor;
    GLubyte _backGroundImageOpacity;
};

}
}
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
namespace cocos2d {

namespace ui{





class Button : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Button();




    virtual ~Button();




    static Button* create();
# 69 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTextures(const char* normal,const char* selected,const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 78 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTextureNormal(const char* normal, TextureResType texType = UI_TEX_TYPE_LOCAL);
# 87 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTexturePressed(const char* selected, TextureResType texType = UI_TEX_TYPE_LOCAL);
# 96 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIButton.h"
    void loadTextureDisabled(const char* disabled, TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setCapInsets(const CCRect &capInsets);






    void setCapInsetsNormalRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetNormalRenderer();






    void setCapInsetsPressedRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetPressedRenderer();






    void setCapInsetsDisabledRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetDisabledRenderer();


    virtual void setAnchorPoint(const CCPoint &pt);






    virtual void setScale9Enabled(bool able);

    bool isScale9Enabled();






    void setPressedActionEnabled(bool enabled);


    virtual void ignoreContentAdaptWithSize(bool ignore);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

    void setTitleText(const std::string& text);
    const char* getTitleText() const;
    void setTitleColor(const ccColor3B& color);
    const ccColor3B& getTitleColor() const;
    void setTitleFontSize(float size);
    float getTitleFontSize() const;
    void setTitleFontName(const char* fontName);
    const char* getTitleFontName() const;

protected:
    virtual bool init();
    virtual void initRenderer();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void normalTextureScaleChangedWithSize();
    void pressedTextureScaleChangedWithSize();
    void disabledTextureScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    CCNode* _buttonNormalRenderer;
    CCNode* _buttonClickedRenderer;
    CCNode* _buttonDisableRenderer;
    CCLabelTTF* _titleRenderer;
    std::string _normalFileName;
    std::string _clickedFileName;
    std::string _disabledFileName;
    bool _prevIgnoreSize;
    bool _scale9Enabled;
    CCRect _capInsetsNormal;
    CCRect _capInsetsPressed;
    CCRect _capInsetsDisabled;
    TextureResType _normalTexType;
    TextureResType _pressedTexType;
    TextureResType _disabledTexType;
    CCSize _normalTextureSize;
    CCSize _pressedTextureSize;
    CCSize _disabledTextureSize;
    bool _pressedActionEnabled;
    ccColor3B _titleColor;
    float _normalTextureScaleXInSize;
    float _normalTextureScaleYInSize;
    float _pressedTextureScaleXInSize;
    float _pressedTextureScaleYInSize;
    bool _normalTextureLoaded;
    bool _pressedTextureLoaded;
    bool _disabledTextureLoaded;
};

}

}
# 32 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    CHECKBOX_STATE_EVENT_SELECTED,
    CHECKBOX_STATE_EVENT_UNSELECTED
}CheckBoxEventType;

typedef void (CCObject::*SEL_SelectedStateEvent)(CCObject*,CheckBoxEventType);






class CheckBox : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    CheckBox();




    virtual ~CheckBox();




    static CheckBox* create();
# 80 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextures(const char* backGround,const char* backGroundSelected,const char* cross,const char* backGroundDisabled,const char* frontCrossDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 89 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureBackGround(const char* backGround,TextureResType type = UI_TEX_TYPE_LOCAL);
# 98 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureBackGroundSelected(const char* backGroundSelected,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 107 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureFrontCross(const char* cross,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 116 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureBackGroundDisabled(const char* backGroundDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 125 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UICheckBox.h"
    void loadTextureFrontCrossDisabled(const char* frontCrossDisabled,TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setSelectedState(bool selected);






    bool getSelectedState();


    virtual void setAnchorPoint(const CCPoint &pt);


    void addEventListenerCheckBox(CCObject* target,SEL_SelectedStateEvent selector);


    virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

protected:
    virtual bool init();
    virtual void initRenderer();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    void selectedEvent();
    void unSelectedEvent();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void backGroundTextureScaleChangedWithSize();
    void backGroundSelectedTextureScaleChangedWithSize();
    void frontCrossTextureScaleChangedWithSize();
    void backGroundDisabledTextureScaleChangedWithSize();
    void frontCrossDisabledTextureScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    CCSprite* _backGroundBoxRenderer;
    CCSprite* _backGroundSelectedBoxRenderer;
    CCSprite* _frontCrossRenderer;
    CCSprite* _backGroundBoxDisabledRenderer;
    CCSprite* _frontCrossDisabledRenderer;
    bool _isSelected;

    CCObject* _checkBoxEventListener;
    SEL_SelectedStateEvent _checkBoxEventSelector;

    TextureResType _backGroundTexType;
    TextureResType _backGroundSelectedTexType;
    TextureResType _frontCrossTexType;
    TextureResType _backGroundDisabledTexType;
    TextureResType _frontCrossDisabledTexType;

    std::string _backGroundFileName;
    std::string _backGroundSelectedFileName;
    std::string _frontCrossFileName;
    std::string _backGroundDisabledFileName;
    std::string _frontCrossDisabledFileName;
};

}

}
# 33 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIImageView.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIImageView.h"
namespace cocos2d {

namespace ui {





class ImageView : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    ImageView();




    virtual ~ImageView();




    static ImageView* create();
# 65 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIImageView.h"
    void loadTexture(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);





    void setTextureRect(const CCRect& rect);






    void setScale9Enabled(bool able);

    bool isScale9Enabled();






    void setCapInsets(const CCRect &capInsets);

    const CCRect& getCapInsets();


    virtual void setAnchorPoint(const CCPoint &pt);


    virtual void ignoreContentAdaptWithSize(bool ignore);




    virtual std::string getDescription() const;

    virtual const CCSize& getContentSize() const;
    virtual CCNode* getVirtualRenderer();
protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void imageTextureScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    bool _scale9Enabled;
    bool _prevIgnoreSize;
    CCRect _capInsets;
    CCNode* _imageRenderer;
    std::string _textureFile;
    TextureResType _imageTexType;
    CCSize _imageTextureSize;
};

}

}
# 34 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabel.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabel.h"
namespace cocos2d {

namespace ui {





class Label : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Label();




    virtual ~Label();




    static Label* create();






    void setText(const std::string& text);






    const char* getStringValue();






    int getStringLength();






    void setFontSize(int size);

    int getFontSize();






    void setFontName(const std::string& name);

    const char* getFontName();





    void setTouchScaleChangeEnabled(bool enabled);






    bool isTouchScaleChangeEnabled();


    virtual void setAnchorPoint(const CCPoint &pt);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

    void setTextAreaSize(const CCSize &size);

    CCSize getTextAreaSize();

    void setTextHorizontalAlignment(CCTextAlignment alignment);

    CCTextAlignment getTextHorizontalAlignment();

    void setTextVerticalAlignment(CCVerticalTextAlignment alignment);

    CCVerticalTextAlignment getTextVerticalAlignment();
protected:
    virtual bool init();
    virtual void initRenderer();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    virtual void updateFlippedX();
    virtual void updateFlippedY();
    void labelScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    bool _touchScaleChangeEnabled;
    float _normalScaleValueX;
    float _normalScaleValueY;
    std::string _fontName;
    int _fontSize;
    float _onSelectedScaleOffset;
    CCLabelTTF* _labelRenderer;
};

}

}
# 35 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelAtlas.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelAtlas.h"
namespace cocos2d {

namespace ui {





class UICCLabelAtlas : public CCLabelAtlas
{
public:



    UICCLabelAtlas();




    virtual ~UICCLabelAtlas();




    static UICCLabelAtlas* create();
    void setProperty(const std::string& string, const std::string& charMapFile, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
    void setProperty(const std::string& string, CCTexture2D *texture, unsigned int itemWidth, unsigned int itemHeight, unsigned int startCharMap);
    virtual void updateDisplayedOpacity(GLubyte opacity);
    virtual void draw(void);
};




class LabelAtlas : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    LabelAtlas();




    virtual ~LabelAtlas();




    static LabelAtlas* create();


    void setProperty(const std::string& stringValue,const std::string& charMapFile, int itemWidth, int itemHeight, const std::string& startCharMap);


    void setStringValue(const std::string& value);


    const char* getStringValue() const;


    virtual void setAnchorPoint(const CCPoint &pt);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;

protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void labelAtlasScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    UICCLabelAtlas* _labelAtlasRenderer;
    std::string _stringValue;
    std::string _charMapFileName;
    int _itemWidth;
    int _itemHeight;
    std::string _startCharMap;
};

}
}
# 36 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    LoadingBarTypeLeft,
    LoadingBarTypeRight
}LoadingBarType;




class LoadingBar : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    LoadingBar();




    virtual ~LoadingBar();




    static LoadingBar* create();
# 71 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
    void setDirection(LoadingBarType dir);
# 80 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
    int getDirection();
# 89 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILoadingBar.h"
    void loadTexture(const char* texture,TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setPercent(int percent);






    int getPercent();






    void setScale9Enabled(bool enabled);

    bool isScale9Enabled();






    void setCapInsets(const CCRect &capInsets);

    const CCRect& getCapInsets();


    virtual void ignoreContentAdaptWithSize(bool ignore);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();




    virtual std::string getDescription() const;
protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void setScale9Scale();
    void barRendererScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    LoadingBarType _barType;
    int _percent;
    float _totalLength;
    CCNode* _barRenderer;
    TextureResType _renderBarTexType;
    CCSize _barRendererTextureSize;
    bool _scale9Enabled;
    bool _prevIgnoreSize;
    CCRect _capInsets;
    std::string _textureFile;
};

}
}
# 37 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollInterface.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollInterface.h"
namespace cocos2d {

namespace ui {

class UIScrollInterface
{
public:
    virtual ~UIScrollInterface() {}

protected:
    virtual void handlePressLogic(const CCPoint &touchPoint) = 0;
    virtual void handleMoveLogic(const CCPoint &touchPoint) = 0;
    virtual void handleReleaseLogic(const CCPoint &touchPoint) = 0;
    virtual void interceptTouchEvent(int handleState, Widget* sender, const CCPoint &touchPoint) = 0;
};

}
}
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h" 2

namespace cocos2d {

namespace ui {

class ScrollInnerContainer : public Layout
{
public:
    ScrollInnerContainer();
    virtual ~ScrollInnerContainer();
    static ScrollInnerContainer* create();
    virtual const CCSize& getLayoutSize();
protected:
};

enum SCROLLVIEW_DIR
{
    SCROLLVIEW_DIR_NONE,
    SCROLLVIEW_DIR_VERTICAL,
    SCROLLVIEW_DIR_HORIZONTAL,
    SCROLLVIEW_DIR_BOTH
};

typedef enum
{
    SCROLLVIEW_EVENT_SCROLL_TO_TOP,
    SCROLLVIEW_EVENT_SCROLL_TO_BOTTOM,
    SCROLLVIEW_EVENT_SCROLL_TO_LEFT,
    SCROLLVIEW_EVENT_SCROLL_TO_RIGHT,
    SCROLLVIEW_EVENT_SCROLLING,
    SCROLLVIEW_EVENT_BOUNCE_TOP,
    SCROLLVIEW_EVENT_BOUNCE_BOTTOM,
    SCROLLVIEW_EVENT_BOUNCE_LEFT,
    SCROLLVIEW_EVENT_BOUNCE_RIGHT
}ScrollviewEventType;

typedef void (CCObject::*SEL_ScrollViewEvent)(CCObject*, ScrollviewEventType);



class ScrollView : public Layout , public UIScrollInterface
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    ScrollView();




    virtual ~ScrollView();




    static ScrollView* create();
# 98 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void setDirection(SCROLLVIEW_DIR dir);
# 107 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    SCROLLVIEW_DIR getDirection();
# 116 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    Layout* getInnerContainer();




    void scrollToBottom(float time, bool attenuated);




    void scrollToTop(float time, bool attenuated);




    void scrollToLeft(float time, bool attenuated);




    void scrollToRight(float time, bool attenuated);




    void scrollToTopLeft(float time, bool attenuated);




    void scrollToTopRight(float time, bool attenuated);




    void scrollToBottomLeft(float time, bool attenuated);




    void scrollToBottomRight(float time, bool attenuated);




    void scrollToPercentVertical(float percent, float time, bool attenuated);




    void scrollToPercentHorizontal(float percent, float time, bool attenuated);




    void scrollToPercentBothDirection(const CCPoint& percent, float time, bool attenuated);




    void jumpToBottom();




    void jumpToTop();




    void jumpToLeft();




    void jumpToRight();




    void jumpToTopLeft();




    void jumpToTopRight();




    void jumpToBottomLeft();




    void jumpToBottomRight();




    void jumpToPercentVertical(float percent);




    void jumpToPercentHorizontal(float percent);




    void jumpToPercentBothDirection(const CCPoint& percent);
# 235 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    void setInnerContainerSize(const CCSize &size);
# 244 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
 const CCSize& getInnerContainerSize() const;




    void addEventListenerScrollView(CCObject* target, SEL_ScrollViewEvent selector);

    virtual void addChild(CCNode * child);
# 260 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void addChild(CCNode * child, int zOrder);
# 270 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void addChild(CCNode* child, int zOrder, int tag);


    virtual void removeAllChildren();

    virtual void removeAllChildrenWithCleanup(bool cleanup);

    virtual void removeChild(CCNode* child);


 virtual void removeChild(CCNode* child, bool cleaup);


    virtual CCArray* getChildren();

    virtual unsigned int getChildrenCount() const;

    virtual CCNode * getChildByTag(int tag);

    virtual Widget* getChildByName(const char* name);

    virtual void addNode(CCNode* node);

    virtual void addNode(CCNode * node, int zOrder);

    virtual void addNode(CCNode* node, int zOrder, int tag);

    virtual CCNode * getNodeByTag(int tag);

    virtual void removeNodeByTag(int tag);

    virtual CCArray* getNodes();

    virtual void removeNode(CCNode* node);

    virtual void removeAllNodes();


    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unusedEvent);

    virtual void update(float dt);

    void setBounceEnabled(bool enabled);

    bool isBounceEnabled() const;

    void setInertiaScrollEnabled(bool enabled);

    bool isInertiaScrollEnabled() const;
# 330 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual void setLayoutType(LayoutType type);
# 339 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIScrollView.h"
    virtual LayoutType getLayoutType() const;




    virtual std::string getDescription() const;

    virtual void onEnter();
protected:
    virtual bool init();
    virtual void initRenderer();
    void moveChildren(float offsetX, float offsetY);
    void autoScrollChildren(float dt);
    void bounceChildren(float dt);
    void checkBounceBoundary();
    bool checkNeedBounce();
    void startAutoScrollChildrenWithOriginalSpeed(const CCPoint& dir, float v, bool attenuated, float acceleration);
    void startAutoScrollChildrenWithDestination(const CCPoint& des, float time, bool attenuated);
    void jumpToDestination(const CCPoint& des);
    void stopAutoScrollChildren();
    void startBounceChildren(float v);
    void stopBounceChildren();
    bool checkCustomScrollDestination(float* touchOffsetX, float* touchOffsetY);
    virtual bool scrollChildren(float touchOffsetX, float touchOffsetY);
    bool bounceScrollChildren(float touchOffsetX, float touchOffsetY);
    void startRecordSlidAction();
    virtual void endRecordSlidAction();
    virtual void handlePressLogic(const CCPoint &touchPoint);
    virtual void handleMoveLogic(const CCPoint &touchPoint);
    virtual void handleReleaseLogic(const CCPoint &touchPoint);
    virtual void interceptTouchEvent(int handleState,Widget* sender,const CCPoint &touchPoint);
    virtual void checkChildInfo(int handleState,Widget* sender,const CCPoint &touchPoint);
    void recordSlidTime(float dt);
    void scrollToTopEvent();
    void scrollToBottomEvent();
    void scrollToLeftEvent();
    void scrollToRightEvent();
    void scrollingEvent();
    void bounceTopEvent();
    void bounceBottomEvent();
    void bounceLeftEvent();
    void bounceRightEvent();
    virtual void onSizeChanged();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    virtual void setClippingEnabled(bool able) {Layout::setClippingEnabled(able);};
    virtual void doLayout();
protected:
    ScrollInnerContainer* _innerContainer;

    SCROLLVIEW_DIR _direction;

    CCPoint _touchBeganPoint;
    CCPoint _touchMovedPoint;
    CCPoint _touchEndedPoint;
    CCPoint _touchMovingPoint;
    CCPoint _autoScrollDir;

    float _topBoundary;
    float _bottomBoundary;
    float _leftBoundary;
    float _rightBoundary;

    float _bounceTopBoundary;
    float _bounceBottomBoundary;
    float _bounceLeftBoundary;
    float _bounceRightBoundary;


    bool _autoScroll;
    float _autoScrollAddUpTime;

    float _autoScrollOriginalSpeed;
    float _autoScrollAcceleration;
    bool _isAutoScrollSpeedAttenuated;
    bool _needCheckAutoScrollDestination;
    CCPoint _autoScrollDestination;

    bool _bePressed;
    float _slidTime;
    CCPoint _moveChildPoint;
    float _childFocusCancelOffset;

    bool _leftBounceNeeded;
    bool _topBounceNeeded;
    bool _rightBounceNeeded;
    bool _bottomBounceNeeded;

    bool _bounceEnabled;
    bool _bouncing;
    CCPoint _bounceDir;
    float _bounceOriginalSpeed;
    bool _inertiaScrollEnabled;



    CCObject* _scrollViewEventListener;
    SEL_ScrollViewEvent _scrollViewEventSelector;
};

}
}
# 38 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    SLIDER_PERCENTCHANGED
}SliderEventType;

typedef void (CCObject::*SEL_SlidPercentChangedEvent)(CCObject*,SliderEventType);






class Slider : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    Slider();




    virtual ~Slider();




    static Slider* create();
# 74 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadBarTexture(const char* fileName,TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setScale9Enabled(bool able);

    bool isScale9Enabled();






    void setCapInsets(const CCRect &capInsets);






    void setCapInsetsBarRenderer(const CCRect &capInsets);

    const CCRect& getCapInsetBarRenderer();






    void setCapInsetProgressBarRebderer(const CCRect &capInsets);

    const CCRect& getCapInsetProgressBarRebderer();
# 121 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTextures(const char* normal,const char* pressed,const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 130 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTextureNormal(const char* normal,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 139 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTexturePressed(const char* pressed,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 148 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadSlidBallTextureDisabled(const char* disabled,TextureResType texType = UI_TEX_TYPE_LOCAL);
# 157 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UISlider.h"
    void loadProgressBarTexture(const char* fileName, TextureResType texType = UI_TEX_TYPE_LOCAL);






    void setPercent(int percent);






    int getPercent();




    void addEventListenerSlider(CCObject* target,SEL_SlidPercentChangedEvent selector);

    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unused_event);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unused_event);


    virtual const CCSize& getContentSize() const;


    virtual CCNode* getVirtualRenderer();


    virtual void ignoreContentAdaptWithSize(bool ignore);




    virtual std::string getDescription() const;

protected:
    virtual bool init();
    virtual void initRenderer();
    float getPercentWithBallPos(float location);
    void percentChangedEvent();
    virtual void onPressStateChangedToNormal();
    virtual void onPressStateChangedToPressed();
    virtual void onPressStateChangedToDisabled();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void barRendererScaleChangedWithSize();
    void progressBarRendererScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    CCNode* _barRenderer;
    CCNode* _progressBarRenderer;
    CCSize _progressBarTextureSize;

    CCSprite* _slidBallNormalRenderer;
    CCSprite* _slidBallPressedRenderer;
    CCSprite* _slidBallDisabledRenderer;
    CCNode* _slidBallRenderer;

    float _barLength;
    int _percent;

    bool _scale9Enabled;
    bool _prevIgnoreSize;
    std::string _textureFile;
    std::string _progressBarTextureFile;
    std::string _slidBallNormalTextureFile;
    std::string _slidBallPressedTextureFile;
    std::string _slidBallDisabledTextureFile;

    CCRect _capInsetsBarRenderer;
    CCRect _capInsetsProgressBarRenderer;

    CCObject* _sliderEventListener;
    SEL_SlidPercentChangedEvent _sliderEventSelector;
    TextureResType _barTexType;
    TextureResType _progressBarTexType;
    TextureResType _ballNTexType;
    TextureResType _ballPTexType;
    TextureResType _ballDTexType;
};

}
}
# 39 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UITextField.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UITextField.h"
namespace cocos2d {

namespace ui {





class UICCTextField: public CCTextFieldTTF, public CCTextFieldDelegate
{
public:
    UICCTextField();
    ~UICCTextField();

    virtual void onEnter();


    static UICCTextField* create(const char *placeholder, const char *fontName, float fontSize);


    virtual bool onTextFieldAttachWithIME(CCTextFieldTTF *pSender);
    virtual bool onTextFieldDetachWithIME(CCTextFieldTTF * pSender);
    virtual bool onTextFieldInsertText(CCTextFieldTTF * pSender, const char * text, int nLen);
    virtual bool onTextFieldDeleteBackward(CCTextFieldTTF * pSender, const char * delText, int nLen);

    void insertText(const char* text, int len);
    void deleteBackward();

    void openIME();
    void closeIME();

    void setMaxLengthEnabled(bool enable);
    bool isMaxLengthEnabled();
    void setMaxLength(int length);
    int getMaxLength();
    int getCharCount();
    void setPasswordEnabled(bool enable);
    bool isPasswordEnabled();
    void setPasswordStyleText(const char* styleText);
    void setPasswordText(const char* text);
    void setAttachWithIME(bool attach);
    bool getAttachWithIME();
    void setDetachWithIME(bool detach);
    bool getDetachWithIME();
    void setInsertText(bool insert);
    bool getInsertText();
    void setDeleteBackward(bool deleteBackward);
    bool getDeleteBackward();
protected:
    bool _maxLengthEnabled;
    int _maxLength;
    bool _passwordEnabled;
    std::string _passwordStyleText;
    bool _attachWithIME;
    bool _detachWithIME;
    bool _insertText;
    bool _deleteBackward;
};

typedef enum
{
    TEXTFIELD_EVENT_ATTACH_WITH_IME,
    TEXTFIELD_EVENT_DETACH_WITH_IME,
    TEXTFIELD_EVENT_INSERT_TEXT,
    TEXTFIELD_EVENT_DELETE_BACKWARD,
}TextFiledEventType;

typedef void (CCObject::*SEL_TextFieldEvent)(CCObject*, TextFiledEventType);






class TextField : public Widget
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:
    TextField();
    virtual ~TextField();
    static TextField* create();
    void setTouchSize(const CCSize &size);
    CCSize getTouchSize();
    void setTouchAreaEnabled(bool enable);
    virtual bool hitTest(const CCPoint &pt);
    void setText(const std::string& text);
    void setPlaceHolder(const std::string& value);
    const char* getPlaceHolder();
    void setFontSize(int size);
    int getFontSize();
    void setFontName(const std::string& name);
    const char* getFontName();
    virtual void didNotSelectSelf();
    const char* getStringValue();
    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unused_event);
    void setMaxLengthEnabled(bool enable);
    bool isMaxLengthEnabled();
    void setMaxLength(int length);
    int getMaxLength();
    void setPasswordEnabled(bool enable);
    bool isPasswordEnabled();
    void setPasswordStyleText(const char* styleText);
    const char* getPasswordStyleText();
    virtual void update(float dt);
    bool getAttachWithIME();
    void setAttachWithIME(bool attach);
    bool getDetachWithIME();
    void setDetachWithIME(bool detach);
    bool getInsertText();
    void setInsertText(bool insertText);
    bool getDeleteBackward();
    void setDeleteBackward(bool deleteBackward);
    void addEventListenerTextField(CCObject* target, SEL_TextFieldEvent selecor);

    virtual void setAnchorPoint(const CCPoint &pt);




    virtual std::string getDescription() const;

    virtual const CCSize& getContentSize() const;
    virtual CCNode* getVirtualRenderer();
    void attachWithIME();
    virtual void onEnter();

    void setTextAreaSize(const CCSize &size);
    void setTextHorizontalAlignment(CCTextAlignment alignment);
    void setTextVerticalAlignment(CCVerticalTextAlignment alignment);


protected:
    virtual bool init();
    virtual void initRenderer();

    void attachWithIMEEvent();
    void detachWithIMEEvent();
    void insertTextEvent();
    void deleteBackwardEvent();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void textfieldRendererScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    UICCTextField* _textFieldRenderer;

    float _touchWidth;
    float _touchHeight;
    bool _useTouchArea;

    CCObject* _textFieldEventListener;
    SEL_TextFieldEvent _textFieldEventSelector;

    std::string _passwordStyleText;
};

}

}
# 40 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
namespace cocos2d {

namespace ui{

typedef enum
{
    LISTVIEW_GRAVITY_LEFT,
    LISTVIEW_GRAVITY_RIGHT,
    LISTVIEW_GRAVITY_CENTER_HORIZONTAL,

    LISTVIEW_GRAVITY_TOP,
    LISTVIEW_GRAVITY_BOTTOM,
    LISTVIEW_GRAVITY_CENTER_VERTICAL,
}ListViewGravity;

typedef enum
{
    LISTVIEW_ONSELECTEDITEM_START,
    LISTVIEW_ONSELECTEDITEM_END
}ListViewEventType;

typedef void (CCObject::*SEL_ListViewEvent)(CCObject*,ListViewEventType);


class ListView : public ScrollView
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:




    ListView();




    virtual ~ListView();




    static ListView* create();
# 84 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    void setItemModel(Widget* model);




    void pushBackDefaultItem();




    void insertDefaultItem(int index);




    void pushBackCustomItem(Widget* item);




    void insertCustomItem(Widget* item, int index);




    void removeLastItem();






    void removeItem(int index);

    void removeAllItems();
# 127 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    Widget* getItem(unsigned int index);




    CCArray* getItems();
# 141 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    unsigned int getIndex(Widget* item) const;





    void setGravity(ListViewGravity gravity);






    void setItemsMargin(float margin);

    float getItemsMargin();

    virtual void sortAllChildren();

    int getCurSelectedIndex() const;

    void addEventListenerListView(CCObject* target, SEL_ListViewEvent selector);
# 171 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIListView.h"
    virtual void setDirection(SCROLLVIEW_DIR dir);

    virtual std::string getDescription() const;

    void requestRefreshView();

    void refreshView();
protected:
    virtual void addChild(CCNode* child) {ScrollView::addChild(child);};
    virtual void addChild(CCNode * child, int zOrder) {ScrollView::addChild(child, zOrder);};
    virtual void addChild(CCNode* child, int zOrder, int tag) {ScrollView::addChild(child, zOrder, tag);};
    virtual void removeChild(CCNode* widget) {ScrollView::removeChild(widget);};
    virtual void removeChild(CCNode* widget, bool cleanup) {ScrollView::removeChild(widget, cleanup);};

    virtual void removeAllChildren() {ScrollView::removeAllChildren();};
    virtual void removeAllChildrenWithCleanup(bool cleanup) {ScrollView::removeAllChildrenWithCleanup(cleanup);};
    virtual CCArray* getChildren() {return ScrollView::getChildren();};
    virtual unsigned int getChildrenCount() const {return ScrollView::getChildrenCount();};
    virtual CCNode * getChildByTag(int tag) {return ScrollView::getChildByTag(tag);};
    virtual Widget* getChildByName(const char* name) {return ScrollView::getChildByName(name);};
    virtual bool init();
    void updateInnerContainerSize();
    void remedyLayoutParameter(Widget* item);
    virtual void onSizeChanged();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    void selectedItemEvent(int state);
    virtual void interceptTouchEvent(int handleState,Widget* sender,const CCPoint &touchPoint);
protected:

    Widget* _model;
    ListViewGravity _gravity;
    float _itemsMargin;
    CCObject* _listViewEventListener;
    SEL_ListViewEvent _listViewEventSelector;
    int _curSelectedIndex;
    bool _refreshViewDirty;
    CCArray* _items;
};

}
}
# 41 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelBMFont.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UILabelBMFont.h"
namespace cocos2d {

namespace ui {





class LabelBMFont : public Widget
{
    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    LabelBMFont();




    virtual ~LabelBMFont();




    static LabelBMFont* create();


    void setFntFile(const char* fileName);


    void setText(const char* value);


    const char* getStringValue();
    virtual void setAnchorPoint(const CCPoint &pt);
    virtual const CCSize& getContentSize() const;
    virtual CCNode* getVirtualRenderer();



    virtual std::string getDescription() const;
protected:
    virtual void initRenderer();
    virtual void onSizeChanged();
    virtual void updateTextureColor();
    virtual void updateTextureOpacity();
    virtual void updateTextureRGBA();
    void labelBMFontScaleChangedWithSize();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
protected:
    cocos2d::CCLabelBMFont* _labelBMFontRenderer;
    bool _fntFileHasInit;
    std::string _fntFileName;
    std::string _stringValue;
};

}
}
# 42 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h"
namespace cocos2d {

namespace ui {

typedef enum
{
    PAGEVIEW_EVENT_TURNING,
}PageViewEventType;

typedef void (CCObject::*SEL_PageViewEvent)(CCObject*, PageViewEventType);


typedef enum {
    PAGEVIEW_TOUCHLEFT,
    PAGEVIEW_TOUCHRIGHT
}PVTouchDir;

class PageView : public Layout , public UIScrollInterface
{

    public: static cocos2d::extension::ObjectFactory::TInfo Type; static cocos2d::CCObject* createInstance(void);

public:



    PageView();




    virtual ~PageView();




    static PageView* create();
# 78 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h"
    void addWidgetToPage(Widget* widget, int pageIdx, bool forceCreate);






    void addPage(Layout* page);






    void insertPage(Layout* page, int idx);






    void removePage(Layout* page);






    void removePageAtIndex(int index);

    void removeAllPages();






    void scrollToPage(int idx);






    int getCurPageIndex() const;

    CCArray* getPages();

    Layout* getPage(int index);


    void addEventListenerPageView(CCObject *target, SEL_PageViewEvent selector);




    virtual bool onTouchBegan(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchMoved(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchEnded(CCTouch *touch, CCEvent *unusedEvent);
    virtual void onTouchCancelled(CCTouch *touch, CCEvent *unusedEvent);


    virtual void update(float dt);







    virtual void setLayoutType(LayoutType type){};
# 157 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/ScrollWidget/UIPageView.h"
    virtual LayoutType getLayoutType() const {return LAYOUT_ABSOLUTE;};




    virtual std::string getDescription() const;

    virtual void onEnter();
protected:
    virtual void addChild(CCNode * child);
    virtual void addChild(CCNode * child, int zOrder);
    virtual void addChild(CCNode* child, int zOrder, int tag);
    virtual void removeChild(CCNode* widget);
    virtual void removeChild(CCNode* widget, bool cleanup);
    virtual void removeAllChildren();
    virtual void removeAllChildrenWithCleanup(bool cleanup);
    virtual CCArray* getChildren(){return Widget::getChildren();};
    virtual unsigned int getChildrenCount() const {return Widget::getChildrenCount();};
    virtual CCNode * getChildByTag(int tag) {return Widget::getChildByTag(tag);};
    virtual Widget* getChildByName(const char* name) {return Widget::getChildByName(name);};
    virtual bool init();
    Layout* createPage();
    float getPositionXByIndex(int idx);
    void updateBoundaryPages();
    virtual void handlePressLogic(const CCPoint &touchPoint);
    virtual void handleMoveLogic(const CCPoint &touchPoint);
    virtual void handleReleaseLogic(const CCPoint &touchPoint);
    virtual void interceptTouchEvent(int handleState, Widget* sender, const CCPoint &touchPoint);
    virtual void checkChildInfo(int handleState, Widget* sender, const CCPoint &touchPoint);
    virtual bool scrollPages(float touchOffset);
    void movePages(float offset);
    void pageTurningEvent();
    void updateChildrenSize();
    void updateChildrenPosition();
    virtual void onSizeChanged();
    virtual Widget* createCloneInstance();
    virtual void copySpecialProperties(Widget* model);
    virtual void copyClonedWidgetChildren(Widget* model);
    virtual void setClippingEnabled(bool enabled) {Layout::setClippingEnabled(enabled);};
    virtual void doLayout() {if (!_doLayoutDirty){return;} _doLayoutDirty = false;};
protected:
    int _curPageIdx;
    CCArray* _pages;
    PVTouchDir _touchMoveDir;
    float _touchStartLocation;
    float _touchMoveStartLocation;
    CCPoint _movePagePoint;
    Widget* _leftChild;
    Widget* _rightChild;
    float _leftBoundary;
    float _rightBoundary;
    bool _isAutoScrolling;
    float _autoScrollDistance;
    float _autoScrollSpeed;
    int _autoScrollDir;
    float _childFocusCancelOffset;
    CCObject* _pageViewEventListener;
    SEL_PageViewEvent _pageViewEventSelector;

};

}
}
# 43 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h" 1
# 28 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
namespace cocos2d {

namespace ui {





class UIHelper
{
public:
# 48 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
    static Widget* seekWidgetByTag(Widget* root, int tag);
# 59 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
    static Widget* seekWidgetByName(Widget* root, const char* name);
# 72 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UIHelper.h"
    static Widget* seekWidgetByRelativeName(Widget* root, const char* name);


    static Widget* seekActionWidgetByActionTag(Widget* root, int tag);
};
}

}
# 44 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h"
# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1
# 31 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/WidgetReader/WidgetReaderProtocol.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/WidgetReader/WidgetReaderProtocol.h"
namespace cocos2d
{
    namespace ui
    {
        class Widget;
    }
}

namespace cocos2d { namespace extension {

class WidgetReaderProtocol
{
public:
    virtual void setPropsFromJsonDictionary(ui::Widget* widget, const rapidjson::Value& options) = 0;
};

}}
# 32 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../../Reader/GUIReader.h" 2


namespace cocos2d { namespace extension {

typedef void (CCObject::*SEL_ParseEvent)(const std::string&, CCObject*, const rapidjson::Value&);







class GUIReader : public CCObject
{
public:



    GUIReader();



    ~GUIReader();



    static GUIReader* shareReader();



 static void purge();

    cocos2d::ui::Widget* widgetFromJsonFile(const char* fileName);
    int getVersionInteger(const char* str);
    void storeFileDesignSize(const char* fileName, const cocos2d::CCSize &size);
    const cocos2d::CCSize getFileDesignSize(const char* fileName) const;

    const std::string& getFilePath() const { return m_strFilePath; };

    void registerTypeAndCallBack(const std::string& classType,
                                 ObjectFactory::Instance ins,
                                 CCObject* object,
                                 SEL_ParseEvent callBack);
protected:
    std::string m_strFilePath;
    CCDictionary* _fileDesignSizes;

    typedef std::map<std::string, SEL_ParseEvent> ParseCallBackMap;
    ParseCallBackMap _mapParseSelector;
    typedef std::map<std::string, CCObject*> ParseObjectMap;
    ParseObjectMap _mapObject;

public:
    ParseCallBackMap getParseCallBackMap() { return _mapParseSelector; };
    ParseObjectMap getParseObjectMap() { return _mapObject; };
};

class WidgetPropertiesReader : public CCObject
{
public:
    virtual cocos2d::ui::Widget* createWidget(const rapidjson::Value& dic, const char* fullPath, const char* fileName)=0;
    virtual cocos2d::ui::Widget* widgetFromJsonDictionary(const rapidjson::Value& data) = 0;
    virtual void setPropsForAllWidgetFromJsonDictionary(WidgetReaderProtocol* reader, cocos2d::ui::Widget* widget, const rapidjson::Value& options) = 0;

    virtual void setPropsForAllCustomWidgetFromJsonDictionary(const std::string& classType,
                                                              cocos2d::ui::Widget* widget,
                                                              const rapidjson::Value& customOptions) = 0;

protected:
    std::string m_strFilePath;
};







class WidgetPropertiesReader0250 : public WidgetPropertiesReader
{


public:
    WidgetPropertiesReader0250(){};
    virtual ~WidgetPropertiesReader0250(){};

    virtual cocos2d::ui::Widget* createWidget(const rapidjson::Value& dic, const char* fullPath, const char* fileName);
    virtual cocos2d::ui::Widget* widgetFromJsonDictionary(const rapidjson::Value& dic);
    virtual void setPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setColorPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForButtonFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForCheckBoxFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForImageViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelAtlasFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelBMFontFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLoadingBarFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForSliderFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForTextFieldFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setPropsForLayoutFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForScrollViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setPropsForAllWidgetFromJsonDictionary(WidgetReaderProtocol* reader, cocos2d::ui::Widget* widget, const rapidjson::Value& options);

    virtual void setPropsForAllCustomWidgetFromJsonDictionary(const std::string& classType,
                                                              cocos2d::ui::Widget* widget,
                                                              const rapidjson::Value& customOptions);
};





class WidgetPropertiesReader0300 : public WidgetPropertiesReader
{


public:
    WidgetPropertiesReader0300(){};
    virtual ~WidgetPropertiesReader0300(){};

    virtual cocos2d::ui::Widget* createWidget(const rapidjson::Value& dic, const char* fullPath, const char* fileName);
    virtual cocos2d::ui::Widget* widgetFromJsonDictionary(const rapidjson::Value& dic);
    virtual void setPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setColorPropsForWidgetFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForButtonFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForCheckBoxFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForImageViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelAtlasFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLabelBMFontFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForLoadingBarFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForSliderFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForTextFieldFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);

    virtual void setPropsForLayoutFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForPageViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForScrollViewFromJsonDictionary(cocos2d::ui::Widget*widget,const rapidjson::Value& options);
    virtual void setPropsForListViewFromJsonDictionary(cocos2d::ui::Widget* widget, const rapidjson::Value& options);

    virtual void setPropsForAllWidgetFromJsonDictionary(WidgetReaderProtocol* reader, cocos2d::ui::Widget* widget, const rapidjson::Value& options);

    virtual void setPropsForAllCustomWidgetFromJsonDictionary(const std::string& classType,
                                                              cocos2d::ui::Widget* widget,
                                                              const rapidjson::Value& customOptions);
};

}}
# 45 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UITouchGroup.h" 1
# 33 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UITouchGroup.h"
namespace cocos2d {

namespace ui {




class TouchGroup : public CCLayer
{

public:




    TouchGroup();





    virtual ~TouchGroup();




    static TouchGroup *create(void);


    virtual bool init();

    virtual void onEnter();
    virtual void onExit();
    virtual void onEnterTransitionDidFinish();

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);






    void addWidget(Widget* widget);
# 87 "Cacao/include/cocos2dext/CocoStudio/GUI/System/UITouchGroup.h"
    void removeWidget(Widget* widget);






    Widget* getWidgetByTag(int tag);






    Widget* getWidgetByName(const char* name);




    virtual void clear();






    Widget* getRootWidget();
protected:
    bool checkEventWidget(CCTouch* touch, CCEvent *pEvent);
    bool checkTouchEvent(Widget* root, CCTouch* touch, CCEvent* pEvent);
protected:
    Widget* m_pRootWidget;
    CCPoint touchBeganedPoint;
    CCPoint touchMovedPoint;
    CCPoint touchEndedPoint;
    CCPoint touchCanceledPoint;
    CCArray* m_pSelectedWidgets;
};

}

}
# 46 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/Compatible/CompatibleClasses.h" 1
# 22 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/Compatible/CompatibleClasses.h"
namespace cocos2d {

namespace ui {

typedef cocos2d::ui::Layout UIPanel;
typedef cocos2d::ui::Layout UILayout;
typedef cocos2d::ui::Widget UIWidget;

typedef cocos2d::ui::LayoutParameter UILayoutParameter;
typedef cocos2d::ui::Margin UIMargin;

typedef cocos2d::ui::ListView UIListView;
typedef cocos2d::ui::PageView UIPageView;
typedef cocos2d::ui::ScrollView UIDragPanel;
typedef cocos2d::ui::ScrollView UIScrollView;
typedef cocos2d::ui::Button UIButton;
typedef cocos2d::ui::Button UITextButton;
typedef cocos2d::ui::CheckBox UICheckBox;
typedef cocos2d::ui::ImageView UIImageView;
typedef cocos2d::ui::Label UILabel;
typedef cocos2d::ui::LabelAtlas UILabelAtlas;
typedef cocos2d::ui::LabelBMFont UILabelBMFont;
typedef cocos2d::ui::LoadingBar UILoadingBar;
typedef cocos2d::ui::Slider UISlider;
typedef cocos2d::ui::TextField UITextField;
typedef cocos2d::ui::TouchGroup UILayer;

typedef cocos2d::ui::LinearGravity UILinearGravity;
typedef cocos2d::ui::RelativeAlign UIRelativeAlign;
typedef cocos2d::ui::LayoutParameter UILayoutParameter;
typedef cocos2d::ui::LinearLayoutParameter UILinearLayoutParameter;
typedef cocos2d::ui::RelativeLayoutParameter UIRelativeLayoutParameter;
}
}
# 47 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2
# 1 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIRichText.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/GUI/System/../UIWidgets/UIRichText.h"
namespace cocos2d {

namespace ui {

typedef enum {
    RICH_TEXT,
    RICH_IMAGE,
    RICH_CUSTOM
}RichElementType;

class RichElement : public CCObject
{
public:
    RichElement(){};
    virtual ~RichElement(){};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity);
protected:
    RichElementType _type;
    int _tag;
    ccColor3B _color;
    GLubyte _opacity;
    friend class RichText;
};

class RichElementText : public RichElement
{
public:
    RichElementText(){_type = RICH_TEXT;};
    virtual ~RichElementText(){};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity, const char* text, const char* fontName, float fontSize);
    static RichElementText* create(int tag, const ccColor3B& color, GLubyte opacity, const char* text, const char* fontName, float fontSize);
protected:
    std::string _text;
    std::string _fontName;
    float _fontSize;
    friend class RichText;

};

class RichElementImage : public RichElement
{
public:
    RichElementImage(){_type = RICH_IMAGE;};
    virtual ~RichElementImage(){};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity, const char* filePath);
    static RichElementImage* create(int tag, const ccColor3B& color, GLubyte opacity, const char* filePath);
protected:
    std::string _filePath;
    CCRect _textureRect;
    int _textureType;
    friend class RichText;
};

class RichElementCustomNode : public RichElement
{
public:
    RichElementCustomNode(){_type = RICH_CUSTOM;};
    virtual ~RichElementCustomNode(){do { if(_customNode) { (_customNode)->release(); } } while(0);};
    virtual bool init(int tag, const ccColor3B& color, GLubyte opacity, CCNode* customNode);
    static RichElementCustomNode* create(int tag, const ccColor3B& color, GLubyte opacity, CCNode* customNode);
protected:
    CCNode* _customNode;
    friend class RichText;
};

class RichText : public Widget
{
public:
    RichText();
    virtual ~RichText();
    static RichText* create();
    void insertElement(RichElement* element, int index);
    void pushBackElement(RichElement* element);
    void removeElement(int index);
    void removeElement(RichElement* element);
    virtual void visit();
    void setVerticalSpace(float space);
    virtual void setAnchorPoint(const CCPoint &pt);
    virtual const CCSize& getContentSize() const;
    void formatText();
    virtual void ignoreContentAdaptWithSize(bool ignore);
protected:
    virtual bool init();
    virtual void initRenderer();
    void pushToContainer(CCNode* renderer);
    void handleTextRenderer(const char* text, const char* fontName, float fontSize, const ccColor3B& color, GLubyte opacity);
    void handleImageRenderer(const char* fileParh, const ccColor3B& color, GLubyte opacity);
    void handleCustomRenderer(CCNode* renderer);
    void formarRenderers();
    void addNewLine();
protected:
    bool _formatTextDirty;
    CCArray* _richElements;
    std::vector<CCArray*> _elementRenders;
    float _leftSpaceWidth;
    float _verticalSpace;
    CCNode* _elementRenderersContainer;
};

}

}
# 48 "Cacao/include/cocos2dext/CocoStudio/GUI/System/CocosGUI.h" 2



const char* CocosGUIVersion();
# 67 "Cacao/include/cocos2dext/cocos-ext.h" 2



# 1 "Cacao/include/cocos2dext/CocoStudio/Reader/SceneReader.h" 1
# 29 "Cacao/include/cocos2dext/CocoStudio/Reader/SceneReader.h"
# 1 "Cacao/include/cocos2dext/cocos-ext.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Reader/SceneReader.h" 2


namespace cocos2d { namespace extension {


typedef void (CCObject::*SEL_CallFuncOD)(CCObject*, void*);






class SceneReader
{
public:
 SceneReader(void);
 virtual ~SceneReader(void);

public:
 static SceneReader* sharedSceneReader();
 static void purge();
 static const char* sceneReaderVersion();
 cocos2d::CCNode* createNodeWithSceneFile(const char *pszFileName);
 static void setTarget(CCObject *rec, SEL_CallFuncOD selector);
 cocos2d::CCNode* getNodeByTag(int nTag);
private:
    cocos2d::CCNode* createObject(const rapidjson::Value &root, cocos2d::CCNode* parent);
    void setPropertyFromJsonDict(const rapidjson::Value &root, cocos2d::CCNode *node);
    bool readJson(const char *pszFileName, rapidjson::Document &doc);
 cocos2d::CCNode* nodeByTag(cocos2d::CCNode *pParent, int nTag);
private:
 static SceneReader* _sharedReader;
 static CCObject* _pListener;
 static SEL_CallFuncOD _pfnSelector;
 cocos2d::CCNode *_pNode;
};


}}
# 71 "Cacao/include/cocos2dext/cocos-ext.h" 2

# 1 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h" 1
# 30 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
# 1 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionObject.h" 1
# 32 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionObject.h"
namespace cocos2d { namespace extension {

class ActionNode;




class ActionObject:public CCObject
{
public:




 ActionObject();




 virtual ~ActionObject();






 void setName(const char* name);






 const char* getName();






 void setLoop(bool bLoop);






 bool getLoop();






 void setUnitTime(float fTime);






 float getUnitTime();






 void setCurrentTime(float fTime);






 float getCurrentTime();






 float getTotalTime();





 bool isPlaying();




 void play();






 void play(CCCallFunc* func);




 void pause();




 void stop();






 void addActionNode(ActionNode* node);






 void removeActionNode(ActionNode* node);


 void updateToFrameByTime(float fTime);


 void initWithDictionary(const rapidjson::Value& dic,CCObject* root);

 void simulationActionUpdate(float dt);

protected:
 CCArray* m_ActionNodeList;
 std::string m_name;
 bool m_loop;
 bool m_bPause;
 bool m_bPlaying;
 float m_fUnitTime;
 float m_CurrentTime;
 CCScheduler *m_pScheduler;
 CCCallFunc *m_CallBack;
 float m_fTotalTime;
};

}}
# 31 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h" 2

namespace cocos2d { namespace extension {




class ActionManager:public CCObject
{
public:





 ActionManager();





 virtual ~ActionManager();




 static ActionManager* shareManager();




 static void purge();
# 72 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
 ActionObject* getActionByName(const char* jsonName,const char* actionName);
# 81 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
 ActionObject* playActionByName(const char* jsonName,const char* actionName);
# 92 "Cacao/include/cocos2dext/CocoStudio/Action/CCActionManager.h"
 ActionObject* playActionByName(const char* jsonName,const char* actionName, CCCallFunc* func);


 void initWithDictionary(const char* jsonName,const rapidjson::Value &dic,CCObject* root);




 void releaseActions();

protected:
 CCDictionary* m_pActionDic;
};

}}
# 73 "Cacao/include/cocos2dext/cocos-ext.h" 2








# 1 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 1
# 29 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h"
# 1 "Cacao/include/cocos2dext/spine/spine.h" 1
# 29 "Cacao/include/cocos2dext/spine/spine.h"
# 1 "Cacao/include/cocos2dext/spine/Animation.h" 1
# 29 "Cacao/include/cocos2dext/spine/Animation.h"
namespace cocos2d { namespace extension {

typedef struct Timeline Timeline;
struct Skeleton;

typedef struct {
 const char* const name;
 float duration;

 int timelineCount;
 Timeline** timelines;
} Animation;

Animation* Animation_create (const char* name, int timelineCount);
void Animation_dispose (Animation* self);

void Animation_apply (const Animation* self, struct Skeleton* skeleton, float time, int loop);
void Animation_mix (const Animation* self, struct Skeleton* skeleton, float time, int loop, float alpha);



struct Timeline {
 const void* const vtable;
};

void Timeline_dispose (Timeline* self);
void Timeline_apply (const Timeline* self, struct Skeleton* skeleton, float time, float alpha);



typedef struct {
 Timeline super;
 float* curves;
} CurveTimeline;

void CurveTimeline_setLinear (CurveTimeline* self, int frameIndex);
void CurveTimeline_setStepped (CurveTimeline* self, int frameIndex);




void CurveTimeline_setCurve (CurveTimeline* self, int frameIndex, float cx1, float cy1, float cx2, float cy2);
float CurveTimeline_getCurvePercent (const CurveTimeline* self, int frameIndex, float percent);



typedef struct BaseTimeline {
 CurveTimeline super;
 int const framesLength;
 float* const frames;
 int boneIndex;
} RotateTimeline;

RotateTimeline* RotateTimeline_create (int frameCount);

void RotateTimeline_setFrame (RotateTimeline* self, int frameIndex, float time, float angle);



typedef struct BaseTimeline TranslateTimeline;

TranslateTimeline* TranslateTimeline_create (int frameCount);

void TranslateTimeline_setFrame (TranslateTimeline* self, int frameIndex, float time, float x, float y);



typedef struct BaseTimeline ScaleTimeline;

ScaleTimeline* ScaleTimeline_create (int frameCount);

void ScaleTimeline_setFrame (ScaleTimeline* self, int frameIndex, float time, float x, float y);



typedef struct {
 CurveTimeline super;
 int const framesLength;
 float* const frames;
 int slotIndex;
} ColorTimeline;

ColorTimeline* ColorTimeline_create (int frameCount);

void ColorTimeline_setFrame (ColorTimeline* self, int frameIndex, float time, float r, float g, float b, float a);



typedef struct {
 Timeline super;
 int const framesLength;
 float* const frames;
 int slotIndex;
 const char** const attachmentNames;
} AttachmentTimeline;

AttachmentTimeline* AttachmentTimeline_create (int frameCount);


void AttachmentTimeline_setFrame (AttachmentTimeline* self, int frameIndex, float time, const char* attachmentName);

}}
# 30 "Cacao/include/cocos2dext/spine/spine.h" 2
# 1 "Cacao/include/cocos2dext/spine/AnimationState.h" 1
# 29 "Cacao/include/cocos2dext/spine/AnimationState.h"
# 1 "Cacao/include/cocos2dext/spine/AnimationStateData.h" 1
# 30 "Cacao/include/cocos2dext/spine/AnimationStateData.h"
# 1 "Cacao/include/cocos2dext/spine/SkeletonData.h" 1
# 29 "Cacao/include/cocos2dext/spine/SkeletonData.h"
# 1 "Cacao/include/cocos2dext/spine/BoneData.h" 1
# 29 "Cacao/include/cocos2dext/spine/BoneData.h"
namespace cocos2d { namespace extension {

typedef struct BoneData BoneData;
struct BoneData {
 const char* const name;
 BoneData* const parent;
 float length;
 float x, y;
 float rotation;
 float scaleX, scaleY;
};

BoneData* BoneData_create (const char* name, BoneData* parent);
void BoneData_dispose (BoneData* self);

}}
# 30 "Cacao/include/cocos2dext/spine/SkeletonData.h" 2
# 1 "Cacao/include/cocos2dext/spine/SlotData.h" 1
# 31 "Cacao/include/cocos2dext/spine/SlotData.h"
namespace cocos2d { namespace extension {

typedef struct {
 const char* const name;
 const BoneData* const boneData;
 const char* const attachmentName;
 float r, g, b, a;
} SlotData;

SlotData* SlotData_create (const char* name, BoneData* boneData);
void SlotData_dispose (SlotData* self);


void SlotData_setAttachmentName (SlotData* self, const char* attachmentName);

}}
# 31 "Cacao/include/cocos2dext/spine/SkeletonData.h" 2
# 1 "Cacao/include/cocos2dext/spine/Skin.h" 1
# 29 "Cacao/include/cocos2dext/spine/Skin.h"
# 1 "Cacao/include/cocos2dext/spine/Attachment.h" 1
# 29 "Cacao/include/cocos2dext/spine/Attachment.h"
namespace cocos2d { namespace extension {

struct Slot;

typedef enum {
 ATTACHMENT_REGION, ATTACHMENT_REGION_SEQUENCE
} AttachmentType;

typedef struct Attachment Attachment;
struct Attachment {
 const char* const name;
 AttachmentType type;

 const void* const vtable;
};

void Attachment_dispose (Attachment* self);

}}
# 30 "Cacao/include/cocos2dext/spine/Skin.h" 2

namespace cocos2d { namespace extension {

struct Skeleton;

typedef struct {
 const char* const name;
} Skin;

Skin* Skin_create (const char* name);
void Skin_dispose (Skin* self);


void Skin_addAttachment (Skin* self, int slotIndex, const char* name, Attachment* attachment);

Attachment* Skin_getAttachment (const Skin* self, int slotIndex, const char* name);


const char* Skin_getAttachmentName (const Skin* self, int slotIndex, int attachmentIndex);


void Skin_attachAll (const Skin* self, struct Skeleton* skeleton, const Skin* oldSkin);

}}
# 32 "Cacao/include/cocos2dext/spine/SkeletonData.h" 2


namespace cocos2d { namespace extension {

typedef struct {
 int boneCount;
 BoneData** bones;

 int slotCount;
 SlotData** slots;

 int skinCount;
 Skin** skins;
 Skin* defaultSkin;

 int animationCount;
 Animation** animations;
} SkeletonData;

SkeletonData* SkeletonData_create ();
void SkeletonData_dispose (SkeletonData* self);

BoneData* SkeletonData_findBone (const SkeletonData* self, const char* boneName);
int SkeletonData_findBoneIndex (const SkeletonData* self, const char* boneName);

SlotData* SkeletonData_findSlot (const SkeletonData* self, const char* slotName);
int SkeletonData_findSlotIndex (const SkeletonData* self, const char* slotName);

Skin* SkeletonData_findSkin (const SkeletonData* self, const char* skinName);

Animation* SkeletonData_findAnimation (const SkeletonData* self, const char* animationName);

}}
# 31 "Cacao/include/cocos2dext/spine/AnimationStateData.h" 2

namespace cocos2d { namespace extension {

typedef struct {
 SkeletonData* const skeletonData;
 const void* const entries;
} AnimationStateData;

AnimationStateData* AnimationStateData_create (SkeletonData* skeletonData);
void AnimationStateData_dispose (AnimationStateData* self);

void AnimationStateData_setMixByName (AnimationStateData* self, const char* fromName, const char* toName, float duration);
void AnimationStateData_setMix (AnimationStateData* self, Animation* from, Animation* to, float duration);

float AnimationStateData_getMix (AnimationStateData* self, Animation* from, Animation* to);

}}
# 30 "Cacao/include/cocos2dext/spine/AnimationState.h" 2

namespace cocos2d { namespace extension {

typedef struct {
 AnimationStateData* const data;
 Animation* const animation;
 float time;
 int loop;
} AnimationState;


AnimationState* AnimationState_create (AnimationStateData* data);
void AnimationState_dispose (AnimationState* self);

void AnimationState_update (AnimationState* self, float delta);

void AnimationState_apply (AnimationState* self, struct Skeleton* skeleton);


void AnimationState_setAnimationByName (AnimationState* self, const char* animationName, int loop);

void AnimationState_setAnimation (AnimationState* self, Animation* animation, int loop);



void AnimationState_addAnimationByName (AnimationState* self, const char* animationName, int loop, float delay);


void AnimationState_addAnimation (AnimationState* self, Animation* animation, int loop, float delay);

void AnimationState_clearAnimation (AnimationState* self);

int AnimationState_isComplete (AnimationState* self);

}}
# 31 "Cacao/include/cocos2dext/spine/spine.h" 2

# 1 "Cacao/include/cocos2dext/spine/Atlas.h" 1
# 29 "Cacao/include/cocos2dext/spine/Atlas.h"
namespace cocos2d { namespace extension {

typedef enum {
 ATLAS_ALPHA, ATLAS_INTENSITY, ATLAS_LUMINANCE_ALPHA, ATLAS_RGB565, ATLAS_RGBA4444, ATLAS_RGB888, ATLAS_RGBA8888
} AtlasFormat;

typedef enum {
 ATLAS_NEAREST,
 ATLAS_LINEAR,
 ATLAS_MIPMAP,
 ATLAS_MIPMAP_NEAREST_NEAREST,
 ATLAS_MIPMAP_LINEAR_NEAREST,
 ATLAS_MIPMAP_NEAREST_LINEAR,
 ATLAS_MIPMAP_LINEAR_LINEAR
} AtlasFilter;

typedef enum {
 ATLAS_MIRROREDREPEAT, ATLAS_CLAMPTOEDGE, ATLAS_REPEAT
} AtlasWrap;

typedef struct AtlasPage AtlasPage;
struct AtlasPage {
 const char* name;
 AtlasFormat format;
 AtlasFilter minFilter, magFilter;
 AtlasWrap uWrap, vWrap;

 void* rendererObject;
 int width, height;

 AtlasPage* next;
};

AtlasPage* AtlasPage_create (const char* name);
void AtlasPage_dispose (AtlasPage* self);



typedef struct AtlasRegion AtlasRegion;
struct AtlasRegion {
 const char* name;
 int x, y, width, height;
 float u, v, u2, v2;
 int offsetX, offsetY;
 int originalWidth, originalHeight;
 int index;
 int rotate;
 int flip;
 int* splits;
 int* pads;

 AtlasPage* page;

 AtlasRegion* next;
};

AtlasRegion* AtlasRegion_create ();
void AtlasRegion_dispose (AtlasRegion* self);



typedef struct {
 AtlasPage* pages;
 AtlasRegion* regions;
} Atlas;


Atlas* Atlas_readAtlas (const char* data, int length, const char* dir);

Atlas* Atlas_readAtlasFile (const char* path);
void Atlas_dispose (Atlas* atlas);


AtlasRegion* Atlas_findRegion (const Atlas* self, const char* name);

}}
# 33 "Cacao/include/cocos2dext/spine/spine.h" 2
# 1 "Cacao/include/cocos2dext/spine/AtlasAttachmentLoader.h" 1
# 29 "Cacao/include/cocos2dext/spine/AtlasAttachmentLoader.h"
# 1 "Cacao/include/cocos2dext/spine/AttachmentLoader.h" 1
# 32 "Cacao/include/cocos2dext/spine/AttachmentLoader.h"
namespace cocos2d { namespace extension {

typedef struct AttachmentLoader AttachmentLoader;
struct AttachmentLoader {
 const char* error1;
 const char* error2;

 const void* const vtable;

 AttachmentLoader () : error1(0), error2(0), vtable(0) {}

};

void AttachmentLoader_dispose (AttachmentLoader* self);


Attachment* AttachmentLoader_newAttachment (AttachmentLoader* self, Skin* skin, AttachmentType type, const char* name);

}}
# 30 "Cacao/include/cocos2dext/spine/AtlasAttachmentLoader.h" 2


namespace cocos2d { namespace extension {

typedef struct {
 AttachmentLoader super;
 Atlas* atlas;
} AtlasAttachmentLoader;

AtlasAttachmentLoader* AtlasAttachmentLoader_create (Atlas* atlas);

}}
# 34 "Cacao/include/cocos2dext/spine/spine.h" 2


# 1 "Cacao/include/cocos2dext/spine/Bone.h" 1
# 31 "Cacao/include/cocos2dext/spine/Bone.h"
namespace cocos2d { namespace extension {

typedef struct Bone Bone;
struct Bone {
 BoneData* const data;
 Bone* const parent;
 float x, y;
 float rotation;
 float scaleX, scaleY;

 float const m00, m01, worldX;
 float const m10, m11, worldY;
 float const worldRotation;
 float const worldScaleX, worldScaleY;
};

void Bone_setYDown (int yDown);


Bone* Bone_create (BoneData* data, Bone* parent);
void Bone_dispose (Bone* self);

void Bone_setToSetupPose (Bone* self);

void Bone_updateWorldTransform (Bone* self, int flipX, int flipY);

}}
# 37 "Cacao/include/cocos2dext/spine/spine.h" 2

# 1 "Cacao/include/cocos2dext/spine/RegionAttachment.h" 1
# 31 "Cacao/include/cocos2dext/spine/RegionAttachment.h"
# 1 "Cacao/include/cocos2dext/spine/Slot.h" 1
# 33 "Cacao/include/cocos2dext/spine/Slot.h"
namespace cocos2d { namespace extension {

struct Skeleton;

typedef struct Slot {
 SlotData* const data;
 struct Skeleton* const skeleton;
 Bone* const bone;
 float r, g, b, a;
 Attachment* const attachment;
} Slot;

Slot* Slot_create (SlotData* data, struct Skeleton* skeleton, Bone* bone);
void Slot_dispose (Slot* self);


void Slot_setAttachment (Slot* self, Attachment* attachment);

void Slot_setAttachmentTime (Slot* self, float time);
float Slot_getAttachmentTime (const Slot* self);

void Slot_setToSetupPose (Slot* self);

}}
# 32 "Cacao/include/cocos2dext/spine/RegionAttachment.h" 2

namespace cocos2d { namespace extension {

typedef enum {
 VERTEX_X1 = 0, VERTEX_Y1, VERTEX_X2, VERTEX_Y2, VERTEX_X3, VERTEX_Y3, VERTEX_X4, VERTEX_Y4
} VertexIndex;

typedef struct RegionAttachment RegionAttachment;
struct RegionAttachment {
 Attachment super;
 float x, y, scaleX, scaleY, rotation, width, height;

 void* rendererObject;
 int regionOffsetX, regionOffsetY;
 int regionWidth, regionHeight;
 int regionOriginalWidth, regionOriginalHeight;

 float offset[8];
 float uvs[8];
};

RegionAttachment* RegionAttachment_create (const char* name);
void RegionAttachment_setUVs (RegionAttachment* self, float u, float v, float u2, float v2, int rotate);
void RegionAttachment_updateOffset (RegionAttachment* self);
void RegionAttachment_computeVertices (RegionAttachment* self, float x, float y, Bone* bone, float* vertices);

}}
# 39 "Cacao/include/cocos2dext/spine/spine.h" 2
# 1 "Cacao/include/cocos2dext/spine/Skeleton.h" 1
# 33 "Cacao/include/cocos2dext/spine/Skeleton.h"
namespace cocos2d { namespace extension {

typedef struct Skeleton Skeleton;
struct Skeleton {
 SkeletonData* const data;

 int boneCount;
 Bone** bones;
 Bone* const root;

 int slotCount;
 Slot** slots;
 Slot** drawOrder;

 Skin* const skin;
 float r, g, b, a;
 float time;
 int flipX, flipY;
 float x, y;
};

Skeleton* Skeleton_create (SkeletonData* data);
void Skeleton_dispose (Skeleton* self);

void Skeleton_updateWorldTransform (const Skeleton* self);

void Skeleton_setToSetupPose (const Skeleton* self);
void Skeleton_setBonesToSetupPose (const Skeleton* self);
void Skeleton_setSlotsToSetupPose (const Skeleton* self);


Bone* Skeleton_findBone (const Skeleton* self, const char* boneName);

int Skeleton_findBoneIndex (const Skeleton* self, const char* boneName);


Slot* Skeleton_findSlot (const Skeleton* self, const char* slotName);

int Skeleton_findSlotIndex (const Skeleton* self, const char* slotName);




void Skeleton_setSkin (Skeleton* self, Skin* skin);


int Skeleton_setSkinByName (Skeleton* self, const char* skinName);


Attachment* Skeleton_getAttachmentForSlotName (const Skeleton* self, const char* slotName, const char* attachmentName);

Attachment* Skeleton_getAttachmentForSlotIndex (const Skeleton* self, int slotIndex, const char* attachmentName);

int Skeleton_setAttachment (Skeleton* self, const char* slotName, const char* attachmentName);

void Skeleton_update (Skeleton* self, float deltaTime);

}}
# 40 "Cacao/include/cocos2dext/spine/spine.h" 2

# 1 "Cacao/include/cocos2dext/spine/SkeletonJson.h" 1
# 35 "Cacao/include/cocos2dext/spine/SkeletonJson.h"
namespace cocos2d { namespace extension {

typedef struct {
 float scale;
 AttachmentLoader* attachmentLoader;
 const char* const error;
} SkeletonJson;

SkeletonJson* SkeletonJson_createWithLoader (AttachmentLoader* attachmentLoader);
SkeletonJson* SkeletonJson_create (Atlas* atlas);
void SkeletonJson_dispose (SkeletonJson* self);

SkeletonData* SkeletonJson_readSkeletonData (SkeletonJson* self, const char* json);
SkeletonData* SkeletonJson_readSkeletonDataFile (SkeletonJson* self, const char* path);

}}
# 42 "Cacao/include/cocos2dext/spine/spine.h" 2
# 30 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 2

# 1 "Cacao/include/cocos2dext/spine/CCSkeleton.h" 1
# 32 "Cacao/include/cocos2dext/spine/CCSkeleton.h"
namespace cocos2d { namespace extension {




class CCSkeleton: public cocos2d::CCNodeRGBA, public cocos2d::CCBlendProtocol {
public:
 Skeleton* skeleton;
 Bone* rootBone;
 float timeScale;
 bool debugSlots;
 bool debugBones;
 bool premultipliedAlpha;

 static CCSkeleton* createWithData (SkeletonData* skeletonData, bool ownsSkeletonData = false);
 static CCSkeleton* createWithFile (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 static CCSkeleton* createWithFile (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 CCSkeleton (SkeletonData* skeletonData, bool ownsSkeletonData = false);
 CCSkeleton (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 CCSkeleton (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 virtual ~CCSkeleton ();

 virtual void update (float deltaTime);
 virtual void draw ();
 virtual cocos2d::CCRect boundingBox ();


 void updateWorldTransform ();

 void setToSetupPose ();
 void setBonesToSetupPose ();
 void setSlotsToSetupPose ();


 Bone* findBone (const char* boneName) const;

 Slot* findSlot (const char* slotName) const;




 bool setSkin (const char* skinName);


 Attachment* getAttachment (const char* slotName, const char* attachmentName) const;

 bool setAttachment (const char* slotName, const char* attachmentName);


 protected: cocos2d::ccBlendFunc blendFunc;public: virtual cocos2d::ccBlendFunc getBlendFunc(void);public: virtual void setBlendFunc(cocos2d::ccBlendFunc var);;
 virtual void setOpacityModifyRGB (bool value);
 virtual bool isOpacityModifyRGB ();

protected:
 CCSkeleton ();
 void setSkeletonData (SkeletonData* skeletonData, bool ownsSkeletonData);
 cocos2d::CCTextureAtlas* getTextureAtlas (RegionAttachment* regionAttachment) const;

private:
 bool ownsSkeletonData;
 Atlas* atlas;
 void initialize ();
};

}}
# 32 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 2
# 1 "Cacao/include/cocos2dext/spine/CCSkeletonAnimation.h" 1
# 33 "Cacao/include/cocos2dext/spine/CCSkeletonAnimation.h"
namespace cocos2d { namespace extension {




class CCSkeletonAnimation: public CCSkeleton {
public:
 std::vector<AnimationState*> states;

 static CCSkeletonAnimation* createWithData (SkeletonData* skeletonData);
 static CCSkeletonAnimation* createWithFile (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 static CCSkeletonAnimation* createWithFile (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 CCSkeletonAnimation (SkeletonData* skeletonData);
 CCSkeletonAnimation (const char* skeletonDataFile, Atlas* atlas, float scale = 1);
 CCSkeletonAnimation (const char* skeletonDataFile, const char* atlasFile, float scale = 1);

 virtual ~CCSkeletonAnimation ();

 virtual void update (float deltaTime);

 void addAnimationState (AnimationStateData* stateData = 0);
 void setAnimationStateData (AnimationStateData* stateData, int stateIndex = 0);
 void setMix (const char* fromAnimation, const char* toAnimation, float duration, int stateIndex = 0);
 void setAnimation (const char* name, bool loop, int stateIndex = 0);
 void addAnimation (const char* name, bool loop, float delay = 0, int stateIndex = 0);
 void clearAnimation (int stateIndex = 0);

protected:
 CCSkeletonAnimation ();

private:
 typedef CCSkeleton super;
 std::vector<AnimationStateData*> stateDatas;

 void initialize ();
};

}}
# 33 "Cacao/include/cocos2dext/spine/spine-cocos2dx.h" 2

namespace cocos2d { namespace extension {

void RegionAttachment_updateQuad (RegionAttachment* self, Slot* slot, cocos2d::ccV3F_C4B_T2F_Quad* quad, bool premultiplied = false);

}}
# 82 "Cacao/include/cocos2dext/cocos-ext.h" 2
# 12 "Cacao/include/cc_defs.hpp" 2






void setupTypeinfos();

typedef void(*queuefunc)(std::string);

typedef struct GameModes {
    bool cube;
    bool ship;
    bool ufo;
    bool ball;
    bool wave;
    bool robot;
    bool spider;
} GameModes;

typedef struct LevelDifficulty {
    int32_t denominator;
    int32_t numerator;
} LevelDifficulty;
# 51 "Cacao/include/cc_defs.hpp"
class GDObj {
public:
    void* valOffset(long offset);
    void setValOffset(long offset, void* setter);
};

class GJGameLevel : public GDObj {
public:
    inline std::string& _name() { if (this) { return *((std::string*)((long)this + 0x138)); } else { return *(std::string*)(-1); } };
    inline int& _levelId() { if (this) { return *((int*)((long)this + 0x130)); } else { return *(int*)(-1); } };
    inline int& _bestNormal() { if (this) { return *((int*)((long)this + 0x214)); } else { return *(int*)(-1); } };
    inline int& _bestPractice() { if (this) { return *((int*)((long)this + 0x238)); } else { return *(int*)(-1); } };
    inline std::string& _author() { if (this) { return *((std::string*)((long)this + 0x150)); } else { return *(std::string*)(-1); } };
    inline LevelDifficulty _difficulty() { return *(LevelDifficulty*)((long)this+0x1b0); };
};

class LevelSettingsObject : public GDObj {
public:
    inline GJGameLevel*& _level() { if (this) { return *((GJGameLevel**)((long)this + 0x150)); } else { return *(GJGameLevel**)(-1); } };
};

class GameLevelManager : public GDObj {
public:
    static GameLevelManager* sharedState();
    GJGameLevel* createNewLevel();
    inline cocos2d::CCDictionary*& _timerDict() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x1e8)); } else { return *(cocos2d::CCDictionary**)(-1); } };
};

class AppDelegate : public GDObj {
public:
    inline cocos2d::CCScene*& _runningScene() { if (this) { return *((cocos2d::CCScene**)((long)this + 0x28)); } else { return *(cocos2d::CCScene**)(-1); } };
    static AppDelegate* get();
};

class GameSoundManager : public GDObj {
public:
    static GameSoundManager* sharedManager();
    void stopBackgroundMusic();
    virtual ~GameSoundManager();
};

class GameObject : public cocos2d::CCSprite, public GDObj{
public:
    GameObject();
    void init(char const* frame);
    void setPosition(cocos2d::CCPoint const& pt);
    void destroyObject();
    int getGroupID(int index);
    void playShineEffect();
    inline int& _type() { if (this) { return *((int*)((long)this + 0x370)); } else { return *(int*)(-1); } };
    inline int& _id() { if (this) { return *((int*)((long)this + 0x3c4)); } else { return *(int*)(-1); } };
    inline bool& _touchTriggered() { if (this) { return *((bool*)((long)this + 0x378)); } else { return *(bool*)(-1); } };
    inline int& _uuid() { if (this) { return *((int*)((long)this + 0x36c)); } else { return *(int*)(-1); } };
};

class SpawnTriggerAction : public cocos2d::CCNode {
 public:
    bool timerEnded;
    float delay;
    float timer;
    int group;
    int uuid;
};

class EffectGameObject : public GameObject {
public:
    inline bool& _touchHoldMode() { if (this) { return *((bool*)((long)this + 0x579)); } else { return *(bool*)(-1); } };
};

class LabelGameObject : public GameObject {
 public:
  static LabelGameObject* create(char const* frame);
};

class PlayerObject : public GameObject {
public:
    static PlayerObject* create(int icn, int icon, cocos2d::CCLayer*);
    void addAllParticles();
    void setColor(cocos2d::_ccColor3B const&);
    void setSecondColor(cocos2d::_ccColor3B const&);
    void flipGravity(bool, bool);
    inline double& _yAccel() { if (this) { return *((double*)((long)this + 0x760)); } else { return *(double*)(-1); } };
    inline float& _xPos() { if (this) { return *((float*)((long)this + 0x7c8)); } else { return *(float*)(-1); } };
    inline bool& _isShip() { if (this) { return *((bool*)((long)this + 0x770)); } else { return *(bool*)(-1); } };
    inline bool& _isUpsideDown() { if (this) { return *((bool*)((long)this + 0x776)); } else { return *(bool*)(-1); } };
    inline float& _vSize() { if (this) { return *((float*)((long)this + 0x77c)); } else { return *(float*)(-1); } };
    inline bool& _isHolding() { if (this) { return *((bool*)((long)this + 0x745)); } else { return *(bool*)(-1); } };
    inline bool& _hasJustHeld() { if (this) { return *((bool*)((long)this + 0x746)); } else { return *(bool*)(-1); } };
};

class GJBaseGameLayer : public cocos2d::CCLayer, public GDObj {
public:
    void spawnGroup(int group);
    inline cocos2d::CCArray*& _objects() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x3a0)); } else { return *(cocos2d::CCArray**)(-1); } };
    inline PlayerObject*& _player1() { if (this) { return *((PlayerObject**)((long)this + 0x380)); } else { return *(PlayerObject**)(-1); } };
    inline PlayerObject*& _player2() { if (this) { return *((PlayerObject**)((long)this + 0x388)); } else { return *(PlayerObject**)(-1); } };
    inline LevelSettingsObject*& _levelSettings() { if (this) { return *((LevelSettingsObject**)((long)this + 0x390)); } else { return *(LevelSettingsObject**)(-1); } };
    inline cocos2d::CCDictionary*& _unknownDict() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x398)); } else { return *(cocos2d::CCDictionary**)(-1); } };
};

class LevelEditorLayer : public GJBaseGameLayer {
public:
    void createObjectsFromString(std::string st, bool idk);
    void removeAllObjects();
    void undoLastAction();
    void redoLastAction();
    inline cocos2d::CCArray*& _objects() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x3a0)); } else { return *(cocos2d::CCArray**)(-1); } };
};

class EditButtonBar : public cocos2d::CCNode, public GDObj {
 public:
    void loadFromItems(cocos2d::CCArray*, int, int, bool);
    inline cocos2d::CCArray*& _objectSlots() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x130)); } else { return *(cocos2d::CCArray**)(-1); } };
};
class EditorUI : public cocos2d::CCLayer, public GDObj {
public:
    void pasteObjects(std::string str);
    void undoLastAction();
    void redoLastAction();
    CCMenuItemSpriteExtra* getCreateBtn(int obid, int four);
    cocos2d::CCArray* getSelectedObjects();
    void selectObjects(cocos2d::CCArray* objs, bool keep);
    inline LevelEditorLayer*& _editorLayer() { if (this) { return *((LevelEditorLayer**)((long)this + 0x408)); } else { return *(LevelEditorLayer**)(-1); } };
    inline cocos2d::CCArray*& _editBars() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x358)); } else { return *(cocos2d::CCArray**)(-1); } };
};

class PlayLayer : public GJBaseGameLayer {
public:
    static PlayLayer* create();
    inline float& _length() { if (this) { return *((float*)((long)this + 0x5f8)); } else { return *(float*)(-1); } };
    inline int& _attempt() { if (this) { return *((int*)((long)this + 0x754)); } else { return *(int*)(-1); } };
    inline bool& _practiceMode() { if (this) { return *((bool*)((long)this + 0x739)); } else { return *(bool*)(-1); } };
    inline float& _time() { if (this) { return *((float*)((long)this + 0x760)); } else { return *(float*)(-1); } };
    inline GameModes _gameModes() { return *(GameModes*)((long)this+0x76f); };
};

class ObjectToolbox : public GDObj {
public:
    static ObjectToolbox* sharedState();
    inline cocos2d::CCDictionary*& _strKeyObjects() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x120)); } else { return *(cocos2d::CCDictionary**)(-1); } };
    inline cocos2d::CCDictionary*& _intKeyObjects() { if (this) { return *((cocos2d::CCDictionary**)((long)this + 0x128)); } else { return *(cocos2d::CCDictionary**)(-1); } };
};

class ButtonSprite : public cocos2d::CCSprite, public GDObj {
public:
    static ButtonSprite* create(char const* text, int width, int relativeWidth, float scale, bool relative);
};

class FLAlertLayer : public cocos2d::CCLayerColor, public GDObj {
public:
    FLAlertLayer();
    static FLAlertLayer* create(void* fdsg, char const* x, const std::string &thing, char const* l, char const* u, float f);

    static FLAlertLayer* create(char const* title, const std::string &desc, char const* btn) {
        return FLAlertLayer::create(__null, title, desc, btn, __null, 300.0);
    }
    virtual ~FLAlertLayer();
    virtual void onEnter(void);
    virtual bool ccTouchBegan(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void ccTouchMoved(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void ccTouchEnded(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void ccTouchCancelled(cocos2d::CCTouch *,cocos2d::CCEvent *);
    virtual void registerWithTouchDispatcher(int);
    virtual void keyBackClicked(void);
    virtual void keyDown(cocos2d::enumKeyCodes);
    int show(void);
    inline cocos2d::CCLayer*& _mainLayer() { if (this) { return *((cocos2d::CCLayer**)((long)this + 0x220)); } else { return *(cocos2d::CCLayer**)(-1); } };
    inline cocos2d::CCMenu*& _mainMenu() { if (this) { return *((cocos2d::CCMenu**)((long)this + 0x1f8)); } else { return *(cocos2d::CCMenu**)(-1); } };
};


class TextArea : public ButtonSprite {
public:
    static TextArea* create(std::string a, char const*, float textSize, float maxWidth, cocos2d::CCPoint position, float returnSize, bool idk);
};


class MenuLayer : public cocos2d::CCLayer, public GDObj {
public:
    void onQuit(cocos2d::CCObject*);
    void keyBackClicked();
};
class MoreVideoOptionsLayer : public FLAlertLayer {
public:
    static MoreVideoOptionsLayer* create();
    bool init();

};

class GJSearchObject : public GDObj {
public:
    static GJSearchObject* create(int, std::string, std::string, std::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, int, int);
};

class LevelBrowserLayer : public GDObj {
public:
    static cocos2d::CCScene* scene(GJSearchObject* search);
};

class EditorPauseLayer : public GDObj {
public:
    static EditorPauseLayer* create(LevelEditorLayer* editor);
    void saveLevel();
    virtual ~EditorPauseLayer();
};

class PauseLayer : public FLAlertLayer {

};

class GJAccountManager : public GDObj {
public:
    static GJAccountManager* sharedState();

    inline char const*& _password() { if (this) { return *((char const**)((long)this + 0x128)); } else { return *(char const**)(-1); } };
    inline char const*& _username() { if (this) { return *((char const**)((long)this + 0x130)); } else { return *(char const**)(-1); } };
};

class GameManager : public GDObj {
public:
    static GameManager* sharedState();
    bool getGameVariable(char const* var);
    void setGameVariable(char const* var, bool val);
    void fadeInMusic(char const* ye);
    void reloadAllStep5();
    void doQuickSave();
    void reloadAll(bool a, bool b, bool c);
    void accountStatusChanged();
    void load();

    void setSecondColorIdx(int idx);
    void setFirstColorIdx(int idx);
    cocos2d::_ccColor3B const& colorForIdx(int idx);
    std::string& manFile();
    virtual ~GameManager();

    inline PlayLayer*& _playLayer() { if (this) { return *((PlayLayer**)((long)this + 0x180)); } else { return *(PlayLayer**)(-1); } };
    inline LevelEditorLayer*& _editorLayer() { if (this) { return *((LevelEditorLayer**)((long)this + 0x188)); } else { return *(LevelEditorLayer**)(-1); } };
    inline int& _scene() { if (this) { return *((int*)((long)this + 0x1f4)); } else { return *(int*)(-1); } };
};

class InfoLayer : public cocos2d::CCLayer, public GDObj {
public:
    void loadPage(int type, bool yes);
    void onRefreshComments(cocos2d::CCObject*);
    void onClose(cocos2d::CCObject*);
    inline cocos2d::CCLayer*& _mainLayer() { if (this) { return *((cocos2d::CCLayer**)((long)this + 0x220)); } else { return *(cocos2d::CCLayer**)(-1); } };
    inline cocos2d::CCMenu*& _rightMenu() { if (this) { return *((cocos2d::CCMenu**)((long)this + 0x1f8)); } else { return *(cocos2d::CCMenu**)(-1); } };
};

class CCMenuItemToggler : public cocos2d::CCNodeRGBA, public GDObj {
public:
    static CCMenuItemToggler* create(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, void (cocos2d::CCObject::*)(cocos2d::CCObject*));
    void setSizeMult(float);
};

class CCTextInputNode : public cocos2d::CCNode, public cocos2d::CCIMEDelegate, public GDObj {
public:
    static CCTextInputNode* create(float x, float y, char const* placeholder, char const* font, int, char const*);
    void setAllowedChars(std::string allowed);
    void setMaxLabelScale(float max);
    void setMaxLabelWidth(float max);
    std::string getString();
    char const* getString_s();
};

class GJEffectManager : public cocos2d::CCNode, public GDObj {
 public:
    inline GJBaseGameLayer*& _gameLayer() { if (this) { return *((GJBaseGameLayer**)((long)this + 0x120)); } else { return *(GJBaseGameLayer**)(-1); } };
    inline cocos2d::CCArray*& _spawnActions() { if (this) { return *((cocos2d::CCArray**)((long)this + 0x1c18)); } else { return *(cocos2d::CCArray**)(-1); } };
};

class SetupSpawnPopup : public FLAlertLayer {
 public:
    inline EffectGameObject*& _object() { if (this) { return *((EffectGameObject**)((long)this + 0x258)); } else { return *(EffectGameObject**)(-1); } };
    void createToggleButton(std::string name, void (cocos2d::CCObject::*)(cocos2d::CCObject*), bool enabled, cocos2d::CCMenu* menu, cocos2d::CCPoint location, cocos2d::CCArray* idk);
};
# 6 "Cacao/include/Cacao.hpp" 2


namespace Cacao {
    typedef void (cocos2d::CCObject::* CC_SEL)(cocos2d::CCObject*);

    cocos2d::CCPoint relativePosition(double x, double y);
    cocos2d::CCPoint addedPosition(double x, double y);
    cocos2d::CCSprite* spriteFromPng(unsigned char* img, int img_len);

    CCMenuItemToggler* createToggler(cocos2d::CCObject* parent, CC_SEL callback);
    void addGDObject(char const* name, int id);

    class FLDialogHelper;

    class FLDialogDelegate {
    protected:
        virtual void onSubmit(FLDialogHelper* dl, const std::string& text);
        virtual void onCancel(FLDialogHelper* dl);
        virtual void onShow(FLDialogHelper* dl);
        friend class FLDialogHelper;
    };

    class FLDialogHelper : public cocos2d::CCNode {
     public:
        static FLDialogHelper* create(FLDialogDelegate* del, char const* title, char const* submit, char const* cancel, char const* placeholder);

        static FLDialogHelper* create(FLDialogDelegate* del, char const* title, char const* submit, char const* cancel);
        static FLDialogHelper* create(FLDialogDelegate* del, char const* title, char const* submit);
        static FLDialogHelper* create(FLDialogDelegate* del, char const* title);
        static FLDialogHelper* create(FLDialogDelegate* del);
        static FLDialogHelper* create();
        void close();
        void show();

        bool initWithStuff(FLDialogDelegate* delegate, char const* title, char const* submit, char const* cancel, char const* placeholder);
     protected:
        FLAlertLayer* alertLayer;
        cocos2d::CCLayer* mainLayer;
        CCTextInputNode* textNode;
        FLDialogDelegate* del;
     private:
        void onSubmit(cocos2d::CCObject*);
        void onCancel(cocos2d::CCObject*);
    };
}
# 2 "speedchange.cpp" 2
# 1 "Cacao/include/cc_macros.hpp" 1
# 3 "speedchange.cpp" 2

ModContainer* m = new ModContainer("Speed change");

void CAChSetupMenus(EditorUI* self) { reinterpret_cast<decltype(&CAChSetupMenus)>(m->getOriginal(getBase()+0xcb50))((self));
 {EditButtonBar* theBar = static_cast<EditButtonBar*>(self->_editBars()->objectAtIndex((index))); CCArray* why = CCArray::create(); CCObject* ob; int counter = 0; if ((theBar->_objectSlots()) && (theBar->_objectSlots())->data->num > 0) for(CCObject** __arr__ = (theBar->_objectSlots())->data->arr, **__end__ = (theBar->_objectSlots())->data->arr + (theBar->_objectSlots())->data->num-1; __arr__ <= __end__ && (((ob) = *__arr__) != __null ); __arr__++) { counter++;
  if (counter==(12)) { why->addObject(self->getCreateBtn((3142), 4)); };
 why->addObject(ob); } theBar->loadFromItems(why, 6, 2, false); };
};

void inject() {
 Cacao::addGDObject("d_potion01_001.png", 3142);
 (m)->registerHook(getBase()+0xcb50, CAChSetupMenus);
 m->enable();
}
